<?xml version="1.0"?>
<root>
  <ModuleHolder ModuleName="--Kernel tables" File="">
    <BlockHolder BlockName="--body" BlockCode=" 

-- kernel tables --
create table if not exists sysoptions(
sysoptionsid binary(16) primary key ,
name varchar(255) null,
value varchar(255) null,
optiontype varchar(255) null
)
go
create table if not exists typelist(
typelistid binary(16) primary key ,
name varchar(255) not null,
securitystyleid binary(16) null, /* default security style for type */
registerproc varchar(255) null,
deleteproc varchar(255) null,
hclproc varchar(255) null /* has children locked */,
propagateproc varchar(255) null /* propagate secrity styleto children */
)
go
create table if not exists instance(
instanceid binary(16) primary key ,
lockuserid binary(16) null, 
locksessionid binary(16) null, 
securitystyleid binary(16) null, /* default security style for document */
changestamp date null,
name varchar(255) null,
objtype varchar(255) null,
exportcounter integer null, 
 ownerpartname varchar(255) null
,ownerrowid binary(16) null
, status binary(16) null
, archived int null default 0
)
go
create table if not exists queryresult (
  queryresultid binary(16) not null ,
  result binary(16) null 
)
go
create table if not exists rpresult (
  rpresultid binary(16) not null ,
  parentlevel int not null ,
  partname varchar (255) null ,
  rowid binary(16) null )
go
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Tables" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
/* TYPE=iud_stage (Этап производства) */
GO

/*этапы*/
create table if not exists iud_stagedef/*этапы процесса*/ (
instanceid binary(16) ,
iud_stagedefid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_stagedef' and 
           column_name   = 'name') then
                alter table iud_stagedef add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_stagedef' and 
           column_name   = 'sequence') then
                alter table iud_stagedef add 
                sequence
 integer null /* порядок вывода */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_stagedef' and 
           column_name   = 'stageicon') then
                alter table iud_stagedef add 
                stageicon
 varchar (80) null /* иконка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_stagedef' and 
           constraint_type   = 'primary key') then
            alter table iud_stagedef add constraint pk_iud_stagedef primary key (iud_stagedefid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_adtype (Тип документа к акту) */
GO

/*тип документа к акту*/
create table if not exists iud_adt_doc/*тип документа к акту*/ (
instanceid binary(16) ,
iud_adt_docid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_adt_doc' and 
           column_name   = 'name') then
                alter table iud_adt_doc add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_adt_doc' and 
           constraint_type   = 'primary key') then
            alter table iud_adt_doc add constraint pk_iud_adt_doc primary key (iud_adt_docid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_org (Орг.структура) */
GO

/*орг структура*/
create table if not exists iu_orgtree/*орг. структура*/ (
instanceid binary(16) ,
iu_orgtreeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
,parentrowid binary(16) 
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_orgtree' and 
           column_name   = 'name') then
                alter table iu_orgtree add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_orgtree' and 
           constraint_type   = 'primary key') then
            alter table iu_orgtree add constraint pk_iu_orgtree primary key (iu_orgtreeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*сотрудники*/
create table if not exists iu_orgusr/*сотрудники*/ (
parentstructrowid binary(16) not null,
iu_orgusrid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_orgusr' and 
           column_name   = 'orguser') then
                alter table iu_orgusr add 
                orguser binary(16) null /* сотрудник */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_orgusr' and 
           column_name   = 'ismanager') then
                alter table iu_orgusr add 
                ismanager
 integer null /* начальник подразделения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_orgusr' and 
           constraint_type   = 'primary key') then
            alter table iu_orgusr add constraint pk_iu_orgusr primary key (iu_orgusrid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_u (Сотрудник) */
GO

/*данные сотрудника*/
create table if not exists iu_u_def/*данные сотрудника*/ (
instanceid binary(16) ,
iu_u_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'archived') then
                alter table iu_u_def add 
                archived int null default 0;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'lastname') then
                alter table iu_u_def add 
                lastname
 varchar (120) null /* фамилия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'name') then
                alter table iu_u_def add 
                name
 varchar (120) null /* имя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'surname') then
                alter table iu_u_def add 
                surname
 varchar (120) null /* отчество */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'currole') then
                alter table iu_u_def add 
                currole binary(16) null /* роль в производстве */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'thetown') then
                alter table iu_u_def add 
                thetown binary(16) null /* город */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'sendtomail') then
                alter table iu_u_def add 
                sendtomail
 integer null /* оповещать по почте */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'freelancer') then
                alter table iu_u_def add 
                freelancer
 integer null /* удаленная работа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'email') then
                alter table iu_u_def add 
                email
 varchar (60) null /* e-mail */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'thephone') then
                alter table iu_u_def add 
                thephone
 varchar (40) null /* телефон */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'login') then
                alter table iu_u_def add 
                login
 varchar (64) null /* имя для входа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def' and 
           column_name   = 'lastsend') then
                alter table iu_u_def add 
                lastsend
 datetime null /* последнее сканирование задач */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_u_def' and 
           constraint_type   = 'primary key') then
            alter table iu_u_def add constraint pk_iu_u_def primary key (iu_u_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*данные сотрудника*/
create table if not exists iu_u_def_temp/*данные сотрудника temp table*/ (
sessionid binary(16) ,/*  id текущей сесии пользователя   */ 
instanceid binary(16) ,
iu_u_defid binary(16) not null  
,changestamp datetime not null /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'archived') then
                alter table iu_u_def_temp add 
                archived int null default 0;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'lastname') then
                alter table iu_u_def_temp add 
                lastname
 varchar (120) null /* фамилия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'name') then
                alter table iu_u_def_temp add 
                name
 varchar (120) null /* имя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'surname') then
                alter table iu_u_def_temp add 
                surname
 varchar (120) null /* отчество */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'currole') then
                alter table iu_u_def_temp add 
                currole binary(16) null /* роль в производстве */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'thetown') then
                alter table iu_u_def_temp add 
                thetown binary(16) null /* город */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'sendtomail') then
                alter table iu_u_def_temp add 
                sendtomail
 integer null /* оповещать по почте */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'freelancer') then
                alter table iu_u_def_temp add 
                freelancer
 integer null /* удаленная работа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'email') then
                alter table iu_u_def_temp add 
                email
 varchar (60) null /* e-mail */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'thephone') then
                alter table iu_u_def_temp add 
                thephone
 varchar (40) null /* телефон */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'login') then
                alter table iu_u_def_temp add 
                login
 varchar (64) null /* имя для входа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           column_name   = 'lastsend') then
                alter table iu_u_def_temp add 
                lastsend
 datetime null /* последнее сканирование задач */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_u_def_temp' and 
           constraint_type   = 'primary key') then
            alter table iu_u_def_temp add constraint pk_iu_u_def_temp primary key (sessionid,iu_u_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_process (Тип производственного процесса) */
GO

/*процесс*/
create table if not exists iud_process_def/*тип документа*/ (
instanceid binary(16) ,
iud_process_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_process_def' and 
           column_name   = 'name') then
                alter table iud_process_def add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_process_def' and 
           constraint_type   = 'primary key') then
            alter table iud_process_def add constraint pk_iud_process_def primary key (iud_process_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZMetaModel (Спец.: Метамодель системы) */
GO

/*пакет генерации*/
create table if not exists genpackage/*пакет генерации*/ (
instanceid binary(16) ,
genpackageid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'genpackage' and 
           column_name   = 'name') then
                alter table genpackage add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'genpackage' and 
           constraint_type   = 'primary key') then
            alter table genpackage add constraint pk_genpackage primary key (genpackageid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*генераторы*/
create table if not exists generator_target/*генераторы*/ (
parentstructrowid binary(16) not null,
generator_targetid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'generator_target' and 
           column_name   = 'name') then
                alter table generator_target add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'generator_target' and 
           column_name   = 'targettype') then
                alter table generator_target add 
                targettype
 integer null /* тип платформы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'generator_target' and 
           column_name   = 'queuename') then
                alter table generator_target add 
                queuename
 varchar (255) null /* очередь */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'generator_target' and 
           column_name   = 'generatorprogid') then
                alter table generator_target add 
                generatorprogid
 varchar (255) null /* com класс */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'generator_target' and 
           column_name   = 'generatorstyle') then
                alter table generator_target add 
                generatorstyle
 integer null /* вариант */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'generator_target' and 
           column_name   = 'thedevelopmentenv') then
                alter table generator_target add 
                thedevelopmentenv
 integer null /* среда разработки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'generator_target' and 
           constraint_type   = 'primary key') then
            alter table generator_target add constraint pk_generator_target primary key (generator_targetid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*библиотеки*/
create table if not exists genreference/*библиотеки, которые используются при генерации*/ (
parentstructrowid binary(16) not null,
genreferenceid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'genreference' and 
           column_name   = 'name') then
                alter table genreference add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'genreference' and 
           column_name   = 'refclassid') then
                alter table genreference add 
                refclassid
 varchar (40) null /* класс ссылки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'genreference' and 
           column_name   = 'versionmajor') then
                alter table genreference add 
                versionmajor
 integer null /* номер версии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'genreference' and 
           column_name   = 'versionminor') then
                alter table genreference add 
                versionminor
 integer null /* подверсия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'genreference' and 
           constraint_type   = 'primary key') then
            alter table genreference add constraint pk_genreference primary key (genreferenceid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*ручной код*/
create table if not exists genmanualcode/*код, который не укладывается в описание модели*/ (
parentstructrowid binary(16) not null,
genmanualcodeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'genmanualcode' and 
           column_name   = 'name') then
                alter table genmanualcode add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'genmanualcode' and 
           column_name   = 'the_alias') then
                alter table genmanualcode add 
                the_alias
 varchar (80) null /* псевдоним */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'genmanualcode' and 
           column_name   = 'code') then
                alter table genmanualcode add 
                code
 text null /* код */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'genmanualcode' and 
           constraint_type   = 'primary key') then
            alter table genmanualcode add constraint pk_genmanualcode primary key (genmanualcodeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*контрольные элементы*/
create table if not exists gencontrols/*контрольные элементы, которые используются при генерации*/ (
parentstructrowid binary(16) not null,
gencontrolsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'gencontrols' and 
           column_name   = 'controlprogid') then
                alter table gencontrols add 
                controlprogid
 varchar (255) null /* progid контрольконо элемента */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'gencontrols' and 
           column_name   = 'controlclassid') then
                alter table gencontrols add 
                controlclassid
 varchar (40) null /* класс контрольногоэлемента */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'gencontrols' and 
           column_name   = 'versionmajor') then
                alter table gencontrols add 
                versionmajor
 integer null /* версия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'gencontrols' and 
           column_name   = 'versionminor') then
                alter table gencontrols add 
                versionminor
 integer null /* подверсия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'gencontrols' and 
           constraint_type   = 'primary key') then
            alter table gencontrols add constraint pk_gencontrols primary key (gencontrolsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*локализация*/
create table if not exists localizeinfo/**/ (
instanceid binary(16) ,
localizeinfoid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'localizeinfo' and 
           column_name   = 'langfull') then
                alter table localizeinfo add 
                langfull
 varchar (255) null /* язык - название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'localizeinfo' and 
           column_name   = 'langshort') then
                alter table localizeinfo add 
                langshort
 varchar (255) null /* код языка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'localizeinfo' and 
           constraint_type   = 'primary key') then
            alter table localizeinfo add constraint pk_localizeinfo primary key (localizeinfoid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*тип поля*/
create table if not exists fieldtype/*типы полей, перечисления, интервалы*/ (
instanceid binary(16) ,
fieldtypeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtype' and 
           column_name   = 'name') then
                alter table fieldtype add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtype' and 
           column_name   = 'typestyle') then
                alter table fieldtype add 
                typestyle
 integer null /* трактовка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtype' and 
           column_name   = 'the_comment') then
                alter table fieldtype add 
                the_comment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtype' and 
           column_name   = 'allowsize') then
                alter table fieldtype add 
                allowsize
 integer null /* нужен размер */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtype' and 
           column_name   = 'minimum') then
                alter table fieldtype add 
                minimum
 varchar (64) null /* минимум */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtype' and 
           column_name   = 'maximum') then
                alter table fieldtype add 
                maximum
 varchar (64) null /* максимум */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtype' and 
           column_name   = 'allowlikesearch') then
                alter table fieldtype add 
                allowlikesearch
 integer null /* поиск текста */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtype' and 
           column_name   = 'gridsorttype') then
                alter table fieldtype add 
                gridsorttype
 integer null /* вариант сортировки в табличном представлении */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtype' and 
           column_name   = 'delayedsave') then
                alter table fieldtype add 
                delayedsave
 integer null /* отложенное сохранение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'fieldtype' and 
           constraint_type   = 'primary key') then
            alter table fieldtype add constraint pk_fieldtype primary key (fieldtypeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*зачения*/
create table if not exists enumitem/*для описания enum типов*/ (
parentstructrowid binary(16) not null,
enumitemid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'enumitem' and 
           column_name   = 'name') then
                alter table enumitem add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'enumitem' and 
           column_name   = 'namevalue') then
                alter table enumitem add 
                namevalue
 integer null /* значение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'enumitem' and 
           column_name   = 'nameincode') then
                alter table enumitem add 
                nameincode
 varchar (100) null /* название в коде */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'enumitem' and 
           constraint_type   = 'primary key') then
            alter table enumitem add constraint pk_enumitem primary key (enumitemid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*отображение*/
create table if not exists fieldtypemap/*отображение типа поля на физический тип хранения*/ (
parentstructrowid binary(16) not null,
fieldtypemapid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtypemap' and 
           column_name   = 'target') then
                alter table fieldtypemap add 
                target binary(16) null /* платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtypemap' and 
           column_name   = 'stoagetype') then
                alter table fieldtypemap add 
                stoagetype
 varchar (255) null /* тип хранения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldtypemap' and 
           column_name   = 'fixedsize') then
                alter table fieldtypemap add 
                fixedsize
 integer null /* размер */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'fieldtypemap' and 
           constraint_type   = 'primary key') then
            alter table fieldtypemap add constraint pk_fieldtypemap primary key (fieldtypemapid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*методы и процедуры*/
create table if not exists sharedmethod/*методы и процедуры*/ (
instanceid binary(16) ,
sharedmethodid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sharedmethod' and 
           column_name   = 'name') then
                alter table sharedmethod add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sharedmethod' and 
           column_name   = 'the_comment') then
                alter table sharedmethod add 
                the_comment
 text null /* описание метода */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sharedmethod' and 
           column_name   = 'returntype') then
                alter table sharedmethod add 
                returntype binary(16) null /* возвращаемый тип */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'sharedmethod' and 
           constraint_type   = 'primary key') then
            alter table sharedmethod add constraint pk_sharedmethod primary key (sharedmethodid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*реализация*/
create table if not exists script/*код метода на понятном конкретному генератору языке*/ (
parentstructrowid binary(16) not null,
scriptid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'script' and 
           column_name   = 'target') then
                alter table script add 
                target binary(16) null /* целевая платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'script' and 
           column_name   = 'code') then
                alter table script add 
                code
 text null /* скрипт */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'script' and 
           constraint_type   = 'primary key') then
            alter table script add constraint pk_script primary key (scriptid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*параметры*/
create table if not exists parameters/*параметры метода*/ (
parentstructrowid binary(16) not null,
parametersid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parameters' and 
           column_name   = 'sequence') then
                alter table parameters add 
                sequence
 integer null /* последовательность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parameters' and 
           column_name   = 'name') then
                alter table parameters add 
                name
 varchar (80) null /* имя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parameters' and 
           column_name   = 'caption') then
                alter table parameters add 
                caption
 varchar (80) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parameters' and 
           column_name   = 'typeofparm') then
                alter table parameters add 
                typeofparm binary(16) null /* тип данных */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parameters' and 
           column_name   = 'datasize') then
                alter table parameters add 
                datasize
 integer null /* размер */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parameters' and 
           column_name   = 'allownull') then
                alter table parameters add 
                allownull
 integer null /* можно не задавать */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parameters' and 
           column_name   = 'outparam') then
                alter table parameters add 
                outparam
 integer null /* возвращает значение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parameters' and 
           column_name   = 'referencetype') then
                alter table parameters add 
                referencetype
 integer null /* тип ссылки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parameters' and 
           column_name   = 'reftotype') then
                alter table parameters add 
                reftotype binary(16) null /* ссылка на тип */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parameters' and 
           column_name   = 'reftopart') then
                alter table parameters add 
                reftopart binary(16) null /* ссылка на раздел */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'parameters' and 
           constraint_type   = 'primary key') then
            alter table parameters add constraint pk_parameters primary key (parametersid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*тип объекта*/
create table if not exists objecttype/*тип объекта (карточки)*/ (
instanceid binary(16) ,
objecttypeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'package') then
                alter table objecttype add 
                package binary(16) null /* приложение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'the_comment') then
                alter table objecttype add 
                the_comment
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'name') then
                alter table objecttype add 
                name
 varchar (14) null /* код */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'issingleinstance') then
                alter table objecttype add 
                issingleinstance
 integer null /* допускается только один объект */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'chooseview') then
                alter table objecttype add 
                chooseview binary(16) null /* представление для выбора */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'onrun') then
                alter table objecttype add 
                onrun binary(16) null /* при запуске */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'oncreate') then
                alter table objecttype add 
                oncreate binary(16) null /* при создании */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'ondelete') then
                alter table objecttype add 
                ondelete binary(16) null /* при удалении */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'allowreftoobject') then
                alter table objecttype add 
                allowreftoobject
 integer null /* отображать при выборе ссылки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'allowsearch') then
                alter table objecttype add 
                allowsearch
 integer null /* отображать при поиске */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'replicatype') then
                alter table objecttype add 
                replicatype
 integer null /* тип репликации */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'thecomment') then
                alter table objecttype add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'useownership') then
                alter table objecttype add 
                useownership
 integer null /* видмость зависит от пользователя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'usearchiving') then
                alter table objecttype add 
                usearchiving
 integer null /* архивировать вместо удаления */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'commitfullobject') then
                alter table objecttype add 
                commitfullobject
 integer null /* сохранять объект целиком */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objecttype' and 
           column_name   = 'objiconcls') then
                alter table objecttype add 
                objiconcls
 varchar (80) null /* иконка объекта */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'objecttype' and 
           constraint_type   = 'primary key') then
            alter table objecttype add constraint pk_objecttype primary key (objecttypeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*состояния*/
create table if not exists objstatus/*возможные логические состояния документа*/ (
parentstructrowid binary(16) not null,
objstatusid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objstatus' and 
           column_name   = 'name') then
                alter table objstatus add 
                name
 varchar (80) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objstatus' and 
           column_name   = 'isstartup') then
                alter table objstatus add 
                isstartup
 integer null /* начальное */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objstatus' and 
           column_name   = 'isarchive') then
                alter table objstatus add 
                isarchive
 integer null /* архивное */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objstatus' and 
           column_name   = 'the_comment') then
                alter table objstatus add 
                the_comment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'objstatus' and 
           constraint_type   = 'primary key') then
            alter table objstatus add constraint pk_objstatus primary key (objstatusid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*разрешенные переходы*/
create table if not exists nextstate/*матрица переходов */ (
parentstructrowid binary(16) not null,
nextstateid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'nextstate' and 
           column_name   = 'thestate') then
                alter table nextstate add 
                thestate binary(16) null /* разрешенное состояние */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'nextstate' and 
           constraint_type   = 'primary key') then
            alter table nextstate add constraint pk_nextstate primary key (nextstateid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*режим работы*/
create table if not exists objectmode/*режим работы*/ (
parentstructrowid binary(16) not null,
objectmodeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objectmode' and 
           column_name   = 'name') then
                alter table objectmode add 
                name
 varchar (5) null /* название режима */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objectmode' and 
           column_name   = 'defaultmode') then
                alter table objectmode add 
                defaultmode
 integer null /* этот режим является основным режимом работы объекта */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'objectmode' and 
           column_name   = 'thecomment') then
                alter table objectmode add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'objectmode' and 
           constraint_type   = 'primary key') then
            alter table objectmode add constraint pk_objectmode primary key (objectmodeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*органичения разделов*/
create table if not exists structrestriction/*ораничения на доступ к разделу документа*/ (
parentstructrowid binary(16) not null,
structrestrictionid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'structrestriction' and 
           column_name   = 'struct') then
                alter table structrestriction add 
                struct binary(16) null /* структура, доступ к которой ограничен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'structrestriction' and 
           column_name   = 'allowread') then
                alter table structrestriction add 
                allowread
 integer null /* разрешен просмотр */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'structrestriction' and 
           column_name   = 'allowadd') then
                alter table structrestriction add 
                allowadd
 integer null /* разрешено добавлять */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'structrestriction' and 
           column_name   = 'allowedit') then
                alter table structrestriction add 
                allowedit
 integer null /* разрешено изменять */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'structrestriction' and 
           column_name   = 'allowdelete') then
                alter table structrestriction add 
                allowdelete
 integer null /* разрешено удалять */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'structrestriction' and 
           constraint_type   = 'primary key') then
            alter table structrestriction add constraint pk_structrestriction primary key (structrestrictionid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*ограничения методов*/
create table if not exists methodrestriction/*ограничение на использование методов раздела*/ (
parentstructrowid binary(16) not null,
methodrestrictionid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'methodrestriction' and 
           column_name   = 'part') then
                alter table methodrestriction add 
                part binary(16) null /* структура, которой принадлежит метод */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'methodrestriction' and 
           column_name   = 'method') then
                alter table methodrestriction add 
                method binary(16) null /* метод */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'methodrestriction' and 
           column_name   = 'isrestricted') then
                alter table methodrestriction add 
                isrestricted
 integer null /* запрещено использовать */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'methodrestriction' and 
           constraint_type   = 'primary key') then
            alter table methodrestriction add constraint pk_methodrestriction primary key (methodrestrictionid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*ограничения полей*/
create table if not exists fieldrestriction/*ограничения на доступ к полям раздела*/ (
parentstructrowid binary(16) not null,
fieldrestrictionid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldrestriction' and 
           column_name   = 'thepart') then
                alter table fieldrestriction add 
                thepart binary(16) null /* структура, которой принадлежит поле */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldrestriction' and 
           column_name   = 'thefield') then
                alter table fieldrestriction add 
                thefield binary(16) null /* поле, на которое накладывается ограничение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldrestriction' and 
           column_name   = 'allowread') then
                alter table fieldrestriction add 
                allowread
 integer null /* разрешен просмотр */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldrestriction' and 
           column_name   = 'allowmodify') then
                alter table fieldrestriction add 
                allowmodify
 integer null /* разрешена модификация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldrestriction' and 
           column_name   = 'mandatoryfield') then
                alter table fieldrestriction add 
                mandatoryfield
 integer null /* обязательное поле */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'fieldrestriction' and 
           constraint_type   = 'primary key') then
            alter table fieldrestriction add constraint pk_fieldrestriction primary key (fieldrestrictionid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*методы типа*/
create table if not exists typemenu/*методы уровня типа*/ (
parentstructrowid binary(16) not null,
typemenuid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'typemenu' and 
           column_name   = 'name') then
                alter table typemenu add 
                name
 varchar (64) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'typemenu' and 
           column_name   = 'caption') then
                alter table typemenu add 
                caption
 varchar (80) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'typemenu' and 
           column_name   = 'tooltip') then
                alter table typemenu add 
                tooltip
 varchar (80) null /* подсказка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'typemenu' and 
           column_name   = 'the_action') then
                alter table typemenu add 
                the_action binary(16) null /* метод */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'typemenu' and 
           column_name   = 'ismenuitem') then
                alter table typemenu add 
                ismenuitem
 integer null /* включать в меню */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'typemenu' and 
           column_name   = 'istoolbarbutton') then
                alter table typemenu add 
                istoolbarbutton
 integer null /* включать в тулбар */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'typemenu' and 
           column_name   = 'hotkey') then
                alter table typemenu add 
                hotkey
 varchar (20) null /* горячая клавиша */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'typemenu' and 
           constraint_type   = 'primary key') then
            alter table typemenu add constraint pk_typemenu primary key (typemenuid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*проверка правильности*/
create table if not exists instancevalidator/*проверка правильности для объекта в целом*/ (
parentstructrowid binary(16) not null,
instancevalidatorid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'instancevalidator' and 
           column_name   = 'target') then
                alter table instancevalidator add 
                target binary(16) null /* платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'instancevalidator' and 
           column_name   = 'code') then
                alter table instancevalidator add 
                code
 text null /* скрипт */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'instancevalidator' and 
           constraint_type   = 'primary key') then
            alter table instancevalidator add constraint pk_instancevalidator primary key (instancevalidatorid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*раздел*/
create table if not exists part/*раздел объекта*/ (
parentstructrowid binary(16) not null,
partid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
,parentrowid binary(16) 
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'sequence') then
                alter table part add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'parttype') then
                alter table part add 
                parttype
 integer null /* тип структры */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'caption') then
                alter table part add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'name') then
                alter table part add 
                name
 varchar (20) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'the_comment') then
                alter table part add 
                the_comment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'nolog') then
                alter table part add 
                nolog
 integer null /* не записывать в журнал */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'manualregister') then
                alter table part add 
                manualregister
 integer null /* исключить из индексирования */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'oncreate') then
                alter table part add 
                oncreate binary(16) null /* при создании */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'onsave') then
                alter table part add 
                onsave binary(16) null /* при сохранении */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'onrun') then
                alter table part add 
                onrun binary(16) null /* при открытии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'ondelete') then
                alter table part add 
                ondelete binary(16) null /* при удалении */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'addbehaivor') then
                alter table part add 
                addbehaivor
 integer null /* поведение при добавлении */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'extenderobject') then
                alter table part add 
                extenderobject binary(16) null /* объект расширения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'shablonbrief') then
                alter table part add 
                shablonbrief
 varchar (100) null /* шаблон для краткого отображения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'rulebrief') then
                alter table part add 
                rulebrief
 varchar (500) null /* правило составления brief поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'isjormalchange') then
                alter table part add 
                isjormalchange
 integer null /* вести журнал изменений */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'usearchiving') then
                alter table part add 
                usearchiving
 integer null /* архивировать вместо удаления */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'integerpkey') then
                alter table part add 
                integerpkey
 integer null /* целочисленный ключ */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'part' and 
           column_name   = 'particoncls') then
                alter table part add 
                particoncls
 varchar (80) null /* иконка раздела */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'part' and 
           constraint_type   = 'primary key') then
            alter table part add constraint pk_part primary key (partid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*методы раздела*/
create table if not exists partmenu/*методы уровня раздела*/ (
parentstructrowid binary(16) not null,
partmenuid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partmenu' and 
           column_name   = 'name') then
                alter table partmenu add 
                name
 varchar (64) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partmenu' and 
           column_name   = 'caption') then
                alter table partmenu add 
                caption
 varchar (80) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partmenu' and 
           column_name   = 'tooltip') then
                alter table partmenu add 
                tooltip
 varchar (80) null /* подсказка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partmenu' and 
           column_name   = 'the_action') then
                alter table partmenu add 
                the_action binary(16) null /* метод */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partmenu' and 
           column_name   = 'ismenuitem') then
                alter table partmenu add 
                ismenuitem
 integer null /* включать в меню */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partmenu' and 
           column_name   = 'istoolbarbutton') then
                alter table partmenu add 
                istoolbarbutton
 integer null /* в тулбар */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partmenu' and 
           column_name   = 'hotkey') then
                alter table partmenu add 
                hotkey
 varchar (20) null /* горячая клавиша */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'partmenu' and 
           constraint_type   = 'primary key') then
            alter table partmenu add constraint pk_partmenu primary key (partmenuid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*отображение параметров*/
create table if not exists partparammap/*отображение значений полей раздела на параметры метода*/ (
parentstructrowid binary(16) not null,
partparammapid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partparammap' and 
           column_name   = 'fieldname') then
                alter table partparammap add 
                fieldname
 varchar (255) null /* поле (значение) */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partparammap' and 
           column_name   = 'paramname') then
                alter table partparammap add 
                paramname
 varchar (80) null /* параметр */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partparammap' and 
           column_name   = 'noedit') then
                alter table partparammap add 
                noedit
 integer null /* редактировать параметр нельзя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'partparammap' and 
           constraint_type   = 'primary key') then
            alter table partparammap add constraint pk_partparammap primary key (partparammapid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*представление*/
create table if not exists partview/*вариант представления, который может использоваться для создания журнала*/ (
parentstructrowid binary(16) not null,
partviewid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview' and 
           column_name   = 'name') then
                alter table partview add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview' and 
           column_name   = 'the_alias') then
                alter table partview add 
                the_alias
 varchar (64) null /* псевдоним */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview' and 
           column_name   = 'forchoose') then
                alter table partview add 
                forchoose
 integer null /* для поиска */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview' and 
           column_name   = 'filterfield0') then
                alter table partview add 
                filterfield0
 varchar (255) null /* поле - фильтр 0 */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview' and 
           column_name   = 'filterfield1') then
                alter table partview add 
                filterfield1
 varchar (255) null /* поле - фильтр 1 */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview' and 
           column_name   = 'filterfield2') then
                alter table partview add 
                filterfield2
 varchar (255) null /* поле - фильтр 2 */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview' and 
           column_name   = 'filterfield3') then
                alter table partview add 
                filterfield3
 varchar (255) null /* поле - фильтр 3 */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'partview' and 
           constraint_type   = 'primary key') then
            alter table partview add constraint pk_partview primary key (partviewid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*колонка*/
create table if not exists viewcolumn/*колонка пердставления*/ (
parentstructrowid binary(16) not null,
viewcolumnid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'viewcolumn' and 
           column_name   = 'sequence') then
                alter table viewcolumn add 
                sequence
 integer null /* № */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'viewcolumn' and 
           column_name   = 'name') then
                alter table viewcolumn add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'viewcolumn' and 
           column_name   = 'the_alias') then
                alter table viewcolumn add 
                the_alias
 varchar (64) null /* псвдоним */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'viewcolumn' and 
           column_name   = 'frompart') then
                alter table viewcolumn add 
                frompart binary(16) null /* раздел */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'viewcolumn' and 
           column_name   = 'field') then
                alter table viewcolumn add 
                field binary(16) null /* поле */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'viewcolumn' and 
           column_name   = 'aggregation') then
                alter table viewcolumn add 
                aggregation
 integer null /* агрегация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'viewcolumn' and 
           column_name   = 'expression') then
                alter table viewcolumn add 
                expression
 text null /* формула */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'viewcolumn' and 
           column_name   = 'forcombo') then
                alter table viewcolumn add 
                forcombo
 integer null /* для комбо */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'viewcolumn' and 
           constraint_type   = 'primary key') then
            alter table viewcolumn add constraint pk_viewcolumn primary key (viewcolumnid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*связанные представления*/
create table if not exists partview_lnk/**/ (
parentstructrowid binary(16) not null,
partview_lnkid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview_lnk' and 
           column_name   = 'theview') then
                alter table partview_lnk add 
                theview binary(16) null /* представление */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview_lnk' and 
           column_name   = 'thejoinsource') then
                alter table partview_lnk add 
                thejoinsource binary(16) null /* связь: поле для join источник */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview_lnk' and 
           column_name   = 'reftype') then
                alter table partview_lnk add 
                reftype
 integer null /* связывать как */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview_lnk' and 
           column_name   = 'thejoindestination') then
                alter table partview_lnk add 
                thejoindestination binary(16) null /* свзяь: поле для join приемник */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview_lnk' and 
           column_name   = 'handjoin') then
                alter table partview_lnk add 
                handjoin
 varchar (255) null /* ручной join */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'partview_lnk' and 
           column_name   = 'seq') then
                alter table partview_lnk add 
                seq
 integer null /* порядок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'partview_lnk' and 
           constraint_type   = 'primary key') then
            alter table partview_lnk add constraint pk_partview_lnk primary key (partview_lnkid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*логика на форме*/
create table if not exists validator/*действия в впроцессе редактирования*/ (
parentstructrowid binary(16) not null,
validatorid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'validator' and 
           column_name   = 'target') then
                alter table validator add 
                target binary(16) null /* целевая платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'validator' and 
           column_name   = 'code') then
                alter table validator add 
                code
 text null /* скрипт */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'validator' and 
           constraint_type   = 'primary key') then
            alter table validator add constraint pk_validator primary key (validatorid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*ограничение уникальности*/
create table if not exists uniqueconstraint/*ограничение уникальности*/ (
parentstructrowid binary(16) not null,
uniqueconstraintid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'uniqueconstraint' and 
           column_name   = 'name') then
                alter table uniqueconstraint add 
                name
 varchar (80) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'uniqueconstraint' and 
           column_name   = 'perparent') then
                alter table uniqueconstraint add 
                perparent
 integer null /* по родителю */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'uniqueconstraint' and 
           column_name   = 'thecomment') then
                alter table uniqueconstraint add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'uniqueconstraint' and 
           constraint_type   = 'primary key') then
            alter table uniqueconstraint add constraint pk_uniqueconstraint primary key (uniqueconstraintid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*поля ограничения*/
create table if not exists constraintfield/*поля ограничения*/ (
parentstructrowid binary(16) not null,
constraintfieldid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'constraintfield' and 
           column_name   = 'thefield') then
                alter table constraintfield add 
                thefield binary(16) null /* поле */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'constraintfield' and 
           constraint_type   = 'primary key') then
            alter table constraintfield add constraint pk_constraintfield primary key (constraintfieldid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*интерфейсы расширения*/
create table if not exists extenderinterface/**/ (
parentstructrowid binary(16) not null,
extenderinterfaceid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'extenderinterface' and 
           column_name   = 'thename') then
                alter table extenderinterface add 
                thename
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'extenderinterface' and 
           column_name   = 'targetplatform') then
                alter table extenderinterface add 
                targetplatform binary(16) null /* целевая платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'extenderinterface' and 
           column_name   = 'theobject') then
                alter table extenderinterface add 
                theobject
 varchar (255) null /* объект */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'extenderinterface' and 
           column_name   = 'theconfig') then
                alter table extenderinterface add 
                theconfig
 varchar (512) null /* конфиг */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'extenderinterface' and 
           constraint_type   = 'primary key') then
            alter table extenderinterface add constraint pk_extenderinterface primary key (extenderinterfaceid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*поле*/
create table if not exists field/*поле*/ (
parentstructrowid binary(16) not null,
fieldid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'tabname') then
                alter table field add 
                tabname
 varchar (60) null /* имя вкладки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'fieldgroupbox') then
                alter table field add 
                fieldgroupbox
 varchar (60) null /* имя группы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'sequence') then
                alter table field add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'caption') then
                alter table field add 
                caption
 varchar (80) null /* надпись */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'name') then
                alter table field add 
                name
 varchar (64) null /* имя поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'fieldtype') then
                alter table field add 
                fieldtype binary(16) null /* тип поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'isbrief') then
                alter table field add 
                isbrief
 integer null /* краткая информация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'istabbrief') then
                alter table field add 
                istabbrief
 integer null /* для отображения в таблице */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'allownull') then
                alter table field add 
                allownull
 integer null /* может быть пустым */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'datasize') then
                alter table field add 
                datasize
 integer null /* размер поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'referencetype') then
                alter table field add 
                referencetype
 integer null /* тип ссылки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'reftotype') then
                alter table field add 
                reftotype binary(16) null /* ссылка на тип */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'reftopart') then
                alter table field add 
                reftopart binary(16) null /* ссылка на раздел */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'thestyle') then
                alter table field add 
                thestyle
 varchar (50) null /* стиль */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'internalreference') then
                alter table field add 
                internalreference
 integer null /* ссылка в пределах объекта */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'createrefonly') then
                alter table field add 
                createrefonly
 integer null /* только создание объекта */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'isautonumber') then
                alter table field add 
                isautonumber
 integer null /* автонумерация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'thenumerator') then
                alter table field add 
                thenumerator binary(16) null /* нумератор */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'zonetemplate') then
                alter table field add 
                zonetemplate
 varchar (255) null /* шаблон зоны нумерации */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'numberdatefield') then
                alter table field add 
                numberdatefield binary(16) null /* поле для расчета даты */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'thecomment') then
                alter table field add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'shablonbrief') then
                alter table field add 
                shablonbrief
 varchar (100) null /* шаблон для краткого отображения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'thenameclass') then
                alter table field add 
                thenameclass
 varchar (100) null /* имя класса для мастера строк */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'field' and 
           column_name   = 'themask') then
                alter table field add 
                themask
 varchar (64) null /* маска */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'field' and 
           constraint_type   = 'primary key') then
            alter table field add constraint pk_field primary key (fieldid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*интерфейсы расширения*/
create table if not exists fldextenders/**/ (
parentstructrowid binary(16) not null,
fldextendersid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fldextenders' and 
           column_name   = 'thename') then
                alter table fldextenders add 
                thename
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fldextenders' and 
           column_name   = 'targetplatform') then
                alter table fldextenders add 
                targetplatform binary(16) null /* целевая платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fldextenders' and 
           column_name   = 'theobject') then
                alter table fldextenders add 
                theobject
 varchar (255) null /* объект */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fldextenders' and 
           column_name   = 'theconfig') then
                alter table fldextenders add 
                theconfig
 varchar (512) null /* конфиг */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'fldextenders' and 
           constraint_type   = 'primary key') then
            alter table fldextenders add constraint pk_fldextenders primary key (fldextendersid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*описание источника данных*/
create table if not exists fieldsrcdef/*описание источника данных для полей типа referencesql */ (
parentstructrowid binary(16) not null,
fieldsrcdefid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldsrcdef' and 
           column_name   = 'provider') then
                alter table fieldsrcdef add 
                provider
 varchar (128) null /* провайдер */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldsrcdef' and 
           column_name   = 'connectionstring') then
                alter table fieldsrcdef add 
                connectionstring
 varchar (512) null /* строка соединения с источником */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldsrcdef' and 
           column_name   = 'datasource') then
                alter table fieldsrcdef add 
                datasource
 varchar (512) null /* источник данных */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldsrcdef' and 
           column_name   = 'idfield') then
                alter table fieldsrcdef add 
                idfield
 varchar (128) null /* id */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldsrcdef' and 
           column_name   = 'briefstring') then
                alter table fieldsrcdef add 
                briefstring
 varchar (512) null /* источник краткой информации */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldsrcdef' and 
           column_name   = 'filterstring') then
                alter table fieldsrcdef add 
                filterstring
 varchar (512) null /* фильтр источника данных */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldsrcdef' and 
           column_name   = 'sortfield') then
                alter table fieldsrcdef add 
                sortfield
 varchar (512) null /* сортировка источника данных */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldsrcdef' and 
           column_name   = 'descriptionstring') then
                alter table fieldsrcdef add 
                descriptionstring
 text null /* примечания */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldsrcdef' and 
           column_name   = 'dontshowdialog') then
                alter table fieldsrcdef add 
                dontshowdialog
 integer null /* не показывать форму выбора */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'fieldsrcdef' and 
           constraint_type   = 'primary key') then
            alter table fieldsrcdef add constraint pk_fieldsrcdef primary key (fieldsrcdefid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*динамический фильтр*/
create table if not exists dinamicfilterscript/*выражение для построения дополнительного фильтра для ссылочных полей*/ (
parentstructrowid binary(16) not null,
dinamicfilterscriptid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'dinamicfilterscript' and 
           column_name   = 'target') then
                alter table dinamicfilterscript add 
                target binary(16) null /* целевая платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'dinamicfilterscript' and 
           column_name   = 'code') then
                alter table dinamicfilterscript add 
                code
 text null /* скрипт */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'dinamicfilterscript' and 
           constraint_type   = 'primary key') then
            alter table dinamicfilterscript add constraint pk_dinamicfilterscript primary key (dinamicfilterscriptid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*значение по умолчанию*/
create table if not exists fieldexpression/*выражение для вычисления поля
или значение по умолчанию*/ (
parentstructrowid binary(16) not null,
fieldexpressionid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldexpression' and 
           column_name   = 'target') then
                alter table fieldexpression add 
                target binary(16) null /* платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldexpression' and 
           column_name   = 'code') then
                alter table fieldexpression add 
                code
 text null /* скрипт */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'fieldexpression' and 
           constraint_type   = 'primary key') then
            alter table fieldexpression add constraint pk_fieldexpression primary key (fieldexpressionid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*логика поля на форме*/
create table if not exists fieldvalidator/*логика взаимосвязей на форме при изменении поля*/ (
parentstructrowid binary(16) not null,
fieldvalidatorid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldvalidator' and 
           column_name   = 'target') then
                alter table fieldvalidator add 
                target binary(16) null /* платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldvalidator' and 
           column_name   = 'code') then
                alter table fieldvalidator add 
                code
 text null /* скрипт */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'fieldvalidator' and 
           constraint_type   = 'primary key') then
            alter table fieldvalidator add constraint pk_fieldvalidator primary key (fieldvalidatorid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*методы поля*/
create table if not exists fieldmenu/*методы, ассоциированные с полем*/ (
parentstructrowid binary(16) not null,
fieldmenuid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldmenu' and 
           column_name   = 'name') then
                alter table fieldmenu add 
                name
 varchar (64) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldmenu' and 
           column_name   = 'caption') then
                alter table fieldmenu add 
                caption
 varchar (80) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldmenu' and 
           column_name   = 'tooltip') then
                alter table fieldmenu add 
                tooltip
 varchar (80) null /* подсказка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldmenu' and 
           column_name   = 'actionid') then
                alter table fieldmenu add 
                actionid binary(16) null /* идентификатор вызываемого метода */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldmenu' and 
           column_name   = 'ismenuitem') then
                alter table fieldmenu add 
                ismenuitem
 integer null /* в меню */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldmenu' and 
           column_name   = 'istoolbarbutton') then
                alter table fieldmenu add 
                istoolbarbutton
 integer null /* в тулбар */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldmenu' and 
           column_name   = 'hotkey') then
                alter table fieldmenu add 
                hotkey
 varchar (20) null /* горячая клавиша */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'fieldmenu' and 
           constraint_type   = 'primary key') then
            alter table fieldmenu add constraint pk_fieldmenu primary key (fieldmenuid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*отображение параметров*/
create table if not exists fieldparammap/*отображение значений на параметры метода*/ (
parentstructrowid binary(16) not null,
fieldparammapid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldparammap' and 
           column_name   = 'fieldname') then
                alter table fieldparammap add 
                fieldname
 varchar (255) null /* поле (значение) */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldparammap' and 
           column_name   = 'paramname') then
                alter table fieldparammap add 
                paramname
 varchar (80) null /* параметр */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fieldparammap' and 
           column_name   = 'noedit') then
                alter table fieldparammap add 
                noedit
 integer null /* редактировать параметр нельзя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'fieldparammap' and 
           constraint_type   = 'primary key') then
            alter table fieldparammap add constraint pk_fieldparammap primary key (fieldparammapid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*приложение*/
create table if not exists mtzapp/*группа взаимосвязных документов*/ (
instanceid binary(16) ,
mtzappid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtzapp' and 
           column_name   = 'name') then
                alter table mtzapp add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtzapp' and 
           column_name   = 'dbname') then
                alter table mtzapp add 
                dbname
 varchar (64) null /* база данных */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtzapp' and 
           column_name   = 'thecomment') then
                alter table mtzapp add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'mtzapp' and 
           constraint_type   = 'primary key') then
            alter table mtzapp add constraint pk_mtzapp primary key (mtzappid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*обязательные приложения*/
create table if not exists parentpackage/*приложения от которых зависит данное приложение*/ (
parentstructrowid binary(16) not null,
parentpackageid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'parentpackage' and 
           column_name   = 'package') then
                alter table parentpackage add 
                package binary(16) null /* приложение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'parentpackage' and 
           constraint_type   = 'primary key') then
            alter table parentpackage add constraint pk_parentpackage primary key (parentpackageid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZJrnl (Описание журнала) */
GO

/*колонки журнала*/
create table if not exists journalcolumn/*колонки журнала*/ (
instanceid binary(16) ,
journalcolumnid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journalcolumn' and 
           column_name   = 'sequence') then
                alter table journalcolumn add 
                sequence
 integer null /* последовательность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journalcolumn' and 
           column_name   = 'name') then
                alter table journalcolumn add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journalcolumn' and 
           column_name   = 'columnalignment') then
                alter table journalcolumn add 
                columnalignment
 integer null /* выравнивание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journalcolumn' and 
           column_name   = 'colsort') then
                alter table journalcolumn add 
                colsort
 integer null /* сортировка колонки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journalcolumn' and 
           column_name   = 'groupaggregation') then
                alter table journalcolumn add 
                groupaggregation
 integer null /* аггрегация при группировке */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'journalcolumn' and 
           constraint_type   = 'primary key') then
            alter table journalcolumn add constraint pk_journalcolumn primary key (journalcolumnid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*состав колонки*/
create table if not exists jcolumnsource/*состав колонки*/ (
parentstructrowid binary(16) not null,
jcolumnsourceid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'jcolumnsource' and 
           column_name   = 'srcpartview') then
                alter table jcolumnsource add 
                srcpartview binary(16) null /* представление */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'jcolumnsource' and 
           column_name   = 'viewfield') then
                alter table jcolumnsource add 
                viewfield
 varchar (255) null /* поле представления */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'jcolumnsource' and 
           constraint_type   = 'primary key') then
            alter table jcolumnsource add constraint pk_jcolumnsource primary key (jcolumnsourceid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*источники журнала*/
create table if not exists journalsrc/*источники журнала*/ (
instanceid binary(16) ,
journalsrcid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journalsrc' and 
           column_name   = 'partview') then
                alter table journalsrc add 
                partview binary(16) null /* представление */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journalsrc' and 
           column_name   = 'onrun') then
                alter table journalsrc add 
                onrun
 integer null /* при открытии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journalsrc' and 
           column_name   = 'openmode') then
                alter table journalsrc add 
                openmode
 varchar (64) null /* режим открытия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journalsrc' and 
           column_name   = 'viewalias') then
                alter table journalsrc add 
                viewalias
 varchar (255) null /* псевдоним представления */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'journalsrc' and 
           constraint_type   = 'primary key') then
            alter table journalsrc add constraint pk_journalsrc primary key (journalsrcid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*журнал*/
create table if not exists journal/*журнал*/ (
instanceid binary(16) ,
journalid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journal' and 
           column_name   = 'name') then
                alter table journal add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journal' and 
           column_name   = 'the_alias') then
                alter table journal add 
                the_alias
 varchar (32) null /* псевдоним */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journal' and 
           column_name   = 'thecomment') then
                alter table journal add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journal' and 
           column_name   = 'jrnliconcls') then
                alter table journal add 
                jrnliconcls
 varchar (80) null /* иконка журнала */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'journal' and 
           column_name   = 'usefavorites') then
                alter table journal add 
                usefavorites
 integer null /* массовое выделение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'journal' and 
           constraint_type   = 'primary key') then
            alter table journal add constraint pk_journal primary key (journalid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_us (Состояние урока) */
GO

/*статусы*/
create table if not exists iu_urok_sn/*статусы урока*/ (
instanceid binary(16) ,
iu_urok_snid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_sn' and 
           column_name   = 'statusdate') then
                alter table iu_urok_sn add 
                statusdate
 datetime null /* дата получения статуса */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_sn' and 
           column_name   = 'urokstatus') then
                alter table iu_urok_sn add 
                urokstatus binary(16) null /* статус */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_urok_sn' and 
           constraint_type   = 'primary key') then
            alter table iu_urok_sn add constraint pk_iu_urok_sn primary key (iu_urok_snid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*сообщения*/
create table if not exists iu_urok_msg/*сообщения сервера по ходу процесса*/ (
instanceid binary(16) ,
iu_urok_msgid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_msg' and 
           column_name   = 'info') then
                alter table iu_urok_msg add 
                info
 varchar (255) null /* сообщение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_msg' and 
           column_name   = 'thedate') then
                alter table iu_urok_msg add 
                thedate
 datetime null /* дата сообщения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_urok_msg' and 
           constraint_type   = 'primary key') then
            alter table iu_urok_msg add constraint pk_iu_urok_msg primary key (iu_urok_msgid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*график производства*/
create table if not exists iu_urok_graph/*график производства*/ (
instanceid binary(16) ,
iu_urok_graphid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_graph' and 
           column_name   = 'stageenddate') then
                alter table iu_urok_graph add 
                stageenddate
 datetime null /* дата завершения стадии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_graph' and 
           column_name   = 'thestatus') then
                alter table iu_urok_graph add 
                thestatus binary(16) null /* состояние */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_graph' and 
           column_name   = 'stagepercent') then
                alter table iu_urok_graph add 
                stagepercent
 integer null /* процент готовности */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_graph' and 
           column_name   = 'planduration') then
                alter table iu_urok_graph add 
                planduration
 integer null /* плановая длительность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_graph' and 
           column_name   = 'passnumber') then
                alter table iu_urok_graph add 
                passnumber
 integer null /* номер прохода */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_graph' and 
           column_name   = 'stagestartdate') then
                alter table iu_urok_graph add 
                stagestartdate
 datetime null /* дата начала стадии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_graph' and 
           column_name   = 'planstartdate') then
                alter table iu_urok_graph add 
                planstartdate
 date null /* плановая дата начала */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_urok_graph' and 
           constraint_type   = 'primary key') then
            alter table iu_urok_graph add constraint pk_iu_urok_graph primary key (iu_urok_graphid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*текущий этап*/
create table if not exists iu_urok_prc/*состояние урока, отделено от данных урока*/ (
instanceid binary(16) ,
iu_urok_prcid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_prc' and 
           column_name   = 'theprocess') then
                alter table iu_urok_prc add 
                theprocess binary(16) null /* урок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_prc' and 
           column_name   = 'topstage') then
                alter table iu_urok_prc add 
                topstage binary(16) null /* этап */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_prc' and 
           column_name   = 'iu_urok_stage') then
                alter table iu_urok_prc add 
                iu_urok_stage binary(16) null /* подэтап */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_prc' and 
           column_name   = 'isdone') then
                alter table iu_urok_prc add 
                isdone
 integer null /* завершен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_prc' and 
           column_name   = 'laststate') then
                alter table iu_urok_prc add 
                laststate binary(16) null /* последний статус */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_prc' and 
           column_name   = 'lastmessage') then
                alter table iu_urok_prc add 
                lastmessage
 varchar (255) null /* последнее сообщение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_prc' and 
           column_name   = 'manualcontrol') then
                alter table iu_urok_prc add 
                manualcontrol
 integer null /* требуется управление */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_prc' and 
           column_name   = 'taskdelayed') then
                alter table iu_urok_prc add 
                taskdelayed
 integer null /* опаздание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_urok_prc' and 
           constraint_type   = 'primary key') then
            alter table iu_urok_prc add constraint pk_iu_urok_prc primary key (iu_urok_prcid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=STDInfoStore (Каталог) */
GO

/*папка*/
create table if not exists folder/*папка каталога*/ (
instanceid binary(16) ,
folderid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
,parentrowid binary(16) 
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'folder' and 
           column_name   = 'name') then
                alter table folder add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'folder' and 
           column_name   = 'foldertype') then
                alter table folder add 
                foldertype
 integer null /* тип папки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'folder' and 
           constraint_type   = 'primary key') then
            alter table folder add constraint pk_folder primary key (folderid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*документы*/
create table if not exists shortcut/*ярлыки документов*/ (
parentstructrowid binary(16) not null,
shortcutid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'shortcut' and 
           column_name   = 'docitem') then
                alter table shortcut add 
                docitem binary(16) null /* документ */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'shortcut' and 
           column_name   = 'startmode') then
                alter table shortcut add 
                startmode
 varchar (255) null /* режим */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'shortcut' and 
           constraint_type   = 'primary key') then
            alter table shortcut add constraint pk_shortcut primary key (shortcutid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*описание*/
create table if not exists infostoredef/*описание каталога*/ (
instanceid binary(16) ,
infostoredefid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'infostoredef' and 
           column_name   = 'thegroup') then
                alter table infostoredef add 
                thegroup binary(16) null /* группа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'infostoredef' and 
           column_name   = 'name') then
                alter table infostoredef add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'infostoredef' and 
           column_name   = 'infostoretype') then
                alter table infostoredef add 
                infostoretype
 integer null /* тип каталога */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'infostoredef' and 
           column_name   = 'theuser') then
                alter table infostoredef add 
                theuser binary(16) null /* пользователь */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'infostoredef' and 
           constraint_type   = 'primary key') then
            alter table infostoredef add constraint pk_infostoredef primary key (infostoredefid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_rt (Тип ссылки) */
GO

/*тип ссылки*/
create table if not exists iud_rt_def/*тип ссылки на файл*/ (
instanceid binary(16) ,
iud_rt_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_rt_def' and 
           column_name   = 'name') then
                alter table iud_rt_def add 
                name
 varchar (80) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_rt_def' and 
           constraint_type   = 'primary key') then
            alter table iud_rt_def add constraint pk_iud_rt_def primary key (iud_rt_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZSystem (Спец.: Системные данные) */
GO

/*сессия пользователя*/
create table if not exists the_session/*зарегистрированные сессии пользователей*/ (
instanceid binary(16) ,
the_sessionid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'applicationid') then
                alter table the_session add 
                applicationid binary(16) null /* приложение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'userrole') then
                alter table the_session add 
                userrole binary(16) null /* текущая роль пользователя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'closedat') then
                alter table the_session add 
                closedat
 datetime null /* момент закрытия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'closed') then
                alter table the_session add 
                closed
 integer null /* закрыта */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'usersid') then
                alter table the_session add 
                usersid binary(16) null /* пользователь */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'lastaccess') then
                alter table the_session add 
                lastaccess
 datetime null /* последнее подтверждение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'startat') then
                alter table the_session add 
                startat
 datetime null /* момент открытия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'lang') then
                alter table the_session add 
                lang
 varchar (25) null /* локализация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'the_session' and 
           column_name   = 'login') then
                alter table the_session add 
                login
 varchar (255) null /* login */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'the_session' and 
           constraint_type   = 'primary key') then
            alter table the_session add constraint pk_the_session primary key (the_sessionid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*разрешенные владельцы*/
create table if not exists sysrefcache/*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
instanceid binary(16) ,
sysrefcacheid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sysrefcache' and 
           column_name   = 'cachetype') then
                alter table sysrefcache add 
                cachetype
 integer null /* тип кеширования */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sysrefcache' and 
           column_name   = 'objectownerid') then
                alter table sysrefcache add 
                objectownerid binary(16) null /* идентификатор владельца */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sysrefcache' and 
           column_name   = 'sessionid') then
                alter table sysrefcache add 
                sessionid binary(16) null /* сессия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'sysrefcache' and 
           column_name   = 'modulename') then
                alter table sysrefcache add 
                modulename
 varchar (40) null /* модуль */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'sysrefcache' and 
           constraint_type   = 'primary key') then
            alter table sysrefcache add constraint pk_sysrefcache primary key (sysrefcacheid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*журнал событий*/
create table if not exists syslog/*журнал событий, которые произошли в системе*/ (
instanceid binary(16) ,
syslogid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'syslog' and 
           column_name   = 'thesession') then
                alter table syslog add 
                thesession binary(16) null /* сессия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'syslog' and 
           column_name   = 'the_resource') then
                alter table syslog add 
                the_resource
 varchar (255) null /* ресурс */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'syslog' and 
           column_name   = 'logstructid') then
                alter table syslog add 
                logstructid
 varchar (255) null /* раздел с которым происхоит действие */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'syslog' and 
           column_name   = 'verb') then
                alter table syslog add 
                verb
 varchar (80) null /* действие */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'syslog' and 
           column_name   = 'loginstanceid') then
                alter table syslog add 
                loginstanceid binary(16) null /* идентификатор документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'syslog' and 
           constraint_type   = 'primary key') then
            alter table syslog add constraint pk_syslog primary key (syslogid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZwp (Описание АРМ) */
GO

/*поведение журналов*/
create table if not exists armjournal/*описание действий журанлов*/ (
instanceid binary(16) ,
armjournalid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'armjournal' and 
           column_name   = 'thejournal') then
                alter table armjournal add 
                thejournal binary(16) null /* журнал */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'armjournal' and 
           constraint_type   = 'primary key') then
            alter table armjournal add constraint pk_armjournal primary key (armjournalid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*отчеты*/
create table if not exists armjrnlrep/*отчеты из журнала*/ (
parentstructrowid binary(16) not null,
armjrnlrepid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'armjrnlrep' and 
           column_name   = 'repname') then
                alter table armjrnlrep add 
                repname
 varchar (255) null /* название отчета */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'armjrnlrep' and 
           column_name   = 'thereport') then
                alter table armjrnlrep add 
                thereport binary(16) null /* отчет */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'armjrnlrep' and 
           constraint_type   = 'primary key') then
            alter table armjrnlrep add constraint pk_armjrnlrep primary key (armjrnlrepid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*действия*/
create table if not exists armjrnlrun/*дополнительные действия в журнале*/ (
parentstructrowid binary(16) not null,
armjrnlrunid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'armjrnlrun' and 
           column_name   = 'name') then
                alter table armjrnlrun add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'armjrnlrun' and 
           column_name   = 'theextention') then
                alter table armjrnlrun add 
                theextention binary(16) null /* расширение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'armjrnlrun' and 
           constraint_type   = 'primary key') then
            alter table armjrnlrun add constraint pk_armjrnlrun primary key (armjrnlrunid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*добавление*/
create table if not exists armjrnladd/*варианты обработки добавления*/ (
parentstructrowid binary(16) not null,
armjrnladdid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'armjrnladd' and 
           column_name   = 'name') then
                alter table armjrnladd add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'armjrnladd' and 
           column_name   = 'theextention') then
                alter table armjrnladd add 
                theextention binary(16) null /* расширение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'armjrnladd' and 
           constraint_type   = 'primary key') then
            alter table armjrnladd add constraint pk_armjrnladd primary key (armjrnladdid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*меню*/
create table if not exists entrypoints/*меню*/ (
instanceid binary(16) ,
entrypointsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
,parentrowid binary(16) 
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'sequence') then
                alter table entrypoints add 
                sequence
 integer null /* последовательность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'name') then
                alter table entrypoints add 
                name
 varchar (38) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'caption') then
                alter table entrypoints add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'astoolbaritem') then
                alter table entrypoints add 
                astoolbaritem
 integer null /* включить в тулбар */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'actiontype') then
                alter table entrypoints add 
                actiontype
 integer null /* вариант действия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'thefilter') then
                alter table entrypoints add 
                thefilter binary(16) null /* фильтр */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'journal') then
                alter table entrypoints add 
                journal binary(16) null /* журнал */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'report') then
                alter table entrypoints add 
                report binary(16) null /* отчет */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'document') then
                alter table entrypoints add 
                document binary(16) null /* документ */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'method') then
                alter table entrypoints add 
                method binary(16) null /* метод */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'iconfile') then
                alter table entrypoints add 
                iconfile
 varchar (2000) null /* файл картинки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'theextention') then
                alter table entrypoints add 
                theextention binary(16) null /* расширение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'arm') then
                alter table entrypoints add 
                arm binary(16) null /* арм */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'thecomment') then
                alter table entrypoints add 
                thecomment
 text null /* примечание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'objecttype') then
                alter table entrypoints add 
                objecttype binary(16) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'journalfixedquery') then
                alter table entrypoints add 
                journalfixedquery
 text null /* ограничения к журналу */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'allowadd') then
                alter table entrypoints add 
                allowadd
 integer null /* разрешено добавление */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'allowedit') then
                alter table entrypoints add 
                allowedit
 integer null /* разрешено редактирование */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'allowdel') then
                alter table entrypoints add 
                allowdel
 integer null /* рарешено удаление */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'allowfilter') then
                alter table entrypoints add 
                allowfilter
 integer null /* разрешен фильтр */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'entrypoints' and 
           column_name   = 'allowprint') then
                alter table entrypoints add 
                allowprint
 integer null /* разрешена печать */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'entrypoints' and 
           constraint_type   = 'primary key') then
            alter table entrypoints add constraint pk_entrypoints primary key (entrypointsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*привязка фильтра*/
create table if not exists epfilterlink/*привязка фильтра к журналу*/ (
parentstructrowid binary(16) not null,
epfilterlinkid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'epfilterlink' and 
           column_name   = 'rowsource') then
                alter table epfilterlink add 
                rowsource
 varchar (255) null /* источник */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'epfilterlink' and 
           column_name   = 'theexpression') then
                alter table epfilterlink add 
                theexpression
 text null /* выражение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'epfilterlink' and 
           column_name   = 'filterfield') then
                alter table epfilterlink add 
                filterfield
 varchar (255) null /* поле фильтра */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'epfilterlink' and 
           constraint_type   = 'primary key') then
            alter table epfilterlink add constraint pk_epfilterlink primary key (epfilterlinkid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*арм*/
create table if not exists workplace/*арм*/ (
instanceid binary(16) ,
workplaceid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'workplace' and 
           column_name   = 'name') then
                alter table workplace add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'workplace' and 
           column_name   = 'caption') then
                alter table workplace add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'workplace' and 
           column_name   = 'theversion') then
                alter table workplace add 
                theversion
 varchar (30) null /* версия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'workplace' and 
           column_name   = 'theplatform') then
                alter table workplace add 
                theplatform
 integer null /* платформа реализации */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'workplace' and 
           column_name   = 'thecomment') then
                alter table workplace add 
                thecomment
 text null /* примечание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'workplace' and 
           constraint_type   = 'primary key') then
            alter table workplace add constraint pk_workplace primary key (workplaceid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*список типов*/
create table if not exists armtypes/*типы документов, которые подключаются в mdi режиме*/ (
instanceid binary(16) ,
armtypesid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'armtypes' and 
           column_name   = 'thedocumenttype') then
                alter table armtypes add 
                thedocumenttype binary(16) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'armtypes' and 
           constraint_type   = 'primary key') then
            alter table armtypes add constraint pk_armtypes primary key (armtypesid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_d_urole (Роль сотрудника) */
GO

/*роль*/
create table if not exists iu_crole/*роль в процессе производства*/ (
instanceid binary(16) ,
iu_croleid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_crole' and 
           column_name   = 'archived') then
                alter table iu_crole add 
                archived int null default 0;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_crole' and 
           column_name   = 'name') then
                alter table iu_crole add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_crole' and 
           column_name   = 'allowsetuser') then
                alter table iu_crole add 
                allowsetuser
 integer null /* требует явного назначения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_crole' and 
           constraint_type   = 'primary key') then
            alter table iu_crole add constraint pk_iu_crole primary key (iu_croleid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=ROLES (Роли) */
GO

/*доступные действия*/
create table if not exists roles_operations/*именованные операции*/ (
instanceid binary(16) ,
roles_operationsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_operations' and 
           column_name   = 'info') then
                alter table roles_operations add 
                info
 varchar (256) null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_operations' and 
           column_name   = 'allowaction') then
                alter table roles_operations add 
                allowaction
 integer null /* разрешено */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_operations' and 
           column_name   = 'name') then
                alter table roles_operations add 
                name
 varchar (255) null /* код */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles_operations' and 
           constraint_type   = 'primary key') then
            alter table roles_operations add constraint pk_roles_operations primary key (roles_operationsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*доступные приложения*/
create table if not exists roles_wp/*доступные приложения*/ (
instanceid binary(16) ,
roles_wpid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_wp' and 
           column_name   = 'wp') then
                alter table roles_wp add 
                wp binary(16) null /* приложение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles_wp' and 
           constraint_type   = 'primary key') then
            alter table roles_wp add constraint pk_roles_wp primary key (roles_wpid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*разрешенные пункты меню*/
create table if not exists roles_act/*разрешенные пункты меню*/ (
parentstructrowid binary(16) not null,
roles_actid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_act' and 
           column_name   = 'accesible') then
                alter table roles_act add 
                accesible
 integer null /* доступность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_act' and 
           column_name   = 'menuname') then
                alter table roles_act add 
                menuname
 varchar (255) null /* меню */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_act' and 
           column_name   = 'menucode') then
                alter table roles_act add 
                menucode
 varchar (255) null /* код пункта меню */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles_act' and 
           constraint_type   = 'primary key') then
            alter table roles_act add constraint pk_roles_act primary key (roles_actid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*модули*/
create table if not exists roles2_module/**/ (
instanceid binary(16) ,
roles2_moduleid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'groupname') then
                alter table roles2_module add 
                groupname
 varchar (60) null /* имя группы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'caption') then
                alter table roles2_module add 
                caption
 varchar (80) null /* надпись */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'sequence') then
                alter table roles2_module add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'moduleaccessible') then
                alter table roles2_module add 
                moduleaccessible
 integer null /* разрешен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'customizevisibility') then
                alter table roles2_module add 
                customizevisibility
 integer null /* настраивать видимость */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'theicon') then
                alter table roles2_module add 
                theicon
 varchar (64) null /* иконка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'name') then
                alter table roles2_module add 
                name
 varchar (255) null /* код модуля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'thecomment') then
                alter table roles2_module add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'allobjects') then
                alter table roles2_module add 
                allobjects
 integer null /* вся фирма */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'colegsobject') then
                alter table roles2_module add 
                colegsobject
 integer null /* объекты коллег */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_module' and 
           column_name   = 'substructobjects') then
                alter table roles2_module add 
                substructobjects
 integer null /* подчиненные подразделения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles2_module' and 
           constraint_type   = 'primary key') then
            alter table roles2_module add constraint pk_roles2_module primary key (roles2_moduleid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*действия и отчеты*/
create table if not exists roles2_modreport/**/ (
parentstructrowid binary(16) not null,
roles2_modreportid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_modreport' and 
           column_name   = 'name') then
                alter table roles2_modreport add 
                name
 varchar (64) null /* код */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_modreport' and 
           column_name   = 'allowaction') then
                alter table roles2_modreport add 
                allowaction
 integer null /* разрешен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_modreport' and 
           column_name   = 'caption') then
                alter table roles2_modreport add 
                caption
 varchar (80) null /* надпись */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_modreport' and 
           column_name   = 'sequence') then
                alter table roles2_modreport add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_modreport' and 
           column_name   = 'theicon') then
                alter table roles2_modreport add 
                theicon
 varchar (64) null /* иконка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_modreport' and 
           column_name   = 'isreport') then
                alter table roles2_modreport add 
                isreport
 integer null /* это отчет */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles2_modreport' and 
           column_name   = 'selecttype') then
                alter table roles2_modreport add 
                selecttype
 integer null /* вариант выбора */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles2_modreport' and 
           constraint_type   = 'primary key') then
            alter table roles2_modreport add constraint pk_roles2_modreport primary key (roles2_modreportid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*доступные документы*/
create table if not exists roles_doc/**/ (
instanceid binary(16) ,
roles_docid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_doc' and 
           column_name   = 'the_document') then
                alter table roles_doc add 
                the_document binary(16) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_doc' and 
           column_name   = 'the_denied') then
                alter table roles_doc add 
                the_denied
 integer null /* запрещен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_doc' and 
           column_name   = 'allowdeletedoc') then
                alter table roles_doc add 
                allowdeletedoc
 integer null /* разрешено удаление */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles_doc' and 
           constraint_type   = 'primary key') then
            alter table roles_doc add constraint pk_roles_doc primary key (roles_docid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*доступные состояния*/
create table if not exists roles_doc_state/**/ (
parentstructrowid binary(16) not null,
roles_doc_stateid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_doc_state' and 
           column_name   = 'the_state') then
                alter table roles_doc_state add 
                the_state binary(16) null /* состояние */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_doc_state' and 
           column_name   = 'the_mode') then
                alter table roles_doc_state add 
                the_mode binary(16) null /* режим */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_doc_state' and 
           column_name   = 'allowdelete') then
                alter table roles_doc_state add 
                allowdelete
 integer null /* можно удалять */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_doc_state' and 
           column_name   = 'statechangedisabled') then
                alter table roles_doc_state add 
                statechangedisabled
 integer null /* запрещена смена состояния */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles_doc_state' and 
           constraint_type   = 'primary key') then
            alter table roles_doc_state add constraint pk_roles_doc_state primary key (roles_doc_stateid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*отчёты*/
create table if not exists roles_reports/**/ (
instanceid binary(16) ,
roles_reportsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_reports' and 
           column_name   = 'the_report') then
                alter table roles_reports add 
                the_report binary(16) null /* отчёт */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles_reports' and 
           constraint_type   = 'primary key') then
            alter table roles_reports add constraint pk_roles_reports primary key (roles_reportsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*пользователи*/
create table if not exists roles_user/*пользователи*/ (
instanceid binary(16) ,
roles_userid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_user' and 
           column_name   = 'theuser') then
                alter table roles_user add 
                theuser binary(16) null /* пользователь */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles_user' and 
           constraint_type   = 'primary key') then
            alter table roles_user add constraint pk_roles_user primary key (roles_userid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*отображение на группы*/
create table if not exists roles_map/*отображение на группы защиты*/ (
instanceid binary(16) ,
roles_mapid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_map' and 
           column_name   = 'thegroup') then
                alter table roles_map add 
                thegroup binary(16) null /* группа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles_map' and 
           constraint_type   = 'primary key') then
            alter table roles_map add constraint pk_roles_map primary key (roles_mapid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*определение роли*/
create table if not exists roles_def/*определение роли*/ (
instanceid binary(16) ,
roles_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_def' and 
           column_name   = 'name') then
                alter table roles_def add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_def' and 
           column_name   = 'allobjects') then
                alter table roles_def add 
                allobjects
 integer null /* вся фирма */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_def' and 
           column_name   = 'colegsobject') then
                alter table roles_def add 
                colegsobject
 integer null /* объекты коллег */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'roles_def' and 
           column_name   = 'substructobjects') then
                alter table roles_def add 
                substructobjects
 integer null /* подчиненные подразделения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'roles_def' and 
           constraint_type   = 'primary key') then
            alter table roles_def add constraint pk_roles_def primary key (roles_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_urok (Урок) */
GO

/*материалы*/
create table if not exists iu_urok_docs/*все текстовые материалы с версиями*/ (
instanceid binary(16) ,
iu_urok_docsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'doctype') then
                alter table iu_urok_docs add 
                doctype binary(16) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'addby') then
                alter table iu_urok_docs add 
                addby binary(16) null /* кем добавлен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'adddate') then
                alter table iu_urok_docs add 
                adddate
 datetime null /* когда добавлен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'version') then
                alter table iu_urok_docs add 
                version
 integer null /* № версии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'activeversion') then
                alter table iu_urok_docs add 
                activeversion
 integer null /* активная версия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'filereftype') then
                alter table iu_urok_docs add 
                filereftype binary(16) null /* тип ссылки на файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'fileref_ext') then
        alter table iu_urok_docs add 
            fileref_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'fileref') then
                alter table iu_urok_docs add 
                fileref varchar(255) null /* файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'fileurl') then
                alter table iu_urok_docs add 
                fileurl varchar(255) null /* url файла */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'filetext') then
                alter table iu_urok_docs add 
                filetext
 text null /* текст документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'info') then
                alter table iu_urok_docs add 
                info
 varchar (255) null /* комментарий */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_docs' and 
           column_name   = 'origname') then
                alter table iu_urok_docs add 
                origname
 varchar (255) null /* оригинальное название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_urok_docs' and 
           constraint_type   = 'primary key') then
            alter table iu_urok_docs add constraint pk_iu_urok_docs primary key (iu_urok_docsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*исполнители*/
create table if not exists iu_urok_creators/*исполнители*/ (
instanceid binary(16) ,
iu_urok_creatorsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_creators' and 
           column_name   = 'processrole') then
                alter table iu_urok_creators add 
                processrole binary(16) null /* роль в процессе */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_creators' and 
           column_name   = 'doer') then
                alter table iu_urok_creators add 
                doer binary(16) null /* исполнитель */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_creators' and 
           column_name   = 'doers') then
                alter table iu_urok_creators add 
                doers
 varchar (390) null /* группа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_creators' and 
           column_name   = 'selectby') then
                alter table iu_urok_creators add 
                selectby binary(16) null /* кем был назначен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_creators' and 
           column_name   = 'selectday') then
                alter table iu_urok_creators add 
                selectday
 datetime null /* дата назначения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_urok_creators' and 
           constraint_type   = 'primary key') then
            alter table iu_urok_creators add constraint pk_iu_urok_creators primary key (iu_urok_creatorsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*описание*/
create table if not exists iu_urok_def/**/ (
instanceid binary(16) ,
iu_urok_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'ucode') then
                alter table iu_urok_def add 
                ucode
 varchar (20) null /* код урока */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'datecreated') then
                alter table iu_urok_def add 
                datecreated
 datetime null /* дата создания */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'subject') then
                alter table iu_urok_def add 
                subject binary(16) null /* предмет */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'theclassnum') then
                alter table iu_urok_def add 
                theclassnum binary(16) null /* класс */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'plannum') then
                alter table iu_urok_def add 
                plannum
 varchar (6) null /* номер по плану */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'maketown') then
                alter table iu_urok_def add 
                maketown binary(16) null /* город съемки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'actiondate') then
                alter table iu_urok_def add 
                actiondate
 date null /* дата съемки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'actiondate2') then
                alter table iu_urok_def add 
                actiondate2
 date null /* дата досъема */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'coursetype') then
                alter table iu_urok_def add 
                coursetype binary(16) null /* тип курса */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'rtheme') then
                alter table iu_urok_def add 
                rtheme
 varchar (255) null /* тема раздела */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'classtheme') then
                alter table iu_urok_def add 
                classtheme
 varchar (255) null /* тема урока */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'thequarter') then
                alter table iu_urok_def add 
                thequarter
 integer null /* четверть */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'schooldate') then
                alter table iu_urok_def add 
                schooldate varchar(20) null /* дата в школе */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'curator') then
                alter table iu_urok_def add 
                curator binary(16) null /* куратор */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'theteacher') then
                alter table iu_urok_def add 
                theteacher binary(16) null /* учитель */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'methodist') then
                alter table iu_urok_def add 
                methodist binary(16) null /* методист */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'methodist2') then
                alter table iu_urok_def add 
                methodist2 binary(16) null /* методист 2 */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'processtype') then
                alter table iu_urok_def add 
                processtype binary(16) null /* тип процесса */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'ckksn') then
                alter table iu_urok_def add 
                ckksn binary(16) null /* финальный статус */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'testpageref') then
                alter table iu_urok_def add 
                testpageref varchar(255) null /* тестовая */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'pubstate') then
                alter table iu_urok_def add 
                pubstate binary(16) null /* статус публикации */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'mainref') then
                alter table iu_urok_def add 
                mainref varchar(255) null /* публикация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'thefilm') then
                alter table iu_urok_def add 
                thefilm binary(16) null /* связанный урок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'thefilmurl') then
                alter table iu_urok_def add 
                thefilmurl varchar(255) null /* связ. урок ссылка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'info') then
                alter table iu_urok_def add 
                info
 text null /* примечание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_def' and 
           column_name   = 'notes') then
                alter table iu_urok_def add 
                notes
 text null /* заметки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_urok_def' and 
           constraint_type   = 'primary key') then
            alter table iu_urok_def add constraint pk_iu_urok_def primary key (iu_urok_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*видеоматериалы*/
create table if not exists iu_urok_video/*видеофрагменты к уроку*/ (
instanceid binary(16) ,
iu_urok_videoid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'adddate') then
                alter table iu_urok_video add 
                adddate
 datetime null /* когда добавлен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'doctype') then
                alter table iu_urok_video add 
                doctype binary(16) null /* тип видео */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'activeversion') then
                alter table iu_urok_video add 
                activeversion
 integer null /* активная версия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'addby') then
                alter table iu_urok_video add 
                addby binary(16) null /* кем добавлен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'version') then
                alter table iu_urok_video add 
                version
 integer null /* № версии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'fileurl') then
                alter table iu_urok_video add 
                fileurl varchar(255) null /* url файла */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'fileref_ext') then
        alter table iu_urok_video add 
            fileref_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'fileref') then
                alter table iu_urok_video add 
                fileref varchar(255) null /* файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'info') then
                alter table iu_urok_video add 
                info
 varchar (255) null /* комментарий */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'nocomments') then
                alter table iu_urok_video add 
                nocomments
 integer null /* скрыть */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_urok_video' and 
           column_name   = 'origname') then
                alter table iu_urok_video add 
                origname
 varchar (255) null /* оригинальное название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_urok_video' and 
           constraint_type   = 'primary key') then
            alter table iu_urok_video add constraint pk_iu_urok_video primary key (iu_urok_videoid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_mt (Тип сообщения) */
GO

/*тип сообщения*/
create table if not exists iud_mt_def/*тип сообщения для обсуждений*/ (
instanceid binary(16) ,
iud_mt_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_mt_def' and 
           column_name   = 'name') then
                alter table iud_mt_def add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_mt_def' and 
           column_name   = 'mticon') then
                alter table iud_mt_def add 
                mticon
 varchar (80) null /* иконка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_mt_def' and 
           constraint_type   = 'primary key') then
            alter table iud_mt_def add constraint pk_iud_mt_def primary key (iud_mt_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_sn (Названия статусов) */
GO

/*названия статусов*/
create table if not exists iud_sn_def/*названия статусов*/ (
instanceid binary(16) ,
iud_sn_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_sn_def' and 
           column_name   = 'name') then
                alter table iud_sn_def add 
                name
 varchar (255) null /* статус */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_sn_def' and 
           column_name   = 'sequence') then
                alter table iud_sn_def add 
                sequence
 integer null /* порядок вывода */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_sn_def' and 
           column_name   = 'isfinal') then
                alter table iud_sn_def add 
                isfinal
 integer null /* финальный статус */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_sn_def' and 
           constraint_type   = 'primary key') then
            alter table iud_sn_def add constraint pk_iud_sn_def primary key (iud_sn_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_fst (Тип хранения файла) */
GO

/*тип хранения файла*/
create table if not exists iud_filestoretype/*тип хранения файла*/ (
instanceid binary(16) ,
iud_filestoretypeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_filestoretype' and 
           column_name   = 'name') then
                alter table iud_filestoretype add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_filestoretype' and 
           constraint_type   = 'primary key') then
            alter table iud_filestoretype add constraint pk_iud_filestoretype primary key (iud_filestoretypeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_p (Предметы) */
GO

/*предмет*/
create table if not exists iud_predmet/*школьные предметы*/ (
instanceid binary(16) ,
iud_predmetid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_predmet' and 
           column_name   = 'name') then
                alter table iud_predmet add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_predmet' and 
           column_name   = 'prefix') then
                alter table iud_predmet add 
                prefix
 varchar (4) null /* префикс */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_predmet' and 
           column_name   = 'predmeticon') then
                alter table iud_predmet add 
                predmeticon
 varchar (80) null /* иконка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_predmet' and 
           constraint_type   = 'primary key') then
            alter table iud_predmet add constraint pk_iud_predmet primary key (iud_predmetid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_d_doctype (Тип документа) */
GO

/*тип документа*/
create table if not exists iud_doctype/*тип документа*/ (
instanceid binary(16) ,
iud_doctypeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_doctype' and 
           column_name   = 'sequence') then
                alter table iud_doctype add 
                sequence
 integer null /* порядок вывода */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_doctype' and 
           column_name   = 'name') then
                alter table iud_doctype add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_doctype' and 
           column_name   = 'filetype') then
                alter table iud_doctype add 
                filetype binary(16) null /* тип файла */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_doctype' and 
           column_name   = 'versionpolicy') then
                alter table iud_doctype add 
                versionpolicy binary(16) null /* организация версий */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_doctype' and 
           constraint_type   = 'primary key') then
            alter table iud_doctype add constraint pk_iud_doctype primary key (iud_doctypeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZUsers (Справочник: пользователи) */
GO

/*пользователи*/
create table if not exists users/*пользователи*/ (
instanceid binary(16) ,
usersid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'family') then
                alter table users add 
                family
 varchar (255) null /* фамилия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'name') then
                alter table users add 
                name
 varchar (64) null /* имя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'surname') then
                alter table users add 
                surname
 varchar (255) null /* отчество */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'login') then
                alter table users add 
                login
 varchar (64) null /* имя для входа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'password') then
                alter table users add 
                password varchar(80) null /* пароль */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'domainame') then
                alter table users add 
                domainame
 varchar (255) null /* доменное имя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'email') then
                alter table users add 
                email varchar(255) null /* e-mail */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'phone') then
                alter table users add 
                phone
 varchar (20) null /* телефон */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'users' and 
           column_name   = 'localphone') then
                alter table users add 
                localphone
 varchar (20) null /* местный телефон */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'users' and 
           constraint_type   = 'primary key') then
            alter table users add constraint pk_users primary key (usersid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*группы*/
create table if not exists groups/*группы*/ (
instanceid binary(16) ,
groupsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'groups' and 
           column_name   = 'name') then
                alter table groups add 
                name
 varchar (80) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'groups' and 
           column_name   = 'adgroup') then
                alter table groups add 
                adgroup
 varchar (255) null /* группа ad */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'groups' and 
           constraint_type   = 'primary key') then
            alter table groups add constraint pk_groups primary key (groupsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*состав группы*/
create table if not exists groupuser/*состав группы*/ (
parentstructrowid binary(16) not null,
groupuserid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'groupuser' and 
           column_name   = 'theuser') then
                alter table groupuser add 
                theuser binary(16) null /* пользователь */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'groupuser' and 
           constraint_type   = 'primary key') then
            alter table groupuser add constraint pk_groupuser primary key (groupuserid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_cls (Классы) */
GO

/*класс*/
create table if not exists iu_clsinfo/*номера классов*/ (
instanceid binary(16) ,
iu_clsinfoid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_clsinfo' and 
           column_name   = 'name') then
                alter table iu_clsinfo add 
                name
 varchar (10) null /* класс */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_clsinfo' and 
           column_name   = 'sequence') then
                alter table iu_clsinfo add 
                sequence
 integer null /* порядок вывода */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_clsinfo' and 
           constraint_type   = 'primary key') then
            alter table iu_clsinfo add constraint pk_iu_clsinfo primary key (iu_clsinfoid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=STDNumerator (Нумератор) */
GO

/*зоны*/
create table if not exists num_zones/*зоны уникальных нумеров*/ (
instanceid binary(16) ,
num_zonesid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'num_zones' and 
           column_name   = 'zonemask') then
                alter table num_zones add 
                zonemask
 varchar (255) null /* маска зоны */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'num_zones' and 
           constraint_type   = 'primary key') then
            alter table num_zones add constraint pk_num_zones primary key (num_zonesid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*номера*/
create table if not exists num_values/*уникальные номера*/ (
parentstructrowid binary(16) not null,
num_valuesid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'num_values' and 
           column_name   = 'the_value') then
                alter table num_values add 
                the_value
 integer null /* значение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'num_values' and 
           column_name   = 'ownerpartname') then
                alter table num_values add 
                ownerpartname
 varchar (64) null /* раздел */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'num_values' and 
           column_name   = 'ownerrowid') then
                alter table num_values add 
                ownerrowid binary(16) null /* идентификатор строки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'num_values' and 
           constraint_type   = 'primary key') then
            alter table num_values add constraint pk_num_values primary key (num_valuesid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*описание*/
create table if not exists num_head/*описание нумератора*/ (
instanceid binary(16) ,
num_headid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'num_head' and 
           column_name   = 'name') then
                alter table num_head add 
                name
 varchar (80) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'num_head' and 
           column_name   = 'shema') then
                alter table num_head add 
                shema
 integer null /* схема нумерации */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'num_head' and 
           constraint_type   = 'primary key') then
            alter table num_head add constraint pk_num_head primary key (num_headid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_ft (Тип файла) */
GO

/*тип файла*/
create table if not exists iud_filetype/*тип файла ( текст, видео и т.п.)*/ (
instanceid binary(16) ,
iud_filetypeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_filetype' and 
           column_name   = 'name') then
                alter table iud_filetype add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_filetype' and 
           column_name   = 'allowtiming') then
                alter table iud_filetype add 
                allowtiming
 integer null /* возможен тайминг */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_filetype' and 
           constraint_type   = 'primary key') then
            alter table iud_filetype add constraint pk_iud_filetype primary key (iud_filetypeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZExt (Расширения функциональности) */
GO

/*описание*/
create table if not exists mtzext_def/*список зарегистрированных расширений*/ (
instanceid binary(16) ,
mtzext_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtzext_def' and 
           column_name   = 'name') then
                alter table mtzext_def add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtzext_def' and 
           column_name   = 'exttype') then
                alter table mtzext_def add 
                exttype
 integer null /* тип расширения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtzext_def' and 
           column_name   = 'thedescription') then
                alter table mtzext_def add 
                thedescription
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'mtzext_def' and 
           constraint_type   = 'primary key') then
            alter table mtzext_def add constraint pk_mtzext_def primary key (mtzext_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*реализации расширения*/
create table if not exists mtzextrel/*реализации расширения для разных разработческих плаформ*/ (
instanceid binary(16) ,
mtzextrelid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtzextrel' and 
           column_name   = 'theplatform') then
                alter table mtzextrel add 
                theplatform
 integer null /* реализация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtzextrel' and 
           column_name   = 'theclassname') then
                alter table mtzextrel add 
                theclassname
 varchar (255) null /* название класса */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtzextrel' and 
           column_name   = 'thelibraryname') then
                alter table mtzextrel add 
                thelibraryname
 varchar (255) null /* название библиотеки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'mtzextrel' and 
           constraint_type   = 'primary key') then
            alter table mtzextrel add constraint pk_mtzextrel primary key (mtzextrelid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_vt (Тип видео) */
GO

/*тип видео*/
create table if not exists iud_videotype/*тип видео*/ (
instanceid binary(16) ,
iud_videotypeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_videotype' and 
           column_name   = 'sequence') then
                alter table iud_videotype add 
                sequence
 integer null /* порядок вывода */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_videotype' and 
           column_name   = 'filetype') then
                alter table iud_videotype add 
                filetype binary(16) null /* тип файла */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_videotype' and 
           column_name   = 'name') then
                alter table iud_videotype add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_videotype' and 
           column_name   = 'versionpolicy') then
                alter table iud_videotype add 
                versionpolicy binary(16) null /* организация версий */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_videotype' and 
           column_name   = 'nocomments') then
                alter table iud_videotype add 
                nocomments
 integer null /* скрыть */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_videotype' and 
           constraint_type   = 'primary key') then
            alter table iud_videotype add constraint pk_iud_videotype primary key (iud_videotypeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_cm (Комментарии) */
GO

/*источник*/
create table if not exists iu_cm_def/*источник данных для комментирования*/ (
instanceid binary(16) ,
iu_cm_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_def' and 
           column_name   = 'theprocess') then
                alter table iu_cm_def add 
                theprocess binary(16) null /* урок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_def' and 
           column_name   = 'thevideo') then
                alter table iu_cm_def add 
                thevideo binary(16) null /* видео */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_def' and 
           column_name   = 'thedoc') then
                alter table iu_cm_def add 
                thedoc binary(16) null /* документ */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_def' and 
           column_name   = 'isdiscussion') then
                alter table iu_cm_def add 
                isdiscussion
 integer null /* обсуждение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_def' and 
           column_name   = 'thetheme') then
                alter table iu_cm_def add 
                thetheme
 varchar (255) null /* тема */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_def' and 
           column_name   = 'thedate') then
                alter table iu_cm_def add 
                thedate
 datetime null /* дата */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_def' and 
           column_name   = 'theauthor') then
                alter table iu_cm_def add 
                theauthor binary(16) null /* добавил */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_cm_def' and 
           constraint_type   = 'primary key') then
            alter table iu_cm_def add constraint pk_iu_cm_def primary key (iu_cm_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*тайминг*/
create table if not exists iu_cm_time/**/ (
instanceid binary(16) ,
iu_cm_timeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'messagetype') then
                alter table iu_cm_time add 
                messagetype binary(16) null /* тип сообщения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'thedate') then
                alter table iu_cm_time add 
                thedate
 datetime null /* дата */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'theauthor') then
                alter table iu_cm_time add 
                theauthor binary(16) null /* добавил */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'endtime') then
                alter table iu_cm_time add 
                endtime
 varchar (15) null /* тайминг.конец */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'info') then
                alter table iu_cm_time add 
                info
 text null /* сообщение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'starttime') then
                alter table iu_cm_time add 
                starttime
 varchar (15) null /* тайминг.начало */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'ischecked') then
                alter table iu_cm_time add 
                ischecked
 integer null /* проверен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'thefile_ext') then
        alter table iu_cm_time add 
            thefile_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'thefile') then
                alter table iu_cm_time add 
                thefile varchar(255) null /* файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'theref') then
                alter table iu_cm_time add 
                theref varchar(255) null /* ссылка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_time' and 
           column_name   = 'curatoronly') then
                alter table iu_cm_time add 
                curatoronly
 integer null /* скрытый */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_cm_time' and 
           constraint_type   = 'primary key') then
            alter table iu_cm_time add constraint pk_iu_cm_time primary key (iu_cm_timeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*сообщения*/
create table if not exists iu_cm_msg/**/ (
instanceid binary(16) ,
iu_cm_msgid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
,parentrowid binary(16) 
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_msg' and 
           column_name   = 'info') then
                alter table iu_cm_msg add 
                info
 text null /* сообщение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_msg' and 
           column_name   = 'messagetype') then
                alter table iu_cm_msg add 
                messagetype binary(16) null /* тип сообщения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_msg' and 
           column_name   = 'theauthor') then
                alter table iu_cm_msg add 
                theauthor binary(16) null /* добавил */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_msg' and 
           column_name   = 'thedate') then
                alter table iu_cm_msg add 
                thedate
 datetime null /* дата */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_msg' and 
           column_name   = 'thefile_ext') then
        alter table iu_cm_msg add 
            thefile_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_msg' and 
           column_name   = 'thefile') then
                alter table iu_cm_msg add 
                thefile varchar(255) null /* файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_cm_msg' and 
           column_name   = 'theref') then
                alter table iu_cm_msg add 
                theref varchar(255) null /* ссылка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_cm_msg' and 
           constraint_type   = 'primary key') then
            alter table iu_cm_msg add constraint pk_iu_cm_msg primary key (iu_cm_msgid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_plog (Логирование событий) */
GO

/*событие*/
create table if not exists iu_plevent/*событие в системе*/ (
instanceid binary(16) ,
iu_pleventid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_plevent' and 
           column_name   = 'eventtype') then
                alter table iu_plevent add 
                eventtype
 varchar (255) null /* тип события */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_plevent' and 
           column_name   = 'info') then
                alter table iu_plevent add 
                info
 varchar (255) null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_plevent' and 
           column_name   = 'doer') then
                alter table iu_plevent add 
                doer binary(16) null /* сотрудник */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_plevent' and 
           column_name   = 'createdate') then
                alter table iu_plevent add 
                createdate
 datetime null /* дата события */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_plevent' and 
           column_name   = 'theprocess') then
                alter table iu_plevent add 
                theprocess binary(16) null /* урок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_plevent' and 
           column_name   = 'processstatus') then
                alter table iu_plevent add 
                processstatus binary(16) null /* подэтап */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_plevent' and 
           column_name   = 'statetask') then
                alter table iu_plevent add 
                statetask binary(16) null /* задача */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_plevent' and 
           column_name   = 'thedoc') then
                alter table iu_plevent add 
                thedoc binary(16) null /* документ */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_plevent' and 
           column_name   = 'thevideo') then
                alter table iu_plevent add 
                thevideo binary(16) null /* видео */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_plevent' and 
           column_name   = 'thediscussion') then
                alter table iu_plevent add 
                thediscussion binary(16) null /* обсуждение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_plevent' and 
           constraint_type   = 'primary key') then
            alter table iu_plevent add constraint pk_iu_plevent primary key (iu_pleventid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_rcfg (Настройка роли) */
GO

/*модуль*/
create table if not exists iu_rcfg_mod/**/ (
instanceid binary(16) ,
iu_rcfg_modid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'sequence') then
                alter table iu_rcfg_mod add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'caption') then
                alter table iu_rcfg_mod add 
                caption
 varchar (80) null /* надпись */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'theicon') then
                alter table iu_rcfg_mod add 
                theicon
 varchar (64) null /* иконка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'name') then
                alter table iu_rcfg_mod add 
                name
 varchar (255) null /* название меню */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'groupname') then
                alter table iu_rcfg_mod add 
                groupname
 varchar (60) null /* меню верхнего уровня */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'moduleaccessible') then
                alter table iu_rcfg_mod add 
                moduleaccessible
 integer null /* разрешен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'visiblecontrol') then
                alter table iu_rcfg_mod add 
                visiblecontrol
 integer null /* управление видимостью */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'allobjects') then
                alter table iu_rcfg_mod add 
                allobjects
 integer null /* вся фирма */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'colegsobject') then
                alter table iu_rcfg_mod add 
                colegsobject
 integer null /* объекты коллег */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'substructobjects') then
                alter table iu_rcfg_mod add 
                substructobjects
 integer null /* подчиненные подразделения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'tmobjects') then
                alter table iu_rcfg_mod add 
                tmobjects
 integer null /* учителя и методисты */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'mydocmode') then
                alter table iu_rcfg_mod add 
                mydocmode
 varchar (10) null /* мои документы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'otherdocmode') then
                alter table iu_rcfg_mod add 
                otherdocmode
 varchar (10) null /* чужие документы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           column_name   = 'controldocmode') then
                alter table iu_rcfg_mod add 
                controldocmode
 varchar (10) null /* документы на контроле */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_rcfg_mod' and 
           constraint_type   = 'primary key') then
            alter table iu_rcfg_mod add constraint pk_iu_rcfg_mod primary key (iu_rcfg_modid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*режим документа*/
create table if not exists iu_rcfg_docmode/*какую карточку документа открывать*/ (
instanceid binary(16) ,
iu_rcfg_docmodeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_docmode' and 
           column_name   = 'the_document') then
                alter table iu_rcfg_docmode add 
                the_document binary(16) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_docmode' and 
           column_name   = 'addmode') then
                alter table iu_rcfg_docmode add 
                addmode
 varchar (4) null /* режим для  создания */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_docmode' and 
           column_name   = 'editmode') then
                alter table iu_rcfg_docmode add 
                editmode
 varchar (4) null /* режим для редактирования */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_docmode' and 
           column_name   = 'allowadd') then
                alter table iu_rcfg_docmode add 
                allowadd
 integer null /* можно создавать */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_docmode' and 
           column_name   = 'allowdelete') then
                alter table iu_rcfg_docmode add 
                allowdelete
 integer null /* можно удалять */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_docmode' and 
           column_name   = 'allowdelegate') then
                alter table iu_rcfg_docmode add 
                allowdelegate
 integer null /* можно  делегировать */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_rcfg_docmode' and 
           constraint_type   = 'primary key') then
            alter table iu_rcfg_docmode add constraint pk_iu_rcfg_docmode primary key (iu_rcfg_docmodeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*роль*/
create table if not exists iu_rcfg_def/*роль для настройки*/ (
instanceid binary(16) ,
iu_rcfg_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_def' and 
           column_name   = 'archived') then
                alter table iu_rcfg_def add 
                archived int null default 0;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_rcfg_def' and 
           column_name   = 'therole') then
                alter table iu_rcfg_def add 
                therole binary(16) null /* роль */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_rcfg_def' and 
           constraint_type   = 'primary key') then
            alter table iu_rcfg_def add constraint pk_iu_rcfg_def primary key (iu_rcfg_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_t (Города) */
GO

/*город*/
create table if not exists iud_town/*город*/ (
instanceid binary(16) ,
iud_townid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_town' and 
           column_name   = 'name') then
                alter table iud_town add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_town' and 
           constraint_type   = 'primary key') then
            alter table iud_town add constraint pk_iud_town primary key (iud_townid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_reg (Регламентирующая документация) */
GO

/*структура документации*/
create table if not exists iu_regtree/*структура документации*/ (
instanceid binary(16) ,
iu_regtreeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
,parentrowid binary(16) 
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_regtree' and 
           column_name   = 'name') then
                alter table iu_regtree add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_regtree' and 
           constraint_type   = 'primary key') then
            alter table iu_regtree add constraint pk_iu_regtree primary key (iu_regtreeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*документы*/
create table if not exists iu_regdocs/*документы*/ (
parentstructrowid binary(16) not null,
iu_regdocsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_regdocs' and 
           column_name   = 'docname') then
                alter table iu_regdocs add 
                docname
 varchar (255) null /* название документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_regdocs' and 
           column_name   = 'thedoc_ext') then
        alter table iu_regdocs add 
            thedoc_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_regdocs' and 
           column_name   = 'thedoc') then
                alter table iu_regdocs add 
                thedoc varchar(255) null /* файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_regdocs' and 
           column_name   = 'thecomment') then
                alter table iu_regdocs add 
                thecomment
 varchar (4000) null /* комментарий */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_regdocs' and 
           column_name   = 'origname') then
                alter table iu_regdocs add 
                origname
 varchar (255) null /* оригинальное название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_regdocs' and 
           constraint_type   = 'primary key') then
            alter table iu_regdocs add constraint pk_iu_regdocs primary key (iu_regdocsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_s (Подэтап процесса) */
GO

/*подэтап*/
create table if not exists iu_status/*статус урока*/ (
instanceid binary(16) ,
iu_statusid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_status' and 
           column_name   = 'sequence') then
                alter table iu_status add 
                sequence
 integer null /* порядок вывода */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_status' and 
           column_name   = 'theprocess') then
                alter table iu_status add 
                theprocess binary(16) null /* процесс */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_status' and 
           column_name   = 'thestage') then
                alter table iu_status add 
                thestage binary(16) null /* этап */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_status' and 
           column_name   = 'name') then
                alter table iu_status add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_status' and 
           column_name   = 'isstartupstate') then
                alter table iu_status add 
                isstartupstate
 integer null /* это начало */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_status' and 
           column_name   = 'isfinishstate') then
                alter table iu_status add 
                isfinishstate
 integer null /* это завершение  */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_status' and 
           constraint_type   = 'primary key') then
            alter table iu_status add constraint pk_iu_status primary key (iu_statusid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*необходимые исполнители*/
create table if not exists iu_status_doer/*проверка на наличие назначенных исполнителей*/ (
instanceid binary(16) ,
iu_status_doerid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_status_doer' and 
           column_name   = 'doertype') then
                alter table iu_status_doer add 
                doertype binary(16) null /* тип исполнителя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_status_doer' and 
           column_name   = 'doerallowed') then
                alter table iu_status_doer add 
                doerallowed
 integer null /* наличие обязательно */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_status_doer' and 
           constraint_type   = 'primary key') then
            alter table iu_status_doer add constraint pk_iu_status_doer primary key (iu_status_doerid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*задачи*/
create table if not exists iu_statustask/*задачи  для данного состояния*/ (
instanceid binary(16) ,
iu_statustaskid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statustask' and 
           column_name   = 'name') then
                alter table iu_statustask add 
                name
 varchar (255) null /* название задачи */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statustask' and 
           column_name   = 'doertype') then
                alter table iu_statustask add 
                doertype binary(16) null /* тип исполнителя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statustask' and 
           column_name   = 'duration_plan') then
                alter table iu_statustask add 
                duration_plan
 integer null /* плановая длительность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statustask' and 
           column_name   = 'info') then
                alter table iu_statustask add 
                info
 varchar (8000) null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statustask' and 
           column_name   = 'contoller') then
                alter table iu_statustask add 
                contoller binary(16) null /* кто контролирует */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statustask' and 
           column_name   = 'statusonclose') then
                alter table iu_statustask add 
                statusonclose binary(16) null /* статус по завершению */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statustask' and 
           column_name   = 'possiblestatuses') then
                alter table iu_statustask add 
                possiblestatuses
 varchar (255) null /* альтернативные статусы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statustask' and 
           column_name   = 'finishallowed') then
                alter table iu_statustask add 
                finishallowed
 integer null /* завершение обязательно */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statustask' and 
           column_name   = 'tasksequence') then
                alter table iu_statustask add 
                tasksequence
 integer null /* последовательность исполнения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statustask' and 
           column_name   = 'afterall') then
                alter table iu_statustask add 
                afterall
 integer null /* после всех предыдущих */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_statustask' and 
           constraint_type   = 'primary key') then
            alter table iu_statustask add constraint pk_iu_statustask primary key (iu_statustaskid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*ссылки к задаче*/
create table if not exists iu_state_tasklink/*какие ссылки надо включить в описание задачи*/ (
parentstructrowid binary(16) not null,
iu_state_tasklinkid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_state_tasklink' and 
           column_name   = 'doctype') then
                alter table iu_state_tasklink add 
                doctype binary(16) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_state_tasklink' and 
           column_name   = 'allversions') then
                alter table iu_state_tasklink add 
                allversions
 integer null /* все версии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_state_tasklink' and 
           constraint_type   = 'primary key') then
            alter table iu_state_tasklink add constraint pk_iu_state_tasklink primary key (iu_state_tasklinkid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*пакет документов*/
create table if not exists iu_stausdoc/*проверка на полноту пакета документов*/ (
instanceid binary(16) ,
iu_stausdocid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_stausdoc' and 
           column_name   = 'doctype') then
                alter table iu_stausdoc add 
                doctype binary(16) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_stausdoc' and 
           column_name   = 'allowdoc') then
                alter table iu_stausdoc add 
                allowdoc
 integer null /* требовать наличия при проверке */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_stausdoc' and 
           column_name   = 'name') then
                alter table iu_stausdoc add 
                name
 varchar (255) null /* название документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_stausdoc' and 
           column_name   = 'info') then
                alter table iu_stausdoc add 
                info
 varchar (255) null /* дополнительное описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_stausdoc' and 
           constraint_type   = 'primary key') then
            alter table iu_stausdoc add constraint pk_iu_stausdoc primary key (iu_stausdocid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*возможные переходы*/
create table if not exists iu_statusnext/*возможные переходы*/ (
instanceid binary(16) ,
iu_statusnextid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statusnext' and 
           column_name   = 'nextstatus') then
                alter table iu_statusnext add 
                nextstatus binary(16) null /* следующий подэтап */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statusnext' and 
           column_name   = 'statusafter') then
                alter table iu_statusnext add 
                statusafter binary(16) null /* статус по завершению */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_statusnext' and 
           constraint_type   = 'primary key') then
            alter table iu_statusnext add constraint pk_iu_statusnext primary key (iu_statusnextid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*может перевести*/
create table if not exists iu_statuschanger/*может перевести*/ (
parentstructrowid binary(16) not null,
iu_statuschangerid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statuschanger' and 
           column_name   = 'whocan') then
                alter table iu_statuschanger add 
                whocan binary(16) null /* роль в процессе */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_statuschanger' and 
           column_name   = 'checkdocuments') then
                alter table iu_statuschanger add 
                checkdocuments
 integer null /* с проверкой документов */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_statuschanger' and 
           constraint_type   = 'primary key') then
            alter table iu_statuschanger add constraint pk_iu_statuschanger primary key (iu_statuschangerid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZ2JOB (Отложенные обработки) */
GO

/*отложенное событие*/
create table if not exists mtz2job_def/*описание отложенного события*/ (
instanceid binary(16) ,
mtz2job_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtz2job_def' and 
           column_name   = 'eventdate') then
                alter table mtz2job_def add 
                eventdate
 datetime null /* отложено до */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtz2job_def' and 
           column_name   = 'eventype') then
                alter table mtz2job_def add 
                eventype
 varchar (255) null /* тип события */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtz2job_def' and 
           column_name   = 'thruobject') then
                alter table mtz2job_def add 
                thruobject binary(16) null /* объект - причина события */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtz2job_def' and 
           column_name   = 'thrustate') then
                alter table mtz2job_def add 
                thrustate binary(16) null /* состояние - причина */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtz2job_def' and 
           column_name   = 'nextstate') then
                alter table mtz2job_def add 
                nextstate binary(16) null /* состояние после обработки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtz2job_def' and 
           column_name   = 'processdate') then
                alter table mtz2job_def add 
                processdate
 datetime null /* момент обработки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'mtz2job_def' and 
           column_name   = 'processed') then
                alter table mtz2job_def add 
                processed
 integer null /* обработан */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'mtz2job_def' and 
           constraint_type   = 'primary key') then
            alter table mtz2job_def add constraint pk_mtz2job_def primary key (mtz2job_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_c (Тип курса) */
GO

/*тип курса*/
create table if not exists iud_ctype/*тип курса*/ (
instanceid binary(16) ,
iud_ctypeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_ctype' and 
           column_name   = 'name') then
                alter table iud_ctype add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_ctype' and 
           constraint_type   = 'primary key') then
            alter table iud_ctype add constraint pk_iud_ctype primary key (iud_ctypeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iud_sp (Статус публикации) */
GO

/*статус публикации*/
create table if not exists iud_spub/*статус публикации*/ (
instanceid binary(16) ,
iud_spubid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iud_spub' and 
           column_name   = 'name') then
                alter table iud_spub add 
                name
 varchar (120) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iud_spub' and 
           constraint_type   = 'primary key') then
            alter table iud_spub add constraint pk_iud_spub primary key (iud_spubid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZFltr (Описание фильтра) */
GO

/*группа полей фильтра*/
create table if not exists filterfieldgroup/*группа полей фильтра*/ (
instanceid binary(16) ,
filterfieldgroupid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'filterfieldgroup' and 
           column_name   = 'sequence') then
                alter table filterfieldgroup add 
                sequence
 integer null /* последовательность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'filterfieldgroup' and 
           column_name   = 'name') then
                alter table filterfieldgroup add 
                name
 varchar (64) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'filterfieldgroup' and 
           column_name   = 'caption') then
                alter table filterfieldgroup add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'filterfieldgroup' and 
           column_name   = 'allowignore') then
                alter table filterfieldgroup add 
                allowignore
 integer null /* можно отключать */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'filterfieldgroup' and 
           constraint_type   = 'primary key') then
            alter table filterfieldgroup add constraint pk_filterfieldgroup primary key (filterfieldgroupid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*поле фильтра*/
create table if not exists fileterfield/*поле фильтра*/ (
parentstructrowid binary(16) not null,
fileterfieldid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fileterfield' and 
           column_name   = 'sequence') then
                alter table fileterfield add 
                sequence
 integer null /* последовательность */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fileterfield' and 
           column_name   = 'name') then
                alter table fileterfield add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fileterfield' and 
           column_name   = 'caption') then
                alter table fileterfield add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fileterfield' and 
           column_name   = 'fieldtype') then
                alter table fileterfield add 
                fieldtype binary(16) null /* тип поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fileterfield' and 
           column_name   = 'fieldsize') then
                alter table fileterfield add 
                fieldsize
 integer null /* размер */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fileterfield' and 
           column_name   = 'reftype') then
                alter table fileterfield add 
                reftype
 integer null /* тип ссылки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fileterfield' and 
           column_name   = 'reftotype') then
                alter table fileterfield add 
                reftotype binary(16) null /* тип, куда ссылаемся */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fileterfield' and 
           column_name   = 'reftopart') then
                alter table fileterfield add 
                reftopart binary(16) null /* раздел, куда ссылаемся */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'fileterfield' and 
           column_name   = 'valuearray') then
                alter table fileterfield add 
                valuearray
 integer null /* массив значений */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'fileterfield' and 
           constraint_type   = 'primary key') then
            alter table fileterfield add constraint pk_fileterfield primary key (fileterfieldid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*фильтр*/
create table if not exists filters/*фильтр*/ (
instanceid binary(16) ,
filtersid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'filters' and 
           column_name   = 'name') then
                alter table filters add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'filters' and 
           column_name   = 'thecaption') then
                alter table filters add 
                thecaption
 varchar (80) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'filters' and 
           column_name   = 'thecomment') then
                alter table filters add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'filters' and 
           constraint_type   = 'primary key') then
            alter table filters add constraint pk_filters primary key (filtersid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_int (Интерфейс) */
GO

/*модуль*/
create table if not exists iu_int_modules/**/ (
instanceid binary(16) ,
iu_int_modulesid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'sequence') then
                alter table iu_int_modules add 
                sequence
 integer null /* № п/п */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'theicon') then
                alter table iu_int_modules add 
                theicon
 varchar (64) null /* иконка */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'groupname') then
                alter table iu_int_modules add 
                groupname
 varchar (60) null /* меню верхнего урровня */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'name') then
                alter table iu_int_modules add 
                name
 varchar (255) null /* название меню */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'caption') then
                alter table iu_int_modules add 
                caption
 varchar (80) null /* надпись */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'visiblecontrol') then
                alter table iu_int_modules add 
                visiblecontrol
 integer null /* управление видимостью */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'controldocmode') then
                alter table iu_int_modules add 
                controldocmode
 varchar (10) null /* документы на контроле */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'otherdocmode') then
                alter table iu_int_modules add 
                otherdocmode
 varchar (10) null /* чужие документы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'mydocmode') then
                alter table iu_int_modules add 
                mydocmode
 varchar (10) null /* мои документы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'allobjects') then
                alter table iu_int_modules add 
                allobjects
 integer null /* вся фирма */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'colegsobject') then
                alter table iu_int_modules add 
                colegsobject
 integer null /* объекты коллег */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_int_modules' and 
           column_name   = 'substructobjects') then
                alter table iu_int_modules add 
                substructobjects
 integer null /* подчиненные подразделения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_int_modules' and 
           constraint_type   = 'primary key') then
            alter table iu_int_modules add constraint pk_iu_int_modules primary key (iu_int_modulesid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_t (Задачи) */
GO

/*задача*/
create table if not exists iu_task/*описание задачи*/ (
instanceid binary(16) ,
iu_taskid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'doer') then
                alter table iu_task add 
                doer binary(16) null /* исполнитель */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'contoller') then
                alter table iu_task add 
                contoller binary(16) null /* кто контролирует */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'subj') then
                alter table iu_task add 
                subj
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'createdate') then
                alter table iu_task add 
                createdate
 datetime null /* дата создания */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'planenddate') then
                alter table iu_task add 
                planenddate
 datetime null /* плановый срок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'info') then
                alter table iu_task add 
                info
 varchar (4000) null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'manualtask') then
                alter table iu_task add 
                manualtask
 integer null /* выдана вручную */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'theprocess') then
                alter table iu_task add 
                theprocess binary(16) null /* урок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'doer_comment') then
                alter table iu_task add 
                doer_comment
 varchar (255) null /* комментарий к задаче */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'doer_states') then
                alter table iu_task add 
                doer_states binary(16) null /* статус */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'controller_comment') then
                alter table iu_task add 
                controller_comment
 varchar (255) null /* комментарий контролера */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'taskfinished') then
                alter table iu_task add 
                taskfinished
 integer null /* завершена */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'ischecked') then
                alter table iu_task add 
                ischecked
 integer null /* проверена */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'finishdate') then
                alter table iu_task add 
                finishdate
 datetime null /* дата завершения */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'taskcancelled') then
                alter table iu_task add 
                taskcancelled
 integer null /* отменена */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'senttodoer') then
                alter table iu_task add 
                senttodoer
 datetime null /* отослано исполнителю */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'isdelegated') then
                alter table iu_task add 
                isdelegated
 integer null /* делегирована */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'processstatus') then
                alter table iu_task add 
                processstatus binary(16) null /* подэтап */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'statetask') then
                alter table iu_task add 
                statetask binary(16) null /* задача */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_task' and 
           column_name   = 'delegatefrom') then
                alter table iu_task add 
                delegatefrom binary(16) null /* делегирована из */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_task' and 
           constraint_type   = 'primary key') then
            alter table iu_task add constraint pk_iu_task primary key (iu_taskid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*новые материалы*/
create table if not exists iu_taskattach/*новые материалы*/ (
instanceid binary(16) ,
iu_taskattachid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskattach' and 
           column_name   = 'dtype') then
                alter table iu_taskattach add 
                dtype binary(16) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskattach' and 
           column_name   = 'filereftype') then
                alter table iu_taskattach add 
                filereftype binary(16) null /* тип ссылки на файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskattach' and 
           column_name   = 'theref_ext') then
        alter table iu_taskattach add 
            theref_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskattach' and 
           column_name   = 'theref') then
                alter table iu_taskattach add 
                theref varchar(255) null /* файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskattach' and 
           column_name   = 'fileurl') then
                alter table iu_taskattach add 
                fileurl varchar(255) null /* url файла */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskattach' and 
           column_name   = 'filetext') then
                alter table iu_taskattach add 
                filetext
 text null /* текст документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskattach' and 
           column_name   = 'info') then
                alter table iu_taskattach add 
                info
 varchar (255) null /* комментарий */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskattach' and 
           column_name   = 'origname') then
                alter table iu_taskattach add 
                origname
 varchar (255) null /* оригинальное название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_taskattach' and 
           constraint_type   = 'primary key') then
            alter table iu_taskattach add constraint pk_iu_taskattach primary key (iu_taskattachid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*новые видео*/
create table if not exists iu_taskvideo/*новые видео*/ (
instanceid binary(16) ,
iu_taskvideoid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'doctype') then
                alter table iu_taskvideo add 
                doctype binary(16) null /* тип видео */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'adddate') then
                alter table iu_taskvideo add 
                adddate
 datetime null /* когда добавлен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'activeversion') then
                alter table iu_taskvideo add 
                activeversion
 integer null /* активная версия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'fileref_ext') then
        alter table iu_taskvideo add 
            fileref_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'fileref') then
                alter table iu_taskvideo add 
                fileref varchar(255) null /* файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'addby') then
                alter table iu_taskvideo add 
                addby binary(16) null /* кем добавлен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'info') then
                alter table iu_taskvideo add 
                info
 varchar (255) null /* комментарий */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'fileurl') then
                alter table iu_taskvideo add 
                fileurl varchar(255) null /* url файла */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'version') then
                alter table iu_taskvideo add 
                version
 integer null /* № версии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'nocomments') then
                alter table iu_taskvideo add 
                nocomments
 integer null /* скрыть */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskvideo' and 
           column_name   = 'origname') then
                alter table iu_taskvideo add 
                origname
 varchar (255) null /* оригинальное название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_taskvideo' and 
           constraint_type   = 'primary key') then
            alter table iu_taskvideo add constraint pk_iu_taskvideo primary key (iu_taskvideoid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*вложения*/
create table if not exists iu_taskrefs/**/ (
instanceid binary(16) ,
iu_taskrefsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'dtypename') then
                alter table iu_taskrefs add 
                dtypename
 varchar (255) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'filereftype') then
                alter table iu_taskrefs add 
                filereftype binary(16) null /* тип ссылки на файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'theref_ext') then
        alter table iu_taskrefs add 
            theref_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'theref') then
                alter table iu_taskrefs add 
                theref varchar(255) null /* файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'fileurl') then
                alter table iu_taskrefs add 
                fileurl varchar(255) null /* url файла */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'filetext') then
                alter table iu_taskrefs add 
                filetext
 text null /* текст документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'info') then
                alter table iu_taskrefs add 
                info
 varchar (255) null /* комментарий */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'version') then
                alter table iu_taskrefs add 
                version
 integer null /* № версии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'addby') then
                alter table iu_taskrefs add 
                addby binary(16) null /* кем добавлен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'adddate') then
                alter table iu_taskrefs add 
                adddate
 datetime null /* когда добавлен */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_taskrefs' and 
           column_name   = 'origname') then
                alter table iu_taskrefs add 
                origname
 varchar (255) null /* оригинальное название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_taskrefs' and 
           constraint_type   = 'primary key') then
            alter table iu_taskrefs add constraint pk_iu_taskrefs primary key (iu_taskrefsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_l (Личные сообщения) */
GO

/*сообщение*/
create table if not exists iu_l_def/*сообщение*/ (
instanceid binary(16) ,
iu_l_defid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_l_def' and 
           column_name   = 'sender') then
                alter table iu_l_def add 
                sender binary(16) null /* отправитель */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_l_def' and 
           column_name   = 'doer') then
                alter table iu_l_def add 
                doer binary(16) null /* кому */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_l_def' and 
           column_name   = 'info') then
                alter table iu_l_def add 
                info
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_l_def' and 
           column_name   = 'createdate') then
                alter table iu_l_def add 
                createdate
 datetime null /* дата создания */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_l_def' and 
           column_name   = 'readdate') then
                alter table iu_l_def add 
                readdate
 datetime null /* прочитана */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_l_def' and 
           constraint_type   = 'primary key') then
            alter table iu_l_def add constraint pk_iu_l_def primary key (iu_l_defid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_tm (Учителя и Методисты) */
GO

/*досье*/
create table if not exists iu_tm_records/**/ (
instanceid binary(16) ,
iu_tm_recordsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'passport') then
                alter table iu_tm_records add 
                passport
 varchar (255) null /* паспортные данные */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'inn') then
                alter table iu_tm_records add 
                inn
 varchar (12) null /* инн */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'snils') then
                alter table iu_tm_records add 
                snils
 varchar (50) null /* снилс */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'bankinfo') then
                alter table iu_tm_records add 
                bankinfo
 varchar (255) null /* банковские реквизиты */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'scanpassport_ext') then
        alter table iu_tm_records add 
            scanpassport_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'scanpassport') then
                alter table iu_tm_records add 
                scanpassport varchar(255) null /* паспорт */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'scaninn_ext') then
        alter table iu_tm_records add 
            scaninn_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'scaninn') then
                alter table iu_tm_records add 
                scaninn varchar(255) null /* инн */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'scansnils_ext') then
        alter table iu_tm_records add 
            scansnils_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'scansnils') then
                alter table iu_tm_records add 
                scansnils varchar(255) null /* снилс */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'info') then
                alter table iu_tm_records add 
                info
 varchar (4000) null /* информация */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'tmfile_ext') then
        alter table iu_tm_records add 
            tmfile_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'tmfile') then
                alter table iu_tm_records add 
                tmfile varchar(255) null /* файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_records' and 
           column_name   = 'thecomment') then
                alter table iu_tm_records add 
                thecomment
 varchar (4000) null /*   */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_tm_records' and 
           constraint_type   = 'primary key') then
            alter table iu_tm_records add constraint pk_iu_tm_records primary key (iu_tm_recordsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*информация*/
create table if not exists iu_tmdef/*информация об учителях и методистах*/ (
instanceid binary(16) ,
iu_tmdefid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'archived') then
                alter table iu_tmdef add 
                archived int null default 0;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'lastname') then
                alter table iu_tmdef add 
                lastname
 varchar (120) null /* фамилия */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'name') then
                alter table iu_tmdef add 
                name
 varchar (120) null /* имя */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'surname') then
                alter table iu_tmdef add 
                surname
 varchar (120) null /* отчество */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'subjects') then
                alter table iu_tmdef add 
                subjects
 varchar (400) null /* предметы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'classes') then
                alter table iu_tmdef add 
                classes
 varchar (80) null /* классы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'thephone') then
                alter table iu_tmdef add 
                thephone
 varchar (40) null /* телефон */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'email') then
                alter table iu_tmdef add 
                email
 varchar (60) null /* e-mail */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'sendtomail') then
                alter table iu_tmdef add 
                sendtomail
 integer null /* оповещать по почте */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'regal') then
                alter table iu_tmdef add 
                regal
 varchar (250) null /* регалии */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'ismethodist') then
                alter table iu_tmdef add 
                ismethodist
 integer null /* методист */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'thetown') then
                alter table iu_tmdef add 
                thetown binary(16) null /* город */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmdef' and 
           column_name   = 'workat') then
                alter table iu_tmdef add 
                workat
 varchar (250) null /* место работы */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_tmdef' and 
           constraint_type   = 'primary key') then
            alter table iu_tmdef add constraint pk_iu_tmdef primary key (iu_tmdefid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*мастер-кадры и костюмы*/
create table if not exists iu_tmcadr/**/ (
instanceid binary(16) ,
iu_tmcadrid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmcadr' and 
           column_name   = 'photo_ext') then
        alter table iu_tmcadr add 
            photo_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmcadr' and 
           column_name   = 'photo') then
                alter table iu_tmcadr add 
                photo varchar(255) null /* фото */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmcadr' and 
           column_name   = 'info') then
                alter table iu_tmcadr add 
                info
 varchar (4000) null /* примечание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tmcadr' and 
           column_name   = 'mastercadr') then
                alter table iu_tmcadr add 
                mastercadr
 integer null /* мастер-кадр */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_tmcadr' and 
           constraint_type   = 'primary key') then
            alter table iu_tmcadr add constraint pk_iu_tmcadr primary key (iu_tmcadrid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*акты*/
create table if not exists iu_tm_act/**/ (
instanceid binary(16) ,
iu_tm_actid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_act' and 
           column_name   = 'aktnum') then
                alter table iu_tm_act add 
                aktnum
 varchar (120) null /* номер акта */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_act' and 
           column_name   = 'aktfile_ext') then
        alter table iu_tm_act add 
            aktfile_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_act' and 
           column_name   = 'aktfile') then
                alter table iu_tm_act add 
                aktfile varchar(255) null /* файл акта */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_act' and 
           column_name   = 'paymentdate') then
                alter table iu_tm_act add 
                paymentdate
 date null /* дата оплаты */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_act' and 
           column_name   = 'payment') then
                alter table iu_tm_act add 
                payment
 double null /* сумма оплаты */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_act' and 
           column_name   = 'quantity') then
                alter table iu_tm_act add 
                quantity
 integer null /* количество уроков */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_act' and 
           column_name   = 'thecomment') then
                alter table iu_tm_act add 
                thecomment
 varchar (4000) null /*   */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_tm_act' and 
           constraint_type   = 'primary key') then
            alter table iu_tm_act add constraint pk_iu_tm_act primary key (iu_tm_actid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*файлы к акту*/
create table if not exists iu_tm_actfile/**/ (
parentstructrowid binary(16) not null,
iu_tm_actfileid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_actfile' and 
           column_name   = 'dtype') then
                alter table iu_tm_actfile add 
                dtype binary(16) null /* тип документа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_actfile' and 
           column_name   = 'theref_ext') then
        alter table iu_tm_actfile add 
            theref_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_actfile' and 
           column_name   = 'theref') then
                alter table iu_tm_actfile add 
                theref varchar(255) null /* файл */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_actfile' and 
           column_name   = 'info') then
                alter table iu_tm_actfile add 
                info
 varchar (255) null /* комментарий */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_tm_actfile' and 
           constraint_type   = 'primary key') then
            alter table iu_tm_actfile add constraint pk_iu_tm_actfile primary key (iu_tm_actfileid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*договора*/
create table if not exists iu_tm_dog/**/ (
instanceid binary(16) ,
iu_tm_dogid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_dog' and 
           column_name   = 'thedate') then
                alter table iu_tm_dog add 
                thedate
 date null /* дата договора */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_dog' and 
           column_name   = 'thenumber') then
                alter table iu_tm_dog add 
                thenumber
 varchar (50) null /* номер договора */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_dog' and 
           column_name   = 'dogfile_ext') then
        alter table iu_tm_dog add 
            dogfile_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_dog' and 
           column_name   = 'dogfile') then
                alter table iu_tm_dog add 
                dogfile varchar(255) null /* файл договора */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_tm_dog' and 
           column_name   = 'info') then
                alter table iu_tm_dog add 
                info
 varchar (1024) null /* примечание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_tm_dog' and 
           constraint_type   = 'primary key') then
            alter table iu_tm_dog add constraint pk_iu_tm_dog primary key (iu_tm_dogid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=MTZRprt (Описание отчета) */
GO

/*секции*/
create table if not exists rptstruct/*секции*/ (
instanceid binary(16) ,
rptstructid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
,parentrowid binary(16) 
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'rptstruct' and 
           column_name   = 'name') then
                alter table rptstruct add 
                name
 varchar (64) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'rptstruct' and 
           column_name   = 'caption') then
                alter table rptstruct add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'rptstruct' and 
           constraint_type   = 'primary key') then
            alter table rptstruct add constraint pk_rptstruct primary key (rptstructid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*поля секции*/
create table if not exists rptfields/*поля секции*/ (
parentstructrowid binary(16) not null,
rptfieldsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'rptfields' and 
           column_name   = 'name') then
                alter table rptfields add 
                name
 varchar (64) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'rptfields' and 
           column_name   = 'fieldtype') then
                alter table rptfields add 
                fieldtype binary(16) null /* тип поля */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'rptfields' and 
           column_name   = 'fieldsize') then
                alter table rptfields add 
                fieldsize
 integer null /* размер */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'rptfields' and 
           column_name   = 'caption') then
                alter table rptfields add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'rptfields' and 
           constraint_type   = 'primary key') then
            alter table rptfields add constraint pk_rptfields primary key (rptfieldsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*формулы*/
create table if not exists rptformula/*формулы*/ (
instanceid binary(16) ,
rptformulaid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'rptformula' and 
           column_name   = 'name') then
                alter table rptformula add 
                name
 varchar (64) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'rptformula' and 
           column_name   = 'code') then
                alter table rptformula add 
                code
 text null /* выражение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'rptformula' and 
           column_name   = 'platform') then
                alter table rptformula add 
                platform binary(16) null /* платформа */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'rptformula' and 
           constraint_type   = 'primary key') then
            alter table rptformula add constraint pk_rptformula primary key (rptformulaid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*описание*/
create table if not exists reports/*описание*/ (
instanceid binary(16) ,
reportsid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'reports' and 
           column_name   = 'name') then
                alter table reports add 
                name
 varchar (255) null /* название */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'reports' and 
           column_name   = 'reportfile_ext') then
        alter table reports add 
            reportfile_ext nvarchar(4) null;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'reports' and 
           column_name   = 'reportfile') then
                alter table reports add 
                reportfile varchar(255) null /* файл отчета */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'reports' and 
           column_name   = 'caption') then
                alter table reports add 
                caption
 varchar (255) null /* заголовок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'reports' and 
           column_name   = 'preparemethod') then
                alter table reports add 
                preparemethod binary(16) null /* метод для формирования */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'reports' and 
           column_name   = 'reporttype') then
                alter table reports add 
                reporttype
 integer null /* тип отчета */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'reports' and 
           column_name   = 'thereportext') then
                alter table reports add 
                thereportext binary(16) null /* расширение для создания отчета */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'reports' and 
           column_name   = 'reportview') then
                alter table reports add 
                reportview
 varchar (255) null /* базовый запрос */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'reports' and 
           column_name   = 'thecomment') then
                alter table reports add 
                thecomment
 text null /* описание */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'reports' and 
           constraint_type   = 'primary key') then
            alter table reports add constraint pk_reports primary key (reportsid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_subs (Подписка на события) */
GO

/*подписка на событие*/
create table if not exists iu_subsribe/*подписка на событие*/ (
instanceid binary(16) ,
iu_subsribeid binary(16) not null  
,changestamp datetime not null  /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'subscriber') then
                alter table iu_subsribe add 
                subscriber binary(16) null /* подписчик */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'isactive') then
                alter table iu_subsribe add 
                isactive
 integer null /* подписка активна */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'scandate') then
                alter table iu_subsribe add 
                scandate
 datetime null /* время последней обработки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'eventtype') then
                alter table iu_subsribe add 
                eventtype
 varchar (255) null /* тип события */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'theprocess') then
                alter table iu_subsribe add 
                theprocess binary(16) null /* урок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'processstatus') then
                alter table iu_subsribe add 
                processstatus binary(16) null /* подэтап */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'statetask') then
                alter table iu_subsribe add 
                statetask binary(16) null /* задача */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'doer') then
                alter table iu_subsribe add 
                doer binary(16) null /* сотрудник */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'thedoc') then
                alter table iu_subsribe add 
                thedoc binary(16) null /* документ */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'thevideo') then
                alter table iu_subsribe add 
                thevideo binary(16) null /* видео */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe' and 
           column_name   = 'thediscussion') then
                alter table iu_subsribe add 
                thediscussion binary(16) null /* обсуждение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_subsribe' and 
           constraint_type   = 'primary key') then
            alter table iu_subsribe add constraint pk_iu_subsribe primary key (iu_subsribeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO

/*подписка на событие*/
create table if not exists iu_subsribe_temp/*подписка на событие temp table*/ (
sessionid binary(16) ,/*  id текущей сесии пользователя   */ 
instanceid binary(16) ,
iu_subsribeid binary(16) not null  
,changestamp datetime not null /* время последнего изменения */
,timestamp timestamp not null  /* для организации инкрементального индексирования полнотекстовой информации */
,locksessionid binary(16) null  /* temporary lock */
,lockuserid binary(16) null /* checkout lock */
,securitystyleid binary(16) null /* security formula */
)
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'subscriber') then
                alter table iu_subsribe_temp add 
                subscriber binary(16) null /* подписчик */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'isactive') then
                alter table iu_subsribe_temp add 
                isactive
 integer null /* подписка активна */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'scandate') then
                alter table iu_subsribe_temp add 
                scandate
 datetime null /* время последней обработки */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'eventtype') then
                alter table iu_subsribe_temp add 
                eventtype
 varchar (255) null /* тип события */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'theprocess') then
                alter table iu_subsribe_temp add 
                theprocess binary(16) null /* урок */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'processstatus') then
                alter table iu_subsribe_temp add 
                processstatus binary(16) null /* подэтап */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'statetask') then
                alter table iu_subsribe_temp add 
                statetask binary(16) null /* задача */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'doer') then
                alter table iu_subsribe_temp add 
                doer binary(16) null /* сотрудник */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'thedoc') then
                alter table iu_subsribe_temp add 
                thedoc binary(16) null /* документ */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'thevideo') then
                alter table iu_subsribe_temp add 
                thevideo binary(16) null /* видео */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go

drop procedure if exists alter_col
go
create procedure alter_col() begin
        if not exists (select 1 from information_schema.columns where
           table_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           column_name   = 'thediscussion') then
                alter table iu_subsribe_temp add 
                thediscussion binary(16) null /* обсуждение */;
        end if;
end 
go
call alter_col(); 
go

drop procedure if exists alter_col
go
go



drop procedure if exists alter_pk
go
create procedure alter_pk() begin
    if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and 
           table_name   = 'iu_subsribe_temp' and 
           constraint_type   = 'primary key') then
            alter table iu_subsribe_temp add constraint pk_iu_subsribe_temp primary key (sessionid,iu_subsribeid);
    end if;
end 
go
call alter_pk(); 
go

drop procedure if exists alter_pk
go
GO
/* TYPE=iu_urok_arch (Урок.Архив) */
GO
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--Index" BlockCode=" 


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_stagedef' 
  and   index_name   = 'parent_iud_stagedef' ) then
   create index parent_iud_stagedef on iud_stagedef(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_adt_doc' 
  and   index_name   = 'parent_iud_adt_doc' ) then
   create index parent_iud_adt_doc on iud_adt_doc(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_orgtree' 
  and   index_name   = 'parent_iu_orgtree' ) then
   create index parent_iu_orgtree on iu_orgtree(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_orgusr' 
  and   index_name   = 'parent_iu_orgusr' ) then
create index parent_iu_orgusr on iu_orgusr(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_u_def' 
  and   index_name   = 'parent_iu_u_def' ) then
   create index parent_iu_u_def on iu_u_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_u_def_temp' 
  and   index_name   = 'idx_session_iu_u_def_temp' ) then
            create index idx_session_iu_u_def_temp on iu_u_def_temp (sessionid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_process_def' 
  and   index_name   = 'parent_iud_process_def' ) then
   create index parent_iud_process_def on iud_process_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'genpackage' 
  and   index_name   = 'parent_genpackage' ) then
   create index parent_genpackage on genpackage(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'generator_target' 
  and   index_name   = 'parent_generator_target' ) then
create index parent_generator_target on generator_target(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'genreference' 
  and   index_name   = 'parent_genreference' ) then
create index parent_genreference on genreference(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'genmanualcode' 
  and   index_name   = 'parent_genmanualcode' ) then
create index parent_genmanualcode on genmanualcode(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'gencontrols' 
  and   index_name   = 'parent_gencontrols' ) then
create index parent_gencontrols on gencontrols(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'localizeinfo' 
  and   index_name   = 'parent_localizeinfo' ) then
   create index parent_localizeinfo on localizeinfo(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'fieldtype' 
  and   index_name   = 'parent_fieldtype' ) then
   create index parent_fieldtype on fieldtype(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'enumitem' 
  and   index_name   = 'parent_enumitem' ) then
create index parent_enumitem on enumitem(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'fieldtypemap' 
  and   index_name   = 'parent_fieldtypemap' ) then
create index parent_fieldtypemap on fieldtypemap(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'sharedmethod' 
  and   index_name   = 'parent_sharedmethod' ) then
   create index parent_sharedmethod on sharedmethod(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'script' 
  and   index_name   = 'parent_script' ) then
create index parent_script on script(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'parameters' 
  and   index_name   = 'parent_parameters' ) then
create index parent_parameters on parameters(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'objecttype' 
  and   index_name   = 'parent_objecttype' ) then
   create index parent_objecttype on objecttype(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'objstatus' 
  and   index_name   = 'parent_objstatus' ) then
create index parent_objstatus on objstatus(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'nextstate' 
  and   index_name   = 'parent_nextstate' ) then
create index parent_nextstate on nextstate(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'objectmode' 
  and   index_name   = 'parent_objectmode' ) then
create index parent_objectmode on objectmode(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'structrestriction' 
  and   index_name   = 'parent_structrestriction' ) then
create index parent_structrestriction on structrestriction(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'methodrestriction' 
  and   index_name   = 'parent_methodrestriction' ) then
create index parent_methodrestriction on methodrestriction(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'fieldrestriction' 
  and   index_name   = 'parent_fieldrestriction' ) then
create index parent_fieldrestriction on fieldrestriction(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'typemenu' 
  and   index_name   = 'parent_typemenu' ) then
create index parent_typemenu on typemenu(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'instancevalidator' 
  and   index_name   = 'parent_instancevalidator' ) then
create index parent_instancevalidator on instancevalidator(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'part' 
  and   index_name   = 'parent_part' ) then
create index parent_part on part(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'partmenu' 
  and   index_name   = 'parent_partmenu' ) then
create index parent_partmenu on partmenu(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'partparammap' 
  and   index_name   = 'parent_partparammap' ) then
create index parent_partparammap on partparammap(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'partview' 
  and   index_name   = 'parent_partview' ) then
create index parent_partview on partview(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'viewcolumn' 
  and   index_name   = 'parent_viewcolumn' ) then
create index parent_viewcolumn on viewcolumn(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'partview_lnk' 
  and   index_name   = 'parent_partview_lnk' ) then
create index parent_partview_lnk on partview_lnk(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'validator' 
  and   index_name   = 'parent_validator' ) then
create index parent_validator on validator(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'uniqueconstraint' 
  and   index_name   = 'parent_uniqueconstraint' ) then
create index parent_uniqueconstraint on uniqueconstraint(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'constraintfield' 
  and   index_name   = 'parent_constraintfield' ) then
create index parent_constraintfield on constraintfield(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'extenderinterface' 
  and   index_name   = 'parent_extenderinterface' ) then
create index parent_extenderinterface on extenderinterface(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'field' 
  and   index_name   = 'parent_field' ) then
create index parent_field on field(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'fldextenders' 
  and   index_name   = 'parent_fldextenders' ) then
create index parent_fldextenders on fldextenders(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'fieldsrcdef' 
  and   index_name   = 'parent_fieldsrcdef' ) then
create index parent_fieldsrcdef on fieldsrcdef(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'dinamicfilterscript' 
  and   index_name   = 'parent_dinamicfilterscript' ) then
create index parent_dinamicfilterscript on dinamicfilterscript(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'fieldexpression' 
  and   index_name   = 'parent_fieldexpression' ) then
create index parent_fieldexpression on fieldexpression(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'fieldvalidator' 
  and   index_name   = 'parent_fieldvalidator' ) then
create index parent_fieldvalidator on fieldvalidator(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'fieldmenu' 
  and   index_name   = 'parent_fieldmenu' ) then
create index parent_fieldmenu on fieldmenu(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'fieldparammap' 
  and   index_name   = 'parent_fieldparammap' ) then
create index parent_fieldparammap on fieldparammap(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'mtzapp' 
  and   index_name   = 'parent_mtzapp' ) then
   create index parent_mtzapp on mtzapp(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'parentpackage' 
  and   index_name   = 'parent_parentpackage' ) then
create index parent_parentpackage on parentpackage(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'journalcolumn' 
  and   index_name   = 'parent_journalcolumn' ) then
   create index parent_journalcolumn on journalcolumn(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'jcolumnsource' 
  and   index_name   = 'parent_jcolumnsource' ) then
create index parent_jcolumnsource on jcolumnsource(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'journalsrc' 
  and   index_name   = 'parent_journalsrc' ) then
   create index parent_journalsrc on journalsrc(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'journal' 
  and   index_name   = 'parent_journal' ) then
   create index parent_journal on journal(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_urok_sn' 
  and   index_name   = 'parent_iu_urok_sn' ) then
   create index parent_iu_urok_sn on iu_urok_sn(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_urok_msg' 
  and   index_name   = 'parent_iu_urok_msg' ) then
   create index parent_iu_urok_msg on iu_urok_msg(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_urok_graph' 
  and   index_name   = 'parent_iu_urok_graph' ) then
   create index parent_iu_urok_graph on iu_urok_graph(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_urok_prc' 
  and   index_name   = 'parent_iu_urok_prc' ) then
   create index parent_iu_urok_prc on iu_urok_prc(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'folder' 
  and   index_name   = 'parent_folder' ) then
   create index parent_folder on folder(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'shortcut' 
  and   index_name   = 'parent_shortcut' ) then
create index parent_shortcut on shortcut(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'infostoredef' 
  and   index_name   = 'parent_infostoredef' ) then
   create index parent_infostoredef on infostoredef(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_rt_def' 
  and   index_name   = 'parent_iud_rt_def' ) then
   create index parent_iud_rt_def on iud_rt_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'the_session' 
  and   index_name   = 'parent_the_session' ) then
   create index parent_the_session on the_session(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'sysrefcache' 
  and   index_name   = 'parent_sysrefcache' ) then
   create index parent_sysrefcache on sysrefcache(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'syslog' 
  and   index_name   = 'parent_syslog' ) then
   create index parent_syslog on syslog(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'armjournal' 
  and   index_name   = 'parent_armjournal' ) then
   create index parent_armjournal on armjournal(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'armjrnlrep' 
  and   index_name   = 'parent_armjrnlrep' ) then
create index parent_armjrnlrep on armjrnlrep(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'armjrnlrun' 
  and   index_name   = 'parent_armjrnlrun' ) then
create index parent_armjrnlrun on armjrnlrun(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'armjrnladd' 
  and   index_name   = 'parent_armjrnladd' ) then
create index parent_armjrnladd on armjrnladd(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'entrypoints' 
  and   index_name   = 'parent_entrypoints' ) then
   create index parent_entrypoints on entrypoints(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'epfilterlink' 
  and   index_name   = 'parent_epfilterlink' ) then
create index parent_epfilterlink on epfilterlink(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'workplace' 
  and   index_name   = 'parent_workplace' ) then
   create index parent_workplace on workplace(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'armtypes' 
  and   index_name   = 'parent_armtypes' ) then
   create index parent_armtypes on armtypes(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_crole' 
  and   index_name   = 'parent_iu_crole' ) then
   create index parent_iu_crole on iu_crole(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles_operations' 
  and   index_name   = 'parent_roles_operations' ) then
   create index parent_roles_operations on roles_operations(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles_wp' 
  and   index_name   = 'parent_roles_wp' ) then
   create index parent_roles_wp on roles_wp(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles_act' 
  and   index_name   = 'parent_roles_act' ) then
create index parent_roles_act on roles_act(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles2_module' 
  and   index_name   = 'parent_roles2_module' ) then
   create index parent_roles2_module on roles2_module(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles2_modreport' 
  and   index_name   = 'parent_roles2_modreport' ) then
create index parent_roles2_modreport on roles2_modreport(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles_doc' 
  and   index_name   = 'parent_roles_doc' ) then
   create index parent_roles_doc on roles_doc(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles_doc_state' 
  and   index_name   = 'parent_roles_doc_state' ) then
create index parent_roles_doc_state on roles_doc_state(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles_reports' 
  and   index_name   = 'parent_roles_reports' ) then
   create index parent_roles_reports on roles_reports(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles_user' 
  and   index_name   = 'parent_roles_user' ) then
   create index parent_roles_user on roles_user(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles_map' 
  and   index_name   = 'parent_roles_map' ) then
   create index parent_roles_map on roles_map(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'roles_def' 
  and   index_name   = 'parent_roles_def' ) then
   create index parent_roles_def on roles_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_urok_docs' 
  and   index_name   = 'parent_iu_urok_docs' ) then
   create index parent_iu_urok_docs on iu_urok_docs(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_urok_creators' 
  and   index_name   = 'parent_iu_urok_creators' ) then
   create index parent_iu_urok_creators on iu_urok_creators(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_urok_def' 
  and   index_name   = 'parent_iu_urok_def' ) then
   create index parent_iu_urok_def on iu_urok_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_urok_video' 
  and   index_name   = 'parent_iu_urok_video' ) then
   create index parent_iu_urok_video on iu_urok_video(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_mt_def' 
  and   index_name   = 'parent_iud_mt_def' ) then
   create index parent_iud_mt_def on iud_mt_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_sn_def' 
  and   index_name   = 'parent_iud_sn_def' ) then
   create index parent_iud_sn_def on iud_sn_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_filestoretype' 
  and   index_name   = 'parent_iud_filestoretype' ) then
   create index parent_iud_filestoretype on iud_filestoretype(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_predmet' 
  and   index_name   = 'parent_iud_predmet' ) then
   create index parent_iud_predmet on iud_predmet(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_doctype' 
  and   index_name   = 'parent_iud_doctype' ) then
   create index parent_iud_doctype on iud_doctype(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'users' 
  and   index_name   = 'parent_users' ) then
   create index parent_users on users(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'groups' 
  and   index_name   = 'parent_groups' ) then
   create index parent_groups on groups(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'groupuser' 
  and   index_name   = 'parent_groupuser' ) then
create index parent_groupuser on groupuser(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_clsinfo' 
  and   index_name   = 'parent_iu_clsinfo' ) then
   create index parent_iu_clsinfo on iu_clsinfo(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'num_zones' 
  and   index_name   = 'parent_num_zones' ) then
   create index parent_num_zones on num_zones(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'num_values' 
  and   index_name   = 'parent_num_values' ) then
create index parent_num_values on num_values(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'num_head' 
  and   index_name   = 'parent_num_head' ) then
   create index parent_num_head on num_head(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_filetype' 
  and   index_name   = 'parent_iud_filetype' ) then
   create index parent_iud_filetype on iud_filetype(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'mtzext_def' 
  and   index_name   = 'parent_mtzext_def' ) then
   create index parent_mtzext_def on mtzext_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'mtzextrel' 
  and   index_name   = 'parent_mtzextrel' ) then
   create index parent_mtzextrel on mtzextrel(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_videotype' 
  and   index_name   = 'parent_iud_videotype' ) then
   create index parent_iud_videotype on iud_videotype(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_cm_def' 
  and   index_name   = 'parent_iu_cm_def' ) then
   create index parent_iu_cm_def on iu_cm_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_cm_time' 
  and   index_name   = 'parent_iu_cm_time' ) then
   create index parent_iu_cm_time on iu_cm_time(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_cm_msg' 
  and   index_name   = 'parent_iu_cm_msg' ) then
   create index parent_iu_cm_msg on iu_cm_msg(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_plevent' 
  and   index_name   = 'parent_iu_plevent' ) then
   create index parent_iu_plevent on iu_plevent(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_rcfg_mod' 
  and   index_name   = 'parent_iu_rcfg_mod' ) then
   create index parent_iu_rcfg_mod on iu_rcfg_mod(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_rcfg_docmode' 
  and   index_name   = 'parent_iu_rcfg_docmode' ) then
   create index parent_iu_rcfg_docmode on iu_rcfg_docmode(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_rcfg_def' 
  and   index_name   = 'parent_iu_rcfg_def' ) then
   create index parent_iu_rcfg_def on iu_rcfg_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_town' 
  and   index_name   = 'parent_iud_town' ) then
   create index parent_iud_town on iud_town(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_regtree' 
  and   index_name   = 'parent_iu_regtree' ) then
   create index parent_iu_regtree on iu_regtree(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_regdocs' 
  and   index_name   = 'parent_iu_regdocs' ) then
create index parent_iu_regdocs on iu_regdocs(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_status' 
  and   index_name   = 'parent_iu_status' ) then
   create index parent_iu_status on iu_status(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_status_doer' 
  and   index_name   = 'parent_iu_status_doer' ) then
   create index parent_iu_status_doer on iu_status_doer(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_statustask' 
  and   index_name   = 'parent_iu_statustask' ) then
   create index parent_iu_statustask on iu_statustask(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_state_tasklink' 
  and   index_name   = 'parent_iu_state_tasklink' ) then
create index parent_iu_state_tasklink on iu_state_tasklink(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_stausdoc' 
  and   index_name   = 'parent_iu_stausdoc' ) then
   create index parent_iu_stausdoc on iu_stausdoc(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_statusnext' 
  and   index_name   = 'parent_iu_statusnext' ) then
   create index parent_iu_statusnext on iu_statusnext(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_statuschanger' 
  and   index_name   = 'parent_iu_statuschanger' ) then
create index parent_iu_statuschanger on iu_statuschanger(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'mtz2job_def' 
  and   index_name   = 'parent_mtz2job_def' ) then
   create index parent_mtz2job_def on mtz2job_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_ctype' 
  and   index_name   = 'parent_iud_ctype' ) then
   create index parent_iud_ctype on iud_ctype(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iud_spub' 
  and   index_name   = 'parent_iud_spub' ) then
   create index parent_iud_spub on iud_spub(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'filterfieldgroup' 
  and   index_name   = 'parent_filterfieldgroup' ) then
   create index parent_filterfieldgroup on filterfieldgroup(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'fileterfield' 
  and   index_name   = 'parent_fileterfield' ) then
create index parent_fileterfield on fileterfield(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'filters' 
  and   index_name   = 'parent_filters' ) then
   create index parent_filters on filters(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_int_modules' 
  and   index_name   = 'parent_iu_int_modules' ) then
   create index parent_iu_int_modules on iu_int_modules(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_task' 
  and   index_name   = 'parent_iu_task' ) then
   create index parent_iu_task on iu_task(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_taskattach' 
  and   index_name   = 'parent_iu_taskattach' ) then
   create index parent_iu_taskattach on iu_taskattach(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_taskvideo' 
  and   index_name   = 'parent_iu_taskvideo' ) then
   create index parent_iu_taskvideo on iu_taskvideo(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_taskrefs' 
  and   index_name   = 'parent_iu_taskrefs' ) then
   create index parent_iu_taskrefs on iu_taskrefs(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_l_def' 
  and   index_name   = 'parent_iu_l_def' ) then
   create index parent_iu_l_def on iu_l_def(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_tm_records' 
  and   index_name   = 'parent_iu_tm_records' ) then
   create index parent_iu_tm_records on iu_tm_records(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_tmdef' 
  and   index_name   = 'parent_iu_tmdef' ) then
   create index parent_iu_tmdef on iu_tmdef(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_tmcadr' 
  and   index_name   = 'parent_iu_tmcadr' ) then
   create index parent_iu_tmcadr on iu_tmcadr(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_tm_act' 
  and   index_name   = 'parent_iu_tm_act' ) then
   create index parent_iu_tm_act on iu_tm_act(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_tm_actfile' 
  and   index_name   = 'parent_iu_tm_actfile' ) then
create index parent_iu_tm_actfile on iu_tm_actfile(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_tm_dog' 
  and   index_name   = 'parent_iu_tm_dog' ) then
   create index parent_iu_tm_dog on iu_tm_dog(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'rptstruct' 
  and   index_name   = 'parent_rptstruct' ) then
   create index parent_rptstruct on rptstruct(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'rptfields' 
  and   index_name   = 'parent_rptfields' ) then
create index parent_rptfields on rptfields(parentstructrowid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'rptformula' 
  and   index_name   = 'parent_rptformula' ) then
   create index parent_rptformula on rptformula(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'reports' 
  and   index_name   = 'parent_reports' ) then
   create index parent_reports on reports(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_subsribe' 
  and   index_name   = 'parent_iu_subsribe' ) then
   create index parent_iu_subsribe on iu_subsribe(instanceid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO


drop procedure if exists alter_idx
go
create procedure alter_idx() begin
if not exists (select 1 
  from(information_schema.statistics)
  where(table_schema = database()) 
  and   table_name   = 'iu_subsribe_temp' 
  and   index_name   = 'idx_session_iu_subsribe_temp' ) then
            create index idx_session_iu_subsribe_temp on iu_subsribe_temp (sessionid);
end if;
end 
go
call alter_idx(); 
go

drop procedure if exists alter_idx
go
GO
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--ForeignKey" BlockCode="SET @@foreign_key_checks = 0;
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_stagedef' and 
           constraint_type   = 'foreign key') then
alter table iud_stagedef add constraint fk_4a5cf015c18d4149b965806ff5beb13a foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_adt_doc' and 
           constraint_type   = 'foreign key') then
alter table iud_adt_doc add constraint fk_25ee4b11046c4dd9838883bf488dd604 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_orgtree' and 
           constraint_type   = 'foreign key') then
alter table iu_orgtree add constraint fk_33ee9ea9245e4d2b90f925dc9cf2890c foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_orgusr' and 
           constraint_type   = 'foreign key') then
        alter table iu_orgusr add constraint fk_45a184446a254d9b9c8b6f36242e0240 foreign key(parentstructrowid) references iu_orgtree (iu_orgtreeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_u_def' and 
           constraint_type   = 'foreign key') then
alter table iu_u_def add constraint fk_a63cbdcf3ddd4164949752fe925b2a13 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_u_def_temp' and 
           constraint_type   = 'foreign key') then
        alter table iu_u_def_temp add constraint fk_a63cbdcf3ddd4164949752fe925b2a13_temp foreign key(sessionid) references the_session ( the_sessionid )   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_process_def' and 
           constraint_type   = 'foreign key') then
alter table iud_process_def add constraint fk_c1231b6d8f4f4ec38f858a7987466401 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'genpackage' and 
           constraint_type   = 'foreign key') then
alter table genpackage add constraint fk_4612c6057e7247d08a2852cc7bff4c7f foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'generator_target' and 
           constraint_type   = 'foreign key') then
        alter table generator_target add constraint fk_0670efb9512711d58822204c4f4f5020 foreign key(parentstructrowid) references genpackage (genpackageid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'genreference' and 
           constraint_type   = 'foreign key') then
        alter table genreference add constraint fk_673e809bcff64309a52bfe2118ae508e foreign key(parentstructrowid) references generator_target (generator_targetid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'genmanualcode' and 
           constraint_type   = 'foreign key') then
        alter table genmanualcode add constraint fk_766993ca7de64ada82168bddf2b0588e foreign key(parentstructrowid) references generator_target (generator_targetid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'gencontrols' and 
           constraint_type   = 'foreign key') then
        alter table gencontrols add constraint fk_04b31cfb6525474a9f16999870d8eaaf foreign key(parentstructrowid) references generator_target (generator_targetid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'localizeinfo' and 
           constraint_type   = 'foreign key') then
alter table localizeinfo add constraint fk_a57d435a73b34107b22bc18782085c84 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'fieldtype' and 
           constraint_type   = 'foreign key') then
alter table fieldtype add constraint fk_0670efa5512711d58822204c4f4f5020 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'enumitem' and 
           constraint_type   = 'foreign key') then
        alter table enumitem add constraint fk_35f46d2361f8413b924f83792f76e698 foreign key(parentstructrowid) references fieldtype (fieldtypeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'fieldtypemap' and 
           constraint_type   = 'foreign key') then
        alter table fieldtypemap add constraint fk_0670efa6512711d58822204c4f4f5020 foreign key(parentstructrowid) references fieldtype (fieldtypeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'sharedmethod' and 
           constraint_type   = 'foreign key') then
alter table sharedmethod add constraint fk_0670efad512711d58822204c4f4f5020 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'script' and 
           constraint_type   = 'foreign key') then
        alter table script add constraint fk_0670efa3512711d58822204c4f4f5020 foreign key(parentstructrowid) references sharedmethod (sharedmethodid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'parameters' and 
           constraint_type   = 'foreign key') then
        alter table parameters add constraint fk_e598e74ca9de404186fa972e95635600 foreign key(parentstructrowid) references script (scriptid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'objecttype' and 
           constraint_type   = 'foreign key') then
alter table objecttype add constraint fk_0670efaf512711d58822204c4f4f5020 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'objstatus' and 
           constraint_type   = 'foreign key') then
        alter table objstatus add constraint fk_df46c86638f84ef192e25f899d98bd16 foreign key(parentstructrowid) references objecttype (objecttypeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'nextstate' and 
           constraint_type   = 'foreign key') then
        alter table nextstate add constraint fk_11c1a17929b24ddcbdb71eb21d2ff878 foreign key(parentstructrowid) references objstatus (objstatusid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'objectmode' and 
           constraint_type   = 'foreign key') then
        alter table objectmode add constraint fk_1168296da01c45dbb67d76a07f3ff64c foreign key(parentstructrowid) references objecttype (objecttypeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'structrestriction' and 
           constraint_type   = 'foreign key') then
        alter table structrestriction add constraint fk_f448ac333b13489993ee47d3d62962ec foreign key(parentstructrowid) references objectmode (objectmodeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'methodrestriction' and 
           constraint_type   = 'foreign key') then
        alter table methodrestriction add constraint fk_0f7b3070f7094e7d868ccc337e3075d1 foreign key(parentstructrowid) references objectmode (objectmodeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'fieldrestriction' and 
           constraint_type   = 'foreign key') then
        alter table fieldrestriction add constraint fk_24c5119c5dc94aacbb01b8cf8eba998e foreign key(parentstructrowid) references objectmode (objectmodeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'typemenu' and 
           constraint_type   = 'foreign key') then
        alter table typemenu add constraint fk_8776747a743d47b9af1cab00ff81154f foreign key(parentstructrowid) references objecttype (objecttypeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'instancevalidator' and 
           constraint_type   = 'foreign key') then
        alter table instancevalidator add constraint fk_42515bade23340db8f9045dcfce01be6 foreign key(parentstructrowid) references objecttype (objecttypeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'part' and 
           constraint_type   = 'foreign key') then
        alter table part add constraint fk_0670efb1512711d58822204c4f4f5020 foreign key(parentstructrowid) references objecttype (objecttypeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'partmenu' and 
           constraint_type   = 'foreign key') then
        alter table partmenu add constraint fk_548e9e2e89f64822a312101ca4a9fe74 foreign key(parentstructrowid) references part (partid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'partparammap' and 
           constraint_type   = 'foreign key') then
        alter table partparammap add constraint fk_f8be6fca595d4f46acdbfb5838a246ca foreign key(parentstructrowid) references partmenu (partmenuid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'partview' and 
           constraint_type   = 'foreign key') then
        alter table partview add constraint fk_d713b64d4ce8466dbe2b448874dc0469 foreign key(parentstructrowid) references part (partid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'viewcolumn' and 
           constraint_type   = 'foreign key') then
        alter table viewcolumn add constraint fk_3bf43d5e0eb54ddb8efa62df3261a272 foreign key(parentstructrowid) references partview (partviewid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'partview_lnk' and 
           constraint_type   = 'foreign key') then
        alter table partview_lnk add constraint fk_efad7fa2a77c4a30a0e1ff0ffe0e4a61 foreign key(parentstructrowid) references partview (partviewid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'validator' and 
           constraint_type   = 'foreign key') then
        alter table validator add constraint fk_7d323655bad74d12afc2e7ff3613b4a1 foreign key(parentstructrowid) references part (partid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'uniqueconstraint' and 
           constraint_type   = 'foreign key') then
        alter table uniqueconstraint add constraint fk_9caa5c89f1cb4b62b1d0ff2d29a40057 foreign key(parentstructrowid) references part (partid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'constraintfield' and 
           constraint_type   = 'foreign key') then
        alter table constraintfield add constraint fk_c70106b1aa9541738097614495d6ef28 foreign key(parentstructrowid) references uniqueconstraint (uniqueconstraintid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'extenderinterface' and 
           constraint_type   = 'foreign key') then
        alter table extenderinterface add constraint fk_0fefa9963bad4ebba9ad52ac582cd0a7 foreign key(parentstructrowid) references part (partid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'field' and 
           constraint_type   = 'foreign key') then
        alter table field add constraint fk_0670efa4512711d58822204c4f4f5020 foreign key(parentstructrowid) references part (partid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'fldextenders' and 
           constraint_type   = 'foreign key') then
        alter table fldextenders add constraint fk_5d0b0e1a80364b12b08160139558b594 foreign key(parentstructrowid) references field (fieldid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'fieldsrcdef' and 
           constraint_type   = 'foreign key') then
        alter table fieldsrcdef add constraint fk_d3f1af81912c4948a87ddf549ee796e2 foreign key(parentstructrowid) references field (fieldid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'dinamicfilterscript' and 
           constraint_type   = 'foreign key') then
        alter table dinamicfilterscript add constraint fk_23e26182cc8442d6b7a2d8da0026ebee foreign key(parentstructrowid) references field (fieldid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'fieldexpression' and 
           constraint_type   = 'foreign key') then
        alter table fieldexpression add constraint fk_34b08ed0c4b54b9cba59870a4599f52a foreign key(parentstructrowid) references field (fieldid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'fieldvalidator' and 
           constraint_type   = 'foreign key') then
        alter table fieldvalidator add constraint fk_b40bbed584c54b0b8679172aa1acdad9 foreign key(parentstructrowid) references field (fieldid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'fieldmenu' and 
           constraint_type   = 'foreign key') then
        alter table fieldmenu add constraint fk_4189c3e471c2423da56f4e71cb91b52d foreign key(parentstructrowid) references field (fieldid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'fieldparammap' and 
           constraint_type   = 'foreign key') then
        alter table fieldparammap add constraint fk_54752ae806b04ec68daa692e52a0d36c foreign key(parentstructrowid) references fieldmenu (fieldmenuid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'mtzapp' and 
           constraint_type   = 'foreign key') then
alter table mtzapp add constraint fk_8cdbe0c259894210bdfb33c2c45f2509 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'parentpackage' and 
           constraint_type   = 'foreign key') then
        alter table parentpackage add constraint fk_6ea00756b9804d23b209202389953a13 foreign key(parentstructrowid) references mtzapp (mtzappid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'journalcolumn' and 
           constraint_type   = 'foreign key') then
alter table journalcolumn add constraint fk_f8d77b31a757488cbb5822700737d4b8 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'jcolumnsource' and 
           constraint_type   = 'foreign key') then
        alter table jcolumnsource add constraint fk_8d8c85ebd15e45d7b13b0b4001eb9ac2 foreign key(parentstructrowid) references journalcolumn (journalcolumnid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'journalsrc' and 
           constraint_type   = 'foreign key') then
alter table journalsrc add constraint fk_dac3244d70d645a4885dd610f748ebfc foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'journal' and 
           constraint_type   = 'foreign key') then
alter table journal add constraint fk_34c46c6e921547468d9d4800b6549003 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_urok_sn' and 
           constraint_type   = 'foreign key') then
alter table iu_urok_sn add constraint fk_6d63391d1de74b2da54b5981914e68da foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_urok_msg' and 
           constraint_type   = 'foreign key') then
alter table iu_urok_msg add constraint fk_22285e86383144cf80eae4fee08098fa foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_urok_graph' and 
           constraint_type   = 'foreign key') then
alter table iu_urok_graph add constraint fk_bfae498ea0c44ed58fdb09c5b9c0b404 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_urok_prc' and 
           constraint_type   = 'foreign key') then
alter table iu_urok_prc add constraint fk_fc2587961ed64e78948a52d8c8979d62 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'folder' and 
           constraint_type   = 'foreign key') then
alter table folder add constraint fk_b0c4bc9ce2414a7b9cace221da31df89 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'shortcut' and 
           constraint_type   = 'foreign key') then
        alter table shortcut add constraint fk_f434820031d14c14b1881cfe15547265 foreign key(parentstructrowid) references folder (folderid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'infostoredef' and 
           constraint_type   = 'foreign key') then
alter table infostoredef add constraint fk_645ccaf405194b069325b7f2edfe46bd foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_rt_def' and 
           constraint_type   = 'foreign key') then
alter table iud_rt_def add constraint fk_9d0bf818caa342c9b5803b3a57aa5cef foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'the_session' and 
           constraint_type   = 'foreign key') then
alter table the_session add constraint fk_78943ea279364f58b31676e4f968e3b4 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'sysrefcache' and 
           constraint_type   = 'foreign key') then
alter table sysrefcache add constraint fk_35d224df283041549e80ff578aab323c foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'syslog' and 
           constraint_type   = 'foreign key') then
alter table syslog add constraint fk_45eadae898374ee59a3107370302f20f foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'armjournal' and 
           constraint_type   = 'foreign key') then
alter table armjournal add constraint fk_c41c0e058cf34b439d6ec5fcd37beb47 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'armjrnlrep' and 
           constraint_type   = 'foreign key') then
        alter table armjrnlrep add constraint fk_c2763400be344033b4b5756cd5252cea foreign key(parentstructrowid) references armjournal (armjournalid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'armjrnlrun' and 
           constraint_type   = 'foreign key') then
        alter table armjrnlrun add constraint fk_4fe8318100a54b599413d06318a119d4 foreign key(parentstructrowid) references armjournal (armjournalid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'armjrnladd' and 
           constraint_type   = 'foreign key') then
        alter table armjrnladd add constraint fk_f837abedcae9430a9dee519dbb1b79d5 foreign key(parentstructrowid) references armjournal (armjournalid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'entrypoints' and 
           constraint_type   = 'foreign key') then
alter table entrypoints add constraint fk_ef4ede2c458b4eabafe366aa500081da foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'epfilterlink' and 
           constraint_type   = 'foreign key') then
        alter table epfilterlink add constraint fk_d407359f220449699789956215e456e6 foreign key(parentstructrowid) references entrypoints (entrypointsid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'workplace' and 
           constraint_type   = 'foreign key') then
alter table workplace add constraint fk_973921c449264c9da7816062cf81b5ad foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'armtypes' and 
           constraint_type   = 'foreign key') then
alter table armtypes add constraint fk_30f737ce1c814672b0f96e5bf4b15971 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_crole' and 
           constraint_type   = 'foreign key') then
alter table iu_crole add constraint fk_2ea051107dd64b91b774af6ecbc42108 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles_operations' and 
           constraint_type   = 'foreign key') then
alter table roles_operations add constraint fk_32752313ed5d4137a27a7993c1198ab2 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles_wp' and 
           constraint_type   = 'foreign key') then
alter table roles_wp add constraint fk_2e3da519a8bf44b3879b8e676ad5c902 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles_act' and 
           constraint_type   = 'foreign key') then
        alter table roles_act add constraint fk_7f784c67aa8944e98020c6303671a273 foreign key(parentstructrowid) references roles_wp (roles_wpid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles2_module' and 
           constraint_type   = 'foreign key') then
alter table roles2_module add constraint fk_43661530f8a54873a9057b5072cc455d foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles2_modreport' and 
           constraint_type   = 'foreign key') then
        alter table roles2_modreport add constraint fk_974acd4cecf0478387b31cb80c8adf96 foreign key(parentstructrowid) references roles2_module (roles2_moduleid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles_doc' and 
           constraint_type   = 'foreign key') then
alter table roles_doc add constraint fk_2936c942839f4a43a2af4989ea1e7007 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles_doc_state' and 
           constraint_type   = 'foreign key') then
        alter table roles_doc_state add constraint fk_545e45954cc6489e8cf1b02ad530fc76 foreign key(parentstructrowid) references roles_doc (roles_docid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles_reports' and 
           constraint_type   = 'foreign key') then
alter table roles_reports add constraint fk_029e3f5168214852a64b76f7c8351436 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles_user' and 
           constraint_type   = 'foreign key') then
alter table roles_user add constraint fk_5b22a65e6913486bb08d0ac46649124d foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles_map' and 
           constraint_type   = 'foreign key') then
alter table roles_map add constraint fk_a3568985dc4540e28f0d142287bcb315 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'roles_def' and 
           constraint_type   = 'foreign key') then
alter table roles_def add constraint fk_c85f828b377d4b59bb78656d420101e8 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_urok_docs' and 
           constraint_type   = 'foreign key') then
alter table iu_urok_docs add constraint fk_d5c16c3393c0416ba46abb2071b93ce2 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_urok_creators' and 
           constraint_type   = 'foreign key') then
alter table iu_urok_creators add constraint fk_4732bb36d7bf49ed81da2ca4694092d6 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_urok_def' and 
           constraint_type   = 'foreign key') then
alter table iu_urok_def add constraint fk_7de05f64d0ee4d49b7f90240396b8de1 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_urok_video' and 
           constraint_type   = 'foreign key') then
alter table iu_urok_video add constraint fk_1d76f9a76bd448a7ad210c7c073637d5 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_mt_def' and 
           constraint_type   = 'foreign key') then
alter table iud_mt_def add constraint fk_08f4a43d696742df8e24bc466e365bff foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_sn_def' and 
           constraint_type   = 'foreign key') then
alter table iud_sn_def add constraint fk_c7968b05317a452390933abf9b3e7ea5 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_filestoretype' and 
           constraint_type   = 'foreign key') then
alter table iud_filestoretype add constraint fk_0cd762943dea4e989bfde9c58eeaea38 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_predmet' and 
           constraint_type   = 'foreign key') then
alter table iud_predmet add constraint fk_8dcaab28d13f40c58da4a2ad035b3c37 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_doctype' and 
           constraint_type   = 'foreign key') then
alter table iud_doctype add constraint fk_89714b3a26b541fd8832f69ed2ed1441 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'users' and 
           constraint_type   = 'foreign key') then
alter table users add constraint fk_148bb85509654e9ea3d648dcc8ce528b foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'groups' and 
           constraint_type   = 'foreign key') then
alter table groups add constraint fk_a40e6aee7b41476d923caca251c08e87 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'groupuser' and 
           constraint_type   = 'foreign key') then
        alter table groupuser add constraint fk_fe2c9352e29a420b91343e3bdd832a6e foreign key(parentstructrowid) references groups (groupsid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_clsinfo' and 
           constraint_type   = 'foreign key') then
alter table iu_clsinfo add constraint fk_c9db95b0c57f4b14b6fdf61494193844 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'num_zones' and 
           constraint_type   = 'foreign key') then
alter table num_zones add constraint fk_59512432e6df41f9a4366bf7db1800bb foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'num_values' and 
           constraint_type   = 'foreign key') then
        alter table num_values add constraint fk_833dc00be8d74d9191032dd084befc1e foreign key(parentstructrowid) references num_zones (num_zonesid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'num_head' and 
           constraint_type   = 'foreign key') then
alter table num_head add constraint fk_c436bed9294e48a78c376d4cf32343be foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_filetype' and 
           constraint_type   = 'foreign key') then
alter table iud_filetype add constraint fk_d63be57189cd4e6894eb15551326bac7 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'mtzext_def' and 
           constraint_type   = 'foreign key') then
alter table mtzext_def add constraint fk_7f62144a857648bcacba1f9dc4874459 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'mtzextrel' and 
           constraint_type   = 'foreign key') then
alter table mtzextrel add constraint fk_e48fe6dd79f94d42bac3cb39f69171bc foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_videotype' and 
           constraint_type   = 'foreign key') then
alter table iud_videotype add constraint fk_25e15f057cbd405db6a94e16244ac9b4 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_cm_def' and 
           constraint_type   = 'foreign key') then
alter table iu_cm_def add constraint fk_b8b2d96830fc408c9f3cd72b281024c5 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_cm_time' and 
           constraint_type   = 'foreign key') then
alter table iu_cm_time add constraint fk_051bfe8ece9045b88f6adb8b7d8a131e foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_cm_msg' and 
           constraint_type   = 'foreign key') then
alter table iu_cm_msg add constraint fk_ec9af1b07c28454781bd19df49ec1ad7 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_plevent' and 
           constraint_type   = 'foreign key') then
alter table iu_plevent add constraint fk_b70f46c19b334e018c341775e8aada14 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_rcfg_mod' and 
           constraint_type   = 'foreign key') then
alter table iu_rcfg_mod add constraint fk_fa0e39846b7c45c8aecfe2fc7ecb622b foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_rcfg_docmode' and 
           constraint_type   = 'foreign key') then
alter table iu_rcfg_docmode add constraint fk_cf7ed0a3642c4b10834721d86bfecbc4 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_rcfg_def' and 
           constraint_type   = 'foreign key') then
alter table iu_rcfg_def add constraint fk_10f3c6e757424731b94c647263e4e304 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_town' and 
           constraint_type   = 'foreign key') then
alter table iud_town add constraint fk_96cd9cc7242445959828ccb2ab52c3b6 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_regtree' and 
           constraint_type   = 'foreign key') then
alter table iu_regtree add constraint fk_5614525b9a7d41a4ada41c3305c9b2a0 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_regdocs' and 
           constraint_type   = 'foreign key') then
        alter table iu_regdocs add constraint fk_d5b6c31a1e76442d9e75b3511755500c foreign key(parentstructrowid) references iu_regtree (iu_regtreeid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_status' and 
           constraint_type   = 'foreign key') then
alter table iu_status add constraint fk_1e177f938ed745049ad934beae925c38 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_status_doer' and 
           constraint_type   = 'foreign key') then
alter table iu_status_doer add constraint fk_028f57a11ce84f72a760193d394eda82 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_statustask' and 
           constraint_type   = 'foreign key') then
alter table iu_statustask add constraint fk_f22aa6a9900349d6b6fa8ba913cafb07 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_state_tasklink' and 
           constraint_type   = 'foreign key') then
        alter table iu_state_tasklink add constraint fk_9500b06b972e49bf8873e3f6d6a509c1 foreign key(parentstructrowid) references iu_statustask (iu_statustaskid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_stausdoc' and 
           constraint_type   = 'foreign key') then
alter table iu_stausdoc add constraint fk_128f82c2d94f46b282b796fb4071ef1b foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_statusnext' and 
           constraint_type   = 'foreign key') then
alter table iu_statusnext add constraint fk_28d4d8e44e12485fa47716c5b4f5b14e foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_statuschanger' and 
           constraint_type   = 'foreign key') then
        alter table iu_statuschanger add constraint fk_bea3e5f263c54b1384fdbca06983129c foreign key(parentstructrowid) references iu_statusnext (iu_statusnextid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'mtz2job_def' and 
           constraint_type   = 'foreign key') then
alter table mtz2job_def add constraint fk_242a72ab18ee49ccbf1b8e554ad3aa57 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_ctype' and 
           constraint_type   = 'foreign key') then
alter table iud_ctype add constraint fk_b4bc2e0a141748f1be62c345b9f1c57a foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iud_spub' and 
           constraint_type   = 'foreign key') then
alter table iud_spub add constraint fk_db098a5ebc664a6da7003d9028419537 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'filterfieldgroup' and 
           constraint_type   = 'foreign key') then
alter table filterfieldgroup add constraint fk_98c6d923b807418c91e7c351511b5eb1 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'fileterfield' and 
           constraint_type   = 'foreign key') then
        alter table fileterfield add constraint fk_f4b3740ce6764b6ea833ede44cb9fa63 foreign key(parentstructrowid) references filterfieldgroup (filterfieldgroupid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'filters' and 
           constraint_type   = 'foreign key') then
alter table filters add constraint fk_b75ad7246b6f45bdb0bbc75d17309dc9 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_int_modules' and 
           constraint_type   = 'foreign key') then
alter table iu_int_modules add constraint fk_dba8d884728647828b286af8916220b6 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_task' and 
           constraint_type   = 'foreign key') then
alter table iu_task add constraint fk_8cbf857dd1d04a62a21b11251d8218b0 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_taskattach' and 
           constraint_type   = 'foreign key') then
alter table iu_taskattach add constraint fk_3e206fa6bce949b2ba0f11df4c959a78 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_taskvideo' and 
           constraint_type   = 'foreign key') then
alter table iu_taskvideo add constraint fk_0fda5bb2dee14bb28e6fb5522dff03d3 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_taskrefs' and 
           constraint_type   = 'foreign key') then
alter table iu_taskrefs add constraint fk_a31371cac8b34e2f938d7826747f81a9 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_l_def' and 
           constraint_type   = 'foreign key') then
alter table iu_l_def add constraint fk_10d24cf4407f4072bfab6ce9e9d3ef54 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_tm_records' and 
           constraint_type   = 'foreign key') then
alter table iu_tm_records add constraint fk_2af3191317d741bc98bdf98df78a9a83 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_tmdef' and 
           constraint_type   = 'foreign key') then
alter table iu_tmdef add constraint fk_7afce71a0b0c46529680b6520fe4d2c4 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_tmcadr' and 
           constraint_type   = 'foreign key') then
alter table iu_tmcadr add constraint fk_f28dff1ee5bd404ab0acff34e73f0422 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_tm_act' and 
           constraint_type   = 'foreign key') then
alter table iu_tm_act add constraint fk_7a006e22da014976838c973e57c396be foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_tm_actfile' and 
           constraint_type   = 'foreign key') then
        alter table iu_tm_actfile add constraint fk_1478ce3bb4cb45f9b192a245f7f7d240 foreign key(parentstructrowid) references iu_tm_act (iu_tm_actid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_tm_dog' and 
           constraint_type   = 'foreign key') then
alter table iu_tm_dog add constraint fk_421de59a23fb4e1981a0b9b85ab6cecb foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'rptstruct' and 
           constraint_type   = 'foreign key') then
alter table rptstruct add constraint fk_f5e8492a2224452f85ffa14882c6554f foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'rptfields' and 
           constraint_type   = 'foreign key') then
        alter table rptfields add constraint fk_0c77d0de559e43fcb181156e126543f1 foreign key(parentstructrowid) references rptstruct (rptstructid)   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'rptformula' and 
           constraint_type   = 'foreign key') then
alter table rptformula add constraint fk_e422132e07f44c0f8246b0f16cd9186a foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'reports' and 
           constraint_type   = 'foreign key') then
alter table reports add constraint fk_259b3dfab8ac417888fd4b715d372fc3 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_subsribe' and 
           constraint_type   = 'foreign key') then
alter table iu_subsribe add constraint fk_7a65459f871d4a3b92ed2af49a135ea7 foreign key(instanceid) references instance (instanceid) on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO


drop procedure if exists alter_fk
go
create procedure alter_fk() begin
if not exists (select 1 from information_schema.table_constraints where
           constraint_schema = database() and
           table_name   = 'iu_subsribe_temp' and 
           constraint_type   = 'foreign key') then
        alter table iu_subsribe_temp add constraint fk_7a65459f871d4a3b92ed2af49a135ea7_temp foreign key(sessionid) references the_session ( the_sessionid )   on delete cascade;
end if;
end 
go
call alter_fk(); 
go

drop procedure if exists alter_fk
go
GO
SET @@foreign_key_checks = 1;
GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--FunctionsHeader" File="">
    <BlockHolder BlockName="--TableProc" BlockCode=" 


drop function IF EXISTS INSTANCE_MREF_F
GO

create function INSTANCE_MREF_F  (
 aINSTANCE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  
DETERMINISTIC
 begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function if exists instance_brief_f
go
  create function instance_brief_f  (
 ainstanceid varchar(38)
 ,alang varchar(25)
)returns varchar(255) deterministic begin
 declare abrief varchar(255);
  set abrief=' to do';
  return abrief;
end
go


drop function IF EXISTS INSTANCE_MREF_F
GO

create function INSTANCE_MREF_F  (
 aINSTANCE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  
DETERMINISTIC
 begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_stagedef_BRIEF_F
GO

create function iud_stagedef_BRIEF_F  (
 aiud_stagedefid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_stagedef_MREF_F
GO
create function iud_stagedef_MREF_F  (
 aiud_stagedef_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_adt_doc_BRIEF_F
GO

create function iud_adt_doc_BRIEF_F  (
 aiud_adt_docid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_adt_doc_MREF_F
GO
create function iud_adt_doc_MREF_F  (
 aiud_adt_doc_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_orgtree_BRIEF_F
GO

create function iu_orgtree_BRIEF_F  (
 aiu_orgtreeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_orgtree_MREF_F
GO
create function iu_orgtree_MREF_F  (
 aiu_orgtree_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_orgusr_BRIEF_F
GO

create function iu_orgusr_BRIEF_F  (
 aiu_orgusrid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_orgusr_MREF_F
GO
create function iu_orgusr_MREF_F  (
 aiu_orgusr_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_u_def_BRIEF_F
GO

create function iu_u_def_BRIEF_F  (
 aiu_u_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_u_def_MREF_F
GO
create function iu_u_def_MREF_F  (
 aiu_u_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_process_def_BRIEF_F
GO

create function iud_process_def_BRIEF_F  (
 aiud_process_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_process_def_MREF_F
GO
create function iud_process_def_MREF_F  (
 aiud_process_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS GENPACKAGE_BRIEF_F
GO

create function GENPACKAGE_BRIEF_F  (
 aGENPACKAGEid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS GENPACKAGE_MREF_F
GO
create function GENPACKAGE_MREF_F  (
 aGENPACKAGE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS GENERATOR_TARGET_BRIEF_F
GO

create function GENERATOR_TARGET_BRIEF_F  (
 aGENERATOR_TARGETid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS GENERATOR_TARGET_MREF_F
GO
create function GENERATOR_TARGET_MREF_F  (
 aGENERATOR_TARGET_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS GENREFERENCE_BRIEF_F
GO

create function GENREFERENCE_BRIEF_F  (
 aGENREFERENCEid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS GENREFERENCE_MREF_F
GO
create function GENREFERENCE_MREF_F  (
 aGENREFERENCE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS GENMANUALCODE_BRIEF_F
GO

create function GENMANUALCODE_BRIEF_F  (
 aGENMANUALCODEid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS GENMANUALCODE_MREF_F
GO
create function GENMANUALCODE_MREF_F  (
 aGENMANUALCODE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS GENCONTROLS_BRIEF_F
GO

create function GENCONTROLS_BRIEF_F  (
 aGENCONTROLSid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS GENCONTROLS_MREF_F
GO
create function GENCONTROLS_MREF_F  (
 aGENCONTROLS_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS LocalizeInfo_BRIEF_F
GO

create function LocalizeInfo_BRIEF_F  (
 aLocalizeInfoid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS LocalizeInfo_MREF_F
GO
create function LocalizeInfo_MREF_F  (
 aLocalizeInfo_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FIELDTYPE_BRIEF_F
GO

create function FIELDTYPE_BRIEF_F  (
 aFIELDTYPEid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FIELDTYPE_MREF_F
GO
create function FIELDTYPE_MREF_F  (
 aFIELDTYPE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ENUMITEM_BRIEF_F
GO

create function ENUMITEM_BRIEF_F  (
 aENUMITEMid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ENUMITEM_MREF_F
GO
create function ENUMITEM_MREF_F  (
 aENUMITEM_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FIELDTYPEMAP_BRIEF_F
GO

create function FIELDTYPEMAP_BRIEF_F  (
 aFIELDTYPEMAPid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FIELDTYPEMAP_MREF_F
GO
create function FIELDTYPEMAP_MREF_F  (
 aFIELDTYPEMAP_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS SHAREDMETHOD_BRIEF_F
GO

create function SHAREDMETHOD_BRIEF_F  (
 aSHAREDMETHODid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS SHAREDMETHOD_MREF_F
GO
create function SHAREDMETHOD_MREF_F  (
 aSHAREDMETHOD_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS SCRIPT_BRIEF_F
GO

create function SCRIPT_BRIEF_F  (
 aSCRIPTid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS SCRIPT_MREF_F
GO
create function SCRIPT_MREF_F  (
 aSCRIPT_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS PARAMETERS_BRIEF_F
GO

create function PARAMETERS_BRIEF_F  (
 aPARAMETERSid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS PARAMETERS_MREF_F
GO
create function PARAMETERS_MREF_F  (
 aPARAMETERS_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS OBJECTTYPE_BRIEF_F
GO

create function OBJECTTYPE_BRIEF_F  (
 aOBJECTTYPEid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS OBJECTTYPE_MREF_F
GO
create function OBJECTTYPE_MREF_F  (
 aOBJECTTYPE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS OBJSTATUS_BRIEF_F
GO

create function OBJSTATUS_BRIEF_F  (
 aOBJSTATUSid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS OBJSTATUS_MREF_F
GO
create function OBJSTATUS_MREF_F  (
 aOBJSTATUS_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS NEXTSTATE_BRIEF_F
GO

create function NEXTSTATE_BRIEF_F  (
 aNEXTSTATEid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS NEXTSTATE_MREF_F
GO
create function NEXTSTATE_MREF_F  (
 aNEXTSTATE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS OBJECTMODE_BRIEF_F
GO

create function OBJECTMODE_BRIEF_F  (
 aOBJECTMODEid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS OBJECTMODE_MREF_F
GO
create function OBJECTMODE_MREF_F  (
 aOBJECTMODE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS STRUCTRESTRICTION_BRIEF_F
GO

create function STRUCTRESTRICTION_BRIEF_F  (
 aSTRUCTRESTRICTIONid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS STRUCTRESTRICTION_MREF_F
GO
create function STRUCTRESTRICTION_MREF_F  (
 aSTRUCTRESTRICTION_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS METHODRESTRICTION_BRIEF_F
GO

create function METHODRESTRICTION_BRIEF_F  (
 aMETHODRESTRICTIONid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS METHODRESTRICTION_MREF_F
GO
create function METHODRESTRICTION_MREF_F  (
 aMETHODRESTRICTION_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FIELDRESTRICTION_BRIEF_F
GO

create function FIELDRESTRICTION_BRIEF_F  (
 aFIELDRESTRICTIONid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FIELDRESTRICTION_MREF_F
GO
create function FIELDRESTRICTION_MREF_F  (
 aFIELDRESTRICTION_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS TYPEMENU_BRIEF_F
GO

create function TYPEMENU_BRIEF_F  (
 aTYPEMENUid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS TYPEMENU_MREF_F
GO
create function TYPEMENU_MREF_F  (
 aTYPEMENU_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS INSTANCEVALIDATOR_BRIEF_F
GO

create function INSTANCEVALIDATOR_BRIEF_F  (
 aINSTANCEVALIDATORid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS INSTANCEVALIDATOR_MREF_F
GO
create function INSTANCEVALIDATOR_MREF_F  (
 aINSTANCEVALIDATOR_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS PART_BRIEF_F
GO

create function PART_BRIEF_F  (
 aPARTid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS PART_MREF_F
GO
create function PART_MREF_F  (
 aPART_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS PARTMENU_BRIEF_F
GO

create function PARTMENU_BRIEF_F  (
 aPARTMENUid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS PARTMENU_MREF_F
GO
create function PARTMENU_MREF_F  (
 aPARTMENU_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS PARTPARAMMAP_BRIEF_F
GO

create function PARTPARAMMAP_BRIEF_F  (
 aPARTPARAMMAPid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS PARTPARAMMAP_MREF_F
GO
create function PARTPARAMMAP_MREF_F  (
 aPARTPARAMMAP_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS PARTVIEW_BRIEF_F
GO

create function PARTVIEW_BRIEF_F  (
 aPARTVIEWid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS PARTVIEW_MREF_F
GO
create function PARTVIEW_MREF_F  (
 aPARTVIEW_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ViewColumn_BRIEF_F
GO

create function ViewColumn_BRIEF_F  (
 aViewColumnid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ViewColumn_MREF_F
GO
create function ViewColumn_MREF_F  (
 aViewColumn_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS PARTVIEW_LNK_BRIEF_F
GO

create function PARTVIEW_LNK_BRIEF_F  (
 aPARTVIEW_LNKid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS PARTVIEW_LNK_MREF_F
GO
create function PARTVIEW_LNK_MREF_F  (
 aPARTVIEW_LNK_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS VALIDATOR_BRIEF_F
GO

create function VALIDATOR_BRIEF_F  (
 aVALIDATORid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS VALIDATOR_MREF_F
GO
create function VALIDATOR_MREF_F  (
 aVALIDATOR_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS UNIQUECONSTRAINT_BRIEF_F
GO

create function UNIQUECONSTRAINT_BRIEF_F  (
 aUNIQUECONSTRAINTid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS UNIQUECONSTRAINT_MREF_F
GO
create function UNIQUECONSTRAINT_MREF_F  (
 aUNIQUECONSTRAINT_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS CONSTRAINTFIELD_BRIEF_F
GO

create function CONSTRAINTFIELD_BRIEF_F  (
 aCONSTRAINTFIELDid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS CONSTRAINTFIELD_MREF_F
GO
create function CONSTRAINTFIELD_MREF_F  (
 aCONSTRAINTFIELD_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ExtenderInterface_BRIEF_F
GO

create function ExtenderInterface_BRIEF_F  (
 aExtenderInterfaceid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ExtenderInterface_MREF_F
GO
create function ExtenderInterface_MREF_F  (
 aExtenderInterface_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FIELD_BRIEF_F
GO

create function FIELD_BRIEF_F  (
 aFIELDid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FIELD_MREF_F
GO
create function FIELD_MREF_F  (
 aFIELD_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FldExtenders_BRIEF_F
GO

create function FldExtenders_BRIEF_F  (
 aFldExtendersid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FldExtenders_MREF_F
GO
create function FldExtenders_MREF_F  (
 aFldExtenders_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FIELDSRCDEF_BRIEF_F
GO

create function FIELDSRCDEF_BRIEF_F  (
 aFIELDSRCDEFid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FIELDSRCDEF_MREF_F
GO
create function FIELDSRCDEF_MREF_F  (
 aFIELDSRCDEF_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS DINAMICFILTERSCRIPT_BRIEF_F
GO

create function DINAMICFILTERSCRIPT_BRIEF_F  (
 aDINAMICFILTERSCRIPTid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS DINAMICFILTERSCRIPT_MREF_F
GO
create function DINAMICFILTERSCRIPT_MREF_F  (
 aDINAMICFILTERSCRIPT_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FIELDEXPRESSION_BRIEF_F
GO

create function FIELDEXPRESSION_BRIEF_F  (
 aFIELDEXPRESSIONid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FIELDEXPRESSION_MREF_F
GO
create function FIELDEXPRESSION_MREF_F  (
 aFIELDEXPRESSION_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FIELDVALIDATOR_BRIEF_F
GO

create function FIELDVALIDATOR_BRIEF_F  (
 aFIELDVALIDATORid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FIELDVALIDATOR_MREF_F
GO
create function FIELDVALIDATOR_MREF_F  (
 aFIELDVALIDATOR_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FIELDMENU_BRIEF_F
GO

create function FIELDMENU_BRIEF_F  (
 aFIELDMENUid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FIELDMENU_MREF_F
GO
create function FIELDMENU_MREF_F  (
 aFIELDMENU_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FIELDPARAMMAP_BRIEF_F
GO

create function FIELDPARAMMAP_BRIEF_F  (
 aFIELDPARAMMAPid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FIELDPARAMMAP_MREF_F
GO
create function FIELDPARAMMAP_MREF_F  (
 aFIELDPARAMMAP_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS MTZAPP_BRIEF_F
GO

create function MTZAPP_BRIEF_F  (
 aMTZAPPid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS MTZAPP_MREF_F
GO
create function MTZAPP_MREF_F  (
 aMTZAPP_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ParentPackage_BRIEF_F
GO

create function ParentPackage_BRIEF_F  (
 aParentPackageid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ParentPackage_MREF_F
GO
create function ParentPackage_MREF_F  (
 aParentPackage_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS JournalColumn_BRIEF_F
GO

create function JournalColumn_BRIEF_F  (
 aJournalColumnid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS JournalColumn_MREF_F
GO
create function JournalColumn_MREF_F  (
 aJournalColumn_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS JColumnSource_BRIEF_F
GO

create function JColumnSource_BRIEF_F  (
 aJColumnSourceid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS JColumnSource_MREF_F
GO
create function JColumnSource_MREF_F  (
 aJColumnSource_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS JournalSrc_BRIEF_F
GO

create function JournalSrc_BRIEF_F  (
 aJournalSrcid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS JournalSrc_MREF_F
GO
create function JournalSrc_MREF_F  (
 aJournalSrc_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Journal_BRIEF_F
GO

create function Journal_BRIEF_F  (
 aJournalid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Journal_MREF_F
GO
create function Journal_MREF_F  (
 aJournal_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_urok_sn_BRIEF_F
GO

create function iu_urok_sn_BRIEF_F  (
 aiu_urok_snid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_urok_sn_MREF_F
GO
create function iu_urok_sn_MREF_F  (
 aiu_urok_sn_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_urok_msg_BRIEF_F
GO

create function iu_urok_msg_BRIEF_F  (
 aiu_urok_msgid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_urok_msg_MREF_F
GO
create function iu_urok_msg_MREF_F  (
 aiu_urok_msg_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_urok_graph_BRIEF_F
GO

create function iu_urok_graph_BRIEF_F  (
 aiu_urok_graphid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_urok_graph_MREF_F
GO
create function iu_urok_graph_MREF_F  (
 aiu_urok_graph_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_urok_prc_BRIEF_F
GO

create function iu_urok_prc_BRIEF_F  (
 aiu_urok_prcid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_urok_prc_MREF_F
GO
create function iu_urok_prc_MREF_F  (
 aiu_urok_prc_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Folder_BRIEF_F
GO

create function Folder_BRIEF_F  (
 aFolderid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Folder_MREF_F
GO
create function Folder_MREF_F  (
 aFolder_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Shortcut_BRIEF_F
GO

create function Shortcut_BRIEF_F  (
 aShortcutid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Shortcut_MREF_F
GO
create function Shortcut_MREF_F  (
 aShortcut_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS InfoStoreDef_BRIEF_F
GO

create function InfoStoreDef_BRIEF_F  (
 aInfoStoreDefid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS InfoStoreDef_MREF_F
GO
create function InfoStoreDef_MREF_F  (
 aInfoStoreDef_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_rt_def_BRIEF_F
GO

create function iud_rt_def_BRIEF_F  (
 aiud_rt_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_rt_def_MREF_F
GO
create function iud_rt_def_MREF_F  (
 aiud_rt_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS the_Session_BRIEF_F
GO

create function the_Session_BRIEF_F  (
 athe_Sessionid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS the_Session_MREF_F
GO
create function the_Session_MREF_F  (
 athe_Session_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS SysRefCache_BRIEF_F
GO

create function SysRefCache_BRIEF_F  (
 aSysRefCacheid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS SysRefCache_MREF_F
GO
create function SysRefCache_MREF_F  (
 aSysRefCache_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS SysLog_BRIEF_F
GO

create function SysLog_BRIEF_F  (
 aSysLogid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS SysLog_MREF_F
GO
create function SysLog_MREF_F  (
 aSysLog_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ARMJournal_BRIEF_F
GO

create function ARMJournal_BRIEF_F  (
 aARMJournalid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ARMJournal_MREF_F
GO
create function ARMJournal_MREF_F  (
 aARMJournal_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ARMJRNLREP_BRIEF_F
GO

create function ARMJRNLREP_BRIEF_F  (
 aARMJRNLREPid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ARMJRNLREP_MREF_F
GO
create function ARMJRNLREP_MREF_F  (
 aARMJRNLREP_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ARMJRNLRUN_BRIEF_F
GO

create function ARMJRNLRUN_BRIEF_F  (
 aARMJRNLRUNid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ARMJRNLRUN_MREF_F
GO
create function ARMJRNLRUN_MREF_F  (
 aARMJRNLRUN_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ARMJRNLADD_BRIEF_F
GO

create function ARMJRNLADD_BRIEF_F  (
 aARMJRNLADDid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ARMJRNLADD_MREF_F
GO
create function ARMJRNLADD_MREF_F  (
 aARMJRNLADD_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS EntryPoints_BRIEF_F
GO

create function EntryPoints_BRIEF_F  (
 aEntryPointsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS EntryPoints_MREF_F
GO
create function EntryPoints_MREF_F  (
 aEntryPoints_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS EPFilterLink_BRIEF_F
GO

create function EPFilterLink_BRIEF_F  (
 aEPFilterLinkid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS EPFilterLink_MREF_F
GO
create function EPFilterLink_MREF_F  (
 aEPFilterLink_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS WorkPlace_BRIEF_F
GO

create function WorkPlace_BRIEF_F  (
 aWorkPlaceid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS WorkPlace_MREF_F
GO
create function WorkPlace_MREF_F  (
 aWorkPlace_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ARMTypes_BRIEF_F
GO

create function ARMTypes_BRIEF_F  (
 aARMTypesid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ARMTypes_MREF_F
GO
create function ARMTypes_MREF_F  (
 aARMTypes_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_crole_BRIEF_F
GO

create function iu_crole_BRIEF_F  (
 aiu_croleid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_crole_MREF_F
GO
create function iu_crole_MREF_F  (
 aiu_crole_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES_OPERATIONS_BRIEF_F
GO

create function ROLES_OPERATIONS_BRIEF_F  (
 aROLES_OPERATIONSid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES_OPERATIONS_MREF_F
GO
create function ROLES_OPERATIONS_MREF_F  (
 aROLES_OPERATIONS_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES_WP_BRIEF_F
GO

create function ROLES_WP_BRIEF_F  (
 aROLES_WPid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES_WP_MREF_F
GO
create function ROLES_WP_MREF_F  (
 aROLES_WP_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES_ACT_BRIEF_F
GO

create function ROLES_ACT_BRIEF_F  (
 aROLES_ACTid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES_ACT_MREF_F
GO
create function ROLES_ACT_MREF_F  (
 aROLES_ACT_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES2_MODULE_BRIEF_F
GO

create function ROLES2_MODULE_BRIEF_F  (
 aROLES2_MODULEid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES2_MODULE_MREF_F
GO
create function ROLES2_MODULE_MREF_F  (
 aROLES2_MODULE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES2_MODREPORT_BRIEF_F
GO

create function ROLES2_MODREPORT_BRIEF_F  (
 aROLES2_MODREPORTid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES2_MODREPORT_MREF_F
GO
create function ROLES2_MODREPORT_MREF_F  (
 aROLES2_MODREPORT_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES_DOC_BRIEF_F
GO

create function ROLES_DOC_BRIEF_F  (
 aROLES_DOCid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES_DOC_MREF_F
GO
create function ROLES_DOC_MREF_F  (
 aROLES_DOC_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES_DOC_STATE_BRIEF_F
GO

create function ROLES_DOC_STATE_BRIEF_F  (
 aROLES_DOC_STATEid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES_DOC_STATE_MREF_F
GO
create function ROLES_DOC_STATE_MREF_F  (
 aROLES_DOC_STATE_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES_REPORTS_BRIEF_F
GO

create function ROLES_REPORTS_BRIEF_F  (
 aROLES_REPORTSid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES_REPORTS_MREF_F
GO
create function ROLES_REPORTS_MREF_F  (
 aROLES_REPORTS_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES_USER_BRIEF_F
GO

create function ROLES_USER_BRIEF_F  (
 aROLES_USERid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES_USER_MREF_F
GO
create function ROLES_USER_MREF_F  (
 aROLES_USER_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES_MAP_BRIEF_F
GO

create function ROLES_MAP_BRIEF_F  (
 aROLES_MAPid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES_MAP_MREF_F
GO
create function ROLES_MAP_MREF_F  (
 aROLES_MAP_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS ROLES_DEF_BRIEF_F
GO

create function ROLES_DEF_BRIEF_F  (
 aROLES_DEFid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS ROLES_DEF_MREF_F
GO
create function ROLES_DEF_MREF_F  (
 aROLES_DEF_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_urok_docs_BRIEF_F
GO

create function iu_urok_docs_BRIEF_F  (
 aiu_urok_docsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_urok_docs_MREF_F
GO
create function iu_urok_docs_MREF_F  (
 aiu_urok_docs_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_urok_creators_BRIEF_F
GO

create function iu_urok_creators_BRIEF_F  (
 aiu_urok_creatorsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_urok_creators_MREF_F
GO
create function iu_urok_creators_MREF_F  (
 aiu_urok_creators_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_urok_def_BRIEF_F
GO

create function iu_urok_def_BRIEF_F  (
 aiu_urok_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_urok_def_MREF_F
GO
create function iu_urok_def_MREF_F  (
 aiu_urok_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_urok_video_BRIEF_F
GO

create function iu_urok_video_BRIEF_F  (
 aiu_urok_videoid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_urok_video_MREF_F
GO
create function iu_urok_video_MREF_F  (
 aiu_urok_video_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_mt_def_BRIEF_F
GO

create function iud_mt_def_BRIEF_F  (
 aiud_mt_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_mt_def_MREF_F
GO
create function iud_mt_def_MREF_F  (
 aiud_mt_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_sn_def_BRIEF_F
GO

create function iud_sn_def_BRIEF_F  (
 aiud_sn_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_sn_def_MREF_F
GO
create function iud_sn_def_MREF_F  (
 aiud_sn_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_filestoretype_BRIEF_F
GO

create function iud_filestoretype_BRIEF_F  (
 aiud_filestoretypeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_filestoretype_MREF_F
GO
create function iud_filestoretype_MREF_F  (
 aiud_filestoretype_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_predmet_BRIEF_F
GO

create function iud_predmet_BRIEF_F  (
 aiud_predmetid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_predmet_MREF_F
GO
create function iud_predmet_MREF_F  (
 aiud_predmet_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_doctype_BRIEF_F
GO

create function iud_doctype_BRIEF_F  (
 aiud_doctypeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_doctype_MREF_F
GO
create function iud_doctype_MREF_F  (
 aiud_doctype_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Users_BRIEF_F
GO

create function Users_BRIEF_F  (
 aUsersid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Users_MREF_F
GO
create function Users_MREF_F  (
 aUsers_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Groups_BRIEF_F
GO

create function Groups_BRIEF_F  (
 aGroupsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Groups_MREF_F
GO
create function Groups_MREF_F  (
 aGroups_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS GroupUser_BRIEF_F
GO

create function GroupUser_BRIEF_F  (
 aGroupUserid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS GroupUser_MREF_F
GO
create function GroupUser_MREF_F  (
 aGroupUser_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_clsinfo_BRIEF_F
GO

create function iu_clsinfo_BRIEF_F  (
 aiu_clsinfoid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_clsinfo_MREF_F
GO
create function iu_clsinfo_MREF_F  (
 aiu_clsinfo_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Num_zones_BRIEF_F
GO

create function Num_zones_BRIEF_F  (
 aNum_zonesid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Num_zones_MREF_F
GO
create function Num_zones_MREF_F  (
 aNum_zones_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Num_Values_BRIEF_F
GO

create function Num_Values_BRIEF_F  (
 aNum_Valuesid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Num_Values_MREF_F
GO
create function Num_Values_MREF_F  (
 aNum_Values_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Num_head_BRIEF_F
GO

create function Num_head_BRIEF_F  (
 aNum_headid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Num_head_MREF_F
GO
create function Num_head_MREF_F  (
 aNum_head_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_filetype_BRIEF_F
GO

create function iud_filetype_BRIEF_F  (
 aiud_filetypeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_filetype_MREF_F
GO
create function iud_filetype_MREF_F  (
 aiud_filetype_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS MTZExt_def_BRIEF_F
GO

create function MTZExt_def_BRIEF_F  (
 aMTZExt_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS MTZExt_def_MREF_F
GO
create function MTZExt_def_MREF_F  (
 aMTZExt_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS MTZExtRel_BRIEF_F
GO

create function MTZExtRel_BRIEF_F  (
 aMTZExtRelid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS MTZExtRel_MREF_F
GO
create function MTZExtRel_MREF_F  (
 aMTZExtRel_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_videotype_BRIEF_F
GO

create function iud_videotype_BRIEF_F  (
 aiud_videotypeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_videotype_MREF_F
GO
create function iud_videotype_MREF_F  (
 aiud_videotype_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_cm_def_BRIEF_F
GO

create function iu_cm_def_BRIEF_F  (
 aiu_cm_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_cm_def_MREF_F
GO
create function iu_cm_def_MREF_F  (
 aiu_cm_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_cm_time_BRIEF_F
GO

create function iu_cm_time_BRIEF_F  (
 aiu_cm_timeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_cm_time_MREF_F
GO
create function iu_cm_time_MREF_F  (
 aiu_cm_time_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_cm_msg_BRIEF_F
GO

create function iu_cm_msg_BRIEF_F  (
 aiu_cm_msgid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_cm_msg_MREF_F
GO
create function iu_cm_msg_MREF_F  (
 aiu_cm_msg_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_plevent_BRIEF_F
GO

create function iu_plevent_BRIEF_F  (
 aiu_pleventid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_plevent_MREF_F
GO
create function iu_plevent_MREF_F  (
 aiu_plevent_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_rcfg_mod_BRIEF_F
GO

create function iu_rcfg_mod_BRIEF_F  (
 aiu_rcfg_modid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_rcfg_mod_MREF_F
GO
create function iu_rcfg_mod_MREF_F  (
 aiu_rcfg_mod_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_rcfg_docmode_BRIEF_F
GO

create function iu_rcfg_docmode_BRIEF_F  (
 aiu_rcfg_docmodeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_rcfg_docmode_MREF_F
GO
create function iu_rcfg_docmode_MREF_F  (
 aiu_rcfg_docmode_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_rcfg_def_BRIEF_F
GO

create function iu_rcfg_def_BRIEF_F  (
 aiu_rcfg_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_rcfg_def_MREF_F
GO
create function iu_rcfg_def_MREF_F  (
 aiu_rcfg_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_town_BRIEF_F
GO

create function iud_town_BRIEF_F  (
 aiud_townid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_town_MREF_F
GO
create function iud_town_MREF_F  (
 aiud_town_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_regtree_BRIEF_F
GO

create function iu_regtree_BRIEF_F  (
 aiu_regtreeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_regtree_MREF_F
GO
create function iu_regtree_MREF_F  (
 aiu_regtree_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_regdocs_BRIEF_F
GO

create function iu_regdocs_BRIEF_F  (
 aiu_regdocsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_regdocs_MREF_F
GO
create function iu_regdocs_MREF_F  (
 aiu_regdocs_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_status_BRIEF_F
GO

create function iu_status_BRIEF_F  (
 aiu_statusid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_status_MREF_F
GO
create function iu_status_MREF_F  (
 aiu_status_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_status_doer_BRIEF_F
GO

create function iu_status_doer_BRIEF_F  (
 aiu_status_doerid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_status_doer_MREF_F
GO
create function iu_status_doer_MREF_F  (
 aiu_status_doer_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_statustask_BRIEF_F
GO

create function iu_statustask_BRIEF_F  (
 aiu_statustaskid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_statustask_MREF_F
GO
create function iu_statustask_MREF_F  (
 aiu_statustask_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_state_tasklink_BRIEF_F
GO

create function iu_state_tasklink_BRIEF_F  (
 aiu_state_tasklinkid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_state_tasklink_MREF_F
GO
create function iu_state_tasklink_MREF_F  (
 aiu_state_tasklink_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_stausdoc_BRIEF_F
GO

create function iu_stausdoc_BRIEF_F  (
 aiu_stausdocid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_stausdoc_MREF_F
GO
create function iu_stausdoc_MREF_F  (
 aiu_stausdoc_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_statusnext_BRIEF_F
GO

create function iu_statusnext_BRIEF_F  (
 aiu_statusnextid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_statusnext_MREF_F
GO
create function iu_statusnext_MREF_F  (
 aiu_statusnext_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_statuschanger_BRIEF_F
GO

create function iu_statuschanger_BRIEF_F  (
 aiu_statuschangerid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_statuschanger_MREF_F
GO
create function iu_statuschanger_MREF_F  (
 aiu_statuschanger_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS MTZ2JOB_DEF_BRIEF_F
GO

create function MTZ2JOB_DEF_BRIEF_F  (
 aMTZ2JOB_DEFid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS MTZ2JOB_DEF_MREF_F
GO
create function MTZ2JOB_DEF_MREF_F  (
 aMTZ2JOB_DEF_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_ctype_BRIEF_F
GO

create function iud_ctype_BRIEF_F  (
 aiud_ctypeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_ctype_MREF_F
GO
create function iud_ctype_MREF_F  (
 aiud_ctype_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iud_spub_BRIEF_F
GO

create function iud_spub_BRIEF_F  (
 aiud_spubid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iud_spub_MREF_F
GO
create function iud_spub_MREF_F  (
 aiud_spub_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FilterFieldGroup_BRIEF_F
GO

create function FilterFieldGroup_BRIEF_F  (
 aFilterFieldGroupid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FilterFieldGroup_MREF_F
GO
create function FilterFieldGroup_MREF_F  (
 aFilterFieldGroup_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS FileterField_BRIEF_F
GO

create function FileterField_BRIEF_F  (
 aFileterFieldid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS FileterField_MREF_F
GO
create function FileterField_MREF_F  (
 aFileterField_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Filters_BRIEF_F
GO

create function Filters_BRIEF_F  (
 aFiltersid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Filters_MREF_F
GO
create function Filters_MREF_F  (
 aFilters_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_int_modules_BRIEF_F
GO

create function iu_int_modules_BRIEF_F  (
 aiu_int_modulesid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_int_modules_MREF_F
GO
create function iu_int_modules_MREF_F  (
 aiu_int_modules_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_task_BRIEF_F
GO

create function iu_task_BRIEF_F  (
 aiu_taskid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_task_MREF_F
GO
create function iu_task_MREF_F  (
 aiu_task_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_taskattach_BRIEF_F
GO

create function iu_taskattach_BRIEF_F  (
 aiu_taskattachid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_taskattach_MREF_F
GO
create function iu_taskattach_MREF_F  (
 aiu_taskattach_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_taskvideo_BRIEF_F
GO

create function iu_taskvideo_BRIEF_F  (
 aiu_taskvideoid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_taskvideo_MREF_F
GO
create function iu_taskvideo_MREF_F  (
 aiu_taskvideo_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_taskrefs_BRIEF_F
GO

create function iu_taskrefs_BRIEF_F  (
 aiu_taskrefsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_taskrefs_MREF_F
GO
create function iu_taskrefs_MREF_F  (
 aiu_taskrefs_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_l_def_BRIEF_F
GO

create function iu_l_def_BRIEF_F  (
 aiu_l_defid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_l_def_MREF_F
GO
create function iu_l_def_MREF_F  (
 aiu_l_def_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_tm_records_BRIEF_F
GO

create function iu_tm_records_BRIEF_F  (
 aiu_tm_recordsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_tm_records_MREF_F
GO
create function iu_tm_records_MREF_F  (
 aiu_tm_records_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_tmdef_BRIEF_F
GO

create function iu_tmdef_BRIEF_F  (
 aiu_tmdefid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_tmdef_MREF_F
GO
create function iu_tmdef_MREF_F  (
 aiu_tmdef_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_tmcadr_BRIEF_F
GO

create function iu_tmcadr_BRIEF_F  (
 aiu_tmcadrid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_tmcadr_MREF_F
GO
create function iu_tmcadr_MREF_F  (
 aiu_tmcadr_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_tm_act_BRIEF_F
GO

create function iu_tm_act_BRIEF_F  (
 aiu_tm_actid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_tm_act_MREF_F
GO
create function iu_tm_act_MREF_F  (
 aiu_tm_act_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_tm_actfile_BRIEF_F
GO

create function iu_tm_actfile_BRIEF_F  (
 aiu_tm_actfileid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_tm_actfile_MREF_F
GO
create function iu_tm_actfile_MREF_F  (
 aiu_tm_actfile_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_tm_dog_BRIEF_F
GO

create function iu_tm_dog_BRIEF_F  (
 aiu_tm_dogid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_tm_dog_MREF_F
GO
create function iu_tm_dog_MREF_F  (
 aiu_tm_dog_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS RPTStruct_BRIEF_F
GO

create function RPTStruct_BRIEF_F  (
 aRPTStructid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS RPTStruct_MREF_F
GO
create function RPTStruct_MREF_F  (
 aRPTStruct_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS RPTFields_BRIEF_F
GO

create function RPTFields_BRIEF_F  (
 aRPTFieldsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS RPTFields_MREF_F
GO
create function RPTFields_MREF_F  (
 aRPTFields_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS RPTFormula_BRIEF_F
GO

create function RPTFormula_BRIEF_F  (
 aRPTFormulaid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS RPTFormula_MREF_F
GO
create function RPTFormula_MREF_F  (
 aRPTFormula_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS Reports_BRIEF_F
GO

create function Reports_BRIEF_F  (
 aReportsid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS Reports_MREF_F
GO
create function Reports_MREF_F  (
 aReports_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO


drop function IF EXISTS iu_subsribe_BRIEF_F
GO

create function iu_subsribe_BRIEF_F  (
 aiu_subsribeid binary(16)
 ,aLang varchar(25)
) returns varchar(255)  
 DETERMINISTIC  
 begin  
 declare aBRIEF varchar(255);
  set aBRIEF='to do';
return aBRIEF;
end 
GO


drop function IF EXISTS iu_subsribe_MREF_F
GO
create function iu_subsribe_MREF_F  (
 aiu_subsribe_ref varchar(255)
 ,aLang varchar(25)
) returns varchar(255)  DETERMINISTIC begin  
 declare aMREF varchar(255);
  set aMREF='to do';
return aMREF;
end 
GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Functions" File="">
    <BlockHolder BlockName="--TableProc" BlockCode=" 


drop function if exists instance_mref_f
go
create function instance_mref_f  (
 ainstance_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select instance_brief_f(instanceid, alang)  from instance
where ainstance_ref like concat('%',replace(replace(b2g(instanceid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO


drop function if exists instance_brief_f
go
  create function instance_brief_f  (
 ainstanceid binary(16)
 ,alang varchar(25)
)returns varchar(255)
reads sql data
begin
 declare abrief varchar(255);
 declare aec int;
if ainstanceid is null then set abrief=''; return abrief; end if;
select count(*) into aec from instance where instanceid=ainstanceid;
if aec=0 then
  set abrief='';
  select concat(abrief
  ,  ifnull(name,''))
 into abrief from instance  where  instanceid = ainstanceid;
else
  set abrief= '';
end if;
set abrief=left(abrief,255);
  return abrief;
end
go
GO


drop function if exists instance_mref_f
go
create function instance_mref_f  (
 ainstance_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select instance_brief_f(instanceid, alang)  from instance
where ainstance_ref like concat('%',replace(replace(b2g(instanceid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_stagedef_brief_f
go

create function iud_stagedef_brief_f  (
 aiud_stagedefid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_stagedefid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_stagedef where iud_stagedefid=aiud_stagedefid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_stagedef  where  iud_stagedefid = aiud_stagedefid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_stagedef_mref_f
go

create function iud_stagedef_mref_f  (
 aiud_stagedef_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_stagedef_brief_f(iud_stagedefid, alang)  from iud_stagedef
where aiud_stagedef_ref like concat('%',replace(replace(b2g(iud_stagedefid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_adt_doc_brief_f
go

create function iud_adt_doc_brief_f  (
 aiud_adt_docid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_adt_docid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_adt_doc where iud_adt_docid=aiud_adt_docid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_adt_doc  where  iud_adt_docid = aiud_adt_docid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_adt_doc_mref_f
go

create function iud_adt_doc_mref_f  (
 aiud_adt_doc_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_adt_doc_brief_f(iud_adt_docid, alang)  from iud_adt_doc
where aiud_adt_doc_ref like concat('%',replace(replace(b2g(iud_adt_docid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_orgtree_brief_f
go

create function iu_orgtree_brief_f  (
 aiu_orgtreeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_orgtreeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_orgtree where iu_orgtreeid=aiu_orgtreeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iu_orgtree  where  iu_orgtreeid = aiu_orgtreeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_orgtree_mref_f
go

create function iu_orgtree_mref_f  (
 aiu_orgtree_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_orgtree_brief_f(iu_orgtreeid, alang)  from iu_orgtree
where aiu_orgtree_ref like concat('%',replace(replace(b2g(iu_orgtreeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_orgusr_brief_f
go

create function iu_orgusr_brief_f  (
 aiu_orgusrid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_orgusrid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_orgusr where iu_orgusrid=aiu_orgusrid;
if aec&lt;&gt;0 then
  set abrief='';
select orguser
 into atmpid  from iu_orgusr  where  iu_orgusrid = aiu_orgusrid; 
 select iu_u_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_orgusr_mref_f
go

create function iu_orgusr_mref_f  (
 aiu_orgusr_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_orgusr_brief_f(iu_orgusrid, alang)  from iu_orgusr
where aiu_orgusr_ref like concat('%',replace(replace(b2g(iu_orgusrid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_u_def_brief_f
go

create function iu_u_def_brief_f  (
 aiu_u_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_u_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_u_def where iu_u_defid=aiu_u_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(lastname,'') ,' '  )
  into abrief   from iu_u_def  where  iu_u_defid = aiu_u_defid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iu_u_def  where  iu_u_defid = aiu_u_defid; 
  select concat(abrief 
  , '' , ifnull(surname,'') ,' '  )
  into abrief   from iu_u_def  where  iu_u_defid = aiu_u_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_u_def_mref_f
go

create function iu_u_def_mref_f  (
 aiu_u_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_u_def_brief_f(iu_u_defid, alang)  from iu_u_def
where aiu_u_def_ref like concat('%',replace(replace(b2g(iu_u_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_process_def_brief_f
go

create function iud_process_def_brief_f  (
 aiud_process_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_process_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_process_def where iud_process_defid=aiud_process_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_process_def  where  iud_process_defid = aiud_process_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_process_def_mref_f
go

create function iud_process_def_mref_f  (
 aiud_process_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_process_def_brief_f(iud_process_defid, alang)  from iud_process_def
where aiud_process_def_ref like concat('%',replace(replace(b2g(iud_process_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists genpackage_brief_f
go

create function genpackage_brief_f  (
 agenpackageid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if agenpackageid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from genpackage where genpackageid=agenpackageid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from genpackage  where  genpackageid = agenpackageid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists genpackage_mref_f
go

create function genpackage_mref_f  (
 agenpackage_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select genpackage_brief_f(genpackageid, alang)  from genpackage
where agenpackage_ref like concat('%',replace(replace(b2g(genpackageid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists generator_target_brief_f
go

create function generator_target_brief_f  (
 agenerator_targetid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if agenerator_targetid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from generator_target where generator_targetid=agenerator_targetid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from generator_target  where  generator_targetid = agenerator_targetid; 
 select targettype
 into aec  from generator_target where generator_targetid=agenerator_targetid;
  case aec 
when 0 then 
  select concat(abrief ,
 'субд; ') into abrief ;
when 3 then 
  select concat(abrief ,
 'документация; ') into abrief ;
when 1 then 
  select concat(abrief ,
 'модель; ') into abrief ;
when 2 then 
  select concat(abrief ,
 'приложение; ') into abrief ;
when 4 then 
  select concat(abrief ,
 'арм; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists generator_target_mref_f
go

create function generator_target_mref_f  (
 agenerator_target_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select generator_target_brief_f(generator_targetid, alang)  from generator_target
where agenerator_target_ref like concat('%',replace(replace(b2g(generator_targetid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists genreference_brief_f
go

create function genreference_brief_f  (
 agenreferenceid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if agenreferenceid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from genreference where genreferenceid=agenreferenceid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from genreference  where  genreferenceid = agenreferenceid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists genreference_mref_f
go

create function genreference_mref_f  (
 agenreference_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select genreference_brief_f(genreferenceid, alang)  from genreference
where agenreference_ref like concat('%',replace(replace(b2g(genreferenceid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists genmanualcode_brief_f
go

create function genmanualcode_brief_f  (
 agenmanualcodeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if agenmanualcodeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from genmanualcode where genmanualcodeid=agenmanualcodeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from genmanualcode  where  genmanualcodeid = agenmanualcodeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists genmanualcode_mref_f
go

create function genmanualcode_mref_f  (
 agenmanualcode_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select genmanualcode_brief_f(genmanualcodeid, alang)  from genmanualcode
where agenmanualcode_ref like concat('%',replace(replace(b2g(genmanualcodeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists gencontrols_brief_f
go

create function gencontrols_brief_f  (
 agencontrolsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if agencontrolsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from gencontrols where gencontrolsid=agencontrolsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(controlprogid,'') ,' '  )
  into abrief   from gencontrols  where  gencontrolsid = agencontrolsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists gencontrols_mref_f
go

create function gencontrols_mref_f  (
 agencontrols_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select gencontrols_brief_f(gencontrolsid, alang)  from gencontrols
where agencontrols_ref like concat('%',replace(replace(b2g(gencontrolsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists localizeinfo_brief_f
go

create function localizeinfo_brief_f  (
 alocalizeinfoid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if alocalizeinfoid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from localizeinfo where localizeinfoid=alocalizeinfoid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(langfull,'') ,' '  )
  into abrief   from localizeinfo  where  localizeinfoid = alocalizeinfoid; 
  select concat(abrief 
  , '' , ifnull(langshort,'') ,' '  )
  into abrief   from localizeinfo  where  localizeinfoid = alocalizeinfoid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists localizeinfo_mref_f
go

create function localizeinfo_mref_f  (
 alocalizeinfo_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select localizeinfo_brief_f(localizeinfoid, alang)  from localizeinfo
where alocalizeinfo_ref like concat('%',replace(replace(b2g(localizeinfoid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists fieldtype_brief_f
go

create function fieldtype_brief_f  (
 afieldtypeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afieldtypeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from fieldtype where fieldtypeid=afieldtypeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from fieldtype  where  fieldtypeid = afieldtypeid; 
 select typestyle
 into aec  from fieldtype where fieldtypeid=afieldtypeid;
  case aec 
when 4 then 
  select concat(abrief ,
 'ссылка; ') into abrief ;
when 1 then 
  select concat(abrief ,
 'выражение; ') into abrief ;
when 5 then 
  select concat(abrief ,
 'элемент оформления; ') into abrief ;
when 3 then 
  select concat(abrief ,
 'интервал; ') into abrief ;
when 2 then 
  select concat(abrief ,
 'перечисление; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'скалярный тип; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists fieldtype_mref_f
go

create function fieldtype_mref_f  (
 afieldtype_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select fieldtype_brief_f(fieldtypeid, alang)  from fieldtype
where afieldtype_ref like concat('%',replace(replace(b2g(fieldtypeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists enumitem_brief_f
go

create function enumitem_brief_f  (
 aenumitemid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aenumitemid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from enumitem where enumitemid=aenumitemid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from enumitem  where  enumitemid = aenumitemid; 
  select concat(abrief 
  , '' , ifnull(namevalue,'') ,' '  )
  into abrief   from enumitem  where  enumitemid = aenumitemid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists enumitem_mref_f
go

create function enumitem_mref_f  (
 aenumitem_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select enumitem_brief_f(enumitemid, alang)  from enumitem
where aenumitem_ref like concat('%',replace(replace(b2g(enumitemid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists fieldtypemap_brief_f
go

create function fieldtypemap_brief_f  (
 afieldtypemapid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afieldtypemapid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from fieldtypemap where fieldtypemapid=afieldtypemapid;
if aec&lt;&gt;0 then
  set abrief='';
select target
 into atmpid  from fieldtypemap  where  fieldtypemapid = afieldtypemapid; 
 select generator_target_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(stoagetype,'') ,' '  )
  into abrief   from fieldtypemap  where  fieldtypemapid = afieldtypemapid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists fieldtypemap_mref_f
go

create function fieldtypemap_mref_f  (
 afieldtypemap_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select fieldtypemap_brief_f(fieldtypemapid, alang)  from fieldtypemap
where afieldtypemap_ref like concat('%',replace(replace(b2g(fieldtypemapid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists sharedmethod_brief_f
go

create function sharedmethod_brief_f  (
 asharedmethodid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if asharedmethodid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from sharedmethod where sharedmethodid=asharedmethodid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from sharedmethod  where  sharedmethodid = asharedmethodid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists sharedmethod_mref_f
go

create function sharedmethod_mref_f  (
 asharedmethod_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select sharedmethod_brief_f(sharedmethodid, alang)  from sharedmethod
where asharedmethod_ref like concat('%',replace(replace(b2g(sharedmethodid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists script_brief_f
go

create function script_brief_f  (
 ascriptid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if ascriptid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from script where scriptid=ascriptid;
if aec&lt;&gt;0 then
  set abrief='';
select target
 into atmpid  from script  where  scriptid = ascriptid; 
 select generator_target_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists script_mref_f
go

create function script_mref_f  (
 ascript_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select script_brief_f(scriptid, alang)  from script
where ascript_ref like concat('%',replace(replace(b2g(scriptid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists parameters_brief_f
go

create function parameters_brief_f  (
 aparametersid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aparametersid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from parameters where parametersid=aparametersid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from parameters  where  parametersid = aparametersid; 
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from parameters  where  parametersid = aparametersid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists parameters_mref_f
go

create function parameters_mref_f  (
 aparameters_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select parameters_brief_f(parametersid, alang)  from parameters
where aparameters_ref like concat('%',replace(replace(b2g(parametersid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists objecttype_brief_f
go

create function objecttype_brief_f  (
 aobjecttypeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aobjecttypeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from objecttype where objecttypeid=aobjecttypeid;
if aec&lt;&gt;0 then
  set abrief='';
select package
 into atmpid  from objecttype  where  objecttypeid = aobjecttypeid; 
 select mtzapp_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(the_comment,'') ,' '  )
  into abrief   from objecttype  where  objecttypeid = aobjecttypeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists objecttype_mref_f
go

create function objecttype_mref_f  (
 aobjecttype_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select objecttype_brief_f(objecttypeid, alang)  from objecttype
where aobjecttype_ref like concat('%',replace(replace(b2g(objecttypeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists objstatus_brief_f
go

create function objstatus_brief_f  (
 aobjstatusid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aobjstatusid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from objstatus where objstatusid=aobjstatusid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from objstatus  where  objstatusid = aobjstatusid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists objstatus_mref_f
go

create function objstatus_mref_f  (
 aobjstatus_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select objstatus_brief_f(objstatusid, alang)  from objstatus
where aobjstatus_ref like concat('%',replace(replace(b2g(objstatusid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists nextstate_brief_f
go

create function nextstate_brief_f  (
 anextstateid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if anextstateid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from nextstate where nextstateid=anextstateid;
if aec&lt;&gt;0 then
  set abrief='';
select thestate
 into atmpid  from nextstate  where  nextstateid = anextstateid; 
 select objstatus_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists nextstate_mref_f
go

create function nextstate_mref_f  (
 anextstate_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select nextstate_brief_f(nextstateid, alang)  from nextstate
where anextstate_ref like concat('%',replace(replace(b2g(nextstateid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists objectmode_brief_f
go

create function objectmode_brief_f  (
 aobjectmodeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aobjectmodeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from objectmode where objectmodeid=aobjectmodeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from objectmode  where  objectmodeid = aobjectmodeid; 
 select defaultmode
 into aec  from objectmode where objectmodeid=aobjectmodeid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists objectmode_mref_f
go

create function objectmode_mref_f  (
 aobjectmode_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select objectmode_brief_f(objectmodeid, alang)  from objectmode
where aobjectmode_ref like concat('%',replace(replace(b2g(objectmodeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists structrestriction_brief_f
go

create function structrestriction_brief_f  (
 astructrestrictionid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if astructrestrictionid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from structrestriction where structrestrictionid=astructrestrictionid;
if aec&lt;&gt;0 then
  set abrief='';
select struct
 into atmpid  from structrestriction  where  structrestrictionid = astructrestrictionid; 
 select part_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
 select allowread
 into aec  from structrestriction where structrestrictionid=astructrestrictionid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
 select allowadd
 into aec  from structrestriction where structrestrictionid=astructrestrictionid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
 select allowedit
 into aec  from structrestriction where structrestrictionid=astructrestrictionid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
 select allowdelete
 into aec  from structrestriction where structrestrictionid=astructrestrictionid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists structrestriction_mref_f
go

create function structrestriction_mref_f  (
 astructrestriction_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select structrestriction_brief_f(structrestrictionid, alang)  from structrestriction
where astructrestriction_ref like concat('%',replace(replace(b2g(structrestrictionid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists methodrestriction_brief_f
go

create function methodrestriction_brief_f  (
 amethodrestrictionid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if amethodrestrictionid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from methodrestriction where methodrestrictionid=amethodrestrictionid;
if aec&lt;&gt;0 then
  set abrief='';
select method
 into atmpid  from methodrestriction  where  methodrestrictionid = amethodrestrictionid; 
 select sharedmethod_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
 select isrestricted
 into aec  from methodrestriction where methodrestrictionid=amethodrestrictionid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists methodrestriction_mref_f
go

create function methodrestriction_mref_f  (
 amethodrestriction_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select methodrestriction_brief_f(methodrestrictionid, alang)  from methodrestriction
where amethodrestriction_ref like concat('%',replace(replace(b2g(methodrestrictionid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists fieldrestriction_brief_f
go

create function fieldrestriction_brief_f  (
 afieldrestrictionid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afieldrestrictionid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from fieldrestriction where fieldrestrictionid=afieldrestrictionid;
if aec&lt;&gt;0 then
  set abrief='';
select thepart
 into atmpid  from fieldrestriction  where  fieldrestrictionid = afieldrestrictionid; 
 select part_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
select thefield
 into atmpid  from fieldrestriction  where  fieldrestrictionid = afieldrestrictionid; 
 select field_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
 select allowread
 into aec  from fieldrestriction where fieldrestrictionid=afieldrestrictionid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
 select allowmodify
 into aec  from fieldrestriction where fieldrestrictionid=afieldrestrictionid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists fieldrestriction_mref_f
go

create function fieldrestriction_mref_f  (
 afieldrestriction_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select fieldrestriction_brief_f(fieldrestrictionid, alang)  from fieldrestriction
where afieldrestriction_ref like concat('%',replace(replace(b2g(fieldrestrictionid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists typemenu_brief_f
go

create function typemenu_brief_f  (
 atypemenuid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if atypemenuid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from typemenu where typemenuid=atypemenuid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from typemenu  where  typemenuid = atypemenuid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists typemenu_mref_f
go

create function typemenu_mref_f  (
 atypemenu_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select typemenu_brief_f(typemenuid, alang)  from typemenu
where atypemenu_ref like concat('%',replace(replace(b2g(typemenuid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists instancevalidator_brief_f
go

create function instancevalidator_brief_f  (
 ainstancevalidatorid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if ainstancevalidatorid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from instancevalidator where instancevalidatorid=ainstancevalidatorid;
if aec&lt;&gt;0 then
  set abrief='';
select target
 into atmpid  from instancevalidator  where  instancevalidatorid = ainstancevalidatorid; 
 select generator_target_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists instancevalidator_mref_f
go

create function instancevalidator_mref_f  (
 ainstancevalidator_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select instancevalidator_brief_f(instancevalidatorid, alang)  from instancevalidator
where ainstancevalidator_ref like concat('%',replace(replace(b2g(instancevalidatorid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists part_brief_f
go

create function part_brief_f  (
 apartid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if apartid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from part where partid=apartid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from part  where  partid = apartid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from part  where  partid = apartid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists part_mref_f
go

create function part_mref_f  (
 apart_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select part_brief_f(partid, alang)  from part
where apart_ref like concat('%',replace(replace(b2g(partid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists partmenu_brief_f
go

create function partmenu_brief_f  (
 apartmenuid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if apartmenuid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from partmenu where partmenuid=apartmenuid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from partmenu  where  partmenuid = apartmenuid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists partmenu_mref_f
go

create function partmenu_mref_f  (
 apartmenu_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select partmenu_brief_f(partmenuid, alang)  from partmenu
where apartmenu_ref like concat('%',replace(replace(b2g(partmenuid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists partparammap_brief_f
go

create function partparammap_brief_f  (
 apartparammapid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if apartparammapid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from partparammap where partparammapid=apartparammapid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(fieldname,'') ,' '  )
  into abrief   from partparammap  where  partparammapid = apartparammapid; 
  select concat(abrief 
  , '' , ifnull(paramname,'') ,' '  )
  into abrief   from partparammap  where  partparammapid = apartparammapid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists partparammap_mref_f
go

create function partparammap_mref_f  (
 apartparammap_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select partparammap_brief_f(partparammapid, alang)  from partparammap
where apartparammap_ref like concat('%',replace(replace(b2g(partparammapid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists partview_brief_f
go

create function partview_brief_f  (
 apartviewid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if apartviewid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from partview where partviewid=apartviewid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from partview  where  partviewid = apartviewid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists partview_mref_f
go

create function partview_mref_f  (
 apartview_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select partview_brief_f(partviewid, alang)  from partview
where apartview_ref like concat('%',replace(replace(b2g(partviewid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists viewcolumn_brief_f
go

create function viewcolumn_brief_f  (
 aviewcolumnid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aviewcolumnid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from viewcolumn where viewcolumnid=aviewcolumnid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from viewcolumn  where  viewcolumnid = aviewcolumnid; 
select frompart
 into atmpid  from viewcolumn  where  viewcolumnid = aviewcolumnid; 
 select part_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
 select aggregation
 into aec  from viewcolumn where viewcolumnid=aviewcolumnid;
  case aec 
when 3 then 
  select concat(abrief ,
 'sum; ') into abrief ;
when 1 then 
  select concat(abrief ,
 'avg; ') into abrief ;
when 6 then 
  select concat(abrief ,
 'custom; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'none; ') into abrief ;
when 2 then 
  select concat(abrief ,
 'count; ') into abrief ;
when 5 then 
  select concat(abrief ,
 'max; ') into abrief ;
when 4 then 
  select concat(abrief ,
 'min; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists viewcolumn_mref_f
go

create function viewcolumn_mref_f  (
 aviewcolumn_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select viewcolumn_brief_f(viewcolumnid, alang)  from viewcolumn
where aviewcolumn_ref like concat('%',replace(replace(b2g(viewcolumnid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists partview_lnk_brief_f
go

create function partview_lnk_brief_f  (
 apartview_lnkid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if apartview_lnkid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from partview_lnk where partview_lnkid=apartview_lnkid;
if aec&lt;&gt;0 then
  set abrief='';
select theview
 into atmpid  from partview_lnk  where  partview_lnkid = apartview_lnkid; 
 select partview_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists partview_lnk_mref_f
go

create function partview_lnk_mref_f  (
 apartview_lnk_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select partview_lnk_brief_f(partview_lnkid, alang)  from partview_lnk
where apartview_lnk_ref like concat('%',replace(replace(b2g(partview_lnkid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists validator_brief_f
go

create function validator_brief_f  (
 avalidatorid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if avalidatorid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from validator where validatorid=avalidatorid;
if aec&lt;&gt;0 then
  set abrief='';
select target
 into atmpid  from validator  where  validatorid = avalidatorid; 
 select generator_target_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists validator_mref_f
go

create function validator_mref_f  (
 avalidator_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select validator_brief_f(validatorid, alang)  from validator
where avalidator_ref like concat('%',replace(replace(b2g(validatorid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists uniqueconstraint_brief_f
go

create function uniqueconstraint_brief_f  (
 auniqueconstraintid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if auniqueconstraintid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from uniqueconstraint where uniqueconstraintid=auniqueconstraintid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from uniqueconstraint  where  uniqueconstraintid = auniqueconstraintid; 
 select perparent
 into aec  from uniqueconstraint where uniqueconstraintid=auniqueconstraintid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists uniqueconstraint_mref_f
go

create function uniqueconstraint_mref_f  (
 auniqueconstraint_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select uniqueconstraint_brief_f(uniqueconstraintid, alang)  from uniqueconstraint
where auniqueconstraint_ref like concat('%',replace(replace(b2g(uniqueconstraintid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists constraintfield_brief_f
go

create function constraintfield_brief_f  (
 aconstraintfieldid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aconstraintfieldid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from constraintfield where constraintfieldid=aconstraintfieldid;
if aec&lt;&gt;0 then
  set abrief='';
select thefield
 into atmpid  from constraintfield  where  constraintfieldid = aconstraintfieldid; 
 select field_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists constraintfield_mref_f
go

create function constraintfield_mref_f  (
 aconstraintfield_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select constraintfield_brief_f(constraintfieldid, alang)  from constraintfield
where aconstraintfield_ref like concat('%',replace(replace(b2g(constraintfieldid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists extenderinterface_brief_f
go

create function extenderinterface_brief_f  (
 aextenderinterfaceid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aextenderinterfaceid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from extenderinterface where extenderinterfaceid=aextenderinterfaceid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(thename,'') ,' '  )
  into abrief   from extenderinterface  where  extenderinterfaceid = aextenderinterfaceid; 
select targetplatform
 into atmpid  from extenderinterface  where  extenderinterfaceid = aextenderinterfaceid; 
 select generator_target_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(theobject,'') ,' '  )
  into abrief   from extenderinterface  where  extenderinterfaceid = aextenderinterfaceid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists extenderinterface_mref_f
go

create function extenderinterface_mref_f  (
 aextenderinterface_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select extenderinterface_brief_f(extenderinterfaceid, alang)  from extenderinterface
where aextenderinterface_ref like concat('%',replace(replace(b2g(extenderinterfaceid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists field_brief_f
go

create function field_brief_f  (
 afieldid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afieldid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from field where fieldid=afieldid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from field  where  fieldid = afieldid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from field  where  fieldid = afieldid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists field_mref_f
go

create function field_mref_f  (
 afield_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select field_brief_f(fieldid, alang)  from field
where afield_ref like concat('%',replace(replace(b2g(fieldid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists fldextenders_brief_f
go

create function fldextenders_brief_f  (
 afldextendersid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afldextendersid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from fldextenders where fldextendersid=afldextendersid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(thename,'') ,' '  )
  into abrief   from fldextenders  where  fldextendersid = afldextendersid; 
select targetplatform
 into atmpid  from fldextenders  where  fldextendersid = afldextendersid; 
 select generator_target_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(theobject,'') ,' '  )
  into abrief   from fldextenders  where  fldextendersid = afldextendersid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists fldextenders_mref_f
go

create function fldextenders_mref_f  (
 afldextenders_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select fldextenders_brief_f(fldextendersid, alang)  from fldextenders
where afldextenders_ref like concat('%',replace(replace(b2g(fldextendersid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists fieldsrcdef_brief_f
go

create function fieldsrcdef_brief_f  (
 afieldsrcdefid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afieldsrcdefid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from fieldsrcdef where fieldsrcdefid=afieldsrcdefid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(datasource,'') ,' '  )
  into abrief   from fieldsrcdef  where  fieldsrcdefid = afieldsrcdefid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists fieldsrcdef_mref_f
go

create function fieldsrcdef_mref_f  (
 afieldsrcdef_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select fieldsrcdef_brief_f(fieldsrcdefid, alang)  from fieldsrcdef
where afieldsrcdef_ref like concat('%',replace(replace(b2g(fieldsrcdefid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists dinamicfilterscript_brief_f
go

create function dinamicfilterscript_brief_f  (
 adinamicfilterscriptid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if adinamicfilterscriptid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from dinamicfilterscript where dinamicfilterscriptid=adinamicfilterscriptid;
if aec&lt;&gt;0 then
  set abrief='';
select target
 into atmpid  from dinamicfilterscript  where  dinamicfilterscriptid = adinamicfilterscriptid; 
 select generator_target_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists dinamicfilterscript_mref_f
go

create function dinamicfilterscript_mref_f  (
 adinamicfilterscript_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select dinamicfilterscript_brief_f(dinamicfilterscriptid, alang)  from dinamicfilterscript
where adinamicfilterscript_ref like concat('%',replace(replace(b2g(dinamicfilterscriptid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists fieldexpression_brief_f
go

create function fieldexpression_brief_f  (
 afieldexpressionid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afieldexpressionid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from fieldexpression where fieldexpressionid=afieldexpressionid;
if aec&lt;&gt;0 then
  set abrief='';
select target
 into atmpid  from fieldexpression  where  fieldexpressionid = afieldexpressionid; 
 select generator_target_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists fieldexpression_mref_f
go

create function fieldexpression_mref_f  (
 afieldexpression_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select fieldexpression_brief_f(fieldexpressionid, alang)  from fieldexpression
where afieldexpression_ref like concat('%',replace(replace(b2g(fieldexpressionid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists fieldvalidator_brief_f
go

create function fieldvalidator_brief_f  (
 afieldvalidatorid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afieldvalidatorid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from fieldvalidator where fieldvalidatorid=afieldvalidatorid;
if aec&lt;&gt;0 then
  set abrief='';
select target
 into atmpid  from fieldvalidator  where  fieldvalidatorid = afieldvalidatorid; 
 select generator_target_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists fieldvalidator_mref_f
go

create function fieldvalidator_mref_f  (
 afieldvalidator_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select fieldvalidator_brief_f(fieldvalidatorid, alang)  from fieldvalidator
where afieldvalidator_ref like concat('%',replace(replace(b2g(fieldvalidatorid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists fieldmenu_brief_f
go

create function fieldmenu_brief_f  (
 afieldmenuid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afieldmenuid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from fieldmenu where fieldmenuid=afieldmenuid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from fieldmenu  where  fieldmenuid = afieldmenuid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists fieldmenu_mref_f
go

create function fieldmenu_mref_f  (
 afieldmenu_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select fieldmenu_brief_f(fieldmenuid, alang)  from fieldmenu
where afieldmenu_ref like concat('%',replace(replace(b2g(fieldmenuid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists fieldparammap_brief_f
go

create function fieldparammap_brief_f  (
 afieldparammapid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afieldparammapid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from fieldparammap where fieldparammapid=afieldparammapid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(fieldname,'') ,' '  )
  into abrief   from fieldparammap  where  fieldparammapid = afieldparammapid; 
  select concat(abrief 
  , '' , ifnull(paramname,'') ,' '  )
  into abrief   from fieldparammap  where  fieldparammapid = afieldparammapid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists fieldparammap_mref_f
go

create function fieldparammap_mref_f  (
 afieldparammap_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select fieldparammap_brief_f(fieldparammapid, alang)  from fieldparammap
where afieldparammap_ref like concat('%',replace(replace(b2g(fieldparammapid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists mtzapp_brief_f
go

create function mtzapp_brief_f  (
 amtzappid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if amtzappid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from mtzapp where mtzappid=amtzappid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from mtzapp  where  mtzappid = amtzappid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists mtzapp_mref_f
go

create function mtzapp_mref_f  (
 amtzapp_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select mtzapp_brief_f(mtzappid, alang)  from mtzapp
where amtzapp_ref like concat('%',replace(replace(b2g(mtzappid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists parentpackage_brief_f
go

create function parentpackage_brief_f  (
 aparentpackageid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aparentpackageid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from parentpackage where parentpackageid=aparentpackageid;
if aec&lt;&gt;0 then
  set abrief='';
select package
 into atmpid  from parentpackage  where  parentpackageid = aparentpackageid; 
 select mtzapp_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists parentpackage_mref_f
go

create function parentpackage_mref_f  (
 aparentpackage_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select parentpackage_brief_f(parentpackageid, alang)  from parentpackage
where aparentpackage_ref like concat('%',replace(replace(b2g(parentpackageid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists journalcolumn_brief_f
go

create function journalcolumn_brief_f  (
 ajournalcolumnid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if ajournalcolumnid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from journalcolumn where journalcolumnid=ajournalcolumnid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from journalcolumn  where  journalcolumnid = ajournalcolumnid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists journalcolumn_mref_f
go

create function journalcolumn_mref_f  (
 ajournalcolumn_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select journalcolumn_brief_f(journalcolumnid, alang)  from journalcolumn
where ajournalcolumn_ref like concat('%',replace(replace(b2g(journalcolumnid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists jcolumnsource_brief_f
go

create function jcolumnsource_brief_f  (
 ajcolumnsourceid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if ajcolumnsourceid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from jcolumnsource where jcolumnsourceid=ajcolumnsourceid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(viewfield,'') ,' '  )
  into abrief   from jcolumnsource  where  jcolumnsourceid = ajcolumnsourceid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists jcolumnsource_mref_f
go

create function jcolumnsource_mref_f  (
 ajcolumnsource_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select jcolumnsource_brief_f(jcolumnsourceid, alang)  from jcolumnsource
where ajcolumnsource_ref like concat('%',replace(replace(b2g(jcolumnsourceid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists journalsrc_brief_f
go

create function journalsrc_brief_f  (
 ajournalsrcid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if ajournalsrcid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from journalsrc where journalsrcid=ajournalsrcid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(partview,'') ,' '  )
  into abrief   from journalsrc  where  journalsrcid = ajournalsrcid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists journalsrc_mref_f
go

create function journalsrc_mref_f  (
 ajournalsrc_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select journalsrc_brief_f(journalsrcid, alang)  from journalsrc
where ajournalsrc_ref like concat('%',replace(replace(b2g(journalsrcid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists journal_brief_f
go

create function journal_brief_f  (
 ajournalid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if ajournalid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from journal where journalid=ajournalid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from journal  where  journalid = ajournalid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists journal_mref_f
go

create function journal_mref_f  (
 ajournal_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select journal_brief_f(journalid, alang)  from journal
where ajournal_ref like concat('%',replace(replace(b2g(journalid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_urok_sn_brief_f
go

create function iu_urok_sn_brief_f  (
 aiu_urok_snid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_urok_snid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_urok_sn where iu_urok_snid=aiu_urok_snid;
if aec&lt;&gt;0 then
  set abrief='';
select urokstatus
 into atmpid  from iu_urok_sn  where  iu_urok_snid = aiu_urok_snid; 
 select iud_sn_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_urok_sn_mref_f
go

create function iu_urok_sn_mref_f  (
 aiu_urok_sn_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_urok_sn_brief_f(iu_urok_snid, alang)  from iu_urok_sn
where aiu_urok_sn_ref like concat('%',replace(replace(b2g(iu_urok_snid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_urok_msg_brief_f
go

create function iu_urok_msg_brief_f  (
 aiu_urok_msgid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_urok_msgid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_urok_msg where iu_urok_msgid=aiu_urok_msgid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(info,'') ,' '  )
  into abrief   from iu_urok_msg  where  iu_urok_msgid = aiu_urok_msgid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_urok_msg_mref_f
go

create function iu_urok_msg_mref_f  (
 aiu_urok_msg_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_urok_msg_brief_f(iu_urok_msgid, alang)  from iu_urok_msg
where aiu_urok_msg_ref like concat('%',replace(replace(b2g(iu_urok_msgid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_urok_graph_brief_f
go

create function iu_urok_graph_brief_f  (
 aiu_urok_graphid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_urok_graphid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_urok_graph where iu_urok_graphid=aiu_urok_graphid;
if aec&lt;&gt;0 then
  set abrief='';
select thestatus
 into atmpid  from iu_urok_graph  where  iu_urok_graphid = aiu_urok_graphid; 
 select iu_status_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_urok_graph_mref_f
go

create function iu_urok_graph_mref_f  (
 aiu_urok_graph_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_urok_graph_brief_f(iu_urok_graphid, alang)  from iu_urok_graph
where aiu_urok_graph_ref like concat('%',replace(replace(b2g(iu_urok_graphid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_urok_prc_brief_f
go

create function iu_urok_prc_brief_f  (
 aiu_urok_prcid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_urok_prcid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_urok_prc where iu_urok_prcid=aiu_urok_prcid;
if aec&lt;&gt;0 then
  set abrief='';
select theprocess
 into atmpid  from iu_urok_prc  where  iu_urok_prcid = aiu_urok_prcid; 
 select iu_urok_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_urok_prc_mref_f
go

create function iu_urok_prc_mref_f  (
 aiu_urok_prc_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_urok_prc_brief_f(iu_urok_prcid, alang)  from iu_urok_prc
where aiu_urok_prc_ref like concat('%',replace(replace(b2g(iu_urok_prcid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists folder_brief_f
go

create function folder_brief_f  (
 afolderid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afolderid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from folder where folderid=afolderid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from folder  where  folderid = afolderid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists folder_mref_f
go

create function folder_mref_f  (
 afolder_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select folder_brief_f(folderid, alang)  from folder
where afolder_ref like concat('%',replace(replace(b2g(folderid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists shortcut_brief_f
go

create function shortcut_brief_f  (
 ashortcutid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if ashortcutid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from shortcut where shortcutid=ashortcutid;
if aec&lt;&gt;0 then
  set abrief='';
select docitem
 into atmpid  from shortcut  where  shortcutid = ashortcutid; 
 select instance_brief_f( atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists shortcut_mref_f
go

create function shortcut_mref_f  (
 ashortcut_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select shortcut_brief_f(shortcutid, alang)  from shortcut
where ashortcut_ref like concat('%',replace(replace(b2g(shortcutid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists infostoredef_brief_f
go

create function infostoredef_brief_f  (
 ainfostoredefid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if ainfostoredefid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from infostoredef where infostoredefid=ainfostoredefid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from infostoredef  where  infostoredefid = ainfostoredefid; 
 select infostoretype
 into aec  from infostoredef where infostoredefid=ainfostoredefid;
  case aec 
when 2 then 
  select concat(abrief ,
 'групповой; ') into abrief ;
when 0 then 
  select concat(abrief ,
 ' общий; ') into abrief ;
when 1 then 
  select concat(abrief ,
 'персональный; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists infostoredef_mref_f
go

create function infostoredef_mref_f  (
 ainfostoredef_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select infostoredef_brief_f(infostoredefid, alang)  from infostoredef
where ainfostoredef_ref like concat('%',replace(replace(b2g(infostoredefid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_rt_def_brief_f
go

create function iud_rt_def_brief_f  (
 aiud_rt_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_rt_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_rt_def where iud_rt_defid=aiud_rt_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_rt_def  where  iud_rt_defid = aiud_rt_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_rt_def_mref_f
go

create function iud_rt_def_mref_f  (
 aiud_rt_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_rt_def_brief_f(iud_rt_defid, alang)  from iud_rt_def
where aiud_rt_def_ref like concat('%',replace(replace(b2g(iud_rt_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists the_session_brief_f
go

create function the_session_brief_f  (
 athe_sessionid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if athe_sessionid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from the_session where the_sessionid=athe_sessionid;
if aec&lt;&gt;0 then
  set abrief='';
select userrole
 into atmpid  from the_session  where  the_sessionid = athe_sessionid; 
 select groups_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
 select closed
 into aec  from the_session where the_sessionid=athe_sessionid;
  case aec 
when 1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
select usersid
 into atmpid  from the_session  where  the_sessionid = athe_sessionid; 
 select users_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists the_session_mref_f
go

create function the_session_mref_f  (
 athe_session_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select the_session_brief_f(the_sessionid, alang)  from the_session
where athe_session_ref like concat('%',replace(replace(b2g(the_sessionid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists sysrefcache_brief_f
go

create function sysrefcache_brief_f  (
 asysrefcacheid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if asysrefcacheid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from sysrefcache where sysrefcacheid=asysrefcacheid;
if aec&lt;&gt;0 then
  set abrief='';
select sessionid
 into atmpid  from sysrefcache  where  sysrefcacheid = asysrefcacheid; 
 select the_session_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists sysrefcache_mref_f
go

create function sysrefcache_mref_f  (
 asysrefcache_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select sysrefcache_brief_f(sysrefcacheid, alang)  from sysrefcache
where asysrefcache_ref like concat('%',replace(replace(b2g(sysrefcacheid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists syslog_brief_f
go

create function syslog_brief_f  (
 asyslogid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if asyslogid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from syslog where syslogid=asyslogid;
if aec&lt;&gt;0 then
  set abrief='';
select thesession
 into atmpid  from syslog  where  syslogid = asyslogid; 
 select the_session_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(logstructid,'') ,' '  )
  into abrief   from syslog  where  syslogid = asyslogid; 
  select concat(abrief 
  , '' , ifnull(verb,'') ,' '  )
  into abrief   from syslog  where  syslogid = asyslogid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists syslog_mref_f
go

create function syslog_mref_f  (
 asyslog_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select syslog_brief_f(syslogid, alang)  from syslog
where asyslog_ref like concat('%',replace(replace(b2g(syslogid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists armjournal_brief_f
go

create function armjournal_brief_f  (
 aarmjournalid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aarmjournalid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from armjournal where armjournalid=aarmjournalid;
if aec&lt;&gt;0 then
  set abrief='';
select thejournal
 into atmpid  from armjournal  where  armjournalid = aarmjournalid; 
 select instance_brief_f( atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists armjournal_mref_f
go

create function armjournal_mref_f  (
 aarmjournal_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select armjournal_brief_f(armjournalid, alang)  from armjournal
where aarmjournal_ref like concat('%',replace(replace(b2g(armjournalid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists armjrnlrep_brief_f
go

create function armjrnlrep_brief_f  (
 aarmjrnlrepid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aarmjrnlrepid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from armjrnlrep where armjrnlrepid=aarmjrnlrepid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(repname,'') ,' '  )
  into abrief   from armjrnlrep  where  armjrnlrepid = aarmjrnlrepid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists armjrnlrep_mref_f
go

create function armjrnlrep_mref_f  (
 aarmjrnlrep_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select armjrnlrep_brief_f(armjrnlrepid, alang)  from armjrnlrep
where aarmjrnlrep_ref like concat('%',replace(replace(b2g(armjrnlrepid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists armjrnlrun_brief_f
go

create function armjrnlrun_brief_f  (
 aarmjrnlrunid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aarmjrnlrunid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from armjrnlrun where armjrnlrunid=aarmjrnlrunid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from armjrnlrun  where  armjrnlrunid = aarmjrnlrunid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists armjrnlrun_mref_f
go

create function armjrnlrun_mref_f  (
 aarmjrnlrun_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select armjrnlrun_brief_f(armjrnlrunid, alang)  from armjrnlrun
where aarmjrnlrun_ref like concat('%',replace(replace(b2g(armjrnlrunid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists armjrnladd_brief_f
go

create function armjrnladd_brief_f  (
 aarmjrnladdid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aarmjrnladdid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from armjrnladd where armjrnladdid=aarmjrnladdid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from armjrnladd  where  armjrnladdid = aarmjrnladdid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists armjrnladd_mref_f
go

create function armjrnladd_mref_f  (
 aarmjrnladd_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select armjrnladd_brief_f(armjrnladdid, alang)  from armjrnladd
where aarmjrnladd_ref like concat('%',replace(replace(b2g(armjrnladdid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists entrypoints_brief_f
go

create function entrypoints_brief_f  (
 aentrypointsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aentrypointsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from entrypoints where entrypointsid=aentrypointsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from entrypoints  where  entrypointsid = aentrypointsid; 
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from entrypoints  where  entrypointsid = aentrypointsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists entrypoints_mref_f
go

create function entrypoints_mref_f  (
 aentrypoints_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select entrypoints_brief_f(entrypointsid, alang)  from entrypoints
where aentrypoints_ref like concat('%',replace(replace(b2g(entrypointsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists epfilterlink_brief_f
go

create function epfilterlink_brief_f  (
 aepfilterlinkid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aepfilterlinkid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from epfilterlink where epfilterlinkid=aepfilterlinkid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(rowsource,'') ,' '  )
  into abrief   from epfilterlink  where  epfilterlinkid = aepfilterlinkid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists epfilterlink_mref_f
go

create function epfilterlink_mref_f  (
 aepfilterlink_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select epfilterlink_brief_f(epfilterlinkid, alang)  from epfilterlink
where aepfilterlink_ref like concat('%',replace(replace(b2g(epfilterlinkid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists workplace_brief_f
go

create function workplace_brief_f  (
 aworkplaceid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aworkplaceid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from workplace where workplaceid=aworkplaceid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from workplace  where  workplaceid = aworkplaceid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists workplace_mref_f
go

create function workplace_mref_f  (
 aworkplace_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select workplace_brief_f(workplaceid, alang)  from workplace
where aworkplace_ref like concat('%',replace(replace(b2g(workplaceid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists armtypes_brief_f
go

create function armtypes_brief_f  (
 aarmtypesid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aarmtypesid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from armtypes where armtypesid=aarmtypesid;
if aec&lt;&gt;0 then
  set abrief='';
select thedocumenttype
 into atmpid  from armtypes  where  armtypesid = aarmtypesid; 
 select objecttype_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists armtypes_mref_f
go

create function armtypes_mref_f  (
 aarmtypes_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select armtypes_brief_f(armtypesid, alang)  from armtypes
where aarmtypes_ref like concat('%',replace(replace(b2g(armtypesid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_crole_brief_f
go

create function iu_crole_brief_f  (
 aiu_croleid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_croleid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_crole where iu_croleid=aiu_croleid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iu_crole  where  iu_croleid = aiu_croleid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_crole_mref_f
go

create function iu_crole_mref_f  (
 aiu_crole_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_crole_brief_f(iu_croleid, alang)  from iu_crole
where aiu_crole_ref like concat('%',replace(replace(b2g(iu_croleid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles_operations_brief_f
go

create function roles_operations_brief_f  (
 aroles_operationsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles_operationsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles_operations where roles_operationsid=aroles_operationsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(info,'') ,' '  )
  into abrief   from roles_operations  where  roles_operationsid = aroles_operationsid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from roles_operations  where  roles_operationsid = aroles_operationsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles_operations_mref_f
go

create function roles_operations_mref_f  (
 aroles_operations_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles_operations_brief_f(roles_operationsid, alang)  from roles_operations
where aroles_operations_ref like concat('%',replace(replace(b2g(roles_operationsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles_wp_brief_f
go

create function roles_wp_brief_f  (
 aroles_wpid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles_wpid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles_wp where roles_wpid=aroles_wpid;
if aec&lt;&gt;0 then
  set abrief='';
select wp
 into atmpid  from roles_wp  where  roles_wpid = aroles_wpid; 
 select workplace_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles_wp_mref_f
go

create function roles_wp_mref_f  (
 aroles_wp_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles_wp_brief_f(roles_wpid, alang)  from roles_wp
where aroles_wp_ref like concat('%',replace(replace(b2g(roles_wpid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles_act_brief_f
go

create function roles_act_brief_f  (
 aroles_actid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles_actid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles_act where roles_actid=aroles_actid;
if aec&lt;&gt;0 then
  set abrief='';
 select accesible
 into aec  from roles_act where roles_actid=aroles_actid;
  case aec 
when 1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
  select concat(abrief 
  , '' , ifnull(menuname,'') ,' '  )
  into abrief   from roles_act  where  roles_actid = aroles_actid; 
  select concat(abrief 
  , '' , ifnull(menucode,'') ,' '  )
  into abrief   from roles_act  where  roles_actid = aroles_actid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles_act_mref_f
go

create function roles_act_mref_f  (
 aroles_act_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles_act_brief_f(roles_actid, alang)  from roles_act
where aroles_act_ref like concat('%',replace(replace(b2g(roles_actid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles2_module_brief_f
go

create function roles2_module_brief_f  (
 aroles2_moduleid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles2_moduleid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles2_module where roles2_moduleid=aroles2_moduleid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from roles2_module  where  roles2_moduleid = aroles2_moduleid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from roles2_module  where  roles2_moduleid = aroles2_moduleid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles2_module_mref_f
go

create function roles2_module_mref_f  (
 aroles2_module_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles2_module_brief_f(roles2_moduleid, alang)  from roles2_module
where aroles2_module_ref like concat('%',replace(replace(b2g(roles2_moduleid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles2_modreport_brief_f
go

create function roles2_modreport_brief_f  (
 aroles2_modreportid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles2_modreportid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles2_modreport where roles2_modreportid=aroles2_modreportid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from roles2_modreport  where  roles2_modreportid = aroles2_modreportid; 
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from roles2_modreport  where  roles2_modreportid = aroles2_modreportid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles2_modreport_mref_f
go

create function roles2_modreport_mref_f  (
 aroles2_modreport_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles2_modreport_brief_f(roles2_modreportid, alang)  from roles2_modreport
where aroles2_modreport_ref like concat('%',replace(replace(b2g(roles2_modreportid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles_doc_brief_f
go

create function roles_doc_brief_f  (
 aroles_docid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles_docid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles_doc where roles_docid=aroles_docid;
if aec&lt;&gt;0 then
  set abrief='';
select the_document
 into atmpid  from roles_doc  where  roles_docid = aroles_docid; 
 select objecttype_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles_doc_mref_f
go

create function roles_doc_mref_f  (
 aroles_doc_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles_doc_brief_f(roles_docid, alang)  from roles_doc
where aroles_doc_ref like concat('%',replace(replace(b2g(roles_docid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles_doc_state_brief_f
go

create function roles_doc_state_brief_f  (
 aroles_doc_stateid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles_doc_stateid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles_doc_state where roles_doc_stateid=aroles_doc_stateid;
if aec&lt;&gt;0 then
  set abrief='';
select the_state
 into atmpid  from roles_doc_state  where  roles_doc_stateid = aroles_doc_stateid; 
 select objstatus_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
select the_mode
 into atmpid  from roles_doc_state  where  roles_doc_stateid = aroles_doc_stateid; 
 select objectmode_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles_doc_state_mref_f
go

create function roles_doc_state_mref_f  (
 aroles_doc_state_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles_doc_state_brief_f(roles_doc_stateid, alang)  from roles_doc_state
where aroles_doc_state_ref like concat('%',replace(replace(b2g(roles_doc_stateid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles_reports_brief_f
go

create function roles_reports_brief_f  (
 aroles_reportsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles_reportsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles_reports where roles_reportsid=aroles_reportsid;
if aec&lt;&gt;0 then
  set abrief='';
select the_report
 into atmpid  from roles_reports  where  roles_reportsid = aroles_reportsid; 
 select instance_brief_f( atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles_reports_mref_f
go

create function roles_reports_mref_f  (
 aroles_reports_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles_reports_brief_f(roles_reportsid, alang)  from roles_reports
where aroles_reports_ref like concat('%',replace(replace(b2g(roles_reportsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles_user_brief_f
go

create function roles_user_brief_f  (
 aroles_userid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles_userid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles_user where roles_userid=aroles_userid;
if aec&lt;&gt;0 then
  set abrief='';
select theuser
 into atmpid  from roles_user  where  roles_userid = aroles_userid; 
 select users_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles_user_mref_f
go

create function roles_user_mref_f  (
 aroles_user_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles_user_brief_f(roles_userid, alang)  from roles_user
where aroles_user_ref like concat('%',replace(replace(b2g(roles_userid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles_map_brief_f
go

create function roles_map_brief_f  (
 aroles_mapid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles_mapid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles_map where roles_mapid=aroles_mapid;
if aec&lt;&gt;0 then
  set abrief='';
select thegroup
 into atmpid  from roles_map  where  roles_mapid = aroles_mapid; 
 select groups_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles_map_mref_f
go

create function roles_map_mref_f  (
 aroles_map_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles_map_brief_f(roles_mapid, alang)  from roles_map
where aroles_map_ref like concat('%',replace(replace(b2g(roles_mapid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists roles_def_brief_f
go

create function roles_def_brief_f  (
 aroles_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aroles_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from roles_def where roles_defid=aroles_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from roles_def  where  roles_defid = aroles_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists roles_def_mref_f
go

create function roles_def_mref_f  (
 aroles_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select roles_def_brief_f(roles_defid, alang)  from roles_def
where aroles_def_ref like concat('%',replace(replace(b2g(roles_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_urok_docs_brief_f
go

create function iu_urok_docs_brief_f  (
 aiu_urok_docsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_urok_docsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_urok_docs where iu_urok_docsid=aiu_urok_docsid;
if aec&lt;&gt;0 then
  set abrief='';
select doctype
 into atmpid  from iu_urok_docs  where  iu_urok_docsid = aiu_urok_docsid; 
 select iud_doctype_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_urok_docs_mref_f
go

create function iu_urok_docs_mref_f  (
 aiu_urok_docs_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_urok_docs_brief_f(iu_urok_docsid, alang)  from iu_urok_docs
where aiu_urok_docs_ref like concat('%',replace(replace(b2g(iu_urok_docsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_urok_creators_brief_f
go

create function iu_urok_creators_brief_f  (
 aiu_urok_creatorsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_urok_creatorsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_urok_creators where iu_urok_creatorsid=aiu_urok_creatorsid;
if aec&lt;&gt;0 then
  set abrief='';
select processrole
 into atmpid  from iu_urok_creators  where  iu_urok_creatorsid = aiu_urok_creatorsid; 
 select iu_crole_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
select doer
 into atmpid  from iu_urok_creators  where  iu_urok_creatorsid = aiu_urok_creatorsid; 
 select iu_u_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_urok_creators_mref_f
go

create function iu_urok_creators_mref_f  (
 aiu_urok_creators_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_urok_creators_brief_f(iu_urok_creatorsid, alang)  from iu_urok_creators
where aiu_urok_creators_ref like concat('%',replace(replace(b2g(iu_urok_creatorsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_urok_def_brief_f
go

create function iu_urok_def_brief_f  (
 aiu_urok_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_urok_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_urok_def where iu_urok_defid=aiu_urok_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(classtheme,'') ,' '  )
  into abrief   from iu_urok_def  where  iu_urok_defid = aiu_urok_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_urok_def_mref_f
go

create function iu_urok_def_mref_f  (
 aiu_urok_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_urok_def_brief_f(iu_urok_defid, alang)  from iu_urok_def
where aiu_urok_def_ref like concat('%',replace(replace(b2g(iu_urok_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_urok_video_brief_f
go

create function iu_urok_video_brief_f  (
 aiu_urok_videoid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_urok_videoid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_urok_video where iu_urok_videoid=aiu_urok_videoid;
if aec&lt;&gt;0 then
  set abrief='';
select doctype
 into atmpid  from iu_urok_video  where  iu_urok_videoid = aiu_urok_videoid; 
 select iud_videotype_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_urok_video_mref_f
go

create function iu_urok_video_mref_f  (
 aiu_urok_video_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_urok_video_brief_f(iu_urok_videoid, alang)  from iu_urok_video
where aiu_urok_video_ref like concat('%',replace(replace(b2g(iu_urok_videoid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_mt_def_brief_f
go

create function iud_mt_def_brief_f  (
 aiud_mt_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_mt_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_mt_def where iud_mt_defid=aiud_mt_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_mt_def  where  iud_mt_defid = aiud_mt_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_mt_def_mref_f
go

create function iud_mt_def_mref_f  (
 aiud_mt_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_mt_def_brief_f(iud_mt_defid, alang)  from iud_mt_def
where aiud_mt_def_ref like concat('%',replace(replace(b2g(iud_mt_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_sn_def_brief_f
go

create function iud_sn_def_brief_f  (
 aiud_sn_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_sn_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_sn_def where iud_sn_defid=aiud_sn_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_sn_def  where  iud_sn_defid = aiud_sn_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_sn_def_mref_f
go

create function iud_sn_def_mref_f  (
 aiud_sn_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_sn_def_brief_f(iud_sn_defid, alang)  from iud_sn_def
where aiud_sn_def_ref like concat('%',replace(replace(b2g(iud_sn_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_filestoretype_brief_f
go

create function iud_filestoretype_brief_f  (
 aiud_filestoretypeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_filestoretypeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_filestoretype where iud_filestoretypeid=aiud_filestoretypeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_filestoretype  where  iud_filestoretypeid = aiud_filestoretypeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_filestoretype_mref_f
go

create function iud_filestoretype_mref_f  (
 aiud_filestoretype_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_filestoretype_brief_f(iud_filestoretypeid, alang)  from iud_filestoretype
where aiud_filestoretype_ref like concat('%',replace(replace(b2g(iud_filestoretypeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_predmet_brief_f
go

create function iud_predmet_brief_f  (
 aiud_predmetid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_predmetid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_predmet where iud_predmetid=aiud_predmetid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_predmet  where  iud_predmetid = aiud_predmetid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_predmet_mref_f
go

create function iud_predmet_mref_f  (
 aiud_predmet_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_predmet_brief_f(iud_predmetid, alang)  from iud_predmet
where aiud_predmet_ref like concat('%',replace(replace(b2g(iud_predmetid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_doctype_brief_f
go

create function iud_doctype_brief_f  (
 aiud_doctypeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_doctypeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_doctype where iud_doctypeid=aiud_doctypeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_doctype  where  iud_doctypeid = aiud_doctypeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_doctype_mref_f
go

create function iud_doctype_mref_f  (
 aiud_doctype_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_doctype_brief_f(iud_doctypeid, alang)  from iud_doctype
where aiud_doctype_ref like concat('%',replace(replace(b2g(iud_doctypeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists users_brief_f
go

create function users_brief_f  (
 ausersid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if ausersid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from users where usersid=ausersid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(family,'') ,' '  )
  into abrief   from users  where  usersid = ausersid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from users  where  usersid = ausersid; 
  select concat(abrief 
  , '' , ifnull(surname,'') ,' '  )
  into abrief   from users  where  usersid = ausersid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists users_mref_f
go

create function users_mref_f  (
 ausers_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select users_brief_f(usersid, alang)  from users
where ausers_ref like concat('%',replace(replace(b2g(usersid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists groups_brief_f
go

create function groups_brief_f  (
 agroupsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if agroupsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from groups where groupsid=agroupsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from groups  where  groupsid = agroupsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists groups_mref_f
go

create function groups_mref_f  (
 agroups_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select groups_brief_f(groupsid, alang)  from groups
where agroups_ref like concat('%',replace(replace(b2g(groupsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists groupuser_brief_f
go

create function groupuser_brief_f  (
 agroupuserid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if agroupuserid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from groupuser where groupuserid=agroupuserid;
if aec&lt;&gt;0 then
  set abrief='';
select theuser
 into atmpid  from groupuser  where  groupuserid = agroupuserid; 
 select users_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists groupuser_mref_f
go

create function groupuser_mref_f  (
 agroupuser_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select groupuser_brief_f(groupuserid, alang)  from groupuser
where agroupuser_ref like concat('%',replace(replace(b2g(groupuserid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_clsinfo_brief_f
go

create function iu_clsinfo_brief_f  (
 aiu_clsinfoid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_clsinfoid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_clsinfo where iu_clsinfoid=aiu_clsinfoid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iu_clsinfo  where  iu_clsinfoid = aiu_clsinfoid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_clsinfo_mref_f
go

create function iu_clsinfo_mref_f  (
 aiu_clsinfo_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_clsinfo_brief_f(iu_clsinfoid, alang)  from iu_clsinfo
where aiu_clsinfo_ref like concat('%',replace(replace(b2g(iu_clsinfoid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists num_zones_brief_f
go

create function num_zones_brief_f  (
 anum_zonesid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if anum_zonesid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from num_zones where num_zonesid=anum_zonesid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(zonemask,'') ,' '  )
  into abrief   from num_zones  where  num_zonesid = anum_zonesid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists num_zones_mref_f
go

create function num_zones_mref_f  (
 anum_zones_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select num_zones_brief_f(num_zonesid, alang)  from num_zones
where anum_zones_ref like concat('%',replace(replace(b2g(num_zonesid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists num_values_brief_f
go

create function num_values_brief_f  (
 anum_valuesid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if anum_valuesid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from num_values where num_valuesid=anum_valuesid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(the_value,'') ,' '  )
  into abrief   from num_values  where  num_valuesid = anum_valuesid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists num_values_mref_f
go

create function num_values_mref_f  (
 anum_values_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select num_values_brief_f(num_valuesid, alang)  from num_values
where anum_values_ref like concat('%',replace(replace(b2g(num_valuesid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists num_head_brief_f
go

create function num_head_brief_f  (
 anum_headid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if anum_headid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from num_head where num_headid=anum_headid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from num_head  where  num_headid = anum_headid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists num_head_mref_f
go

create function num_head_mref_f  (
 anum_head_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select num_head_brief_f(num_headid, alang)  from num_head
where anum_head_ref like concat('%',replace(replace(b2g(num_headid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_filetype_brief_f
go

create function iud_filetype_brief_f  (
 aiud_filetypeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_filetypeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_filetype where iud_filetypeid=aiud_filetypeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_filetype  where  iud_filetypeid = aiud_filetypeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_filetype_mref_f
go

create function iud_filetype_mref_f  (
 aiud_filetype_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_filetype_brief_f(iud_filetypeid, alang)  from iud_filetype
where aiud_filetype_ref like concat('%',replace(replace(b2g(iud_filetypeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists mtzext_def_brief_f
go

create function mtzext_def_brief_f  (
 amtzext_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if amtzext_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from mtzext_def where mtzext_defid=amtzext_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from mtzext_def  where  mtzext_defid = amtzext_defid; 
 select exttype
 into aec  from mtzext_def where mtzext_defid=amtzext_defid;
  case aec 
when 6 then 
  select concat(abrief ,
 'verifyrowext; ') into abrief ;
when 7 then 
  select concat(abrief ,
 'codegenerator; ') into abrief ;
when 5 then 
  select concat(abrief ,
 'defaultext; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'statusext; ') into abrief ;
when 4 then 
  select concat(abrief ,
 'jrnlrunext; ') into abrief ;
when 2 then 
  select concat(abrief ,
 'customext; ') into abrief ;
when 8 then 
  select concat(abrief ,
 'armgenerator; ') into abrief ;
when 1 then 
  select concat(abrief ,
 'onformext; ') into abrief ;
when 3 then 
  select concat(abrief ,
 'jrnladdext; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists mtzext_def_mref_f
go

create function mtzext_def_mref_f  (
 amtzext_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select mtzext_def_brief_f(mtzext_defid, alang)  from mtzext_def
where amtzext_def_ref like concat('%',replace(replace(b2g(mtzext_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists mtzextrel_brief_f
go

create function mtzextrel_brief_f  (
 amtzextrelid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if amtzextrelid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from mtzextrel where mtzextrelid=amtzextrelid;
if aec&lt;&gt;0 then
  set abrief='';
 select theplatform
 into aec  from mtzextrel where mtzextrelid=amtzextrelid;
  case aec 
when 3 then 
  select concat(abrief ,
 'other; ') into abrief ;
when 1 then 
  select concat(abrief ,
 'dotnet; ') into abrief ;
when 2 then 
  select concat(abrief ,
 'java; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'vb6; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists mtzextrel_mref_f
go

create function mtzextrel_mref_f  (
 amtzextrel_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select mtzextrel_brief_f(mtzextrelid, alang)  from mtzextrel
where amtzextrel_ref like concat('%',replace(replace(b2g(mtzextrelid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_videotype_brief_f
go

create function iud_videotype_brief_f  (
 aiud_videotypeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_videotypeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_videotype where iud_videotypeid=aiud_videotypeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_videotype  where  iud_videotypeid = aiud_videotypeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_videotype_mref_f
go

create function iud_videotype_mref_f  (
 aiud_videotype_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_videotype_brief_f(iud_videotypeid, alang)  from iud_videotype
where aiud_videotype_ref like concat('%',replace(replace(b2g(iud_videotypeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_cm_def_brief_f
go

create function iu_cm_def_brief_f  (
 aiu_cm_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_cm_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_cm_def where iu_cm_defid=aiu_cm_defid;
if aec&lt;&gt;0 then
  set abrief='';
select theprocess
 into atmpid  from iu_cm_def  where  iu_cm_defid = aiu_cm_defid; 
 select iu_urok_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(thetheme,'') ,' '  )
  into abrief   from iu_cm_def  where  iu_cm_defid = aiu_cm_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_cm_def_mref_f
go

create function iu_cm_def_mref_f  (
 aiu_cm_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_cm_def_brief_f(iu_cm_defid, alang)  from iu_cm_def
where aiu_cm_def_ref like concat('%',replace(replace(b2g(iu_cm_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_cm_time_brief_f
go

create function iu_cm_time_brief_f  (
 aiu_cm_timeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_cm_timeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_cm_time where iu_cm_timeid=aiu_cm_timeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(thedate,'') ,' '  )
  into abrief   from iu_cm_time  where  iu_cm_timeid = aiu_cm_timeid; 
select theauthor
 into atmpid  from iu_cm_time  where  iu_cm_timeid = aiu_cm_timeid; 
 select iu_u_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(starttime,'') ,' '  )
  into abrief   from iu_cm_time  where  iu_cm_timeid = aiu_cm_timeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_cm_time_mref_f
go

create function iu_cm_time_mref_f  (
 aiu_cm_time_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_cm_time_brief_f(iu_cm_timeid, alang)  from iu_cm_time
where aiu_cm_time_ref like concat('%',replace(replace(b2g(iu_cm_timeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_cm_msg_brief_f
go

create function iu_cm_msg_brief_f  (
 aiu_cm_msgid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_cm_msgid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_cm_msg where iu_cm_msgid=aiu_cm_msgid;
if aec&lt;&gt;0 then
  set abrief='';
select theauthor
 into atmpid  from iu_cm_msg  where  iu_cm_msgid = aiu_cm_msgid; 
 select iu_u_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(thedate,'') ,' '  )
  into abrief   from iu_cm_msg  where  iu_cm_msgid = aiu_cm_msgid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_cm_msg_mref_f
go

create function iu_cm_msg_mref_f  (
 aiu_cm_msg_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_cm_msg_brief_f(iu_cm_msgid, alang)  from iu_cm_msg
where aiu_cm_msg_ref like concat('%',replace(replace(b2g(iu_cm_msgid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_plevent_brief_f
go

create function iu_plevent_brief_f  (
 aiu_pleventid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_pleventid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_plevent where iu_pleventid=aiu_pleventid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(eventtype,'') ,' '  )
  into abrief   from iu_plevent  where  iu_pleventid = aiu_pleventid; 
  select concat(abrief 
  , '' , ifnull(info,'') ,' '  )
  into abrief   from iu_plevent  where  iu_pleventid = aiu_pleventid; 
select doer
 into atmpid  from iu_plevent  where  iu_pleventid = aiu_pleventid; 
 select iu_u_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_plevent_mref_f
go

create function iu_plevent_mref_f  (
 aiu_plevent_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_plevent_brief_f(iu_pleventid, alang)  from iu_plevent
where aiu_plevent_ref like concat('%',replace(replace(b2g(iu_pleventid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_rcfg_mod_brief_f
go

create function iu_rcfg_mod_brief_f  (
 aiu_rcfg_modid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_rcfg_modid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_rcfg_mod where iu_rcfg_modid=aiu_rcfg_modid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from iu_rcfg_mod  where  iu_rcfg_modid = aiu_rcfg_modid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iu_rcfg_mod  where  iu_rcfg_modid = aiu_rcfg_modid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_rcfg_mod_mref_f
go

create function iu_rcfg_mod_mref_f  (
 aiu_rcfg_mod_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_rcfg_mod_brief_f(iu_rcfg_modid, alang)  from iu_rcfg_mod
where aiu_rcfg_mod_ref like concat('%',replace(replace(b2g(iu_rcfg_modid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_rcfg_docmode_brief_f
go

create function iu_rcfg_docmode_brief_f  (
 aiu_rcfg_docmodeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_rcfg_docmodeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_rcfg_docmode where iu_rcfg_docmodeid=aiu_rcfg_docmodeid;
if aec&lt;&gt;0 then
  set abrief='';
select the_document
 into atmpid  from iu_rcfg_docmode  where  iu_rcfg_docmodeid = aiu_rcfg_docmodeid; 
 select objecttype_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_rcfg_docmode_mref_f
go

create function iu_rcfg_docmode_mref_f  (
 aiu_rcfg_docmode_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_rcfg_docmode_brief_f(iu_rcfg_docmodeid, alang)  from iu_rcfg_docmode
where aiu_rcfg_docmode_ref like concat('%',replace(replace(b2g(iu_rcfg_docmodeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_rcfg_def_brief_f
go

create function iu_rcfg_def_brief_f  (
 aiu_rcfg_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_rcfg_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_rcfg_def where iu_rcfg_defid=aiu_rcfg_defid;
if aec&lt;&gt;0 then
  set abrief='';
select therole
 into atmpid  from iu_rcfg_def  where  iu_rcfg_defid = aiu_rcfg_defid; 
 select iu_crole_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_rcfg_def_mref_f
go

create function iu_rcfg_def_mref_f  (
 aiu_rcfg_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_rcfg_def_brief_f(iu_rcfg_defid, alang)  from iu_rcfg_def
where aiu_rcfg_def_ref like concat('%',replace(replace(b2g(iu_rcfg_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_town_brief_f
go

create function iud_town_brief_f  (
 aiud_townid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_townid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_town where iud_townid=aiud_townid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_town  where  iud_townid = aiud_townid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_town_mref_f
go

create function iud_town_mref_f  (
 aiud_town_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_town_brief_f(iud_townid, alang)  from iud_town
where aiud_town_ref like concat('%',replace(replace(b2g(iud_townid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_regtree_brief_f
go

create function iu_regtree_brief_f  (
 aiu_regtreeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_regtreeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_regtree where iu_regtreeid=aiu_regtreeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iu_regtree  where  iu_regtreeid = aiu_regtreeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_regtree_mref_f
go

create function iu_regtree_mref_f  (
 aiu_regtree_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_regtree_brief_f(iu_regtreeid, alang)  from iu_regtree
where aiu_regtree_ref like concat('%',replace(replace(b2g(iu_regtreeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_regdocs_brief_f
go

create function iu_regdocs_brief_f  (
 aiu_regdocsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_regdocsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_regdocs where iu_regdocsid=aiu_regdocsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(docname,'') ,' '  )
  into abrief   from iu_regdocs  where  iu_regdocsid = aiu_regdocsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_regdocs_mref_f
go

create function iu_regdocs_mref_f  (
 aiu_regdocs_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_regdocs_brief_f(iu_regdocsid, alang)  from iu_regdocs
where aiu_regdocs_ref like concat('%',replace(replace(b2g(iu_regdocsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_status_brief_f
go

create function iu_status_brief_f  (
 aiu_statusid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_statusid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_status where iu_statusid=aiu_statusid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iu_status  where  iu_statusid = aiu_statusid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_status_mref_f
go

create function iu_status_mref_f  (
 aiu_status_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_status_brief_f(iu_statusid, alang)  from iu_status
where aiu_status_ref like concat('%',replace(replace(b2g(iu_statusid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_status_doer_brief_f
go

create function iu_status_doer_brief_f  (
 aiu_status_doerid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_status_doerid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_status_doer where iu_status_doerid=aiu_status_doerid;
if aec&lt;&gt;0 then
  set abrief='';
select doertype
 into atmpid  from iu_status_doer  where  iu_status_doerid = aiu_status_doerid; 
 select iu_crole_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
 select doerallowed
 into aec  from iu_status_doer where iu_status_doerid=aiu_status_doerid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_status_doer_mref_f
go

create function iu_status_doer_mref_f  (
 aiu_status_doer_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_status_doer_brief_f(iu_status_doerid, alang)  from iu_status_doer
where aiu_status_doer_ref like concat('%',replace(replace(b2g(iu_status_doerid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_statustask_brief_f
go

create function iu_statustask_brief_f  (
 aiu_statustaskid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_statustaskid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_statustask where iu_statustaskid=aiu_statustaskid;
if aec&lt;&gt;0 then
  set abrief='';
select doertype
 into atmpid  from iu_statustask  where  iu_statustaskid = aiu_statustaskid; 
 select iu_crole_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(info,'') ,' '  )
  into abrief   from iu_statustask  where  iu_statustaskid = aiu_statustaskid; 
 select finishallowed
 into aec  from iu_statustask where iu_statustaskid=aiu_statustaskid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_statustask_mref_f
go

create function iu_statustask_mref_f  (
 aiu_statustask_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_statustask_brief_f(iu_statustaskid, alang)  from iu_statustask
where aiu_statustask_ref like concat('%',replace(replace(b2g(iu_statustaskid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_state_tasklink_brief_f
go

create function iu_state_tasklink_brief_f  (
 aiu_state_tasklinkid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_state_tasklinkid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_state_tasklink where iu_state_tasklinkid=aiu_state_tasklinkid;
if aec&lt;&gt;0 then
  set abrief='';
select doctype
 into atmpid  from iu_state_tasklink  where  iu_state_tasklinkid = aiu_state_tasklinkid; 
 select iud_doctype_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_state_tasklink_mref_f
go

create function iu_state_tasklink_mref_f  (
 aiu_state_tasklink_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_state_tasklink_brief_f(iu_state_tasklinkid, alang)  from iu_state_tasklink
where aiu_state_tasklink_ref like concat('%',replace(replace(b2g(iu_state_tasklinkid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_stausdoc_brief_f
go

create function iu_stausdoc_brief_f  (
 aiu_stausdocid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_stausdocid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_stausdoc where iu_stausdocid=aiu_stausdocid;
if aec&lt;&gt;0 then
  set abrief='';
select doctype
 into atmpid  from iu_stausdoc  where  iu_stausdocid = aiu_stausdocid; 
 select iud_doctype_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iu_stausdoc  where  iu_stausdocid = aiu_stausdocid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_stausdoc_mref_f
go

create function iu_stausdoc_mref_f  (
 aiu_stausdoc_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_stausdoc_brief_f(iu_stausdocid, alang)  from iu_stausdoc
where aiu_stausdoc_ref like concat('%',replace(replace(b2g(iu_stausdocid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_statusnext_brief_f
go

create function iu_statusnext_brief_f  (
 aiu_statusnextid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_statusnextid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_statusnext where iu_statusnextid=aiu_statusnextid;
if aec&lt;&gt;0 then
  set abrief='';
select nextstatus
 into atmpid  from iu_statusnext  where  iu_statusnextid = aiu_statusnextid; 
 select iu_status_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_statusnext_mref_f
go

create function iu_statusnext_mref_f  (
 aiu_statusnext_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_statusnext_brief_f(iu_statusnextid, alang)  from iu_statusnext
where aiu_statusnext_ref like concat('%',replace(replace(b2g(iu_statusnextid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_statuschanger_brief_f
go

create function iu_statuschanger_brief_f  (
 aiu_statuschangerid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_statuschangerid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_statuschanger where iu_statuschangerid=aiu_statuschangerid;
if aec&lt;&gt;0 then
  set abrief='';
select whocan
 into atmpid  from iu_statuschanger  where  iu_statuschangerid = aiu_statuschangerid; 
 select iu_crole_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_statuschanger_mref_f
go

create function iu_statuschanger_mref_f  (
 aiu_statuschanger_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_statuschanger_brief_f(iu_statuschangerid, alang)  from iu_statuschanger
where aiu_statuschanger_ref like concat('%',replace(replace(b2g(iu_statuschangerid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists mtz2job_def_brief_f
go

create function mtz2job_def_brief_f  (
 amtz2job_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if amtz2job_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from mtz2job_def where mtz2job_defid=amtz2job_defid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(eventdate,'') ,' '  )
  into abrief   from mtz2job_def  where  mtz2job_defid = amtz2job_defid; 
  select concat(abrief 
  , '' , ifnull(eventype,'') ,' '  )
  into abrief   from mtz2job_def  where  mtz2job_defid = amtz2job_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists mtz2job_def_mref_f
go

create function mtz2job_def_mref_f  (
 amtz2job_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select mtz2job_def_brief_f(mtz2job_defid, alang)  from mtz2job_def
where amtz2job_def_ref like concat('%',replace(replace(b2g(mtz2job_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_ctype_brief_f
go

create function iud_ctype_brief_f  (
 aiud_ctypeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_ctypeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_ctype where iud_ctypeid=aiud_ctypeid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_ctype  where  iud_ctypeid = aiud_ctypeid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_ctype_mref_f
go

create function iud_ctype_mref_f  (
 aiud_ctype_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_ctype_brief_f(iud_ctypeid, alang)  from iud_ctype
where aiud_ctype_ref like concat('%',replace(replace(b2g(iud_ctypeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iud_spub_brief_f
go

create function iud_spub_brief_f  (
 aiud_spubid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiud_spubid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iud_spub where iud_spubid=aiud_spubid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iud_spub  where  iud_spubid = aiud_spubid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iud_spub_mref_f
go

create function iud_spub_mref_f  (
 aiud_spub_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iud_spub_brief_f(iud_spubid, alang)  from iud_spub
where aiud_spub_ref like concat('%',replace(replace(b2g(iud_spubid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists filterfieldgroup_brief_f
go

create function filterfieldgroup_brief_f  (
 afilterfieldgroupid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afilterfieldgroupid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from filterfieldgroup where filterfieldgroupid=afilterfieldgroupid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from filterfieldgroup  where  filterfieldgroupid = afilterfieldgroupid; 
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from filterfieldgroup  where  filterfieldgroupid = afilterfieldgroupid; 
 select allowignore
 into aec  from filterfieldgroup where filterfieldgroupid=afilterfieldgroupid;
  case aec 
when -1 then 
  select concat(abrief ,
 'да; ') into abrief ;
when 0 then 
  select concat(abrief ,
 'нет; ') into abrief ;
 else 
  select concat(abrief ,
 '; ') into abrief ;
  end case; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists filterfieldgroup_mref_f
go

create function filterfieldgroup_mref_f  (
 afilterfieldgroup_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select filterfieldgroup_brief_f(filterfieldgroupid, alang)  from filterfieldgroup
where afilterfieldgroup_ref like concat('%',replace(replace(b2g(filterfieldgroupid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists fileterfield_brief_f
go

create function fileterfield_brief_f  (
 afileterfieldid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afileterfieldid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from fileterfield where fileterfieldid=afileterfieldid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from fileterfield  where  fileterfieldid = afileterfieldid; 
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from fileterfield  where  fileterfieldid = afileterfieldid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists fileterfield_mref_f
go

create function fileterfield_mref_f  (
 afileterfield_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select fileterfield_brief_f(fileterfieldid, alang)  from fileterfield
where afileterfield_ref like concat('%',replace(replace(b2g(fileterfieldid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists filters_brief_f
go

create function filters_brief_f  (
 afiltersid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if afiltersid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from filters where filtersid=afiltersid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from filters  where  filtersid = afiltersid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists filters_mref_f
go

create function filters_mref_f  (
 afilters_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select filters_brief_f(filtersid, alang)  from filters
where afilters_ref like concat('%',replace(replace(b2g(filtersid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_int_modules_brief_f
go

create function iu_int_modules_brief_f  (
 aiu_int_modulesid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_int_modulesid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_int_modules where iu_int_modulesid=aiu_int_modulesid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iu_int_modules  where  iu_int_modulesid = aiu_int_modulesid; 
  select concat(abrief 
  , '' , ifnull(caption,'') ,' '  )
  into abrief   from iu_int_modules  where  iu_int_modulesid = aiu_int_modulesid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_int_modules_mref_f
go

create function iu_int_modules_mref_f  (
 aiu_int_modules_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_int_modules_brief_f(iu_int_modulesid, alang)  from iu_int_modules
where aiu_int_modules_ref like concat('%',replace(replace(b2g(iu_int_modulesid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_task_brief_f
go

create function iu_task_brief_f  (
 aiu_taskid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_taskid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_task where iu_taskid=aiu_taskid;
if aec&lt;&gt;0 then
  set abrief='';
select doer
 into atmpid  from iu_task  where  iu_taskid = aiu_taskid; 
 select iu_u_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(info,'') ,' '  )
  into abrief   from iu_task  where  iu_taskid = aiu_taskid; 
select theprocess
 into atmpid  from iu_task  where  iu_taskid = aiu_taskid; 
 select iu_urok_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_task_mref_f
go

create function iu_task_mref_f  (
 aiu_task_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_task_brief_f(iu_taskid, alang)  from iu_task
where aiu_task_ref like concat('%',replace(replace(b2g(iu_taskid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_taskattach_brief_f
go

create function iu_taskattach_brief_f  (
 aiu_taskattachid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_taskattachid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_taskattach where iu_taskattachid=aiu_taskattachid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(info,'') ,' '  )
  into abrief   from iu_taskattach  where  iu_taskattachid = aiu_taskattachid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_taskattach_mref_f
go

create function iu_taskattach_mref_f  (
 aiu_taskattach_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_taskattach_brief_f(iu_taskattachid, alang)  from iu_taskattach
where aiu_taskattach_ref like concat('%',replace(replace(b2g(iu_taskattachid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_taskvideo_brief_f
go

create function iu_taskvideo_brief_f  (
 aiu_taskvideoid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_taskvideoid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_taskvideo where iu_taskvideoid=aiu_taskvideoid;
if aec&lt;&gt;0 then
  set abrief='';
select doctype
 into atmpid  from iu_taskvideo  where  iu_taskvideoid = aiu_taskvideoid; 
 select iud_videotype_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_taskvideo_mref_f
go

create function iu_taskvideo_mref_f  (
 aiu_taskvideo_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_taskvideo_brief_f(iu_taskvideoid, alang)  from iu_taskvideo
where aiu_taskvideo_ref like concat('%',replace(replace(b2g(iu_taskvideoid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_taskrefs_brief_f
go

create function iu_taskrefs_brief_f  (
 aiu_taskrefsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_taskrefsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_taskrefs where iu_taskrefsid=aiu_taskrefsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(info,'') ,' '  )
  into abrief   from iu_taskrefs  where  iu_taskrefsid = aiu_taskrefsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_taskrefs_mref_f
go

create function iu_taskrefs_mref_f  (
 aiu_taskrefs_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_taskrefs_brief_f(iu_taskrefsid, alang)  from iu_taskrefs
where aiu_taskrefs_ref like concat('%',replace(replace(b2g(iu_taskrefsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_l_def_brief_f
go

create function iu_l_def_brief_f  (
 aiu_l_defid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_l_defid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_l_def where iu_l_defid=aiu_l_defid;
if aec&lt;&gt;0 then
  set abrief='';
select sender
 into atmpid  from iu_l_def  where  iu_l_defid = aiu_l_defid; 
 select iu_u_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
select doer
 into atmpid  from iu_l_def  where  iu_l_defid = aiu_l_defid; 
 select iu_u_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
  select concat(abrief 
  , '' , ifnull(info,'') ,' '  )
  into abrief   from iu_l_def  where  iu_l_defid = aiu_l_defid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_l_def_mref_f
go

create function iu_l_def_mref_f  (
 aiu_l_def_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_l_def_brief_f(iu_l_defid, alang)  from iu_l_def
where aiu_l_def_ref like concat('%',replace(replace(b2g(iu_l_defid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_tm_records_brief_f
go

create function iu_tm_records_brief_f  (
 aiu_tm_recordsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_tm_recordsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_tm_records where iu_tm_recordsid=aiu_tm_recordsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(passport,'') ,' '  )
  into abrief   from iu_tm_records  where  iu_tm_recordsid = aiu_tm_recordsid; 
  select concat(abrief 
  , '' , ifnull(inn,'') ,' '  )
  into abrief   from iu_tm_records  where  iu_tm_recordsid = aiu_tm_recordsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_tm_records_mref_f
go

create function iu_tm_records_mref_f  (
 aiu_tm_records_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_tm_records_brief_f(iu_tm_recordsid, alang)  from iu_tm_records
where aiu_tm_records_ref like concat('%',replace(replace(b2g(iu_tm_recordsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_tmdef_brief_f
go

create function iu_tmdef_brief_f  (
 aiu_tmdefid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_tmdefid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_tmdef where iu_tmdefid=aiu_tmdefid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(lastname,'') ,' '  )
  into abrief   from iu_tmdef  where  iu_tmdefid = aiu_tmdefid; 
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from iu_tmdef  where  iu_tmdefid = aiu_tmdefid; 
  select concat(abrief 
  , '' , ifnull(surname,'') ,' '  )
  into abrief   from iu_tmdef  where  iu_tmdefid = aiu_tmdefid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_tmdef_mref_f
go

create function iu_tmdef_mref_f  (
 aiu_tmdef_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_tmdef_brief_f(iu_tmdefid, alang)  from iu_tmdef
where aiu_tmdef_ref like concat('%',replace(replace(b2g(iu_tmdefid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_tmcadr_brief_f
go

create function iu_tmcadr_brief_f  (
 aiu_tmcadrid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_tmcadrid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_tmcadr where iu_tmcadrid=aiu_tmcadrid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(info,'') ,' '  )
  into abrief   from iu_tmcadr  where  iu_tmcadrid = aiu_tmcadrid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_tmcadr_mref_f
go

create function iu_tmcadr_mref_f  (
 aiu_tmcadr_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_tmcadr_brief_f(iu_tmcadrid, alang)  from iu_tmcadr
where aiu_tmcadr_ref like concat('%',replace(replace(b2g(iu_tmcadrid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_tm_act_brief_f
go

create function iu_tm_act_brief_f  (
 aiu_tm_actid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_tm_actid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_tm_act where iu_tm_actid=aiu_tm_actid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(aktnum,'') ,' '  )
  into abrief   from iu_tm_act  where  iu_tm_actid = aiu_tm_actid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_tm_act_mref_f
go

create function iu_tm_act_mref_f  (
 aiu_tm_act_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_tm_act_brief_f(iu_tm_actid, alang)  from iu_tm_act
where aiu_tm_act_ref like concat('%',replace(replace(b2g(iu_tm_actid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_tm_actfile_brief_f
go

create function iu_tm_actfile_brief_f  (
 aiu_tm_actfileid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_tm_actfileid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_tm_actfile where iu_tm_actfileid=aiu_tm_actfileid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(info,'') ,' '  )
  into abrief   from iu_tm_actfile  where  iu_tm_actfileid = aiu_tm_actfileid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_tm_actfile_mref_f
go

create function iu_tm_actfile_mref_f  (
 aiu_tm_actfile_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_tm_actfile_brief_f(iu_tm_actfileid, alang)  from iu_tm_actfile
where aiu_tm_actfile_ref like concat('%',replace(replace(b2g(iu_tm_actfileid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_tm_dog_brief_f
go

create function iu_tm_dog_brief_f  (
 aiu_tm_dogid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_tm_dogid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_tm_dog where iu_tm_dogid=aiu_tm_dogid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(thedate,'') ,' '  )
  into abrief   from iu_tm_dog  where  iu_tm_dogid = aiu_tm_dogid; 
  select concat(abrief 
  , '' , ifnull(thenumber,'') ,' '  )
  into abrief   from iu_tm_dog  where  iu_tm_dogid = aiu_tm_dogid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_tm_dog_mref_f
go

create function iu_tm_dog_mref_f  (
 aiu_tm_dog_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_tm_dog_brief_f(iu_tm_dogid, alang)  from iu_tm_dog
where aiu_tm_dog_ref like concat('%',replace(replace(b2g(iu_tm_dogid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists rptstruct_brief_f
go

create function rptstruct_brief_f  (
 arptstructid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if arptstructid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from rptstruct where rptstructid=arptstructid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from rptstruct  where  rptstructid = arptstructid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists rptstruct_mref_f
go

create function rptstruct_mref_f  (
 arptstruct_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select rptstruct_brief_f(rptstructid, alang)  from rptstruct
where arptstruct_ref like concat('%',replace(replace(b2g(rptstructid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists rptfields_brief_f
go

create function rptfields_brief_f  (
 arptfieldsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if arptfieldsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from rptfields where rptfieldsid=arptfieldsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from rptfields  where  rptfieldsid = arptfieldsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists rptfields_mref_f
go

create function rptfields_mref_f  (
 arptfields_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select rptfields_brief_f(rptfieldsid, alang)  from rptfields
where arptfields_ref like concat('%',replace(replace(b2g(rptfieldsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists rptformula_brief_f
go

create function rptformula_brief_f  (
 arptformulaid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if arptformulaid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from rptformula where rptformulaid=arptformulaid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from rptformula  where  rptformulaid = arptformulaid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists rptformula_mref_f
go

create function rptformula_mref_f  (
 arptformula_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select rptformula_brief_f(rptformulaid, alang)  from rptformula
where arptformula_ref like concat('%',replace(replace(b2g(rptformulaid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists reports_brief_f
go

create function reports_brief_f  (
 areportsid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if areportsid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from reports where reportsid=areportsid;
if aec&lt;&gt;0 then
  set abrief='';
  select concat(abrief 
  , '' , ifnull(name,'') ,' '  )
  into abrief   from reports  where  reportsid = areportsid; 
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists reports_mref_f
go

create function reports_mref_f  (
 areports_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select reports_brief_f(reportsid, alang)  from reports
where areports_ref like concat('%',replace(replace(b2g(reportsid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO



drop function if exists iu_subsribe_brief_f
go

create function iu_subsribe_brief_f  (
 aiu_subsribeid binary(16)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare abrief varchar(255);
 declare atmpstr varchar(255);
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare atmpmr varchar(255); 
 declare amlftemp varchar(255);
 declare amlfbrief varchar(255);
 declare aec int;
if aiu_subsribeid is null then  set abrief=''; return abrief; end if;
select count(*) into aec from iu_subsribe where iu_subsribeid=aiu_subsribeid;
if aec&lt;&gt;0 then
  set abrief='';
select subscriber
 into atmpid  from iu_subsribe  where  iu_subsribeid = aiu_subsribeid; 
 select iu_u_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
select theprocess
 into atmpid  from iu_subsribe  where  iu_subsribeid = aiu_subsribeid; 
 select iu_urok_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
select doer
 into atmpid  from iu_subsribe  where  iu_subsribeid = aiu_subsribeid; 
 select iu_u_def_brief_f(atmpid, alang) into atmpbrief;
  set abrief= concat(abrief , '' , ifnull(atmpbrief,'') , ' ');
else
  set abrief= '';
end if;
return abrief;
end  
GO



drop function if exists iu_subsribe_mref_f
go

create function iu_subsribe_mref_f  (
 aiu_subsribe_ref varchar(255)
 ,alang varchar(25)
) returns varchar(255) reads sql data  begin  
 declare amref varchar(255);
 declare atmpbrief varchar(255);
 declare fetch_done int default false;
declare multiref_cursor cursor for
select iu_subsribe_brief_f(iu_subsribeid, alang)  from iu_subsribe
where aiu_subsribe_ref like concat('%',replace(replace(b2g(iu_subsribeid),'{',''),'}',''),'%');
 declare continue handler for not found set fetch_done = true;
set amref='';
open multiref_cursor;
  set  fetch_done=false;
fetch multiref_cursor into atmpbrief;
while not fetch_done do 
    if amref&lt;&gt;'' then
        set amref=concat(amref,',');
    end if;
    set amref=concat(amref,atmpbrief);
  set  fetch_done=false;
    fetch multiref_cursor into atmpbrief;
end while;
close multiref_cursor;
set amref=left(amref,255);
return amref;
end 
GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Kernel procs" File="">
    <BlockHolder BlockName="--body" BlockCode=" 


drop function if exists b2g
go
        create  function `b2g`(
    $data binary(16)
) returns char(38) 
    deterministic
begin
    declare $result char(38) default null;
    if $data is not null then
        set $result = concat('{',hex(substring($data,4,1)),hex(substring($data,3,1)),hex(substring($data,2,1)), hex(substring($data,1,1)) , '-', 
                hex(substring($data,6,1)),hex(substring($data,5,1)),'-',
                hex(substring($data,8,1)) , hex(substring($data,7,1)),'-',
                hex(substring($data,9,2)),'-',hex(substring($data,11,6)) ,'}');
        set $result = ucase($result);
    end if;
    return $result;
end
go

drop function if exists g2b
go
create  function `g2b`(
    $data varchar(38)
) returns binary(16)
    deterministic
begin
    declare $result binary(16) default null;
    if $data is not null then
        set $data = replace($data,'-','');
        set $data = replace($data,'{','');
        set $data = replace($data,'}','');
        set $result = concat(unhex(substring($data,7,2)),unhex(substring($data,5,2)),unhex(substring($data,3,2)), unhex(substring($data,1,2)),
                unhex(substring($data,11,2)),unhex(substring($data,9,2)),unhex(substring($data,15,2)) , unhex(substring($data,13,2)),
                unhex(substring($data,17,16)));
    end if;
    return $result;
end
go

drop function if exists checkoperation
go
create  function `checkoperation`(
    acursession varchar(38)
    ,aopname varchar(255)
) returns tinyint(1)
    reads sql data
begin
  declare isok int;
  select 0 into isok;
  select roles_operations.allowaction into isok from   roles_operations  
      join roles_def on roles_def.instanceid=roles_operations.instanceid
      join the_session on the_session.userrole=roles_def.roles_defid
      where the_session.the_sessionid=g2b(acursession) 
      and roles_operations.name=aopname;
  if isok&lt;&gt;0 then
      return 1;
  else
      return 0;
  end if;
end
go

drop function if exists getbrieffromxml
go
create function getbrieffromxml (axmlsource varchar(255))
returns varchar(255)
  deterministic 
body:begin
declare aoutstr  varchar(255);
declare afrom int;
declare ato int;
set afrom = charindex('&lt;brief&gt;', axmlsource);
set ato = charindex('&lt;/brief&gt;', axmlsource);
if (afrom &gt; 0 and ato &gt; 0) then
  set aoutstr = substring(axmlsource, afrom + 7, ato - afrom - 7);
else
  set aoutstr = '';
end if;
return aoutstr;
end
go

drop function if exists getidfromxml
go
create function getidfromxml (axmlsource varchar(255))
returns varchar(255)
 deterministic 
begin
declare aoutstr  varchar(255);
declare afrom  int;
declare ato  int;

set afrom = charindex('&lt;id&gt;', axmlsource);
set ato = charindex('&lt;/id&gt;', axmlsource);
if (afrom &gt; 0 and ato &gt; 0) then
  set aoutstr = substring(axmlsource, afrom + 4, ato - afrom - 4);
 else 
  set aoutstr = '';
end if;

return aoutstr;
end
go

drop procedure if exists instance_owner
go
create procedure instance_owner (  acursession varchar(38) ,ainstanceid varchar(38), aownerpartname varchar(255), aownerrowid varchar(38))
body:begin
declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
select count(*) into aec from instance where instanceid=g2b(ainstanceid);
if aec&gt;0 then
  if aownerpartname is null or aownerrowid is null then
     update instance set ownerpartname=null, ownerrowid = null where instanceid=g2b(ainstanceid);
  else
     update instance set ownerpartname=aownerpartname, ownerrowid = g2b(aownerrowid) where instanceid=g2b(ainstanceid);
  end if;
end if;
end
go


drop procedure if exists sysoptions_save
go
create procedure sysoptions_save ( asysoptionsid varchar(38), aname varchar(255),avalue varchar (255), aoptiontype varchar(255)) 
begin
declare aec  int;
select count(*) into aec from sysoptions where sysoptionsid=g2b(asysoptionsid);
if aec&gt;0 then
  update sysoptions set name=aname, value=avalue, optiontype=aoptiontype where sysoptionsid=g2b(asysoptionsid);
else
  insert into sysoptions (sysoptionsid, name, value, optiontype)values(g2b(asysoptionsid),aname,avalue,aoptiontype);
end if;
end
go


drop procedure if exists instance_save
go
create procedure instance_save (
acursession varchar(38),
ainstanceid varchar(38),
aobjtype varchar(255),
aname varchar(255)
) 
body:begin
 declare atmpstr varchar(255);
 declare assid binary(16);
 declare atmpid binary(16);
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare astatusid binary(16);
declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
select count(*) into aec from instance where instanceid=g2b(ainstanceid);
if aec&gt;0 then
   update instance set name = aname where  instanceid=g2b(ainstanceid);
else
    select count(*) into aec from typelist where name = aobjtype;
    if aec then
      start transaction;
      set astatusid=null;
      select objstatusid into astatusid from objstatus join objecttype on
      objecttype.objecttypeid=objstatus.parentstructrowid and objecttype.name=aobjtype and isstartup&lt;&gt;0;
      if not astatusid is null then
        insert into instance(instanceid,name,objtype,status) values(g2b(ainstanceid),aname,aobjtype,g2b(astatusid));
      else 
        insert into instance(instanceid,name,objtype) values(g2b(ainstanceid),aname,aobjtype);
      end if; 
      commit;
    end if;
end if;
select 'ok' result;
end
go

drop procedure if exists instance_delete
go
create procedure instance_delete (
acursession varchar(38),
ainstanceid varchar(38)
)
body:begin
   declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
   select count(*) into aec from instance where instanceid=g2b(ainstanceid);
    if aec&gt;0 then
         delete from instance where instanceid=g2b(ainstanceid);
        end if;
end
go

drop procedure if exists instance_archive
go
create procedure instance_archive (
acursession varchar(38),
ainstanceid varchar(38)
)
body:begin
   declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
   select count(*) into aec from instance where instanceid=g2b(ainstanceid);
    if aec&gt;0 then
         update instance set archived=1 where instanceid=g2b(ainstanceid);
    end if;
end
go

drop procedure if exists instance_rearchive
go
create procedure instance_rearchive (
acursession varchar(38),
ainstanceid varchar(38)
)
body:begin
   declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
   select count(*) into aec from instance where instanceid=g2b(ainstanceid);
    if aec&gt;0 then
         update instance set archived=0 where instanceid=g2b(ainstanceid);
    end if;
end
go

drop procedure if exists instance_hcl
go
create procedure instance_hcl (
acursession varchar(38),
arowid varchar(38),
out aislocked int
) 
body:begin
declare atmpstr varchar(255);
declare aobjtype varchar(255);
   declare aec  int;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
   select count(*) into aec from instance where instanceid=g2b(ainstanceid);
    if aec&gt;0 then
    set aislocked=0;
    end if;
end
go

drop procedure if exists instance_islocked
go
 create  procedure instance_islocked (
 acursession varchar(38),
 arowid varchar(38) ,
 out aislocked integer 
) body:begin
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
   declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
end if;
   select count(*) into aec from instance where instanceid=g2b(arowid);
   if aec&gt;0 then
        select auserid = usersid  from the_session where the_sessionid=g2b(acursession);
        select alockuserid = lockuserid,alocksessionid = locksessionid from instance where instanceid=g2b(arowid);
        /* verify this row */
   if not alockuserid is null then
    if  alockuserid &lt;&gt; auserid then
      set aislocked = 4; /* checkout by another user */
      leave body;
    else
     set aislocked = 2; /* checkout by caller */
     leave body;
    end if;
   end if;
   if not alocksessionid is null then
        if  alocksessionid &lt;&gt; acursession then
            set aislocked = 3; /* lockes by another user */
            leave body;
        else
            set aislocked = 1; /* locked by caller */
            leave body;
        end if;
   end if;
  end if;
 end
go

drop procedure if exists qr_or_qr
go
create procedure qr_or_qr( aid1 varchar(38), aid2 varchar(38),aidout varchar(38),out acnt integer )
body:begin
delete from queryresult where queryresultid=g2b(aidout);
insert into queryresult(queryresultid,result)
select distinct aidout, result from queryresult where queryresultid in (aid1,aid2);
select acnt=count(*) from queryresult where queryresultid=g2b(aidout);
end
go

drop procedure if exists instance_lock
go
create  procedure instance_lock  (
 acursession varchar(38),
 arowid varchar(38) ,
 alockmode integer
) body:begin

 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aec  int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0  then
    leave body;
 end if;
 select count(*) into aec from instance where instanceid=g2b(arowid);
 if aec&gt;0 then
  select auserid = usersid  from the_session where the_sessionid=g2b(acursession);
  call instance_islocked( acursession,arowid,aislocked);
  if aislocked &gt;=3 then
    leave body;
  end if;
   if  alockmode =2 then
    update instance  set lockuserid =g2b(auserid ),locksessionid=null  where instanceid=g2b(arowid);
     leave body;
   end if;
   if  alockmode =1 then
    update instance  set lockuserid=null ,locksessionid =g2b(acursession)  where instanceid=g2b(arowid);
     leave body;
   end if;
end if;
 end

go

drop procedure if exists instance_unlock
go
create  procedure instance_unlock /*пользователи системы*/ (
 acursession varchar(38),
 arowid varchar(38)
) body:begin
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked int;
 declare aparenttable varchar(255);
 declare aec  int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0  then
    leave body;
 end if;
 select count(*) into aec from instance where instanceid=g2b(arowid);
 if aec&gt;0 then
 call instance_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3 then
    leave body;
  end if;
   if  aislocked =2 then
    update instance set lockuserid=null   where instanceid=g2b(arowid);
     leave body;
   end if;
   if  aislocked =1 then
    update instance set locksessionid=null   where instanceid=g2b(arowid);
     leave body;
   end if;
end if;
 end

go

drop procedure if exists instance_brief
go
  create procedure instance_brief  (
 acursession varchar(38),
 ainstanceid varchar(38),
 out abrief varchar(255)
) body:begin
 declare atmpstr varchar(255);
 declare aaccess int;
 declare atmpbrief varchar(255);
 declare atmpid binary(16);
 declare aec  int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0  then
    leave body;
 end if;
 if ainstanceid is null then set abrief=''; leave body; end if;
 select count(*) into aec from instance where instanceid=g2b(ainstanceid);
 if aec&gt;0 then
   select concat(ifnull(name,''),'; ',ifnull(objtype,'')) into abrief 
   from instance  where  instanceid = g2b(ainstanceid);
 else 
   set abrief= 'неверный идентификатор';
end if;
end

go

drop procedure if exists rowparents
go
        create  procedure rowparents
        (aqueryid varchar(38)
        ,arowid varchar(38)
        ,atable varchar (255)
        ,acursession varchar(38)
        )
body:   begin()
declare aplevel integer;
declare aparent varchar(255);
declare aprev varchar(255);
declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0  then
    leave body;
  end if;
set aparent =atable;
set @tmpid = g2b(arowid);
set aplevel =0;
delete from rpresult where rpresultid  =g2b(aqueryid);
insert into rpresult(rpresultid,parentlevel,partname,rowid)values(g2b(aqueryid),aplevel,atable,g2b(arowid));
again:loop
set aplevel =aplevel + 1;
set aprev = aparent;
set aparent = null;
select value into aparent from sysoptions where optiontype ='parent' and  name=aprev;
 if aparent is null then
    set @ss = concat('select instanceid into @tmprowid from ' , aprev , ' where ' ,aprev ,'id=?');
    prepare stmt from @ss;
    execute stmt using @tmpid;
    deallocate prepare stmt;
   insert into rpresult(rpresultid,parentlevel,partname,rowid)values(g2b(aqueryid),aplevel,'instance',@tmprowid);
   leave again;
 else
    set @ss = concat('select parentstructrowid  into @tmprowid from ' , aprev , ' where ' ,aprev ,'id=?');
    prepare stmt from @ss;
    execute stmt using @tmpid;
    deallocate prepare stmt;
    set @tmpid = @tmprowid;
   insert into rpresult(rpresultid,parentlevel,partname,rowid)
   values(g2b(aqueryid),aplevel,aparent,@tmprowid);
 end if;
end loop again;
end
go
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures" File="">
    <BlockHolder BlockName="--TableProc" BlockCode=" 


drop procedure if exists iud_stagedef_brief
go

create procedure iud_stagedef_brief  (
 acursession varchar(38),
 aiud_stagedefid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_stagedefid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_stagedef where iud_stagedefid=g2b(aiud_stagedefid);
 if  aec &gt;0 then
   set abrief=iud_stagedef_brief_f(g2b(aiud_stagedefid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_stagedef_delete
go

create procedure iud_stagedef_delete /*этапы процесса*/ (
 acursession varchar(38),
 aiud_stagedefid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_stagedef where iud_stagedefid=g2b(aiud_stagedefid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_stage.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_stagedef' result;
    leave body;
  end if;
 call iud_stagedef_logger(acursession,aiud_stagedefid) ; 
  delete from  iud_stagedef 
  where  iud_stagedefid = g2b(aiud_stagedefid) ;
  delete from num_values where ownerpartname='iud_stagedef' and ownerrowid=g2b(aiud_stagedefid);
  end if;
    select 'ok' result;
 end 
go
GO

/*этапы*/

drop procedure if exists iud_stagedef_save
go

create procedure iud_stagedef_save /*этапы процесса*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_stagedefid varchar(38)
,aname
 varchar (120)/* название *//* название */
,asequence
 integer/* порядок вывода *//* порядок вывода */
,astageicon
 varchar (80)/* иконка *//* иконка */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_stagedef where iud_stagedefid=g2b(aiud_stagedefid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_stage.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_stagedef' result;
    leave body;
  end if;
 start transaction ; 
 call iud_stagedef_logger(acursession,aiud_stagedefid) ; 
 update  iud_stagedef set changestamp=now()
,
  name=aname
,
  sequence=asequence
,
  stageicon=astageicon
  where  iud_stagedefid = g2b(aiud_stagedefid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_stagedef where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=этапы правило=(уникальность для стадии.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_stagedef_client_trigger(acursession,aiud_stagedefid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_stage.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_stagedef' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_stagedef
 (  iud_stagedefid 
,instanceid
,name

,sequence

,stageicon

 ) values ( g2b(aiud_stagedefid) 
,g2b(ainstanceid)
,aname

,asequence

,astageicon

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_stagedef where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=этапы правило=(уникальность для стадии.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_stagedef_client_trigger(acursession,aiud_stagedefid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_stagedef_copy
go

create procedure iud_stagedef_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_stagedef 
 ( iud_stagedefid 
,instanceid
,name

,sequence

,stageicon

 ) select 
copymap(acopyaction,b2g(iud_stagedefid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,sequence

,stageicon

 from iud_stagedef
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_stagedef_logger
go

create procedure iud_stagedef_logger /*этапы процесса*/ (
 acursession varchar(38),
 aiud_stagedefid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_stagedef_parent
go
create procedure iud_stagedef_parent /* этапы процесса*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_stagedef where  iud_stagedefid=arowid;
 end 
go
GO


drop procedure if exists iud_stagedef_islocked
go
create procedure iud_stagedef_islocked /* этапы процесса */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_stagedef where iud_stagedefid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_stagedef_lock
go
create procedure iud_stagedef_lock /* этапы процесса */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_stagedef_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_stagedef set lockuserid =auserid ,locksessionid=null  where iud_stagedefid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_stagedef set lockuserid=null ,locksessionid =acursession  where iud_stagedefid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_stagedef_unlock
go
create procedure iud_stagedef_unlock /* этапы процесса */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_stagedef_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_stagedef set lockuserid =null  where iud_stagedefid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_stagedef set locksessionid =null  where iud_stagedefid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_stagedef_client_trigger
GO

create procedure iud_stagedef_client_trigger  (
 acursession varchar(38),
 aiud_stagedefid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_adt_doc_brief
go

create procedure iud_adt_doc_brief  (
 acursession varchar(38),
 aiud_adt_docid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_adt_docid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_adt_doc where iud_adt_docid=g2b(aiud_adt_docid);
 if  aec &gt;0 then
   set abrief=iud_adt_doc_brief_f(g2b(aiud_adt_docid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_adt_doc_delete
go

create procedure iud_adt_doc_delete /*тип документа к акту*/ (
 acursession varchar(38),
 aiud_adt_docid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_adt_doc where iud_adt_docid=g2b(aiud_adt_docid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_adtype.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_adt_doc' result;
    leave body;
  end if;
 call iud_adt_doc_logger(acursession,aiud_adt_docid) ; 
  delete from  iud_adt_doc 
  where  iud_adt_docid = g2b(aiud_adt_docid) ;
  delete from num_values where ownerpartname='iud_adt_doc' and ownerrowid=g2b(aiud_adt_docid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип документа к акту*/

drop procedure if exists iud_adt_doc_save
go

create procedure iud_adt_doc_save /*тип документа к акту*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_adt_docid varchar(38)
,aname
 varchar (120)/* название *//* название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_adt_doc where iud_adt_docid=g2b(aiud_adt_docid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_adtype.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_adt_doc' result;
    leave body;
  end if;
 start transaction ; 
 call iud_adt_doc_logger(acursession,aiud_adt_docid) ; 
 update  iud_adt_doc set changestamp=now()
,
  name=aname
  where  iud_adt_docid = g2b(aiud_adt_docid) ;


call iud_adt_doc_client_trigger(acursession,aiud_adt_docid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_adtype.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_adt_doc' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_adt_doc
 (  iud_adt_docid 
,instanceid
,name

 ) values ( g2b(aiud_adt_docid) 
,g2b(ainstanceid)
,aname

 ) ;


call iud_adt_doc_client_trigger(acursession,aiud_adt_docid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_adt_doc_copy
go

create procedure iud_adt_doc_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_adt_doc 
 ( iud_adt_docid 
,instanceid
,name

 ) select 
copymap(acopyaction,b2g(iud_adt_docid)) 
,copymap(acopyaction,b2g(instanceid))
,name

 from iud_adt_doc
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_adt_doc_logger
go

create procedure iud_adt_doc_logger /*тип документа к акту*/ (
 acursession varchar(38),
 aiud_adt_docid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_adt_doc_parent
go
create procedure iud_adt_doc_parent /* тип документа к акту*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_adt_doc where  iud_adt_docid=arowid;
 end 
go
GO


drop procedure if exists iud_adt_doc_islocked
go
create procedure iud_adt_doc_islocked /* тип документа к акту */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_adt_doc where iud_adt_docid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_adt_doc_lock
go
create procedure iud_adt_doc_lock /* тип документа к акту */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_adt_doc_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_adt_doc set lockuserid =auserid ,locksessionid=null  where iud_adt_docid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_adt_doc set lockuserid=null ,locksessionid =acursession  where iud_adt_docid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_adt_doc_unlock
go
create procedure iud_adt_doc_unlock /* тип документа к акту */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_adt_doc_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_adt_doc set lockuserid =null  where iud_adt_docid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_adt_doc set locksessionid =null  where iud_adt_docid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_adt_doc_client_trigger
GO

create procedure iud_adt_doc_client_trigger  (
 acursession varchar(38),
 aiud_adt_docid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_orgtree_brief
go

create procedure iu_orgtree_brief  (
 acursession varchar(38),
 aiu_orgtreeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_orgtreeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_orgtree where iu_orgtreeid=g2b(aiu_orgtreeid);
 if  aec &gt;0 then
   set abrief=iu_orgtree_brief_f(g2b(aiu_orgtreeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_orgtree_delete
go

create procedure iu_orgtree_delete /*орг. структура*/ (
 acursession varchar(38),
 aiu_orgtreeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_orgtree where iu_orgtreeid=g2b(aiu_orgtreeid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_org.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_orgtree' result;
    leave body;
  end if;
 call iu_orgtree_logger(acursession,aiu_orgtreeid) ; 
  delete from  iu_orgtree 
  where  iu_orgtreeid = g2b(aiu_orgtreeid) ;
  delete from num_values where ownerpartname='iu_orgtree' and ownerrowid=g2b(aiu_orgtreeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*орг структура*/

drop procedure if exists iu_orgtree_save
go

create procedure iu_orgtree_save /*орг. структура*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_orgtreeid varchar(38)
,aparentrowid varchar(38) 
,aname
 varchar (120)/* название *//* название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_orgtree where iu_orgtreeid=g2b(aiu_orgtreeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_org.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_orgtree' result;
    leave body;
  end if;
 start transaction ; 
 call iu_orgtree_logger(acursession,aiu_orgtreeid) ; 
 update  iu_orgtree set changestamp=now()
,parentrowid= g2b(aparentrowid)
,
  name=aname
  where  iu_orgtreeid = g2b(aiu_orgtreeid) ;


call iu_orgtree_client_trigger(acursession,aiu_orgtreeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_org.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_orgtree' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_orgtree
 (  iu_orgtreeid 
,parentrowid
,instanceid
,name

 ) values ( g2b(aiu_orgtreeid) 
,g2b(aparentrowid)
,g2b(ainstanceid)
,aname

 ) ;


call iu_orgtree_client_trigger(acursession,aiu_orgtreeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_orgusr_brief
go

create procedure iu_orgusr_brief  (
 acursession varchar(38),
 aiu_orgusrid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_orgusrid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_orgusr where iu_orgusrid=g2b(aiu_orgusrid);
 if  aec &gt;0 then
   set abrief=iu_orgusr_brief_f(g2b(aiu_orgusrid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_orgusr_delete
go

create procedure iu_orgusr_delete /*сотрудники*/ (
 acursession varchar(38),
 aiu_orgusrid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_orgusr where iu_orgusrid=g2b(aiu_orgusrid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_org.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_orgusr' result;
    leave body;
  end if;
 call iu_orgusr_logger(acursession,aiu_orgusrid) ; 
  delete from  iu_orgusr 
  where  iu_orgusrid = g2b(aiu_orgusrid) ;
  delete from num_values where ownerpartname='iu_orgusr' and ownerrowid=g2b(aiu_orgusrid);
  end if;
    select 'ok' result;
 end 
go
GO

/*сотрудники*/

drop procedure if exists iu_orgusr_save
go

create procedure iu_orgusr_save /*сотрудники*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aiu_orgusrid varchar(38)
,aorguser varchar(38)/* сотрудник *//* сотрудник */
,aismanager
 integer/* начальник подразделения *//* начальник подразделения */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_orgusr where iu_orgusrid=g2b(aiu_orgusrid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_org.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_orgusr' result;
    leave body;
  end if;
 start transaction ; 
 call iu_orgusr_logger(acursession,aiu_orgusrid) ; 
 update  iu_orgusr set changestamp=now()
,
  orguser=g2b(aorguser)
,
  ismanager=aismanager
  where  iu_orgusrid = g2b(aiu_orgusrid) ;


call iu_orgusr_client_trigger(acursession,aiu_orgusrid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_org.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_orgusr' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_orgusr
 (  iu_orgusrid 
,parentstructrowid
,orguser

,ismanager

 ) values ( g2b(aiu_orgusrid) 
,g2b(aparentstructrowid)
,g2b(aorguser)

,aismanager

 ) ;


call iu_orgusr_client_trigger(acursession,aiu_orgusrid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_orgusr_copy
go

create procedure iu_orgusr_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_orgusr 
 ( iu_orgusrid 
,parentstructrowid
,orguser

,ismanager

 ) select 
copymap(acopyaction,b2g(iu_orgusrid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,orguser

,ismanager

 from iu_orgusr
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists iu_orgtree_copy
go

create procedure iu_orgtree_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_iu_orgtree cursor for
select iu_orgtreeid from iu_orgtree where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_orgtree 
 ( iu_orgtreeid 
,instanceid
,parentrowid
,name

 ) select 
copymap(acopyaction,b2g(iu_orgtreeid)) 
,copymap(acopyaction,b2g(instanceid))
,copymap(acopyaction,b2g(parentrowid))
,name

 from iu_orgtree
 where instanceid =g2b( ainstanceid); 
open copy_cursor_iu_orgtree;
  set  fetch_done=false;
fetch copy_cursor_iu_orgtree into aid;
while not fetch_done do 
    call iu_orgusr_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_iu_orgtree into aid;
end while;

close copy_cursor_iu_orgtree;
 end 
go
GO


drop procedure if exists iu_orgtree_logger
go

create procedure iu_orgtree_logger /*орг. структура*/ (
 acursession varchar(38),
 aiu_orgtreeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_orgusr_logger
go

create procedure iu_orgusr_logger /*сотрудники*/ (
 acursession varchar(38),
 aiu_orgusrid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_orgtree_parent
go
create procedure iu_orgtree_parent /* орг. структура*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_orgtree where  iu_orgtreeid=arowid;
 end 
go
GO


drop procedure if exists iu_orgtree_islocked
go
create procedure iu_orgtree_islocked /* орг. структура */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_orgtree where iu_orgtreeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_orgtree_lock
go
create procedure iu_orgtree_lock /* орг. структура */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_orgtree_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_orgtree set lockuserid =auserid ,locksessionid=null  where iu_orgtreeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_orgtree set lockuserid=null ,locksessionid =acursession  where iu_orgtreeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_orgtree_unlock
go
create procedure iu_orgtree_unlock /* орг. структура */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_orgtree_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_orgtree set lockuserid =null  where iu_orgtreeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_orgtree set locksessionid =null  where iu_orgtreeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_orgtree_client_trigger
GO

create procedure iu_orgtree_client_trigger  (
 acursession varchar(38),
 aiu_orgtreeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_orgusr_parent
go
create procedure iu_orgusr_parent /* сотрудники*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from iu_orgusr where  iu_orgusrid=arowid;
  set aparenttable = 'iu_orgtree';
 end 
go
GO


drop procedure if exists iu_orgusr_islocked
go
create procedure iu_orgusr_islocked /* сотрудники */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_orgusr where iu_orgusrid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_orgusr_lock
go
create procedure iu_orgusr_lock /* сотрудники */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_orgusr_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_orgusr set lockuserid =auserid ,locksessionid=null  where iu_orgusrid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_orgusr set lockuserid=null ,locksessionid =acursession  where iu_orgusrid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_orgusr_unlock
go
create procedure iu_orgusr_unlock /* сотрудники */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_orgusr_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_orgusr set lockuserid =null  where iu_orgusrid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_orgusr set locksessionid =null  where iu_orgusrid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_orgusr_client_trigger
GO

create procedure iu_orgusr_client_trigger  (
 acursession varchar(38),
 aiu_orgusrid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_u_def_gettotemp
go

create procedure iu_u_def_gettotemp (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
delete from iu_u_def_temp
 where  sessionid=g2b(acursession) and instanceid =g2b(ainstanceid); 
 insert into iu_u_def_temp 
 (timestamp,changestamp,sessionid, iu_u_defid 
,instanceid
,archived
,lastname

,name

,surname

,currole

,thetown

,sendtomail

,freelancer

,email

,thephone

,login

,lastsend

 ) select 
timestamp,changestamp,g2b(acursession),iu_u_defid 
,instanceid
,archived
,lastname

,name

,surname

,currole

,thetown

,sendtomail

,freelancer

,email

,thephone

,login

,lastsend

 from iu_u_def
 where instanceid =g2b(ainstanceid); 
 end 
go
GO


drop procedure if exists iu_u_def_commitfromtemp
go

create procedure iu_u_def_commitfromtemp (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
delete from iu_u_def
 where   instanceid =g2b(ainstanceid); 
 insert into iu_u_def 
 (timestamp, changestamp,iu_u_defid 
,instanceid
,archived
,lastname

,name

,surname

,currole

,thetown

,sendtomail

,freelancer

,email

,thephone

,login

,lastsend

 ) select 
timestamp, changestamp,iu_u_defid 
,instanceid
,archived
,lastname

,name

,surname

,currole

,thetown

,sendtomail

,freelancer

,email

,thephone

,login

,lastsend

 from iu_u_def_temp
 where  sessionid=g2b(acursession) and instanceid =g2b(ainstanceid); 
 end 
go
GO


drop procedure if exists iu_u_def_droptempdata
go

create procedure iu_u_def_droptempdata (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
delete from iu_u_def_temp
 where  sessionid=g2b(acursession) and instanceid =g2b(ainstanceid); 
 end 
go
GO


drop procedure if exists iu_u_def_brief
go

create procedure iu_u_def_brief  (
 acursession varchar(38),
 aiu_u_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_u_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_u_def where iu_u_defid=g2b(aiu_u_defid);
 if  aec &gt;0 then
   set abrief=iu_u_def_brief_f(g2b(aiu_u_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_u_def_delete
go

create procedure iu_u_def_delete /*данные сотрудника*/ (
 acursession varchar(38),
 aiu_u_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_u_def_temp  where sessionid=g2b(acursession) and iu_u_defid = g2b(aiu_u_defid) ;
if aec&gt;0 then
 select checkoperation( acursession ,'iu_u.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_u_def' result;
    leave body;
  end if;
 call iu_u_def_logger(acursession,aiu_u_defid) ; 
  delete from  iu_u_def_temp 
  where sessionid=g2b(acursession) and iu_u_defid = g2b(aiu_u_defid) ;
  delete from num_values where ownerpartname='iu_u_def' and ownerrowid=g2b(aiu_u_defid);
  end if;
    select 'ok' result;
 end 
go
GO


drop procedure if exists iu_u_def_archive
go

create procedure iu_u_def_archive /*данные сотрудника*/ (
 acursession varchar(38),
 aiu_u_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare atmpid binary(16);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_u_def where iu_u_defid=g2b(aiu_u_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_u.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_u_def' result;
    leave body;
  end if;
 call iu_u_def_logger(acursession,aiu_u_defid) ; 
  update   iu_u_def_temp set archived = 1 
  where sessionid=g2b(acursession) and iu_u_defid = g2b(aiu_u_defid) ;
  end if;
    select 'ok' result;
 end 
go
GO

/*данные сотрудника*/

drop procedure if exists iu_u_def_save
go

create procedure iu_u_def_save /*данные сотрудника*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_u_defid varchar(38)
,alastname
 varchar (120)/* фамилия *//* фамилия */
,aname
 varchar (120)/* имя *//* имя */
,asurname
 varchar (120)/* отчество *//* отчество */
,acurrole varchar(38)/* роль в производстве *//* роль в производстве */
,athetown varchar(38)/* город *//* город */
,asendtomail
 integer/* оповещать по почте *//* оповещать по почте */
,afreelancer
 integer/* удаленная работа *//* удаленная работа */
,aemail
 varchar (60)/* e-mail *//* e-mail */
,athephone
 varchar (40)/* телефон *//* телефон */
,alogin
 varchar (64)/* имя для входа *//* имя для входа */
,alastsend
 datetime/* последнее сканирование задач *//* последнее сканирование задач */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_u_def_temp where sessionid=g2b(acursession) and iu_u_defid=g2b(aiu_u_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_u.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_u_def' result;
    leave body;
  end if;
 start transaction ; 
 call iu_u_def_logger(acursession,aiu_u_defid) ; 
 update  iu_u_def_temp set changestamp=now()
,
  lastname=alastname
,
  name=aname
,
  surname=asurname
,
  currole=g2b(acurrole)
,
  thetown=g2b(athetown)
,
  sendtomail=asendtomail
,
  freelancer=afreelancer
,
  email=aemail
,
  thephone=athephone
,
  login=alogin
,
  lastsend=alastsend
  where  sessionid=g2b(acursession) and iu_u_defid = g2b(aiu_u_defid) ;


call iu_u_def_client_trigger(acursession,aiu_u_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_u.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_u_def' result;
    leave body;
  end if;
select count(*) into aec from iu_u_def_temp where  sessionid=g2b(acursession) and 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_u_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_u_def_temp
 ( sessionid, iu_u_defid 
,instanceid
,lastname

,name

,surname

,currole

,thetown

,sendtomail

,freelancer

,email

,thephone

,login

,lastsend

 ) values ( g2b(acursession), g2b(aiu_u_defid) 
,g2b(ainstanceid)
,alastname

,aname

,asurname

,g2b(acurrole)

,g2b(athetown)

,asendtomail

,afreelancer

,aemail

,athephone

,alogin

,alastsend

 ) ;


call iu_u_def_client_trigger(acursession,aiu_u_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_u_def_copy
go

create procedure iu_u_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_u_def 
 ( iu_u_defid 
,instanceid
,archived
,lastname

,name

,surname

,currole

,thetown

,sendtomail

,freelancer

,email

,thephone

,login

,lastsend

 ) select 
copymap(acopyaction,b2g(iu_u_defid)) 
,copymap(acopyaction,b2g(instanceid))
,archived
,lastname

,name

,surname

,currole

,thetown

,sendtomail

,freelancer

,email

,thephone

,login

,lastsend

 from iu_u_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_u_def_logger
go

create procedure iu_u_def_logger /*данные сотрудника*/ (
 acursession varchar(38),
 aiu_u_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_u_def_parent
go
create procedure iu_u_def_parent /* данные сотрудника*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_u_def where  iu_u_defid=arowid;
 end 
go
GO


drop procedure if exists iu_u_def_islocked
go
create procedure iu_u_def_islocked /* данные сотрудника */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_u_def where iu_u_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_u_def_lock
go
create procedure iu_u_def_lock /* данные сотрудника */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_u_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_u_def set lockuserid =auserid ,locksessionid=null  where iu_u_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_u_def set lockuserid=null ,locksessionid =acursession  where iu_u_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_u_def_unlock
go
create procedure iu_u_def_unlock /* данные сотрудника */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_u_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_u_def set lockuserid =null  where iu_u_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_u_def set locksessionid =null  where iu_u_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_u_def_client_trigger
GO

create procedure iu_u_def_client_trigger  (
 acursession varchar(38),
 aiu_u_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_process_def_brief
go

create procedure iud_process_def_brief  (
 acursession varchar(38),
 aiud_process_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_process_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_process_def where iud_process_defid=g2b(aiud_process_defid);
 if  aec &gt;0 then
   set abrief=iud_process_def_brief_f(g2b(aiud_process_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_process_def_delete
go

create procedure iud_process_def_delete /*тип документа*/ (
 acursession varchar(38),
 aiud_process_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_process_def where iud_process_defid=g2b(aiud_process_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_process.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_process_def' result;
    leave body;
  end if;
 call iud_process_def_logger(acursession,aiud_process_defid) ; 
  delete from  iud_process_def 
  where  iud_process_defid = g2b(aiud_process_defid) ;
  delete from num_values where ownerpartname='iud_process_def' and ownerrowid=g2b(aiud_process_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*процесс*/

drop procedure if exists iud_process_def_save
go

create procedure iud_process_def_save /*тип документа*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_process_defid varchar(38)
,aname
 varchar (120)/* название *//* название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_process_def where iud_process_defid=g2b(aiud_process_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_process.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_process_def' result;
    leave body;
  end if;
 start transaction ; 
 call iud_process_def_logger(acursession,aiud_process_defid) ; 
 update  iud_process_def set changestamp=now()
,
  name=aname
  where  iud_process_defid = g2b(aiud_process_defid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_process_def where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=процесс правило=(уникальность для процесс.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_process_def_client_trigger(acursession,aiud_process_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_process.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_process_def' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_process_def
 (  iud_process_defid 
,instanceid
,name

 ) values ( g2b(aiud_process_defid) 
,g2b(ainstanceid)
,aname

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_process_def where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=процесс правило=(уникальность для процесс.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_process_def_client_trigger(acursession,aiud_process_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_process_def_copy
go

create procedure iud_process_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_process_def 
 ( iud_process_defid 
,instanceid
,name

 ) select 
copymap(acopyaction,b2g(iud_process_defid)) 
,copymap(acopyaction,b2g(instanceid))
,name

 from iud_process_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_process_def_logger
go

create procedure iud_process_def_logger /*тип документа*/ (
 acursession varchar(38),
 aiud_process_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_process_def_parent
go
create procedure iud_process_def_parent /* тип документа*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_process_def where  iud_process_defid=arowid;
 end 
go
GO


drop procedure if exists iud_process_def_islocked
go
create procedure iud_process_def_islocked /* тип документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_process_def where iud_process_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_process_def_lock
go
create procedure iud_process_def_lock /* тип документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_process_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_process_def set lockuserid =auserid ,locksessionid=null  where iud_process_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_process_def set lockuserid=null ,locksessionid =acursession  where iud_process_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_process_def_unlock
go
create procedure iud_process_def_unlock /* тип документа */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_process_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_process_def set lockuserid =null  where iud_process_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_process_def set locksessionid =null  where iud_process_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_process_def_client_trigger
GO

create procedure iud_process_def_client_trigger  (
 acursession varchar(38),
 aiud_process_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists genpackage_brief
go

create procedure genpackage_brief  (
 acursession varchar(38),
 agenpackageid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if agenpackageid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from genpackage where genpackageid=g2b(agenpackageid);
 if  aec &gt;0 then
   set abrief=genpackage_brief_f(g2b(agenpackageid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists genpackage_delete
go

create procedure genpackage_delete /*пакет генерации*/ (
 acursession varchar(38),
 agenpackageid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from genpackage where genpackageid=g2b(agenpackageid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=genpackage' result;
    leave body;
  end if;
 call genpackage_logger(acursession,agenpackageid) ; 
  delete from  genpackage 
  where  genpackageid = g2b(agenpackageid) ;
  delete from num_values where ownerpartname='genpackage' and ownerrowid=g2b(agenpackageid);
  end if;
    select 'ok' result;
 end 
go
GO

/*пакет генерации*/

drop procedure if exists genpackage_save
go

create procedure genpackage_save /*пакет генерации*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 agenpackageid varchar(38)
,aname
 varchar (255)/* название *//* название */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from genpackage where genpackageid=g2b(agenpackageid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=genpackage' result;
    leave body;
  end if;
 start transaction ; 
 call genpackage_logger(acursession,agenpackageid) ; 
 update  genpackage set changestamp=now()
,
  name=aname
  where  genpackageid = g2b(agenpackageid) ;


call genpackage_client_trigger(acursession,agenpackageid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=genpackage' result;
    leave body;
  end if;
 start transaction;  
 insert into   genpackage
 (  genpackageid 
,instanceid
,name

 ) values ( g2b(agenpackageid) 
,g2b(ainstanceid)
,aname

 ) ;


call genpackage_client_trigger(acursession,agenpackageid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists generator_target_brief
go

create procedure generator_target_brief  (
 acursession varchar(38),
 agenerator_targetid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if agenerator_targetid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from generator_target where generator_targetid=g2b(agenerator_targetid);
 if  aec &gt;0 then
   set abrief=generator_target_brief_f(g2b(agenerator_targetid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists generator_target_delete
go

create procedure generator_target_delete /*генераторы*/ (
 acursession varchar(38),
 agenerator_targetid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from generator_target where generator_targetid=g2b(agenerator_targetid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=generator_target' result;
    leave body;
  end if;
 call generator_target_logger(acursession,agenerator_targetid) ; 
  delete from  generator_target 
  where  generator_targetid = g2b(agenerator_targetid) ;
  delete from num_values where ownerpartname='generator_target' and ownerrowid=g2b(agenerator_targetid);
  end if;
    select 'ok' result;
 end 
go
GO

/*генераторы*/

drop procedure if exists generator_target_save
go

create procedure generator_target_save /*генераторы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 agenerator_targetid varchar(38)
,aname
 varchar (255)/* название *//* название */
,atargettype
 integer/* тип платформы *//* тип платформы */
,aqueuename
 varchar (255)/* очередь *//* очередь */
,ageneratorprogid
 varchar (255)/* com класс *//* com класс */
,ageneratorstyle
 integer/* вариант *//* вариант */
,athedevelopmentenv
 integer/* среда разработки *//* среда разработки */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from generator_target where generator_targetid=g2b(agenerator_targetid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=generator_target' result;
    leave body;
  end if;
 start transaction ; 
 call generator_target_logger(acursession,agenerator_targetid) ; 
 update  generator_target set changestamp=now()
,
  name=aname
,
  targettype=atargettype
,
  queuename=aqueuename
,
  generatorprogid=ageneratorprogid
,
  generatorstyle=ageneratorstyle
,
  thedevelopmentenv=athedevelopmentenv
  where  generator_targetid = g2b(agenerator_targetid) ;


call generator_target_client_trigger(acursession,agenerator_targetid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=generator_target' result;
    leave body;
  end if;
 start transaction;  
 insert into   generator_target
 (  generator_targetid 
,parentstructrowid
,name

,targettype

,queuename

,generatorprogid

,generatorstyle

,thedevelopmentenv

 ) values ( g2b(agenerator_targetid) 
,g2b(aparentstructrowid)
,aname

,atargettype

,aqueuename

,ageneratorprogid

,ageneratorstyle

,athedevelopmentenv

 ) ;


call generator_target_client_trigger(acursession,agenerator_targetid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists genreference_brief
go

create procedure genreference_brief  (
 acursession varchar(38),
 agenreferenceid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if agenreferenceid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from genreference where genreferenceid=g2b(agenreferenceid);
 if  aec &gt;0 then
   set abrief=genreference_brief_f(g2b(agenreferenceid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists genreference_delete
go

create procedure genreference_delete /*библиотеки, которые используются при генерации*/ (
 acursession varchar(38),
 agenreferenceid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from genreference where genreferenceid=g2b(agenreferenceid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=genreference' result;
    leave body;
  end if;
 call genreference_logger(acursession,agenreferenceid) ; 
  delete from  genreference 
  where  genreferenceid = g2b(agenreferenceid) ;
  delete from num_values where ownerpartname='genreference' and ownerrowid=g2b(agenreferenceid);
  end if;
    select 'ok' result;
 end 
go
GO

/*библиотеки*/

drop procedure if exists genreference_save
go

create procedure genreference_save /*библиотеки, которые используются при генерации*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 agenreferenceid varchar(38)
,aname
 varchar (255)/* название *//* название */
,arefclassid
 varchar (40)/* класс ссылки *//* класс ссылки */
,aversionmajor
 integer/* номер версии *//* номер версии */
,aversionminor
 integer/* подверсия *//* подверсия */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from genreference where genreferenceid=g2b(agenreferenceid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=genreference' result;
    leave body;
  end if;
 start transaction ; 
 call genreference_logger(acursession,agenreferenceid) ; 
 update  genreference set changestamp=now()
,
  name=aname
,
  refclassid=arefclassid
,
  versionmajor=aversionmajor
,
  versionminor=aversionminor
  where  genreferenceid = g2b(agenreferenceid) ;


call genreference_client_trigger(acursession,agenreferenceid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=genreference' result;
    leave body;
  end if;
 start transaction;  
 insert into   genreference
 (  genreferenceid 
,parentstructrowid
,name

,refclassid

,versionmajor

,versionminor

 ) values ( g2b(agenreferenceid) 
,g2b(aparentstructrowid)
,aname

,arefclassid

,aversionmajor

,aversionminor

 ) ;


call genreference_client_trigger(acursession,agenreferenceid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists genmanualcode_brief
go

create procedure genmanualcode_brief  (
 acursession varchar(38),
 agenmanualcodeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if agenmanualcodeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from genmanualcode where genmanualcodeid=g2b(agenmanualcodeid);
 if  aec &gt;0 then
   set abrief=genmanualcode_brief_f(g2b(agenmanualcodeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists genmanualcode_delete
go

create procedure genmanualcode_delete /*код, который не укладывается в описание модели*/ (
 acursession varchar(38),
 agenmanualcodeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from genmanualcode where genmanualcodeid=g2b(agenmanualcodeid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=genmanualcode' result;
    leave body;
  end if;
 call genmanualcode_logger(acursession,agenmanualcodeid) ; 
  delete from  genmanualcode 
  where  genmanualcodeid = g2b(agenmanualcodeid) ;
  delete from num_values where ownerpartname='genmanualcode' and ownerrowid=g2b(agenmanualcodeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*ручной код*/

drop procedure if exists genmanualcode_save
go

create procedure genmanualcode_save /*код, который не укладывается в описание модели*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 agenmanualcodeid varchar(38)
,aname
 varchar (255)/* название *//* название */
,athe_alias
 varchar (80)/* псевдоним *//* псевдоним */
,acode
 text/* код *//* код */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from genmanualcode where genmanualcodeid=g2b(agenmanualcodeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=genmanualcode' result;
    leave body;
  end if;
 start transaction ; 
 call genmanualcode_logger(acursession,agenmanualcodeid) ; 
 update  genmanualcode set changestamp=now()
,
  name=aname
,
  the_alias=athe_alias
,
  code=acode
  where  genmanualcodeid = g2b(agenmanualcodeid) ;


call genmanualcode_client_trigger(acursession,agenmanualcodeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=genmanualcode' result;
    leave body;
  end if;
 start transaction;  
 insert into   genmanualcode
 (  genmanualcodeid 
,parentstructrowid
,name

,the_alias

,code

 ) values ( g2b(agenmanualcodeid) 
,g2b(aparentstructrowid)
,aname

,athe_alias

,acode

 ) ;


call genmanualcode_client_trigger(acursession,agenmanualcodeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists gencontrols_brief
go

create procedure gencontrols_brief  (
 acursession varchar(38),
 agencontrolsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if agencontrolsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from gencontrols where gencontrolsid=g2b(agencontrolsid);
 if  aec &gt;0 then
   set abrief=gencontrols_brief_f(g2b(agencontrolsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists gencontrols_delete
go

create procedure gencontrols_delete /*контрольные элементы, которые используются при генерации*/ (
 acursession varchar(38),
 agencontrolsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from gencontrols where gencontrolsid=g2b(agencontrolsid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=gencontrols' result;
    leave body;
  end if;
 call gencontrols_logger(acursession,agencontrolsid) ; 
  delete from  gencontrols 
  where  gencontrolsid = g2b(agencontrolsid) ;
  delete from num_values where ownerpartname='gencontrols' and ownerrowid=g2b(agencontrolsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*контрольные элементы*/

drop procedure if exists gencontrols_save
go

create procedure gencontrols_save /*контрольные элементы, которые используются при генерации*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 agencontrolsid varchar(38)
,acontrolprogid
 varchar (255)/* progid контрольконо элемента *//* progid контрольконо элемента */
,acontrolclassid
 varchar (40)/* класс контрольногоэлемента *//* класс контрольногоэлемента */
,aversionmajor
 integer/* версия *//* версия */
,aversionminor
 integer/* подверсия *//* подверсия */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from gencontrols where gencontrolsid=g2b(agencontrolsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=gencontrols' result;
    leave body;
  end if;
 start transaction ; 
 call gencontrols_logger(acursession,agencontrolsid) ; 
 update  gencontrols set changestamp=now()
,
  controlprogid=acontrolprogid
,
  controlclassid=acontrolclassid
,
  versionmajor=aversionmajor
,
  versionminor=aversionminor
  where  gencontrolsid = g2b(agencontrolsid) ;


call gencontrols_client_trigger(acursession,agencontrolsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=gencontrols' result;
    leave body;
  end if;
 start transaction;  
 insert into   gencontrols
 (  gencontrolsid 
,parentstructrowid
,controlprogid

,controlclassid

,versionmajor

,versionminor

 ) values ( g2b(agencontrolsid) 
,g2b(aparentstructrowid)
,acontrolprogid

,acontrolclassid

,aversionmajor

,aversionminor

 ) ;


call gencontrols_client_trigger(acursession,agencontrolsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists genreference_copy
go

create procedure genreference_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into genreference 
 ( genreferenceid 
,parentstructrowid
,name

,refclassid

,versionmajor

,versionminor

 ) select 
copymap(acopyaction,b2g(genreferenceid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,refclassid

,versionmajor

,versionminor

 from genreference
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists genmanualcode_copy
go

create procedure genmanualcode_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into genmanualcode 
 ( genmanualcodeid 
,parentstructrowid
,name

,the_alias

,code

 ) select 
copymap(acopyaction,b2g(genmanualcodeid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,the_alias

,code

 from genmanualcode
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists gencontrols_copy
go

create procedure gencontrols_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into gencontrols 
 ( gencontrolsid 
,parentstructrowid
,controlprogid

,controlclassid

,versionmajor

,versionminor

 ) select 
copymap(acopyaction,b2g(gencontrolsid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,controlprogid

,controlclassid

,versionmajor

,versionminor

 from gencontrols
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists generator_target_copy
go

create procedure generator_target_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_generator_target cursor for
select generator_targetid from generator_target where 
parentstructrowid=aparentstructrowid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into generator_target 
 ( generator_targetid 
,parentstructrowid
,name

,targettype

,queuename

,generatorprogid

,generatorstyle

,thedevelopmentenv

 ) select 
copymap(acopyaction,b2g(generator_targetid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,targettype

,queuename

,generatorprogid

,generatorstyle

,thedevelopmentenv

 from generator_target
 where parentstructrowid =g2b(aparentstructrowid); 
open copy_cursor_generator_target;
  set  fetch_done=false;
fetch copy_cursor_generator_target into aid;
while not fetch_done do 
    call genreference_copy(acursession,acopyaction,ainstanceid,aid);
    call genmanualcode_copy(acursession,acopyaction,ainstanceid,aid);
    call gencontrols_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_generator_target into aid;
end while;

close copy_cursor_generator_target;
 end 
go
GO


drop procedure if exists genpackage_copy
go

create procedure genpackage_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_genpackage cursor for
select genpackageid from genpackage where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into genpackage 
 ( genpackageid 
,instanceid
,name

 ) select 
copymap(acopyaction,b2g(genpackageid)) 
,copymap(acopyaction,b2g(instanceid))
,name

 from genpackage
 where instanceid =g2b( ainstanceid); 
open copy_cursor_genpackage;
  set  fetch_done=false;
fetch copy_cursor_genpackage into aid;
while not fetch_done do 
    call generator_target_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_genpackage into aid;
end while;

close copy_cursor_genpackage;
 end 
go
GO


drop procedure if exists genpackage_logger
go

create procedure genpackage_logger /*пакет генерации*/ (
 acursession varchar(38),
 agenpackageid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists generator_target_logger
go

create procedure generator_target_logger /*генераторы*/ (
 acursession varchar(38),
 agenerator_targetid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists genreference_logger
go

create procedure genreference_logger /*библиотеки, которые используются при генерации*/ (
 acursession varchar(38),
 agenreferenceid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists genmanualcode_logger
go

create procedure genmanualcode_logger /*код, который не укладывается в описание модели*/ (
 acursession varchar(38),
 agenmanualcodeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists gencontrols_logger
go

create procedure gencontrols_logger /*контрольные элементы, которые используются при генерации*/ (
 acursession varchar(38),
 agencontrolsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists genpackage_parent
go
create procedure genpackage_parent /* пакет генерации*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from genpackage where  genpackageid=arowid;
 end 
go
GO


drop procedure if exists genpackage_islocked
go
create procedure genpackage_islocked /* пакет генерации */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from genpackage where genpackageid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists genpackage_lock
go
create procedure genpackage_lock /* пакет генерации */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call genpackage_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update genpackage set lockuserid =auserid ,locksessionid=null  where genpackageid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update genpackage set lockuserid=null ,locksessionid =acursession  where genpackageid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists genpackage_unlock
go
create procedure genpackage_unlock /* пакет генерации */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call genpackage_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update genpackage set lockuserid =null  where genpackageid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update genpackage set locksessionid =null  where genpackageid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS genpackage_client_trigger
GO

create procedure genpackage_client_trigger  (
 acursession varchar(38),
 aGENPACKAGEid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists generator_target_parent
go
create procedure generator_target_parent /* генераторы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from generator_target where  generator_targetid=arowid;
  set aparenttable = 'genpackage';
 end 
go
GO


drop procedure if exists generator_target_islocked
go
create procedure generator_target_islocked /* генераторы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from generator_target where generator_targetid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists generator_target_lock
go
create procedure generator_target_lock /* генераторы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call generator_target_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update generator_target set lockuserid =auserid ,locksessionid=null  where generator_targetid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update generator_target set lockuserid=null ,locksessionid =acursession  where generator_targetid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists generator_target_unlock
go
create procedure generator_target_unlock /* генераторы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call generator_target_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update generator_target set lockuserid =null  where generator_targetid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update generator_target set locksessionid =null  where generator_targetid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS generator_target_client_trigger
GO

create procedure generator_target_client_trigger  (
 acursession varchar(38),
 aGENERATOR_TARGETid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists genreference_parent
go
create procedure genreference_parent /* библиотеки, которые используются при генерации*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from genreference where  genreferenceid=arowid;
  set aparenttable = 'generator_target';
 end 
go
GO


drop procedure if exists genreference_islocked
go
create procedure genreference_islocked /* библиотеки, которые используются при генерации */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from genreference where genreferenceid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists genreference_lock
go
create procedure genreference_lock /* библиотеки, которые используются при генерации */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call genreference_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update genreference set lockuserid =auserid ,locksessionid=null  where genreferenceid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update genreference set lockuserid=null ,locksessionid =acursession  where genreferenceid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists genreference_unlock
go
create procedure genreference_unlock /* библиотеки, которые используются при генерации */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call genreference_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update genreference set lockuserid =null  where genreferenceid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update genreference set locksessionid =null  where genreferenceid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS genreference_client_trigger
GO

create procedure genreference_client_trigger  (
 acursession varchar(38),
 aGENREFERENCEid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists genmanualcode_parent
go
create procedure genmanualcode_parent /* код, который не укладывается в описание модели*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from genmanualcode where  genmanualcodeid=arowid;
  set aparenttable = 'generator_target';
 end 
go
GO


drop procedure if exists genmanualcode_islocked
go
create procedure genmanualcode_islocked /* код, который не укладывается в описание модели */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from genmanualcode where genmanualcodeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists genmanualcode_lock
go
create procedure genmanualcode_lock /* код, который не укладывается в описание модели */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call genmanualcode_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update genmanualcode set lockuserid =auserid ,locksessionid=null  where genmanualcodeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update genmanualcode set lockuserid=null ,locksessionid =acursession  where genmanualcodeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists genmanualcode_unlock
go
create procedure genmanualcode_unlock /* код, который не укладывается в описание модели */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call genmanualcode_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update genmanualcode set lockuserid =null  where genmanualcodeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update genmanualcode set locksessionid =null  where genmanualcodeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS genmanualcode_client_trigger
GO

create procedure genmanualcode_client_trigger  (
 acursession varchar(38),
 aGENMANUALCODEid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists gencontrols_parent
go
create procedure gencontrols_parent /* контрольные элементы, которые используются при генерации*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from gencontrols where  gencontrolsid=arowid;
  set aparenttable = 'generator_target';
 end 
go
GO


drop procedure if exists gencontrols_islocked
go
create procedure gencontrols_islocked /* контрольные элементы, которые используются при генерации */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from gencontrols where gencontrolsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists gencontrols_lock
go
create procedure gencontrols_lock /* контрольные элементы, которые используются при генерации */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call gencontrols_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update gencontrols set lockuserid =auserid ,locksessionid=null  where gencontrolsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update gencontrols set lockuserid=null ,locksessionid =acursession  where gencontrolsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists gencontrols_unlock
go
create procedure gencontrols_unlock /* контрольные элементы, которые используются при генерации */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call gencontrols_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update gencontrols set lockuserid =null  where gencontrolsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update gencontrols set locksessionid =null  where gencontrolsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS gencontrols_client_trigger
GO

create procedure gencontrols_client_trigger  (
 acursession varchar(38),
 aGENCONTROLSid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists localizeinfo_brief
go

create procedure localizeinfo_brief  (
 acursession varchar(38),
 alocalizeinfoid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if alocalizeinfoid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from localizeinfo where localizeinfoid=g2b(alocalizeinfoid);
 if  aec &gt;0 then
   set abrief=localizeinfo_brief_f(g2b(alocalizeinfoid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists localizeinfo_delete
go

create procedure localizeinfo_delete /**/ (
 acursession varchar(38),
 alocalizeinfoid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from localizeinfo where localizeinfoid=g2b(alocalizeinfoid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=localizeinfo' result;
    leave body;
  end if;
 call localizeinfo_logger(acursession,alocalizeinfoid) ; 
  delete from  localizeinfo 
  where  localizeinfoid = g2b(alocalizeinfoid) ;
  delete from num_values where ownerpartname='localizeinfo' and ownerrowid=g2b(alocalizeinfoid);
  end if;
    select 'ok' result;
 end 
go
GO

/*локализация*/

drop procedure if exists localizeinfo_save
go

create procedure localizeinfo_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 alocalizeinfoid varchar(38)
,alangfull
 varchar (255)/* язык - название *//* язык - название */
,alangshort
 varchar (255)/* код языка *//* код языка */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from localizeinfo where localizeinfoid=g2b(alocalizeinfoid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=localizeinfo' result;
    leave body;
  end if;
 start transaction ; 
 call localizeinfo_logger(acursession,alocalizeinfoid) ; 
 update  localizeinfo set changestamp=now()
,
  langfull=alangfull
,
  langshort=alangshort
  where  localizeinfoid = g2b(alocalizeinfoid) ;


call localizeinfo_client_trigger(acursession,alocalizeinfoid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=localizeinfo' result;
    leave body;
  end if;
 start transaction;  
 insert into   localizeinfo
 (  localizeinfoid 
,instanceid
,langfull

,langshort

 ) values ( g2b(alocalizeinfoid) 
,g2b(ainstanceid)
,alangfull

,alangshort

 ) ;


call localizeinfo_client_trigger(acursession,alocalizeinfoid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists localizeinfo_copy
go

create procedure localizeinfo_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into localizeinfo 
 ( localizeinfoid 
,instanceid
,langfull

,langshort

 ) select 
copymap(acopyaction,b2g(localizeinfoid)) 
,copymap(acopyaction,b2g(instanceid))
,langfull

,langshort

 from localizeinfo
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists localizeinfo_logger
go

create procedure localizeinfo_logger /**/ (
 acursession varchar(38),
 alocalizeinfoid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists localizeinfo_parent
go
create procedure localizeinfo_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from localizeinfo where  localizeinfoid=arowid;
 end 
go
GO


drop procedure if exists localizeinfo_islocked
go
create procedure localizeinfo_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from localizeinfo where localizeinfoid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists localizeinfo_lock
go
create procedure localizeinfo_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call localizeinfo_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update localizeinfo set lockuserid =auserid ,locksessionid=null  where localizeinfoid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update localizeinfo set lockuserid=null ,locksessionid =acursession  where localizeinfoid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists localizeinfo_unlock
go
create procedure localizeinfo_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call localizeinfo_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update localizeinfo set lockuserid =null  where localizeinfoid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update localizeinfo set locksessionid =null  where localizeinfoid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS localizeinfo_client_trigger
GO

create procedure localizeinfo_client_trigger  (
 acursession varchar(38),
 aLocalizeInfoid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists fieldtype_brief
go

create procedure fieldtype_brief  (
 acursession varchar(38),
 afieldtypeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afieldtypeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from fieldtype where fieldtypeid=g2b(afieldtypeid);
 if  aec &gt;0 then
   set abrief=fieldtype_brief_f(g2b(afieldtypeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists fieldtype_delete
go

create procedure fieldtype_delete /*типы полей, перечисления, интервалы*/ (
 acursession varchar(38),
 afieldtypeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldtype where fieldtypeid=g2b(afieldtypeid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=fieldtype' result;
    leave body;
  end if;
 call fieldtype_logger(acursession,afieldtypeid) ; 
  delete from  fieldtype 
  where  fieldtypeid = g2b(afieldtypeid) ;
  delete from num_values where ownerpartname='fieldtype' and ownerrowid=g2b(afieldtypeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип поля*/

drop procedure if exists fieldtype_save
go

create procedure fieldtype_save /*типы полей, перечисления, интервалы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 afieldtypeid varchar(38)
,aname
 varchar (255)/* название *//* название */
,atypestyle
 integer/* трактовка *//* трактовка */
,athe_comment
 text/* описание *//* описание */
,aallowsize
 integer/* нужен размер *//* нужен размер */
,aminimum
 varchar (64)/* минимум *//* минимум */
,amaximum
 varchar (64)/* максимум *//* максимум */
,aallowlikesearch
 integer/* поиск текста *//* поиск текста */
,agridsorttype
 integer/* вариант сортировки в табличном представлении *//* вариант сортировки в табличном представлении */
,adelayedsave
 integer/* отложенное сохранение *//* отложенное сохранение */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldtype where fieldtypeid=g2b(afieldtypeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=fieldtype' result;
    leave body;
  end if;
 start transaction ; 
 call fieldtype_logger(acursession,afieldtypeid) ; 
 update  fieldtype set changestamp=now()
,
  name=aname
,
  typestyle=atypestyle
,
  the_comment=athe_comment
,
  allowsize=aallowsize
,
  minimum=aminimum
,
  maximum=amaximum
,
  allowlikesearch=aallowlikesearch
,
  gridsorttype=agridsorttype
,
  delayedsave=adelayedsave
  where  fieldtypeid = g2b(afieldtypeid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from fieldtype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=тип поля' result;
  rollback;
  leave body;
end if;
 -- end if;

call fieldtype_client_trigger(acursession,afieldtypeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=fieldtype' result;
    leave body;
  end if;
 start transaction;  
 insert into   fieldtype
 (  fieldtypeid 
,instanceid
,name

,typestyle

,the_comment

,allowsize

,minimum

,maximum

,allowlikesearch

,gridsorttype

,delayedsave

 ) values ( g2b(afieldtypeid) 
,g2b(ainstanceid)
,aname

,atypestyle

,athe_comment

,aallowsize

,aminimum

,amaximum

,aallowlikesearch

,agridsorttype

,adelayedsave

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from fieldtype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=тип поля' result;
  rollback;
  leave body;
end if;
 -- end if;

call fieldtype_client_trigger(acursession,afieldtypeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists enumitem_brief
go

create procedure enumitem_brief  (
 acursession varchar(38),
 aenumitemid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aenumitemid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from enumitem where enumitemid=g2b(aenumitemid);
 if  aec &gt;0 then
   set abrief=enumitem_brief_f(g2b(aenumitemid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists enumitem_delete
go

create procedure enumitem_delete /*для описания enum типов*/ (
 acursession varchar(38),
 aenumitemid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from enumitem where enumitemid=g2b(aenumitemid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=enumitem' result;
    leave body;
  end if;
 call enumitem_logger(acursession,aenumitemid) ; 
  delete from  enumitem 
  where  enumitemid = g2b(aenumitemid) ;
  delete from num_values where ownerpartname='enumitem' and ownerrowid=g2b(aenumitemid);
  end if;
    select 'ok' result;
 end 
go
GO

/*зачения*/

drop procedure if exists enumitem_save
go

create procedure enumitem_save /*для описания enum типов*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aenumitemid varchar(38)
,aname
 varchar (255)/* название *//* название */
,anamevalue
 integer/* значение *//* значение */
,anameincode
 varchar (100)/* название в коде *//* название в коде */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from enumitem where enumitemid=g2b(aenumitemid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=enumitem' result;
    leave body;
  end if;
 start transaction ; 
 call enumitem_logger(acursession,aenumitemid) ; 
 update  enumitem set changestamp=now()
,
  name=aname
,
  namevalue=anamevalue
,
  nameincode=anameincode
  where  enumitemid = g2b(aenumitemid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from enumitem where  parentstructrowid=g2b(aparentstructrowid) 
 and namevalue=anamevalue;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=зачения' result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from enumitem where  parentstructrowid=g2b(aparentstructrowid) 
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=зачения' result;
  rollback;
  leave body;
end if;
 -- end if;

call enumitem_client_trigger(acursession,aenumitemid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=enumitem' result;
    leave body;
  end if;
 start transaction;  
 insert into   enumitem
 (  enumitemid 
,parentstructrowid
,name

,namevalue

,nameincode

 ) values ( g2b(aenumitemid) 
,g2b(aparentstructrowid)
,aname

,anamevalue

,anameincode

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from enumitem where  parentstructrowid=g2b(aparentstructrowid) 
 and namevalue=anamevalue;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=зачения' result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from enumitem where  parentstructrowid=g2b(aparentstructrowid) 
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=зачения' result;
  rollback;
  leave body;
end if;
 -- end if;

call enumitem_client_trigger(acursession,aenumitemid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists fieldtypemap_brief
go

create procedure fieldtypemap_brief  (
 acursession varchar(38),
 afieldtypemapid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afieldtypemapid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from fieldtypemap where fieldtypemapid=g2b(afieldtypemapid);
 if  aec &gt;0 then
   set abrief=fieldtypemap_brief_f(g2b(afieldtypemapid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists fieldtypemap_delete
go

create procedure fieldtypemap_delete /*отображение типа поля на физический тип хранения*/ (
 acursession varchar(38),
 afieldtypemapid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldtypemap where fieldtypemapid=g2b(afieldtypemapid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=fieldtypemap' result;
    leave body;
  end if;
 call fieldtypemap_logger(acursession,afieldtypemapid) ; 
  delete from  fieldtypemap 
  where  fieldtypemapid = g2b(afieldtypemapid) ;
  delete from num_values where ownerpartname='fieldtypemap' and ownerrowid=g2b(afieldtypemapid);
  end if;
    select 'ok' result;
 end 
go
GO

/*отображение*/

drop procedure if exists fieldtypemap_save
go

create procedure fieldtypemap_save /*отображение типа поля на физический тип хранения*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 afieldtypemapid varchar(38)
,atarget varchar(38)/* платформа *//* платформа */
,astoagetype
 varchar (255)/* тип хранения *//* тип хранения */
,afixedsize
 integer/* размер *//* размер */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldtypemap where fieldtypemapid=g2b(afieldtypemapid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=fieldtypemap' result;
    leave body;
  end if;
 start transaction ; 
 call fieldtypemap_logger(acursession,afieldtypemapid) ; 
 update  fieldtypemap set changestamp=now()
,
  target=g2b(atarget)
,
  stoagetype=astoagetype
,
  fixedsize=afixedsize
  where  fieldtypemapid = g2b(afieldtypemapid) ;


call fieldtypemap_client_trigger(acursession,afieldtypemapid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=fieldtypemap' result;
    leave body;
  end if;
 start transaction;  
 insert into   fieldtypemap
 (  fieldtypemapid 
,parentstructrowid
,target

,stoagetype

,fixedsize

 ) values ( g2b(afieldtypemapid) 
,g2b(aparentstructrowid)
,g2b(atarget)

,astoagetype

,afixedsize

 ) ;


call fieldtypemap_client_trigger(acursession,afieldtypemapid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists enumitem_copy
go

create procedure enumitem_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into enumitem 
 ( enumitemid 
,parentstructrowid
,name

,namevalue

,nameincode

 ) select 
copymap(acopyaction,b2g(enumitemid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,namevalue

,nameincode

 from enumitem
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists fieldtypemap_copy
go

create procedure fieldtypemap_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into fieldtypemap 
 ( fieldtypemapid 
,parentstructrowid
,target

,stoagetype

,fixedsize

 ) select 
copymap(acopyaction,b2g(fieldtypemapid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,target

,stoagetype

,fixedsize

 from fieldtypemap
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists fieldtype_copy
go

create procedure fieldtype_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_fieldtype cursor for
select fieldtypeid from fieldtype where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into fieldtype 
 ( fieldtypeid 
,instanceid
,name

,typestyle

,the_comment

,allowsize

,minimum

,maximum

,allowlikesearch

,gridsorttype

,delayedsave

 ) select 
copymap(acopyaction,b2g(fieldtypeid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,typestyle

,the_comment

,allowsize

,minimum

,maximum

,allowlikesearch

,gridsorttype

,delayedsave

 from fieldtype
 where instanceid =g2b( ainstanceid); 
open copy_cursor_fieldtype;
  set  fetch_done=false;
fetch copy_cursor_fieldtype into aid;
while not fetch_done do 
    call enumitem_copy(acursession,acopyaction,ainstanceid,aid);
    call fieldtypemap_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_fieldtype into aid;
end while;

close copy_cursor_fieldtype;
 end 
go
GO


drop procedure if exists fieldtype_logger
go

create procedure fieldtype_logger /*типы полей, перечисления, интервалы*/ (
 acursession varchar(38),
 afieldtypeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists enumitem_logger
go

create procedure enumitem_logger /*для описания enum типов*/ (
 acursession varchar(38),
 aenumitemid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists fieldtypemap_logger
go

create procedure fieldtypemap_logger /*отображение типа поля на физический тип хранения*/ (
 acursession varchar(38),
 afieldtypemapid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists fieldtype_parent
go
create procedure fieldtype_parent /* типы полей, перечисления, интервалы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from fieldtype where  fieldtypeid=arowid;
 end 
go
GO


drop procedure if exists fieldtype_islocked
go
create procedure fieldtype_islocked /* типы полей, перечисления, интервалы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from fieldtype where fieldtypeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists fieldtype_lock
go
create procedure fieldtype_lock /* типы полей, перечисления, интервалы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call fieldtype_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update fieldtype set lockuserid =auserid ,locksessionid=null  where fieldtypeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update fieldtype set lockuserid=null ,locksessionid =acursession  where fieldtypeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists fieldtype_unlock
go
create procedure fieldtype_unlock /* типы полей, перечисления, интервалы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call fieldtype_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update fieldtype set lockuserid =null  where fieldtypeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update fieldtype set locksessionid =null  where fieldtypeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS fieldtype_client_trigger
GO

create procedure fieldtype_client_trigger  (
 acursession varchar(38),
 aFIELDTYPEid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists enumitem_parent
go
create procedure enumitem_parent /* для описания enum типов*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from enumitem where  enumitemid=arowid;
  set aparenttable = 'fieldtype';
 end 
go
GO


drop procedure if exists enumitem_islocked
go
create procedure enumitem_islocked /* для описания enum типов */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from enumitem where enumitemid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists enumitem_lock
go
create procedure enumitem_lock /* для описания enum типов */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call enumitem_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update enumitem set lockuserid =auserid ,locksessionid=null  where enumitemid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update enumitem set lockuserid=null ,locksessionid =acursession  where enumitemid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists enumitem_unlock
go
create procedure enumitem_unlock /* для описания enum типов */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call enumitem_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update enumitem set lockuserid =null  where enumitemid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update enumitem set locksessionid =null  where enumitemid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS enumitem_client_trigger
GO

create procedure enumitem_client_trigger  (
 acursession varchar(38),
 aENUMITEMid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists fieldtypemap_parent
go
create procedure fieldtypemap_parent /* отображение типа поля на физический тип хранения*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from fieldtypemap where  fieldtypemapid=arowid;
  set aparenttable = 'fieldtype';
 end 
go
GO


drop procedure if exists fieldtypemap_islocked
go
create procedure fieldtypemap_islocked /* отображение типа поля на физический тип хранения */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from fieldtypemap where fieldtypemapid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists fieldtypemap_lock
go
create procedure fieldtypemap_lock /* отображение типа поля на физический тип хранения */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call fieldtypemap_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update fieldtypemap set lockuserid =auserid ,locksessionid=null  where fieldtypemapid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update fieldtypemap set lockuserid=null ,locksessionid =acursession  where fieldtypemapid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists fieldtypemap_unlock
go
create procedure fieldtypemap_unlock /* отображение типа поля на физический тип хранения */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call fieldtypemap_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update fieldtypemap set lockuserid =null  where fieldtypemapid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update fieldtypemap set locksessionid =null  where fieldtypemapid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS fieldtypemap_client_trigger
GO

create procedure fieldtypemap_client_trigger  (
 acursession varchar(38),
 aFIELDTYPEMAPid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists sharedmethod_brief
go

create procedure sharedmethod_brief  (
 acursession varchar(38),
 asharedmethodid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if asharedmethodid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from sharedmethod where sharedmethodid=g2b(asharedmethodid);
 if  aec &gt;0 then
   set abrief=sharedmethod_brief_f(g2b(asharedmethodid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists sharedmethod_delete
go

create procedure sharedmethod_delete /*методы и процедуры*/ (
 acursession varchar(38),
 asharedmethodid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from sharedmethod where sharedmethodid=g2b(asharedmethodid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=sharedmethod' result;
    leave body;
  end if;
 call sharedmethod_logger(acursession,asharedmethodid) ; 
  delete from  sharedmethod 
  where  sharedmethodid = g2b(asharedmethodid) ;
  delete from num_values where ownerpartname='sharedmethod' and ownerrowid=g2b(asharedmethodid);
  end if;
    select 'ok' result;
 end 
go
GO

/*методы и процедуры*/

drop procedure if exists sharedmethod_save
go

create procedure sharedmethod_save /*методы и процедуры*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 asharedmethodid varchar(38)
,aname
 varchar (255)/* название *//* название */
,athe_comment
 text/* описание метода *//* описание метода */
,areturntype varchar(38)/* возвращаемый тип *//* возвращаемый тип */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from sharedmethod where sharedmethodid=g2b(asharedmethodid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=sharedmethod' result;
    leave body;
  end if;
 start transaction ; 
 call sharedmethod_logger(acursession,asharedmethodid) ; 
 update  sharedmethod set changestamp=now()
,
  name=aname
,
  the_comment=athe_comment
,
  returntype=g2b(areturntype)
  where  sharedmethodid = g2b(asharedmethodid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from sharedmethod where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=методы и процедуры' result;
  rollback;
  leave body;
end if;
 -- end if;

call sharedmethod_client_trigger(acursession,asharedmethodid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=sharedmethod' result;
    leave body;
  end if;
 start transaction;  
 insert into   sharedmethod
 (  sharedmethodid 
,instanceid
,name

,the_comment

,returntype

 ) values ( g2b(asharedmethodid) 
,g2b(ainstanceid)
,aname

,athe_comment

,g2b(areturntype)

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from sharedmethod where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=методы и процедуры' result;
  rollback;
  leave body;
end if;
 -- end if;

call sharedmethod_client_trigger(acursession,asharedmethodid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists script_brief
go

create procedure script_brief  (
 acursession varchar(38),
 ascriptid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if ascriptid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from script where scriptid=g2b(ascriptid);
 if  aec &gt;0 then
   set abrief=script_brief_f(g2b(ascriptid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists script_delete
go

create procedure script_delete /*код метода на понятном конкретному генератору языке*/ (
 acursession varchar(38),
 ascriptid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from script where scriptid=g2b(ascriptid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=script' result;
    leave body;
  end if;
 call script_logger(acursession,ascriptid) ; 
  delete from  script 
  where  scriptid = g2b(ascriptid) ;
  delete from num_values where ownerpartname='script' and ownerrowid=g2b(ascriptid);
  end if;
    select 'ok' result;
 end 
go
GO

/*реализация*/

drop procedure if exists script_save
go

create procedure script_save /*код метода на понятном конкретному генератору языке*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 ascriptid varchar(38)
,atarget varchar(38)/* целевая платформа *//* целевая платформа */
,acode
 text/* скрипт *//* скрипт */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from script where scriptid=g2b(ascriptid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=script' result;
    leave body;
  end if;
 start transaction ; 
 call script_logger(acursession,ascriptid) ; 
 update  script set changestamp=now()
,
  target=g2b(atarget)
,
  code=acode
  where  scriptid = g2b(ascriptid) ;


call script_client_trigger(acursession,ascriptid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=script' result;
    leave body;
  end if;
 start transaction;  
 insert into   script
 (  scriptid 
,parentstructrowid
,target

,code

 ) values ( g2b(ascriptid) 
,g2b(aparentstructrowid)
,g2b(atarget)

,acode

 ) ;


call script_client_trigger(acursession,ascriptid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists parameters_brief
go

create procedure parameters_brief  (
 acursession varchar(38),
 aparametersid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aparametersid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from parameters where parametersid=g2b(aparametersid);
 if  aec &gt;0 then
   set abrief=parameters_brief_f(g2b(aparametersid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists parameters_delete
go

create procedure parameters_delete /*параметры метода*/ (
 acursession varchar(38),
 aparametersid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from parameters where parametersid=g2b(aparametersid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=parameters' result;
    leave body;
  end if;
 call parameters_logger(acursession,aparametersid) ; 
  delete from  parameters 
  where  parametersid = g2b(aparametersid) ;
  delete from num_values where ownerpartname='parameters' and ownerrowid=g2b(aparametersid);
  end if;
    select 'ok' result;
 end 
go
GO

/*параметры*/

drop procedure if exists parameters_save
go

create procedure parameters_save /*параметры метода*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aparametersid varchar(38)
,asequence
 integer/* последовательность *//* последовательность */
,aname
 varchar (80)/* имя *//* имя */
,acaption
 varchar (80)/* заголовок *//* заголовок */
,atypeofparm varchar(38)/* тип данных *//* тип данных */
,adatasize
 integer/* размер *//* размер */
,aallownull
 integer/* можно не задавать *//* можно не задавать */
,aoutparam
 integer/* возвращает значение *//* возвращает значение */
,areferencetype
 integer/* тип ссылки *//* тип ссылки */
,areftotype varchar(38)/* ссылка на тип *//* ссылка на тип */
,areftopart varchar(38)/* ссылка на раздел *//* ссылка на раздел */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from parameters where parametersid=g2b(aparametersid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=parameters' result;
    leave body;
  end if;
 start transaction ; 
 call parameters_logger(acursession,aparametersid) ; 
 update  parameters set changestamp=now()
,
  sequence=asequence
,
  name=aname
,
  caption=acaption
,
  typeofparm=g2b(atypeofparm)
,
  datasize=adatasize
,
  allownull=aallownull
,
  outparam=aoutparam
,
  referencetype=areferencetype
,
  reftotype=g2b(areftotype)
,
  reftopart=g2b(areftopart)
  where  parametersid = g2b(aparametersid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from parameters where  parentstructrowid=g2b(aparentstructrowid) 
 and sequence=asequence;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=параметры' result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from parameters where  parentstructrowid=g2b(aparentstructrowid) 
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=параметры' result;
  rollback;
  leave body;
end if;
 -- end if;

call parameters_client_trigger(acursession,aparametersid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=parameters' result;
    leave body;
  end if;
 start transaction;  
 insert into   parameters
 (  parametersid 
,parentstructrowid
,sequence

,name

,caption

,typeofparm

,datasize

,allownull

,outparam

,referencetype

,reftotype

,reftopart

 ) values ( g2b(aparametersid) 
,g2b(aparentstructrowid)
,asequence

,aname

,acaption

,g2b(atypeofparm)

,adatasize

,aallownull

,aoutparam

,areferencetype

,g2b(areftotype)

,g2b(areftopart)

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from parameters where  parentstructrowid=g2b(aparentstructrowid) 
 and sequence=asequence;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=параметры' result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from parameters where  parentstructrowid=g2b(aparentstructrowid) 
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=параметры' result;
  rollback;
  leave body;
end if;
 -- end if;

call parameters_client_trigger(acursession,aparametersid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists parameters_copy
go

create procedure parameters_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into parameters 
 ( parametersid 
,parentstructrowid
,sequence

,name

,caption

,typeofparm

,datasize

,allownull

,outparam

,referencetype

,reftotype

,reftopart

 ) select 
copymap(acopyaction,b2g(parametersid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,sequence

,name

,caption

,typeofparm

,datasize

,allownull

,outparam

,referencetype

,reftotype

,reftopart

 from parameters
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists script_copy
go

create procedure script_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_script cursor for
select scriptid from script where 
parentstructrowid=aparentstructrowid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into script 
 ( scriptid 
,parentstructrowid
,target

,code

 ) select 
copymap(acopyaction,b2g(scriptid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,target

,code

 from script
 where parentstructrowid =g2b(aparentstructrowid); 
open copy_cursor_script;
  set  fetch_done=false;
fetch copy_cursor_script into aid;
while not fetch_done do 
    call parameters_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_script into aid;
end while;

close copy_cursor_script;
 end 
go
GO


drop procedure if exists sharedmethod_copy
go

create procedure sharedmethod_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_sharedmethod cursor for
select sharedmethodid from sharedmethod where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into sharedmethod 
 ( sharedmethodid 
,instanceid
,name

,the_comment

,returntype

 ) select 
copymap(acopyaction,b2g(sharedmethodid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,the_comment

,returntype

 from sharedmethod
 where instanceid =g2b( ainstanceid); 
open copy_cursor_sharedmethod;
  set  fetch_done=false;
fetch copy_cursor_sharedmethod into aid;
while not fetch_done do 
    call script_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_sharedmethod into aid;
end while;

close copy_cursor_sharedmethod;
 end 
go
GO


drop procedure if exists sharedmethod_logger
go

create procedure sharedmethod_logger /*методы и процедуры*/ (
 acursession varchar(38),
 asharedmethodid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists script_logger
go

create procedure script_logger /*код метода на понятном конкретному генератору языке*/ (
 acursession varchar(38),
 ascriptid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists parameters_logger
go

create procedure parameters_logger /*параметры метода*/ (
 acursession varchar(38),
 aparametersid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists sharedmethod_parent
go
create procedure sharedmethod_parent /* методы и процедуры*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from sharedmethod where  sharedmethodid=arowid;
 end 
go
GO


drop procedure if exists sharedmethod_islocked
go
create procedure sharedmethod_islocked /* методы и процедуры */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from sharedmethod where sharedmethodid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists sharedmethod_lock
go
create procedure sharedmethod_lock /* методы и процедуры */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call sharedmethod_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update sharedmethod set lockuserid =auserid ,locksessionid=null  where sharedmethodid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update sharedmethod set lockuserid=null ,locksessionid =acursession  where sharedmethodid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists sharedmethod_unlock
go
create procedure sharedmethod_unlock /* методы и процедуры */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call sharedmethod_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update sharedmethod set lockuserid =null  where sharedmethodid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update sharedmethod set locksessionid =null  where sharedmethodid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS sharedmethod_client_trigger
GO

create procedure sharedmethod_client_trigger  (
 acursession varchar(38),
 aSHAREDMETHODid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists script_parent
go
create procedure script_parent /* код метода на понятном конкретному генератору языке*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from script where  scriptid=arowid;
  set aparenttable = 'sharedmethod';
 end 
go
GO


drop procedure if exists script_islocked
go
create procedure script_islocked /* код метода на понятном конкретному генератору языке */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from script where scriptid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists script_lock
go
create procedure script_lock /* код метода на понятном конкретному генератору языке */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call script_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update script set lockuserid =auserid ,locksessionid=null  where scriptid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update script set lockuserid=null ,locksessionid =acursession  where scriptid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists script_unlock
go
create procedure script_unlock /* код метода на понятном конкретному генератору языке */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call script_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update script set lockuserid =null  where scriptid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update script set locksessionid =null  where scriptid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS script_client_trigger
GO

create procedure script_client_trigger  (
 acursession varchar(38),
 aSCRIPTid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists parameters_parent
go
create procedure parameters_parent /* параметры метода*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from parameters where  parametersid=arowid;
  set aparenttable = 'script';
 end 
go
GO


drop procedure if exists parameters_islocked
go
create procedure parameters_islocked /* параметры метода */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from parameters where parametersid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists parameters_lock
go
create procedure parameters_lock /* параметры метода */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call parameters_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update parameters set lockuserid =auserid ,locksessionid=null  where parametersid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update parameters set lockuserid=null ,locksessionid =acursession  where parametersid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists parameters_unlock
go
create procedure parameters_unlock /* параметры метода */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call parameters_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update parameters set lockuserid =null  where parametersid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update parameters set locksessionid =null  where parametersid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS parameters_client_trigger
GO

create procedure parameters_client_trigger  (
 acursession varchar(38),
 aPARAMETERSid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists objecttype_brief
go

create procedure objecttype_brief  (
 acursession varchar(38),
 aobjecttypeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aobjecttypeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from objecttype where objecttypeid=g2b(aobjecttypeid);
 if  aec &gt;0 then
   set abrief=objecttype_brief_f(g2b(aobjecttypeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists objecttype_delete
go

create procedure objecttype_delete /*тип объекта (карточки)*/ (
 acursession varchar(38),
 aobjecttypeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from objecttype where objecttypeid=g2b(aobjecttypeid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=objecttype' result;
    leave body;
  end if;
 call objecttype_logger(acursession,aobjecttypeid) ; 
  delete from  objecttype 
  where  objecttypeid = g2b(aobjecttypeid) ;
  delete from num_values where ownerpartname='objecttype' and ownerrowid=g2b(aobjecttypeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип объекта*/

drop procedure if exists objecttype_save
go

create procedure objecttype_save /*тип объекта (карточки)*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aobjecttypeid varchar(38)
,apackage varchar(38)/* приложение *//* приложение */
,athe_comment
 varchar (255)/* название *//* название */
,aname
 varchar (14)/* код *//* код */
,aissingleinstance
 integer/* допускается только один объект *//* допускается только один объект */
,achooseview varchar(38)/* представление для выбора *//* представление для выбора */
,aonrun varchar(38)/* при запуске *//* при запуске */
,aoncreate varchar(38)/* при создании *//* при создании */
,aondelete varchar(38)/* при удалении *//* при удалении */
,aallowreftoobject
 integer/* отображать при выборе ссылки *//* отображать при выборе ссылки */
,aallowsearch
 integer/* отображать при поиске *//* отображать при поиске */
,areplicatype
 integer/* тип репликации *//* тип репликации */
,athecomment
 text/* описание *//* описание */
,auseownership
 integer/* видмость зависит от пользователя *//* видмость зависит от пользователя */
,ausearchiving
 integer/* архивировать вместо удаления *//* архивировать вместо удаления */
,acommitfullobject
 integer/* сохранять объект целиком *//* сохранять объект целиком */
,aobjiconcls
 varchar (80)/* иконка объекта *//* иконка объекта */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from objecttype where objecttypeid=g2b(aobjecttypeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=objecttype' result;
    leave body;
  end if;
 start transaction ; 
 call objecttype_logger(acursession,aobjecttypeid) ; 
 update  objecttype set changestamp=now()
,
  package=g2b(apackage)
,
  the_comment=athe_comment
,
  name=aname
,
  issingleinstance=aissingleinstance
,
  chooseview=g2b(achooseview)
,
  onrun=g2b(aonrun)
,
  oncreate=g2b(aoncreate)
,
  ondelete=g2b(aondelete)
,
  allowreftoobject=aallowreftoobject
,
  allowsearch=aallowsearch
,
  replicatype=areplicatype
,
  thecomment=athecomment
,
  useownership=auseownership
,
  usearchiving=ausearchiving
,
  commitfullobject=acommitfullobject
,
  objiconcls=aobjiconcls
  where  objecttypeid = g2b(aobjecttypeid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from objecttype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=тип объекта' result;
  rollback;
  leave body;
end if;
 -- end if;

call objecttype_client_trigger(acursession,aobjecttypeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=objecttype' result;
    leave body;
  end if;
 start transaction;  
 insert into   objecttype
 (  objecttypeid 
,instanceid
,package

,the_comment

,name

,issingleinstance

,chooseview

,onrun

,oncreate

,ondelete

,allowreftoobject

,allowsearch

,replicatype

,thecomment

,useownership

,usearchiving

,commitfullobject

,objiconcls

 ) values ( g2b(aobjecttypeid) 
,g2b(ainstanceid)
,g2b(apackage)

,athe_comment

,aname

,aissingleinstance

,g2b(achooseview)

,g2b(aonrun)

,g2b(aoncreate)

,g2b(aondelete)

,aallowreftoobject

,aallowsearch

,areplicatype

,athecomment

,auseownership

,ausearchiving

,acommitfullobject

,aobjiconcls

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from objecttype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=тип объекта' result;
  rollback;
  leave body;
end if;
 -- end if;

call objecttype_client_trigger(acursession,aobjecttypeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists objstatus_brief
go

create procedure objstatus_brief  (
 acursession varchar(38),
 aobjstatusid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aobjstatusid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from objstatus where objstatusid=g2b(aobjstatusid);
 if  aec &gt;0 then
   set abrief=objstatus_brief_f(g2b(aobjstatusid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists objstatus_delete
go

create procedure objstatus_delete /*возможные логические состояния документа*/ (
 acursession varchar(38),
 aobjstatusid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from objstatus where objstatusid=g2b(aobjstatusid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=objstatus' result;
    leave body;
  end if;
 call objstatus_logger(acursession,aobjstatusid) ; 
  delete from  objstatus 
  where  objstatusid = g2b(aobjstatusid) ;
  delete from num_values where ownerpartname='objstatus' and ownerrowid=g2b(aobjstatusid);
  end if;
    select 'ok' result;
 end 
go
GO

/*состояния*/

drop procedure if exists objstatus_save
go

create procedure objstatus_save /*возможные логические состояния документа*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aobjstatusid varchar(38)
,aname
 varchar (80)/* название *//* название */
,aisstartup
 integer/* начальное *//* начальное */
,aisarchive
 integer/* архивное *//* архивное */
,athe_comment
 text/* описание *//* описание */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from objstatus where objstatusid=g2b(aobjstatusid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=objstatus' result;
    leave body;
  end if;
 start transaction ; 
 call objstatus_logger(acursession,aobjstatusid) ; 
 update  objstatus set changestamp=now()
,
  name=aname
,
  isstartup=aisstartup
,
  isarchive=aisarchive
,
  the_comment=athe_comment
  where  objstatusid = g2b(aobjstatusid) ;


call objstatus_client_trigger(acursession,aobjstatusid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=objstatus' result;
    leave body;
  end if;
 start transaction;  
 insert into   objstatus
 (  objstatusid 
,parentstructrowid
,name

,isstartup

,isarchive

,the_comment

 ) values ( g2b(aobjstatusid) 
,g2b(aparentstructrowid)
,aname

,aisstartup

,aisarchive

,athe_comment

 ) ;


call objstatus_client_trigger(acursession,aobjstatusid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists nextstate_brief
go

create procedure nextstate_brief  (
 acursession varchar(38),
 anextstateid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if anextstateid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from nextstate where nextstateid=g2b(anextstateid);
 if  aec &gt;0 then
   set abrief=nextstate_brief_f(g2b(anextstateid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists nextstate_delete
go

create procedure nextstate_delete /*матрица переходов */ (
 acursession varchar(38),
 anextstateid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from nextstate where nextstateid=g2b(anextstateid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=nextstate' result;
    leave body;
  end if;
 call nextstate_logger(acursession,anextstateid) ; 
  delete from  nextstate 
  where  nextstateid = g2b(anextstateid) ;
  delete from num_values where ownerpartname='nextstate' and ownerrowid=g2b(anextstateid);
  end if;
    select 'ok' result;
 end 
go
GO

/*разрешенные переходы*/

drop procedure if exists nextstate_save
go

create procedure nextstate_save /*матрица переходов */ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 anextstateid varchar(38)
,athestate varchar(38)/* разрешенное состояние *//* разрешенное состояние */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from nextstate where nextstateid=g2b(anextstateid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=nextstate' result;
    leave body;
  end if;
 start transaction ; 
 call nextstate_logger(acursession,anextstateid) ; 
 update  nextstate set changestamp=now()
,
  thestate=g2b(athestate)
  where  nextstateid = g2b(anextstateid) ;


call nextstate_client_trigger(acursession,anextstateid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=nextstate' result;
    leave body;
  end if;
 start transaction;  
 insert into   nextstate
 (  nextstateid 
,parentstructrowid
,thestate

 ) values ( g2b(anextstateid) 
,g2b(aparentstructrowid)
,g2b(athestate)

 ) ;


call nextstate_client_trigger(acursession,anextstateid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists objectmode_brief
go

create procedure objectmode_brief  (
 acursession varchar(38),
 aobjectmodeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aobjectmodeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from objectmode where objectmodeid=g2b(aobjectmodeid);
 if  aec &gt;0 then
   set abrief=objectmode_brief_f(g2b(aobjectmodeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists objectmode_delete
go

create procedure objectmode_delete /*режим работы*/ (
 acursession varchar(38),
 aobjectmodeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from objectmode where objectmodeid=g2b(aobjectmodeid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=objectmode' result;
    leave body;
  end if;
 call objectmode_logger(acursession,aobjectmodeid) ; 
  delete from  objectmode 
  where  objectmodeid = g2b(aobjectmodeid) ;
  delete from num_values where ownerpartname='objectmode' and ownerrowid=g2b(aobjectmodeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*режим работы*/

drop procedure if exists objectmode_save
go

create procedure objectmode_save /*режим работы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aobjectmodeid varchar(38)
,aname
 varchar (5)/* название режима *//* название режима */
,adefaultmode
 integer/* этот режим является основным режимом работы объекта *//* этот режим является основным режимом работы объекта */
,athecomment
 text/* описание *//* описание */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from objectmode where objectmodeid=g2b(aobjectmodeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=objectmode' result;
    leave body;
  end if;
 start transaction ; 
 call objectmode_logger(acursession,aobjectmodeid) ; 
 update  objectmode set changestamp=now()
,
  name=aname
,
  defaultmode=adefaultmode
,
  thecomment=athecomment
  where  objectmodeid = g2b(aobjectmodeid) ;


call objectmode_client_trigger(acursession,aobjectmodeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=objectmode' result;
    leave body;
  end if;
 start transaction;  
 insert into   objectmode
 (  objectmodeid 
,parentstructrowid
,name

,defaultmode

,thecomment

 ) values ( g2b(aobjectmodeid) 
,g2b(aparentstructrowid)
,aname

,adefaultmode

,athecomment

 ) ;


call objectmode_client_trigger(acursession,aobjectmodeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists structrestriction_brief
go

create procedure structrestriction_brief  (
 acursession varchar(38),
 astructrestrictionid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if astructrestrictionid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from structrestriction where structrestrictionid=g2b(astructrestrictionid);
 if  aec &gt;0 then
   set abrief=structrestriction_brief_f(g2b(astructrestrictionid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists structrestriction_delete
go

create procedure structrestriction_delete /*ораничения на доступ к разделу документа*/ (
 acursession varchar(38),
 astructrestrictionid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from structrestriction where structrestrictionid=g2b(astructrestrictionid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=structrestriction' result;
    leave body;
  end if;
 call structrestriction_logger(acursession,astructrestrictionid) ; 
  delete from  structrestriction 
  where  structrestrictionid = g2b(astructrestrictionid) ;
  delete from num_values where ownerpartname='structrestriction' and ownerrowid=g2b(astructrestrictionid);
  end if;
    select 'ok' result;
 end 
go
GO

/*органичения разделов*/

drop procedure if exists structrestriction_save
go

create procedure structrestriction_save /*ораничения на доступ к разделу документа*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 astructrestrictionid varchar(38)
,astruct varchar(38)/* структура, доступ к которой ограничен *//* структура, доступ к которой ограничен */
,aallowread
 integer/* разрешен просмотр *//* разрешен просмотр */
,aallowadd
 integer/* разрешено добавлять *//* разрешено добавлять */
,aallowedit
 integer/* разрешено изменять *//* разрешено изменять */
,aallowdelete
 integer/* разрешено удалять *//* разрешено удалять */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from structrestriction where structrestrictionid=g2b(astructrestrictionid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=structrestriction' result;
    leave body;
  end if;
 start transaction ; 
 call structrestriction_logger(acursession,astructrestrictionid) ; 
 update  structrestriction set changestamp=now()
,
  struct=g2b(astruct)
,
  allowread=aallowread
,
  allowadd=aallowadd
,
  allowedit=aallowedit
,
  allowdelete=aallowdelete
  where  structrestrictionid = g2b(astructrestrictionid) ;


call structrestriction_client_trigger(acursession,astructrestrictionid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=structrestriction' result;
    leave body;
  end if;
 start transaction;  
 insert into   structrestriction
 (  structrestrictionid 
,parentstructrowid
,struct

,allowread

,allowadd

,allowedit

,allowdelete

 ) values ( g2b(astructrestrictionid) 
,g2b(aparentstructrowid)
,g2b(astruct)

,aallowread

,aallowadd

,aallowedit

,aallowdelete

 ) ;


call structrestriction_client_trigger(acursession,astructrestrictionid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists methodrestriction_brief
go

create procedure methodrestriction_brief  (
 acursession varchar(38),
 amethodrestrictionid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if amethodrestrictionid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from methodrestriction where methodrestrictionid=g2b(amethodrestrictionid);
 if  aec &gt;0 then
   set abrief=methodrestriction_brief_f(g2b(amethodrestrictionid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists methodrestriction_delete
go

create procedure methodrestriction_delete /*ограничение на использование методов раздела*/ (
 acursession varchar(38),
 amethodrestrictionid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from methodrestriction where methodrestrictionid=g2b(amethodrestrictionid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=methodrestriction' result;
    leave body;
  end if;
 call methodrestriction_logger(acursession,amethodrestrictionid) ; 
  delete from  methodrestriction 
  where  methodrestrictionid = g2b(amethodrestrictionid) ;
  delete from num_values where ownerpartname='methodrestriction' and ownerrowid=g2b(amethodrestrictionid);
  end if;
    select 'ok' result;
 end 
go
GO

/*ограничения методов*/

drop procedure if exists methodrestriction_save
go

create procedure methodrestriction_save /*ограничение на использование методов раздела*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 amethodrestrictionid varchar(38)
,apart varchar(38)/* структура, которой принадлежит метод *//* структура, которой принадлежит метод */
,amethod varchar(38)/* метод *//* метод */
,aisrestricted
 integer/* запрещено использовать *//* запрещено использовать */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from methodrestriction where methodrestrictionid=g2b(amethodrestrictionid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=methodrestriction' result;
    leave body;
  end if;
 start transaction ; 
 call methodrestriction_logger(acursession,amethodrestrictionid) ; 
 update  methodrestriction set changestamp=now()
,
  part=g2b(apart)
,
  method=g2b(amethod)
,
  isrestricted=aisrestricted
  where  methodrestrictionid = g2b(amethodrestrictionid) ;


call methodrestriction_client_trigger(acursession,amethodrestrictionid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=methodrestriction' result;
    leave body;
  end if;
 start transaction;  
 insert into   methodrestriction
 (  methodrestrictionid 
,parentstructrowid
,part

,method

,isrestricted

 ) values ( g2b(amethodrestrictionid) 
,g2b(aparentstructrowid)
,g2b(apart)

,g2b(amethod)

,aisrestricted

 ) ;


call methodrestriction_client_trigger(acursession,amethodrestrictionid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists fieldrestriction_brief
go

create procedure fieldrestriction_brief  (
 acursession varchar(38),
 afieldrestrictionid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afieldrestrictionid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from fieldrestriction where fieldrestrictionid=g2b(afieldrestrictionid);
 if  aec &gt;0 then
   set abrief=fieldrestriction_brief_f(g2b(afieldrestrictionid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists fieldrestriction_delete
go

create procedure fieldrestriction_delete /*ограничения на доступ к полям раздела*/ (
 acursession varchar(38),
 afieldrestrictionid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldrestriction where fieldrestrictionid=g2b(afieldrestrictionid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=fieldrestriction' result;
    leave body;
  end if;
 call fieldrestriction_logger(acursession,afieldrestrictionid) ; 
  delete from  fieldrestriction 
  where  fieldrestrictionid = g2b(afieldrestrictionid) ;
  delete from num_values where ownerpartname='fieldrestriction' and ownerrowid=g2b(afieldrestrictionid);
  end if;
    select 'ok' result;
 end 
go
GO

/*ограничения полей*/

drop procedure if exists fieldrestriction_save
go

create procedure fieldrestriction_save /*ограничения на доступ к полям раздела*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 afieldrestrictionid varchar(38)
,athepart varchar(38)/* структура, которой принадлежит поле *//* структура, которой принадлежит поле */
,athefield varchar(38)/* поле, на которое накладывается ограничение *//* поле, на которое накладывается ограничение */
,aallowread
 integer/* разрешен просмотр *//* разрешен просмотр */
,aallowmodify
 integer/* разрешена модификация *//* разрешена модификация */
,amandatoryfield
 integer/* обязательное поле *//* обязательное поле */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldrestriction where fieldrestrictionid=g2b(afieldrestrictionid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=fieldrestriction' result;
    leave body;
  end if;
 start transaction ; 
 call fieldrestriction_logger(acursession,afieldrestrictionid) ; 
 update  fieldrestriction set changestamp=now()
,
  thepart=g2b(athepart)
,
  thefield=g2b(athefield)
,
  allowread=aallowread
,
  allowmodify=aallowmodify
,
  mandatoryfield=amandatoryfield
  where  fieldrestrictionid = g2b(afieldrestrictionid) ;


call fieldrestriction_client_trigger(acursession,afieldrestrictionid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=fieldrestriction' result;
    leave body;
  end if;
 start transaction;  
 insert into   fieldrestriction
 (  fieldrestrictionid 
,parentstructrowid
,thepart

,thefield

,allowread

,allowmodify

,mandatoryfield

 ) values ( g2b(afieldrestrictionid) 
,g2b(aparentstructrowid)
,g2b(athepart)

,g2b(athefield)

,aallowread

,aallowmodify

,amandatoryfield

 ) ;


call fieldrestriction_client_trigger(acursession,afieldrestrictionid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists typemenu_brief
go

create procedure typemenu_brief  (
 acursession varchar(38),
 atypemenuid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if atypemenuid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from typemenu where typemenuid=g2b(atypemenuid);
 if  aec &gt;0 then
   set abrief=typemenu_brief_f(g2b(atypemenuid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists typemenu_delete
go

create procedure typemenu_delete /*методы уровня типа*/ (
 acursession varchar(38),
 atypemenuid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from typemenu where typemenuid=g2b(atypemenuid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=typemenu' result;
    leave body;
  end if;
 call typemenu_logger(acursession,atypemenuid) ; 
  delete from  typemenu 
  where  typemenuid = g2b(atypemenuid) ;
  delete from num_values where ownerpartname='typemenu' and ownerrowid=g2b(atypemenuid);
  end if;
    select 'ok' result;
 end 
go
GO

/*методы типа*/

drop procedure if exists typemenu_save
go

create procedure typemenu_save /*методы уровня типа*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 atypemenuid varchar(38)
,aname
 varchar (64)/* название *//* название */
,acaption
 varchar (80)/* заголовок *//* заголовок */
,atooltip
 varchar (80)/* подсказка *//* подсказка */
,athe_action varchar(38)/* метод *//* метод */
,aismenuitem
 integer/* включать в меню *//* включать в меню */
,aistoolbarbutton
 integer/* включать в тулбар *//* включать в тулбар */
,ahotkey
 varchar (20)/* горячая клавиша *//* горячая клавиша */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from typemenu where typemenuid=g2b(atypemenuid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=typemenu' result;
    leave body;
  end if;
 start transaction ; 
 call typemenu_logger(acursession,atypemenuid) ; 
 update  typemenu set changestamp=now()
,
  name=aname
,
  caption=acaption
,
  tooltip=atooltip
,
  the_action=g2b(athe_action)
,
  ismenuitem=aismenuitem
,
  istoolbarbutton=aistoolbarbutton
,
  hotkey=ahotkey
  where  typemenuid = g2b(atypemenuid) ;


call typemenu_client_trigger(acursession,atypemenuid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=typemenu' result;
    leave body;
  end if;
 start transaction;  
 insert into   typemenu
 (  typemenuid 
,parentstructrowid
,name

,caption

,tooltip

,the_action

,ismenuitem

,istoolbarbutton

,hotkey

 ) values ( g2b(atypemenuid) 
,g2b(aparentstructrowid)
,aname

,acaption

,atooltip

,g2b(athe_action)

,aismenuitem

,aistoolbarbutton

,ahotkey

 ) ;


call typemenu_client_trigger(acursession,atypemenuid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists instancevalidator_brief
go

create procedure instancevalidator_brief  (
 acursession varchar(38),
 ainstancevalidatorid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if ainstancevalidatorid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from instancevalidator where instancevalidatorid=g2b(ainstancevalidatorid);
 if  aec &gt;0 then
   set abrief=instancevalidator_brief_f(g2b(ainstancevalidatorid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists instancevalidator_delete
go

create procedure instancevalidator_delete /*проверка правильности для объекта в целом*/ (
 acursession varchar(38),
 ainstancevalidatorid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from instancevalidator where instancevalidatorid=g2b(ainstancevalidatorid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=instancevalidator' result;
    leave body;
  end if;
 call instancevalidator_logger(acursession,ainstancevalidatorid) ; 
  delete from  instancevalidator 
  where  instancevalidatorid = g2b(ainstancevalidatorid) ;
  delete from num_values where ownerpartname='instancevalidator' and ownerrowid=g2b(ainstancevalidatorid);
  end if;
    select 'ok' result;
 end 
go
GO

/*проверка правильности*/

drop procedure if exists instancevalidator_save
go

create procedure instancevalidator_save /*проверка правильности для объекта в целом*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 ainstancevalidatorid varchar(38)
,atarget varchar(38)/* платформа *//* платформа */
,acode
 text/* скрипт *//* скрипт */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from instancevalidator where instancevalidatorid=g2b(ainstancevalidatorid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=instancevalidator' result;
    leave body;
  end if;
 start transaction ; 
 call instancevalidator_logger(acursession,ainstancevalidatorid) ; 
 update  instancevalidator set changestamp=now()
,
  target=g2b(atarget)
,
  code=acode
  where  instancevalidatorid = g2b(ainstancevalidatorid) ;


call instancevalidator_client_trigger(acursession,ainstancevalidatorid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=instancevalidator' result;
    leave body;
  end if;
 start transaction;  
 insert into   instancevalidator
 (  instancevalidatorid 
,parentstructrowid
,target

,code

 ) values ( g2b(ainstancevalidatorid) 
,g2b(aparentstructrowid)
,g2b(atarget)

,acode

 ) ;


call instancevalidator_client_trigger(acursession,ainstancevalidatorid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists part_brief
go

create procedure part_brief  (
 acursession varchar(38),
 apartid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if apartid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from part where partid=g2b(apartid);
 if  aec &gt;0 then
   set abrief=part_brief_f(g2b(apartid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists part_delete
go

create procedure part_delete /*раздел объекта*/ (
 acursession varchar(38),
 apartid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from part where partid=g2b(apartid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=part' result;
    leave body;
  end if;
 call part_logger(acursession,apartid) ; 
  delete from  part 
  where  partid = g2b(apartid) ;
  delete from num_values where ownerpartname='part' and ownerrowid=g2b(apartid);
  end if;
    select 'ok' result;
 end 
go
GO

/*раздел*/

drop procedure if exists part_save
go

create procedure part_save /*раздел объекта*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 apartid varchar(38)
,aparentrowid varchar(38) 
,asequence
 integer/* № п/п *//* № п/п */
,aparttype
 integer/* тип структры *//* тип структры */
,acaption
 varchar (255)/* заголовок *//* заголовок */
,aname
 varchar (20)/* название *//* название */
,athe_comment
 text/* описание *//* описание */
,anolog
 integer/* не записывать в журнал *//* не записывать в журнал */
,amanualregister
 integer/* исключить из индексирования *//* исключить из индексирования */
,aoncreate varchar(38)/* при создании *//* при создании */
,aonsave varchar(38)/* при сохранении *//* при сохранении */
,aonrun varchar(38)/* при открытии *//* при открытии */
,aondelete varchar(38)/* при удалении *//* при удалении */
,aaddbehaivor
 integer/* поведение при добавлении *//* поведение при добавлении */
,aextenderobject varchar(38)/* объект расширения *//* объект расширения */
,ashablonbrief
 varchar (100)/* шаблон для краткого отображения *//* шаблон для краткого отображения */
,arulebrief
 varchar (500)/* правило составления brief поля *//* правило составления brief поля */
,aisjormalchange
 integer/* вести журнал изменений *//* вести журнал изменений */
,ausearchiving
 integer/* архивировать вместо удаления *//* архивировать вместо удаления */
,aintegerpkey
 integer/* целочисленный ключ *//* целочисленный ключ */
,aparticoncls
 varchar (80)/* иконка раздела *//* иконка раздела */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from part where partid=g2b(apartid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=part' result;
    leave body;
  end if;
 start transaction ; 
 call part_logger(acursession,apartid) ; 
 update  part set changestamp=now()
,parentrowid= g2b(aparentrowid)
,
  sequence=asequence
,
  parttype=aparttype
,
  caption=acaption
,
  name=aname
,
  the_comment=athe_comment
,
  nolog=anolog
,
  manualregister=amanualregister
,
  oncreate=g2b(aoncreate)
,
  onsave=g2b(aonsave)
,
  onrun=g2b(aonrun)
,
  ondelete=g2b(aondelete)
,
  addbehaivor=aaddbehaivor
,
  extenderobject=g2b(aextenderobject)
,
  shablonbrief=ashablonbrief
,
  rulebrief=arulebrief
,
  isjormalchange=aisjormalchange
,
  usearchiving=ausearchiving
,
  integerpkey=aintegerpkey
,
  particoncls=aparticoncls
  where  partid = g2b(apartid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 if aparentrowid is null then
   select count(*) into  auniquerowcount from part where  parentstructrowid=g2b(aparentstructrowid) and parentrowid is null 
 and sequence=asequence;
 else 
   select count(*) into  auniquerowcount from part where  parentstructrowid=g2b(aparentstructrowid) and parentrowid =g2b(aparentrowid) 
 and sequence=asequence;
 end if;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=раздел' result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from part where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=раздел' result;
  rollback;
  leave body;
end if;
 -- end if;

call part_client_trigger(acursession,apartid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=part' result;
    leave body;
  end if;
 start transaction;  
 insert into   part
 (  partid 
,parentrowid
,parentstructrowid
,sequence

,parttype

,caption

,name

,the_comment

,nolog

,manualregister

,oncreate

,onsave

,onrun

,ondelete

,addbehaivor

,extenderobject

,shablonbrief

,rulebrief

,isjormalchange

,usearchiving

,integerpkey

,particoncls

 ) values ( g2b(apartid) 
,g2b(aparentrowid)
,g2b(aparentstructrowid)
,asequence

,aparttype

,acaption

,aname

,athe_comment

,anolog

,amanualregister

,g2b(aoncreate)

,g2b(aonsave)

,g2b(aonrun)

,g2b(aondelete)

,aaddbehaivor

,g2b(aextenderobject)

,ashablonbrief

,arulebrief

,aisjormalchange

,ausearchiving

,aintegerpkey

,aparticoncls

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 if aparentrowid is null then
   select count(*) into  auniquerowcount from part where  parentstructrowid=g2b(aparentstructrowid) and parentrowid is null 
 and sequence=asequence;
 else 
   select count(*) into  auniquerowcount from part where  parentstructrowid=g2b(aparentstructrowid) and parentrowid =g2b(aparentrowid) 
 and sequence=asequence;
 end if;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=раздел' result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from part where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=раздел' result;
  rollback;
  leave body;
end if;
 -- end if;

call part_client_trigger(acursession,apartid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists partmenu_brief
go

create procedure partmenu_brief  (
 acursession varchar(38),
 apartmenuid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if apartmenuid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from partmenu where partmenuid=g2b(apartmenuid);
 if  aec &gt;0 then
   set abrief=partmenu_brief_f(g2b(apartmenuid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists partmenu_delete
go

create procedure partmenu_delete /*методы уровня раздела*/ (
 acursession varchar(38),
 apartmenuid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from partmenu where partmenuid=g2b(apartmenuid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=partmenu' result;
    leave body;
  end if;
 call partmenu_logger(acursession,apartmenuid) ; 
  delete from  partmenu 
  where  partmenuid = g2b(apartmenuid) ;
  delete from num_values where ownerpartname='partmenu' and ownerrowid=g2b(apartmenuid);
  end if;
    select 'ok' result;
 end 
go
GO

/*методы раздела*/

drop procedure if exists partmenu_save
go

create procedure partmenu_save /*методы уровня раздела*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 apartmenuid varchar(38)
,aname
 varchar (64)/* название *//* название */
,acaption
 varchar (80)/* заголовок *//* заголовок */
,atooltip
 varchar (80)/* подсказка *//* подсказка */
,athe_action varchar(38)/* метод *//* метод */
,aismenuitem
 integer/* включать в меню *//* включать в меню */
,aistoolbarbutton
 integer/* в тулбар *//* в тулбар */
,ahotkey
 varchar (20)/* горячая клавиша *//* горячая клавиша */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from partmenu where partmenuid=g2b(apartmenuid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=partmenu' result;
    leave body;
  end if;
 start transaction ; 
 call partmenu_logger(acursession,apartmenuid) ; 
 update  partmenu set changestamp=now()
,
  name=aname
,
  caption=acaption
,
  tooltip=atooltip
,
  the_action=g2b(athe_action)
,
  ismenuitem=aismenuitem
,
  istoolbarbutton=aistoolbarbutton
,
  hotkey=ahotkey
  where  partmenuid = g2b(apartmenuid) ;


call partmenu_client_trigger(acursession,apartmenuid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=partmenu' result;
    leave body;
  end if;
 start transaction;  
 insert into   partmenu
 (  partmenuid 
,parentstructrowid
,name

,caption

,tooltip

,the_action

,ismenuitem

,istoolbarbutton

,hotkey

 ) values ( g2b(apartmenuid) 
,g2b(aparentstructrowid)
,aname

,acaption

,atooltip

,g2b(athe_action)

,aismenuitem

,aistoolbarbutton

,ahotkey

 ) ;


call partmenu_client_trigger(acursession,apartmenuid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists partparammap_brief
go

create procedure partparammap_brief  (
 acursession varchar(38),
 apartparammapid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if apartparammapid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from partparammap where partparammapid=g2b(apartparammapid);
 if  aec &gt;0 then
   set abrief=partparammap_brief_f(g2b(apartparammapid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists partparammap_delete
go

create procedure partparammap_delete /*отображение значений полей раздела на параметры метода*/ (
 acursession varchar(38),
 apartparammapid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from partparammap where partparammapid=g2b(apartparammapid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=partparammap' result;
    leave body;
  end if;
 call partparammap_logger(acursession,apartparammapid) ; 
  delete from  partparammap 
  where  partparammapid = g2b(apartparammapid) ;
  delete from num_values where ownerpartname='partparammap' and ownerrowid=g2b(apartparammapid);
  end if;
    select 'ok' result;
 end 
go
GO

/*отображение параметров*/

drop procedure if exists partparammap_save
go

create procedure partparammap_save /*отображение значений полей раздела на параметры метода*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 apartparammapid varchar(38)
,afieldname
 varchar (255)/* поле (значение) *//* поле (значение) */
,aparamname
 varchar (80)/* параметр *//* параметр */
,anoedit
 integer/* редактировать параметр нельзя *//* редактировать параметр нельзя */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from partparammap where partparammapid=g2b(apartparammapid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=partparammap' result;
    leave body;
  end if;
 start transaction ; 
 call partparammap_logger(acursession,apartparammapid) ; 
 update  partparammap set changestamp=now()
,
  fieldname=afieldname
,
  paramname=aparamname
,
  noedit=anoedit
  where  partparammapid = g2b(apartparammapid) ;


call partparammap_client_trigger(acursession,apartparammapid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=partparammap' result;
    leave body;
  end if;
 start transaction;  
 insert into   partparammap
 (  partparammapid 
,parentstructrowid
,fieldname

,paramname

,noedit

 ) values ( g2b(apartparammapid) 
,g2b(aparentstructrowid)
,afieldname

,aparamname

,anoedit

 ) ;


call partparammap_client_trigger(acursession,apartparammapid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists partview_brief
go

create procedure partview_brief  (
 acursession varchar(38),
 apartviewid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if apartviewid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from partview where partviewid=g2b(apartviewid);
 if  aec &gt;0 then
   set abrief=partview_brief_f(g2b(apartviewid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists partview_delete
go

create procedure partview_delete /*вариант представления, который может использоваться для создания журнала*/ (
 acursession varchar(38),
 apartviewid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from partview where partviewid=g2b(apartviewid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=partview' result;
    leave body;
  end if;
 call partview_logger(acursession,apartviewid) ; 
  delete from  partview 
  where  partviewid = g2b(apartviewid) ;
  delete from num_values where ownerpartname='partview' and ownerrowid=g2b(apartviewid);
  end if;
    select 'ok' result;
 end 
go
GO

/*представление*/

drop procedure if exists partview_save
go

create procedure partview_save /*вариант представления, который может использоваться для создания журнала*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 apartviewid varchar(38)
,aname
 varchar (255)/* название *//* название */
,athe_alias
 varchar (64)/* псевдоним *//* псевдоним */
,aforchoose
 integer/* для поиска *//* для поиска */
,afilterfield0
 varchar (255)/* поле - фильтр 0 *//* поле - фильтр 0 */
,afilterfield1
 varchar (255)/* поле - фильтр 1 *//* поле - фильтр 1 */
,afilterfield2
 varchar (255)/* поле - фильтр 2 *//* поле - фильтр 2 */
,afilterfield3
 varchar (255)/* поле - фильтр 3 *//* поле - фильтр 3 */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from partview where partviewid=g2b(apartviewid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=partview' result;
    leave body;
  end if;
 start transaction ; 
 call partview_logger(acursession,apartviewid) ; 
 update  partview set changestamp=now()
,
  name=aname
,
  the_alias=athe_alias
,
  forchoose=aforchoose
,
  filterfield0=afilterfield0
,
  filterfield1=afilterfield1
,
  filterfield2=afilterfield2
,
  filterfield3=afilterfield3
  where  partviewid = g2b(apartviewid) ;


call partview_client_trigger(acursession,apartviewid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=partview' result;
    leave body;
  end if;
 start transaction;  
 insert into   partview
 (  partviewid 
,parentstructrowid
,name

,the_alias

,forchoose

,filterfield0

,filterfield1

,filterfield2

,filterfield3

 ) values ( g2b(apartviewid) 
,g2b(aparentstructrowid)
,aname

,athe_alias

,aforchoose

,afilterfield0

,afilterfield1

,afilterfield2

,afilterfield3

 ) ;


call partview_client_trigger(acursession,apartviewid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists viewcolumn_brief
go

create procedure viewcolumn_brief  (
 acursession varchar(38),
 aviewcolumnid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aviewcolumnid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from viewcolumn where viewcolumnid=g2b(aviewcolumnid);
 if  aec &gt;0 then
   set abrief=viewcolumn_brief_f(g2b(aviewcolumnid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists viewcolumn_delete
go

create procedure viewcolumn_delete /*колонка пердставления*/ (
 acursession varchar(38),
 aviewcolumnid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from viewcolumn where viewcolumnid=g2b(aviewcolumnid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=viewcolumn' result;
    leave body;
  end if;
 call viewcolumn_logger(acursession,aviewcolumnid) ; 
  delete from  viewcolumn 
  where  viewcolumnid = g2b(aviewcolumnid) ;
  delete from num_values where ownerpartname='viewcolumn' and ownerrowid=g2b(aviewcolumnid);
  end if;
    select 'ok' result;
 end 
go
GO

/*колонка*/

drop procedure if exists viewcolumn_save
go

create procedure viewcolumn_save /*колонка пердставления*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aviewcolumnid varchar(38)
,asequence
 integer/* № *//* № */
,aname
 varchar (255)/* название *//* название */
,athe_alias
 varchar (64)/* псвдоним *//* псвдоним */
,afrompart varchar(38)/* раздел *//* раздел */
,afield varchar(38)/* поле *//* поле */
,aaggregation
 integer/* агрегация *//* агрегация */
,aexpression
 text/* формула *//* формула */
,aforcombo
 integer/* для комбо *//* для комбо */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from viewcolumn where viewcolumnid=g2b(aviewcolumnid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=viewcolumn' result;
    leave body;
  end if;
 start transaction ; 
 call viewcolumn_logger(acursession,aviewcolumnid) ; 
 update  viewcolumn set changestamp=now()
,
  sequence=asequence
,
  name=aname
,
  the_alias=athe_alias
,
  frompart=g2b(afrompart)
,
  field=g2b(afield)
,
  aggregation=aaggregation
,
  expression=aexpression
,
  forcombo=aforcombo
  where  viewcolumnid = g2b(aviewcolumnid) ;


call viewcolumn_client_trigger(acursession,aviewcolumnid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=viewcolumn' result;
    leave body;
  end if;
 start transaction;  
 insert into   viewcolumn
 (  viewcolumnid 
,parentstructrowid
,sequence

,name

,the_alias

,frompart

,field

,aggregation

,expression

,forcombo

 ) values ( g2b(aviewcolumnid) 
,g2b(aparentstructrowid)
,asequence

,aname

,athe_alias

,g2b(afrompart)

,g2b(afield)

,aaggregation

,aexpression

,aforcombo

 ) ;


call viewcolumn_client_trigger(acursession,aviewcolumnid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists partview_lnk_brief
go

create procedure partview_lnk_brief  (
 acursession varchar(38),
 apartview_lnkid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if apartview_lnkid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from partview_lnk where partview_lnkid=g2b(apartview_lnkid);
 if  aec &gt;0 then
   set abrief=partview_lnk_brief_f(g2b(apartview_lnkid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists partview_lnk_delete
go

create procedure partview_lnk_delete /**/ (
 acursession varchar(38),
 apartview_lnkid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from partview_lnk where partview_lnkid=g2b(apartview_lnkid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=partview_lnk' result;
    leave body;
  end if;
 call partview_lnk_logger(acursession,apartview_lnkid) ; 
  delete from  partview_lnk 
  where  partview_lnkid = g2b(apartview_lnkid) ;
  delete from num_values where ownerpartname='partview_lnk' and ownerrowid=g2b(apartview_lnkid);
  end if;
    select 'ok' result;
 end 
go
GO

/*связанные представления*/

drop procedure if exists partview_lnk_save
go

create procedure partview_lnk_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 apartview_lnkid varchar(38)
,atheview varchar(38)/* представление *//* представление */
,athejoinsource varchar(38)/* связь: поле для join источник *//* связь: поле для join источник */
,areftype
 integer/* связывать как *//* связывать как */
,athejoindestination varchar(38)/* свзяь: поле для join приемник *//* свзяь: поле для join приемник */
,ahandjoin
 varchar (255)/* ручной join *//* ручной join */
,aseq
 integer/* порядок *//* порядок */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from partview_lnk where partview_lnkid=g2b(apartview_lnkid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=partview_lnk' result;
    leave body;
  end if;
 start transaction ; 
 call partview_lnk_logger(acursession,apartview_lnkid) ; 
 update  partview_lnk set changestamp=now()
,
  theview=g2b(atheview)
,
  thejoinsource=g2b(athejoinsource)
,
  reftype=areftype
,
  thejoindestination=g2b(athejoindestination)
,
  handjoin=ahandjoin
,
  seq=aseq
  where  partview_lnkid = g2b(apartview_lnkid) ;


call partview_lnk_client_trigger(acursession,apartview_lnkid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=partview_lnk' result;
    leave body;
  end if;
 start transaction;  
 insert into   partview_lnk
 (  partview_lnkid 
,parentstructrowid
,theview

,thejoinsource

,reftype

,thejoindestination

,handjoin

,seq

 ) values ( g2b(apartview_lnkid) 
,g2b(aparentstructrowid)
,g2b(atheview)

,g2b(athejoinsource)

,areftype

,g2b(athejoindestination)

,ahandjoin

,aseq

 ) ;


call partview_lnk_client_trigger(acursession,apartview_lnkid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists validator_brief
go

create procedure validator_brief  (
 acursession varchar(38),
 avalidatorid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if avalidatorid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from validator where validatorid=g2b(avalidatorid);
 if  aec &gt;0 then
   set abrief=validator_brief_f(g2b(avalidatorid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists validator_delete
go

create procedure validator_delete /*действия в впроцессе редактирования*/ (
 acursession varchar(38),
 avalidatorid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from validator where validatorid=g2b(avalidatorid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=validator' result;
    leave body;
  end if;
 call validator_logger(acursession,avalidatorid) ; 
  delete from  validator 
  where  validatorid = g2b(avalidatorid) ;
  delete from num_values where ownerpartname='validator' and ownerrowid=g2b(avalidatorid);
  end if;
    select 'ok' result;
 end 
go
GO

/*логика на форме*/

drop procedure if exists validator_save
go

create procedure validator_save /*действия в впроцессе редактирования*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 avalidatorid varchar(38)
,atarget varchar(38)/* целевая платформа *//* целевая платформа */
,acode
 text/* скрипт *//* скрипт */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from validator where validatorid=g2b(avalidatorid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=validator' result;
    leave body;
  end if;
 start transaction ; 
 call validator_logger(acursession,avalidatorid) ; 
 update  validator set changestamp=now()
,
  target=g2b(atarget)
,
  code=acode
  where  validatorid = g2b(avalidatorid) ;


call validator_client_trigger(acursession,avalidatorid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=validator' result;
    leave body;
  end if;
 start transaction;  
 insert into   validator
 (  validatorid 
,parentstructrowid
,target

,code

 ) values ( g2b(avalidatorid) 
,g2b(aparentstructrowid)
,g2b(atarget)

,acode

 ) ;


call validator_client_trigger(acursession,avalidatorid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists uniqueconstraint_brief
go

create procedure uniqueconstraint_brief  (
 acursession varchar(38),
 auniqueconstraintid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if auniqueconstraintid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from uniqueconstraint where uniqueconstraintid=g2b(auniqueconstraintid);
 if  aec &gt;0 then
   set abrief=uniqueconstraint_brief_f(g2b(auniqueconstraintid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists uniqueconstraint_delete
go

create procedure uniqueconstraint_delete /*ограничение уникальности*/ (
 acursession varchar(38),
 auniqueconstraintid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from uniqueconstraint where uniqueconstraintid=g2b(auniqueconstraintid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=uniqueconstraint' result;
    leave body;
  end if;
 call uniqueconstraint_logger(acursession,auniqueconstraintid) ; 
  delete from  uniqueconstraint 
  where  uniqueconstraintid = g2b(auniqueconstraintid) ;
  delete from num_values where ownerpartname='uniqueconstraint' and ownerrowid=g2b(auniqueconstraintid);
  end if;
    select 'ok' result;
 end 
go
GO

/*ограничение уникальности*/

drop procedure if exists uniqueconstraint_save
go

create procedure uniqueconstraint_save /*ограничение уникальности*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 auniqueconstraintid varchar(38)
,aname
 varchar (80)/* название *//* название */
,aperparent
 integer/* по родителю *//* по родителю */
,athecomment
 text/* описание *//* описание */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from uniqueconstraint where uniqueconstraintid=g2b(auniqueconstraintid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=uniqueconstraint' result;
    leave body;
  end if;
 start transaction ; 
 call uniqueconstraint_logger(acursession,auniqueconstraintid) ; 
 update  uniqueconstraint set changestamp=now()
,
  name=aname
,
  perparent=aperparent
,
  thecomment=athecomment
  where  uniqueconstraintid = g2b(auniqueconstraintid) ;


call uniqueconstraint_client_trigger(acursession,auniqueconstraintid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=uniqueconstraint' result;
    leave body;
  end if;
 start transaction;  
 insert into   uniqueconstraint
 (  uniqueconstraintid 
,parentstructrowid
,name

,perparent

,thecomment

 ) values ( g2b(auniqueconstraintid) 
,g2b(aparentstructrowid)
,aname

,aperparent

,athecomment

 ) ;


call uniqueconstraint_client_trigger(acursession,auniqueconstraintid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists constraintfield_brief
go

create procedure constraintfield_brief  (
 acursession varchar(38),
 aconstraintfieldid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aconstraintfieldid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from constraintfield where constraintfieldid=g2b(aconstraintfieldid);
 if  aec &gt;0 then
   set abrief=constraintfield_brief_f(g2b(aconstraintfieldid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists constraintfield_delete
go

create procedure constraintfield_delete /*поля ограничения*/ (
 acursession varchar(38),
 aconstraintfieldid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from constraintfield where constraintfieldid=g2b(aconstraintfieldid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=constraintfield' result;
    leave body;
  end if;
 call constraintfield_logger(acursession,aconstraintfieldid) ; 
  delete from  constraintfield 
  where  constraintfieldid = g2b(aconstraintfieldid) ;
  delete from num_values where ownerpartname='constraintfield' and ownerrowid=g2b(aconstraintfieldid);
  end if;
    select 'ok' result;
 end 
go
GO

/*поля ограничения*/

drop procedure if exists constraintfield_save
go

create procedure constraintfield_save /*поля ограничения*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aconstraintfieldid varchar(38)
,athefield varchar(38)/* поле *//* поле */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from constraintfield where constraintfieldid=g2b(aconstraintfieldid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=constraintfield' result;
    leave body;
  end if;
 start transaction ; 
 call constraintfield_logger(acursession,aconstraintfieldid) ; 
 update  constraintfield set changestamp=now()
,
  thefield=g2b(athefield)
  where  constraintfieldid = g2b(aconstraintfieldid) ;


call constraintfield_client_trigger(acursession,aconstraintfieldid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=constraintfield' result;
    leave body;
  end if;
 start transaction;  
 insert into   constraintfield
 (  constraintfieldid 
,parentstructrowid
,thefield

 ) values ( g2b(aconstraintfieldid) 
,g2b(aparentstructrowid)
,g2b(athefield)

 ) ;


call constraintfield_client_trigger(acursession,aconstraintfieldid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists extenderinterface_brief
go

create procedure extenderinterface_brief  (
 acursession varchar(38),
 aextenderinterfaceid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aextenderinterfaceid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from extenderinterface where extenderinterfaceid=g2b(aextenderinterfaceid);
 if  aec &gt;0 then
   set abrief=extenderinterface_brief_f(g2b(aextenderinterfaceid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists extenderinterface_delete
go

create procedure extenderinterface_delete /**/ (
 acursession varchar(38),
 aextenderinterfaceid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from extenderinterface where extenderinterfaceid=g2b(aextenderinterfaceid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=extenderinterface' result;
    leave body;
  end if;
 call extenderinterface_logger(acursession,aextenderinterfaceid) ; 
  delete from  extenderinterface 
  where  extenderinterfaceid = g2b(aextenderinterfaceid) ;
  delete from num_values where ownerpartname='extenderinterface' and ownerrowid=g2b(aextenderinterfaceid);
  end if;
    select 'ok' result;
 end 
go
GO

/*интерфейсы расширения*/

drop procedure if exists extenderinterface_save
go

create procedure extenderinterface_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aextenderinterfaceid varchar(38)
,athename
 varchar (255)/* название *//* название */
,atargetplatform varchar(38)/* целевая платформа *//* целевая платформа */
,atheobject
 varchar (255)/* объект *//* объект */
,atheconfig
 varchar (512)/* конфиг *//* конфиг */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from extenderinterface where extenderinterfaceid=g2b(aextenderinterfaceid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=extenderinterface' result;
    leave body;
  end if;
 start transaction ; 
 call extenderinterface_logger(acursession,aextenderinterfaceid) ; 
 update  extenderinterface set changestamp=now()
,
  thename=athename
,
  targetplatform=g2b(atargetplatform)
,
  theobject=atheobject
,
  theconfig=atheconfig
  where  extenderinterfaceid = g2b(aextenderinterfaceid) ;


call extenderinterface_client_trigger(acursession,aextenderinterfaceid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=extenderinterface' result;
    leave body;
  end if;
 start transaction;  
 insert into   extenderinterface
 (  extenderinterfaceid 
,parentstructrowid
,thename

,targetplatform

,theobject

,theconfig

 ) values ( g2b(aextenderinterfaceid) 
,g2b(aparentstructrowid)
,athename

,g2b(atargetplatform)

,atheobject

,atheconfig

 ) ;


call extenderinterface_client_trigger(acursession,aextenderinterfaceid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists field_brief
go

create procedure field_brief  (
 acursession varchar(38),
 afieldid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afieldid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from field where fieldid=g2b(afieldid);
 if  aec &gt;0 then
   set abrief=field_brief_f(g2b(afieldid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists field_delete
go

create procedure field_delete /*поле*/ (
 acursession varchar(38),
 afieldid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from field where fieldid=g2b(afieldid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=field' result;
    leave body;
  end if;
 call field_logger(acursession,afieldid) ; 
  delete from  field 
  where  fieldid = g2b(afieldid) ;
  delete from num_values where ownerpartname='field' and ownerrowid=g2b(afieldid);
  end if;
    select 'ok' result;
 end 
go
GO

/*поле*/

drop procedure if exists field_save
go

create procedure field_save /*поле*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 afieldid varchar(38)
,atabname
 varchar (60)/* имя вкладки *//* имя вкладки */
,afieldgroupbox
 varchar (60)/* имя группы *//* имя группы */
,asequence
 integer/* № п/п *//* № п/п */
,acaption
 varchar (80)/* надпись *//* надпись */
,aname
 varchar (64)/* имя поля *//* имя поля */
,afieldtype varchar(38)/* тип поля *//* тип поля */
,aisbrief
 integer/* краткая информация *//* краткая информация */
,aistabbrief
 integer/* для отображения в таблице *//* для отображения в таблице */
,aallownull
 integer/* может быть пустым *//* может быть пустым */
,adatasize
 integer/* размер поля *//* размер поля */
,areferencetype
 integer/* тип ссылки *//* тип ссылки */
,areftotype varchar(38)/* ссылка на тип *//* ссылка на тип */
,areftopart varchar(38)/* ссылка на раздел *//* ссылка на раздел */
,athestyle
 varchar (50)/* стиль *//* стиль */
,ainternalreference
 integer/* ссылка в пределах объекта *//* ссылка в пределах объекта */
,acreaterefonly
 integer/* только создание объекта *//* только создание объекта */
,aisautonumber
 integer/* автонумерация *//* автонумерация */
,athenumerator varchar(38)/* нумератор *//* нумератор */
,azonetemplate
 varchar (255)/* шаблон зоны нумерации *//* шаблон зоны нумерации */
,anumberdatefield varchar(38)/* поле для расчета даты *//* поле для расчета даты */
,athecomment
 text/* описание *//* описание */
,ashablonbrief
 varchar (100)/* шаблон для краткого отображения *//* шаблон для краткого отображения */
,athenameclass
 varchar (100)/* имя класса для мастера строк *//* имя класса для мастера строк */
,athemask
 varchar (64)/* маска *//* маска */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from field where fieldid=g2b(afieldid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=field' result;
    leave body;
  end if;
 start transaction ; 
 call field_logger(acursession,afieldid) ; 
 update  field set changestamp=now()
,
  tabname=atabname
,
  fieldgroupbox=afieldgroupbox
,
  sequence=asequence
,
  caption=acaption
,
  name=aname
,
  fieldtype=g2b(afieldtype)
,
  isbrief=aisbrief
,
  istabbrief=aistabbrief
,
  allownull=aallownull
,
  datasize=adatasize
,
  referencetype=areferencetype
,
  reftotype=g2b(areftotype)
,
  reftopart=g2b(areftopart)
,
  thestyle=athestyle
,
  internalreference=ainternalreference
,
  createrefonly=acreaterefonly
,
  isautonumber=aisautonumber
,
  thenumerator=g2b(athenumerator)
,
  zonetemplate=azonetemplate
,
  numberdatefield=g2b(anumberdatefield)
,
  thecomment=athecomment
,
  shablonbrief=ashablonbrief
,
  thenameclass=athenameclass
,
  themask=athemask
  where  fieldid = g2b(afieldid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from field where  parentstructrowid=g2b(aparentstructrowid) 
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=поле' result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from field where  parentstructrowid=g2b(aparentstructrowid) 
 and sequence=asequence;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=поле' result;
  rollback;
  leave body;
end if;
 -- end if;

call field_client_trigger(acursession,afieldid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=field' result;
    leave body;
  end if;
 start transaction;  
 insert into   field
 (  fieldid 
,parentstructrowid
,tabname

,fieldgroupbox

,sequence

,caption

,name

,fieldtype

,isbrief

,istabbrief

,allownull

,datasize

,referencetype

,reftotype

,reftopart

,thestyle

,internalreference

,createrefonly

,isautonumber

,thenumerator

,zonetemplate

,numberdatefield

,thecomment

,shablonbrief

,thenameclass

,themask

 ) values ( g2b(afieldid) 
,g2b(aparentstructrowid)
,atabname

,afieldgroupbox

,asequence

,acaption

,aname

,g2b(afieldtype)

,aisbrief

,aistabbrief

,aallownull

,adatasize

,areferencetype

,g2b(areftotype)

,g2b(areftopart)

,athestyle

,ainternalreference

,acreaterefonly

,aisautonumber

,g2b(athenumerator)

,azonetemplate

,g2b(anumberdatefield)

,athecomment

,ashablonbrief

,athenameclass

,athemask

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from field where  parentstructrowid=g2b(aparentstructrowid) 
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=поле' result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from field where  parentstructrowid=g2b(aparentstructrowid) 
 and sequence=asequence;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=поле' result;
  rollback;
  leave body;
end if;
 -- end if;

call field_client_trigger(acursession,afieldid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists fldextenders_brief
go

create procedure fldextenders_brief  (
 acursession varchar(38),
 afldextendersid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afldextendersid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from fldextenders where fldextendersid=g2b(afldextendersid);
 if  aec &gt;0 then
   set abrief=fldextenders_brief_f(g2b(afldextendersid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists fldextenders_delete
go

create procedure fldextenders_delete /**/ (
 acursession varchar(38),
 afldextendersid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fldextenders where fldextendersid=g2b(afldextendersid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=fldextenders' result;
    leave body;
  end if;
 call fldextenders_logger(acursession,afldextendersid) ; 
  delete from  fldextenders 
  where  fldextendersid = g2b(afldextendersid) ;
  delete from num_values where ownerpartname='fldextenders' and ownerrowid=g2b(afldextendersid);
  end if;
    select 'ok' result;
 end 
go
GO

/*интерфейсы расширения*/

drop procedure if exists fldextenders_save
go

create procedure fldextenders_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 afldextendersid varchar(38)
,athename
 varchar (255)/* название *//* название */
,atargetplatform varchar(38)/* целевая платформа *//* целевая платформа */
,atheobject
 varchar (255)/* объект *//* объект */
,atheconfig
 varchar (512)/* конфиг *//* конфиг */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fldextenders where fldextendersid=g2b(afldextendersid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=fldextenders' result;
    leave body;
  end if;
 start transaction ; 
 call fldextenders_logger(acursession,afldextendersid) ; 
 update  fldextenders set changestamp=now()
,
  thename=athename
,
  targetplatform=g2b(atargetplatform)
,
  theobject=atheobject
,
  theconfig=atheconfig
  where  fldextendersid = g2b(afldextendersid) ;


call fldextenders_client_trigger(acursession,afldextendersid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=fldextenders' result;
    leave body;
  end if;
 start transaction;  
 insert into   fldextenders
 (  fldextendersid 
,parentstructrowid
,thename

,targetplatform

,theobject

,theconfig

 ) values ( g2b(afldextendersid) 
,g2b(aparentstructrowid)
,athename

,g2b(atargetplatform)

,atheobject

,atheconfig

 ) ;


call fldextenders_client_trigger(acursession,afldextendersid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists fieldsrcdef_brief
go

create procedure fieldsrcdef_brief  (
 acursession varchar(38),
 afieldsrcdefid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afieldsrcdefid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from fieldsrcdef where fieldsrcdefid=g2b(afieldsrcdefid);
 if  aec &gt;0 then
   set abrief=fieldsrcdef_brief_f(g2b(afieldsrcdefid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists fieldsrcdef_delete
go

create procedure fieldsrcdef_delete /*описание источника данных для полей типа referencesql */ (
 acursession varchar(38),
 afieldsrcdefid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldsrcdef where fieldsrcdefid=g2b(afieldsrcdefid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=fieldsrcdef' result;
    leave body;
  end if;
 call fieldsrcdef_logger(acursession,afieldsrcdefid) ; 
  delete from  fieldsrcdef 
  where  fieldsrcdefid = g2b(afieldsrcdefid) ;
  delete from num_values where ownerpartname='fieldsrcdef' and ownerrowid=g2b(afieldsrcdefid);
  end if;
    select 'ok' result;
 end 
go
GO

/*описание источника данных*/

drop procedure if exists fieldsrcdef_save
go

create procedure fieldsrcdef_save /*описание источника данных для полей типа referencesql */ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 afieldsrcdefid varchar(38)
,aprovider
 varchar (128)/* провайдер *//* провайдер */
,aconnectionstring
 varchar (512)/* строка соединения с источником *//* строка соединения с источником */
,adatasource
 varchar (512)/* источник данных *//* источник данных */
,aidfield
 varchar (128)/* id *//* id */
,abriefstring
 varchar (512)/* источник краткой информации *//* источник краткой информации */
,afilterstring
 varchar (512)/* фильтр источника данных *//* фильтр источника данных */
,asortfield
 varchar (512)/* сортировка источника данных *//* сортировка источника данных */
,adescriptionstring
 text/* примечания *//* примечания */
,adontshowdialog
 integer/* не показывать форму выбора *//* не показывать форму выбора */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldsrcdef where fieldsrcdefid=g2b(afieldsrcdefid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=fieldsrcdef' result;
    leave body;
  end if;
 start transaction ; 
 call fieldsrcdef_logger(acursession,afieldsrcdefid) ; 
 update  fieldsrcdef set changestamp=now()
,
  provider=aprovider
,
  connectionstring=aconnectionstring
,
  datasource=adatasource
,
  idfield=aidfield
,
  briefstring=abriefstring
,
  filterstring=afilterstring
,
  sortfield=asortfield
,
  descriptionstring=adescriptionstring
,
  dontshowdialog=adontshowdialog
  where  fieldsrcdefid = g2b(afieldsrcdefid) ;


call fieldsrcdef_client_trigger(acursession,afieldsrcdefid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=fieldsrcdef' result;
    leave body;
  end if;
select count(*) into aec from fieldsrcdef where 
parentstructrowid=g2b(aparentstructrowid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;fieldsrcdef&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   fieldsrcdef
 (  fieldsrcdefid 
,parentstructrowid
,provider

,connectionstring

,datasource

,idfield

,briefstring

,filterstring

,sortfield

,descriptionstring

,dontshowdialog

 ) values ( g2b(afieldsrcdefid) 
,g2b(aparentstructrowid)
,aprovider

,aconnectionstring

,adatasource

,aidfield

,abriefstring

,afilterstring

,asortfield

,adescriptionstring

,adontshowdialog

 ) ;


call fieldsrcdef_client_trigger(acursession,afieldsrcdefid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists dinamicfilterscript_brief
go

create procedure dinamicfilterscript_brief  (
 acursession varchar(38),
 adinamicfilterscriptid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if adinamicfilterscriptid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from dinamicfilterscript where dinamicfilterscriptid=g2b(adinamicfilterscriptid);
 if  aec &gt;0 then
   set abrief=dinamicfilterscript_brief_f(g2b(adinamicfilterscriptid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists dinamicfilterscript_delete
go

create procedure dinamicfilterscript_delete /*выражение для построения дополнительного фильтра для ссылочных полей*/ (
 acursession varchar(38),
 adinamicfilterscriptid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from dinamicfilterscript where dinamicfilterscriptid=g2b(adinamicfilterscriptid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=dinamicfilterscript' result;
    leave body;
  end if;
 call dinamicfilterscript_logger(acursession,adinamicfilterscriptid) ; 
  delete from  dinamicfilterscript 
  where  dinamicfilterscriptid = g2b(adinamicfilterscriptid) ;
  delete from num_values where ownerpartname='dinamicfilterscript' and ownerrowid=g2b(adinamicfilterscriptid);
  end if;
    select 'ok' result;
 end 
go
GO

/*динамический фильтр*/

drop procedure if exists dinamicfilterscript_save
go

create procedure dinamicfilterscript_save /*выражение для построения дополнительного фильтра для ссылочных полей*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 adinamicfilterscriptid varchar(38)
,atarget varchar(38)/* целевая платформа *//* целевая платформа */
,acode
 text/* скрипт *//* скрипт */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from dinamicfilterscript where dinamicfilterscriptid=g2b(adinamicfilterscriptid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=dinamicfilterscript' result;
    leave body;
  end if;
 start transaction ; 
 call dinamicfilterscript_logger(acursession,adinamicfilterscriptid) ; 
 update  dinamicfilterscript set changestamp=now()
,
  target=g2b(atarget)
,
  code=acode
  where  dinamicfilterscriptid = g2b(adinamicfilterscriptid) ;


call dinamicfilterscript_client_trigger(acursession,adinamicfilterscriptid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=dinamicfilterscript' result;
    leave body;
  end if;
 start transaction;  
 insert into   dinamicfilterscript
 (  dinamicfilterscriptid 
,parentstructrowid
,target

,code

 ) values ( g2b(adinamicfilterscriptid) 
,g2b(aparentstructrowid)
,g2b(atarget)

,acode

 ) ;


call dinamicfilterscript_client_trigger(acursession,adinamicfilterscriptid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists fieldexpression_brief
go

create procedure fieldexpression_brief  (
 acursession varchar(38),
 afieldexpressionid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afieldexpressionid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from fieldexpression where fieldexpressionid=g2b(afieldexpressionid);
 if  aec &gt;0 then
   set abrief=fieldexpression_brief_f(g2b(afieldexpressionid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists fieldexpression_delete
go

create procedure fieldexpression_delete /*выражение для вычисления поля
или значение по умолчанию*/ (
 acursession varchar(38),
 afieldexpressionid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldexpression where fieldexpressionid=g2b(afieldexpressionid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=fieldexpression' result;
    leave body;
  end if;
 call fieldexpression_logger(acursession,afieldexpressionid) ; 
  delete from  fieldexpression 
  where  fieldexpressionid = g2b(afieldexpressionid) ;
  delete from num_values where ownerpartname='fieldexpression' and ownerrowid=g2b(afieldexpressionid);
  end if;
    select 'ok' result;
 end 
go
GO

/*значение по умолчанию*/

drop procedure if exists fieldexpression_save
go

create procedure fieldexpression_save /*выражение для вычисления поля
или значение по умолчанию*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 afieldexpressionid varchar(38)
,atarget varchar(38)/* платформа *//* платформа */
,acode
 text/* скрипт *//* скрипт */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldexpression where fieldexpressionid=g2b(afieldexpressionid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=fieldexpression' result;
    leave body;
  end if;
 start transaction ; 
 call fieldexpression_logger(acursession,afieldexpressionid) ; 
 update  fieldexpression set changestamp=now()
,
  target=g2b(atarget)
,
  code=acode
  where  fieldexpressionid = g2b(afieldexpressionid) ;


call fieldexpression_client_trigger(acursession,afieldexpressionid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=fieldexpression' result;
    leave body;
  end if;
 start transaction;  
 insert into   fieldexpression
 (  fieldexpressionid 
,parentstructrowid
,target

,code

 ) values ( g2b(afieldexpressionid) 
,g2b(aparentstructrowid)
,g2b(atarget)

,acode

 ) ;


call fieldexpression_client_trigger(acursession,afieldexpressionid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists fieldvalidator_brief
go

create procedure fieldvalidator_brief  (
 acursession varchar(38),
 afieldvalidatorid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afieldvalidatorid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from fieldvalidator where fieldvalidatorid=g2b(afieldvalidatorid);
 if  aec &gt;0 then
   set abrief=fieldvalidator_brief_f(g2b(afieldvalidatorid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists fieldvalidator_delete
go

create procedure fieldvalidator_delete /*логика взаимосвязей на форме при изменении поля*/ (
 acursession varchar(38),
 afieldvalidatorid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldvalidator where fieldvalidatorid=g2b(afieldvalidatorid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=fieldvalidator' result;
    leave body;
  end if;
 call fieldvalidator_logger(acursession,afieldvalidatorid) ; 
  delete from  fieldvalidator 
  where  fieldvalidatorid = g2b(afieldvalidatorid) ;
  delete from num_values where ownerpartname='fieldvalidator' and ownerrowid=g2b(afieldvalidatorid);
  end if;
    select 'ok' result;
 end 
go
GO

/*логика поля на форме*/

drop procedure if exists fieldvalidator_save
go

create procedure fieldvalidator_save /*логика взаимосвязей на форме при изменении поля*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 afieldvalidatorid varchar(38)
,atarget varchar(38)/* платформа *//* платформа */
,acode
 text/* скрипт *//* скрипт */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldvalidator where fieldvalidatorid=g2b(afieldvalidatorid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=fieldvalidator' result;
    leave body;
  end if;
 start transaction ; 
 call fieldvalidator_logger(acursession,afieldvalidatorid) ; 
 update  fieldvalidator set changestamp=now()
,
  target=g2b(atarget)
,
  code=acode
  where  fieldvalidatorid = g2b(afieldvalidatorid) ;


call fieldvalidator_client_trigger(acursession,afieldvalidatorid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=fieldvalidator' result;
    leave body;
  end if;
 start transaction;  
 insert into   fieldvalidator
 (  fieldvalidatorid 
,parentstructrowid
,target

,code

 ) values ( g2b(afieldvalidatorid) 
,g2b(aparentstructrowid)
,g2b(atarget)

,acode

 ) ;


call fieldvalidator_client_trigger(acursession,afieldvalidatorid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists fieldmenu_brief
go

create procedure fieldmenu_brief  (
 acursession varchar(38),
 afieldmenuid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afieldmenuid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from fieldmenu where fieldmenuid=g2b(afieldmenuid);
 if  aec &gt;0 then
   set abrief=fieldmenu_brief_f(g2b(afieldmenuid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists fieldmenu_delete
go

create procedure fieldmenu_delete /*методы, ассоциированные с полем*/ (
 acursession varchar(38),
 afieldmenuid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldmenu where fieldmenuid=g2b(afieldmenuid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=fieldmenu' result;
    leave body;
  end if;
 call fieldmenu_logger(acursession,afieldmenuid) ; 
  delete from  fieldmenu 
  where  fieldmenuid = g2b(afieldmenuid) ;
  delete from num_values where ownerpartname='fieldmenu' and ownerrowid=g2b(afieldmenuid);
  end if;
    select 'ok' result;
 end 
go
GO

/*методы поля*/

drop procedure if exists fieldmenu_save
go

create procedure fieldmenu_save /*методы, ассоциированные с полем*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 afieldmenuid varchar(38)
,aname
 varchar (64)/* название *//* название */
,acaption
 varchar (80)/* заголовок *//* заголовок */
,atooltip
 varchar (80)/* подсказка *//* подсказка */
,aactionid varchar(38)/* идентификатор вызываемого метода *//* идентификатор вызываемого метода */
,aismenuitem
 integer/* в меню *//* в меню */
,aistoolbarbutton
 integer/* в тулбар *//* в тулбар */
,ahotkey
 varchar (20)/* горячая клавиша *//* горячая клавиша */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldmenu where fieldmenuid=g2b(afieldmenuid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=fieldmenu' result;
    leave body;
  end if;
 start transaction ; 
 call fieldmenu_logger(acursession,afieldmenuid) ; 
 update  fieldmenu set changestamp=now()
,
  name=aname
,
  caption=acaption
,
  tooltip=atooltip
,
  actionid=g2b(aactionid)
,
  ismenuitem=aismenuitem
,
  istoolbarbutton=aistoolbarbutton
,
  hotkey=ahotkey
  where  fieldmenuid = g2b(afieldmenuid) ;


call fieldmenu_client_trigger(acursession,afieldmenuid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=fieldmenu' result;
    leave body;
  end if;
 start transaction;  
 insert into   fieldmenu
 (  fieldmenuid 
,parentstructrowid
,name

,caption

,tooltip

,actionid

,ismenuitem

,istoolbarbutton

,hotkey

 ) values ( g2b(afieldmenuid) 
,g2b(aparentstructrowid)
,aname

,acaption

,atooltip

,g2b(aactionid)

,aismenuitem

,aistoolbarbutton

,ahotkey

 ) ;


call fieldmenu_client_trigger(acursession,afieldmenuid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists fieldparammap_brief
go

create procedure fieldparammap_brief  (
 acursession varchar(38),
 afieldparammapid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afieldparammapid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from fieldparammap where fieldparammapid=g2b(afieldparammapid);
 if  aec &gt;0 then
   set abrief=fieldparammap_brief_f(g2b(afieldparammapid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists fieldparammap_delete
go

create procedure fieldparammap_delete /*отображение значений на параметры метода*/ (
 acursession varchar(38),
 afieldparammapid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldparammap where fieldparammapid=g2b(afieldparammapid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=fieldparammap' result;
    leave body;
  end if;
 call fieldparammap_logger(acursession,afieldparammapid) ; 
  delete from  fieldparammap 
  where  fieldparammapid = g2b(afieldparammapid) ;
  delete from num_values where ownerpartname='fieldparammap' and ownerrowid=g2b(afieldparammapid);
  end if;
    select 'ok' result;
 end 
go
GO

/*отображение параметров*/

drop procedure if exists fieldparammap_save
go

create procedure fieldparammap_save /*отображение значений на параметры метода*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 afieldparammapid varchar(38)
,afieldname
 varchar (255)/* поле (значение) *//* поле (значение) */
,aparamname
 varchar (80)/* параметр *//* параметр */
,anoedit
 integer/* редактировать параметр нельзя *//* редактировать параметр нельзя */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fieldparammap where fieldparammapid=g2b(afieldparammapid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=fieldparammap' result;
    leave body;
  end if;
 start transaction ; 
 call fieldparammap_logger(acursession,afieldparammapid) ; 
 update  fieldparammap set changestamp=now()
,
  fieldname=afieldname
,
  paramname=aparamname
,
  noedit=anoedit
  where  fieldparammapid = g2b(afieldparammapid) ;


call fieldparammap_client_trigger(acursession,afieldparammapid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=fieldparammap' result;
    leave body;
  end if;
 start transaction;  
 insert into   fieldparammap
 (  fieldparammapid 
,parentstructrowid
,fieldname

,paramname

,noedit

 ) values ( g2b(afieldparammapid) 
,g2b(aparentstructrowid)
,afieldname

,aparamname

,anoedit

 ) ;


call fieldparammap_client_trigger(acursession,afieldparammapid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists nextstate_copy
go

create procedure nextstate_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into nextstate 
 ( nextstateid 
,parentstructrowid
,thestate

 ) select 
copymap(acopyaction,b2g(nextstateid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,thestate

 from nextstate
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists objstatus_copy
go

create procedure objstatus_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_objstatus cursor for
select objstatusid from objstatus where 
parentstructrowid=aparentstructrowid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into objstatus 
 ( objstatusid 
,parentstructrowid
,name

,isstartup

,isarchive

,the_comment

 ) select 
copymap(acopyaction,b2g(objstatusid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,isstartup

,isarchive

,the_comment

 from objstatus
 where parentstructrowid =g2b(aparentstructrowid); 
open copy_cursor_objstatus;
  set  fetch_done=false;
fetch copy_cursor_objstatus into aid;
while not fetch_done do 
    call nextstate_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_objstatus into aid;
end while;

close copy_cursor_objstatus;
 end 
go
GO


drop procedure if exists structrestriction_copy
go

create procedure structrestriction_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into structrestriction 
 ( structrestrictionid 
,parentstructrowid
,struct

,allowread

,allowadd

,allowedit

,allowdelete

 ) select 
copymap(acopyaction,b2g(structrestrictionid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,struct

,allowread

,allowadd

,allowedit

,allowdelete

 from structrestriction
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists methodrestriction_copy
go

create procedure methodrestriction_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into methodrestriction 
 ( methodrestrictionid 
,parentstructrowid
,part

,method

,isrestricted

 ) select 
copymap(acopyaction,b2g(methodrestrictionid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,part

,method

,isrestricted

 from methodrestriction
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists fieldrestriction_copy
go

create procedure fieldrestriction_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into fieldrestriction 
 ( fieldrestrictionid 
,parentstructrowid
,thepart

,thefield

,allowread

,allowmodify

,mandatoryfield

 ) select 
copymap(acopyaction,b2g(fieldrestrictionid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,thepart

,thefield

,allowread

,allowmodify

,mandatoryfield

 from fieldrestriction
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists objectmode_copy
go

create procedure objectmode_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_objectmode cursor for
select objectmodeid from objectmode where 
parentstructrowid=aparentstructrowid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into objectmode 
 ( objectmodeid 
,parentstructrowid
,name

,defaultmode

,thecomment

 ) select 
copymap(acopyaction,b2g(objectmodeid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,defaultmode

,thecomment

 from objectmode
 where parentstructrowid =g2b(aparentstructrowid); 
open copy_cursor_objectmode;
  set  fetch_done=false;
fetch copy_cursor_objectmode into aid;
while not fetch_done do 
    call structrestriction_copy(acursession,acopyaction,ainstanceid,aid);
    call methodrestriction_copy(acursession,acopyaction,ainstanceid,aid);
    call fieldrestriction_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_objectmode into aid;
end while;

close copy_cursor_objectmode;
 end 
go
GO


drop procedure if exists typemenu_copy
go

create procedure typemenu_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into typemenu 
 ( typemenuid 
,parentstructrowid
,name

,caption

,tooltip

,the_action

,ismenuitem

,istoolbarbutton

,hotkey

 ) select 
copymap(acopyaction,b2g(typemenuid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,caption

,tooltip

,the_action

,ismenuitem

,istoolbarbutton

,hotkey

 from typemenu
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists instancevalidator_copy
go

create procedure instancevalidator_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into instancevalidator 
 ( instancevalidatorid 
,parentstructrowid
,target

,code

 ) select 
copymap(acopyaction,b2g(instancevalidatorid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,target

,code

 from instancevalidator
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists partparammap_copy
go

create procedure partparammap_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into partparammap 
 ( partparammapid 
,parentstructrowid
,fieldname

,paramname

,noedit

 ) select 
copymap(acopyaction,b2g(partparammapid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,fieldname

,paramname

,noedit

 from partparammap
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists partmenu_copy
go

create procedure partmenu_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_partmenu cursor for
select partmenuid from partmenu where 
parentstructrowid=aparentstructrowid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into partmenu 
 ( partmenuid 
,parentstructrowid
,name

,caption

,tooltip

,the_action

,ismenuitem

,istoolbarbutton

,hotkey

 ) select 
copymap(acopyaction,b2g(partmenuid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,caption

,tooltip

,the_action

,ismenuitem

,istoolbarbutton

,hotkey

 from partmenu
 where parentstructrowid =g2b(aparentstructrowid); 
open copy_cursor_partmenu;
  set  fetch_done=false;
fetch copy_cursor_partmenu into aid;
while not fetch_done do 
    call partparammap_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_partmenu into aid;
end while;

close copy_cursor_partmenu;
 end 
go
GO


drop procedure if exists viewcolumn_copy
go

create procedure viewcolumn_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into viewcolumn 
 ( viewcolumnid 
,parentstructrowid
,sequence

,name

,the_alias

,frompart

,field

,aggregation

,expression

,forcombo

 ) select 
copymap(acopyaction,b2g(viewcolumnid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,sequence

,name

,the_alias

,frompart

,field

,aggregation

,expression

,forcombo

 from viewcolumn
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists partview_lnk_copy
go

create procedure partview_lnk_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into partview_lnk 
 ( partview_lnkid 
,parentstructrowid
,theview

,thejoinsource

,reftype

,thejoindestination

,handjoin

,seq

 ) select 
copymap(acopyaction,b2g(partview_lnkid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,theview

,thejoinsource

,reftype

,thejoindestination

,handjoin

,seq

 from partview_lnk
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists partview_copy
go

create procedure partview_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_partview cursor for
select partviewid from partview where 
parentstructrowid=aparentstructrowid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into partview 
 ( partviewid 
,parentstructrowid
,name

,the_alias

,forchoose

,filterfield0

,filterfield1

,filterfield2

,filterfield3

 ) select 
copymap(acopyaction,b2g(partviewid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,the_alias

,forchoose

,filterfield0

,filterfield1

,filterfield2

,filterfield3

 from partview
 where parentstructrowid =g2b(aparentstructrowid); 
open copy_cursor_partview;
  set  fetch_done=false;
fetch copy_cursor_partview into aid;
while not fetch_done do 
    call viewcolumn_copy(acursession,acopyaction,ainstanceid,aid);
    call partview_lnk_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_partview into aid;
end while;

close copy_cursor_partview;
 end 
go
GO


drop procedure if exists validator_copy
go

create procedure validator_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into validator 
 ( validatorid 
,parentstructrowid
,target

,code

 ) select 
copymap(acopyaction,b2g(validatorid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,target

,code

 from validator
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists constraintfield_copy
go

create procedure constraintfield_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into constraintfield 
 ( constraintfieldid 
,parentstructrowid
,thefield

 ) select 
copymap(acopyaction,b2g(constraintfieldid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,thefield

 from constraintfield
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists uniqueconstraint_copy
go

create procedure uniqueconstraint_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_uniqueconstraint cursor for
select uniqueconstraintid from uniqueconstraint where 
parentstructrowid=aparentstructrowid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into uniqueconstraint 
 ( uniqueconstraintid 
,parentstructrowid
,name

,perparent

,thecomment

 ) select 
copymap(acopyaction,b2g(uniqueconstraintid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,perparent

,thecomment

 from uniqueconstraint
 where parentstructrowid =g2b(aparentstructrowid); 
open copy_cursor_uniqueconstraint;
  set  fetch_done=false;
fetch copy_cursor_uniqueconstraint into aid;
while not fetch_done do 
    call constraintfield_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_uniqueconstraint into aid;
end while;

close copy_cursor_uniqueconstraint;
 end 
go
GO


drop procedure if exists extenderinterface_copy
go

create procedure extenderinterface_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into extenderinterface 
 ( extenderinterfaceid 
,parentstructrowid
,thename

,targetplatform

,theobject

,theconfig

 ) select 
copymap(acopyaction,b2g(extenderinterfaceid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,thename

,targetplatform

,theobject

,theconfig

 from extenderinterface
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists fldextenders_copy
go

create procedure fldextenders_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into fldextenders 
 ( fldextendersid 
,parentstructrowid
,thename

,targetplatform

,theobject

,theconfig

 ) select 
copymap(acopyaction,b2g(fldextendersid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,thename

,targetplatform

,theobject

,theconfig

 from fldextenders
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists fieldsrcdef_copy
go

create procedure fieldsrcdef_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into fieldsrcdef 
 ( fieldsrcdefid 
,parentstructrowid
,provider

,connectionstring

,datasource

,idfield

,briefstring

,filterstring

,sortfield

,descriptionstring

,dontshowdialog

 ) select 
copymap(acopyaction,b2g(fieldsrcdefid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,provider

,connectionstring

,datasource

,idfield

,briefstring

,filterstring

,sortfield

,descriptionstring

,dontshowdialog

 from fieldsrcdef
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists dinamicfilterscript_copy
go

create procedure dinamicfilterscript_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into dinamicfilterscript 
 ( dinamicfilterscriptid 
,parentstructrowid
,target

,code

 ) select 
copymap(acopyaction,b2g(dinamicfilterscriptid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,target

,code

 from dinamicfilterscript
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists fieldexpression_copy
go

create procedure fieldexpression_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into fieldexpression 
 ( fieldexpressionid 
,parentstructrowid
,target

,code

 ) select 
copymap(acopyaction,b2g(fieldexpressionid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,target

,code

 from fieldexpression
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists fieldvalidator_copy
go

create procedure fieldvalidator_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into fieldvalidator 
 ( fieldvalidatorid 
,parentstructrowid
,target

,code

 ) select 
copymap(acopyaction,b2g(fieldvalidatorid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,target

,code

 from fieldvalidator
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists fieldparammap_copy
go

create procedure fieldparammap_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into fieldparammap 
 ( fieldparammapid 
,parentstructrowid
,fieldname

,paramname

,noedit

 ) select 
copymap(acopyaction,b2g(fieldparammapid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,fieldname

,paramname

,noedit

 from fieldparammap
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists fieldmenu_copy
go

create procedure fieldmenu_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_fieldmenu cursor for
select fieldmenuid from fieldmenu where 
parentstructrowid=aparentstructrowid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into fieldmenu 
 ( fieldmenuid 
,parentstructrowid
,name

,caption

,tooltip

,actionid

,ismenuitem

,istoolbarbutton

,hotkey

 ) select 
copymap(acopyaction,b2g(fieldmenuid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,caption

,tooltip

,actionid

,ismenuitem

,istoolbarbutton

,hotkey

 from fieldmenu
 where parentstructrowid =g2b(aparentstructrowid); 
open copy_cursor_fieldmenu;
  set  fetch_done=false;
fetch copy_cursor_fieldmenu into aid;
while not fetch_done do 
    call fieldparammap_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_fieldmenu into aid;
end while;

close copy_cursor_fieldmenu;
 end 
go
GO


drop procedure if exists field_copy
go

create procedure field_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_field cursor for
select fieldid from field where 
parentstructrowid=aparentstructrowid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into field 
 ( fieldid 
,parentstructrowid
,tabname

,fieldgroupbox

,sequence

,caption

,name

,fieldtype

,isbrief

,istabbrief

,allownull

,datasize

,referencetype

,reftotype

,reftopart

,thestyle

,internalreference

,createrefonly

,isautonumber

,thenumerator

,zonetemplate

,numberdatefield

,thecomment

,shablonbrief

,thenameclass

,themask

 ) select 
copymap(acopyaction,b2g(fieldid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,tabname

,fieldgroupbox

,sequence

,caption

,name

,fieldtype

,isbrief

,istabbrief

,allownull

,datasize

,referencetype

,reftotype

,reftopart

,thestyle

,internalreference

,createrefonly

,isautonumber

,thenumerator

,zonetemplate

,numberdatefield

,thecomment

,shablonbrief

,thenameclass

,themask

 from field
 where parentstructrowid =g2b(aparentstructrowid); 
open copy_cursor_field;
  set  fetch_done=false;
fetch copy_cursor_field into aid;
while not fetch_done do 
    call fldextenders_copy(acursession,acopyaction,ainstanceid,aid);
    call fieldsrcdef_copy(acursession,acopyaction,ainstanceid,aid);
    call dinamicfilterscript_copy(acursession,acopyaction,ainstanceid,aid);
    call fieldexpression_copy(acursession,acopyaction,ainstanceid,aid);
    call fieldvalidator_copy(acursession,acopyaction,ainstanceid,aid);
    call fieldmenu_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_field into aid;
end while;

close copy_cursor_field;
 end 
go
GO


drop procedure if exists part_copy
go

create procedure part_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_part cursor for
select partid from part where 
parentstructrowid=aparentstructrowid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into part 
 ( partid 
,parentstructrowid
,parentrowid
,sequence

,parttype

,caption

,name

,the_comment

,nolog

,manualregister

,oncreate

,onsave

,onrun

,ondelete

,addbehaivor

,extenderobject

,shablonbrief

,rulebrief

,isjormalchange

,usearchiving

,integerpkey

,particoncls

 ) select 
copymap(acopyaction,b2g(partid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,copymap(acopyaction,b2g(parentrowid))
,sequence

,parttype

,caption

,name

,the_comment

,nolog

,manualregister

,oncreate

,onsave

,onrun

,ondelete

,addbehaivor

,extenderobject

,shablonbrief

,rulebrief

,isjormalchange

,usearchiving

,integerpkey

,particoncls

 from part
 where parentstructrowid =g2b(aparentstructrowid); 
open copy_cursor_part;
  set  fetch_done=false;
fetch copy_cursor_part into aid;
while not fetch_done do 
    call partmenu_copy(acursession,acopyaction,ainstanceid,aid);
    call partview_copy(acursession,acopyaction,ainstanceid,aid);
    call validator_copy(acursession,acopyaction,ainstanceid,aid);
    call uniqueconstraint_copy(acursession,acopyaction,ainstanceid,aid);
    call extenderinterface_copy(acursession,acopyaction,ainstanceid,aid);
    call field_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_part into aid;
end while;

close copy_cursor_part;
 end 
go
GO


drop procedure if exists objecttype_copy
go

create procedure objecttype_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_objecttype cursor for
select objecttypeid from objecttype where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into objecttype 
 ( objecttypeid 
,instanceid
,package

,the_comment

,name

,issingleinstance

,chooseview

,onrun

,oncreate

,ondelete

,allowreftoobject

,allowsearch

,replicatype

,thecomment

,useownership

,usearchiving

,commitfullobject

,objiconcls

 ) select 
copymap(acopyaction,b2g(objecttypeid)) 
,copymap(acopyaction,b2g(instanceid))
,package

,the_comment

,name

,issingleinstance

,chooseview

,onrun

,oncreate

,ondelete

,allowreftoobject

,allowsearch

,replicatype

,thecomment

,useownership

,usearchiving

,commitfullobject

,objiconcls

 from objecttype
 where instanceid =g2b( ainstanceid); 
open copy_cursor_objecttype;
  set  fetch_done=false;
fetch copy_cursor_objecttype into aid;
while not fetch_done do 
    call objstatus_copy(acursession,acopyaction,ainstanceid,aid);
    call objectmode_copy(acursession,acopyaction,ainstanceid,aid);
    call typemenu_copy(acursession,acopyaction,ainstanceid,aid);
    call instancevalidator_copy(acursession,acopyaction,ainstanceid,aid);
    call part_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_objecttype into aid;
end while;

close copy_cursor_objecttype;
 end 
go
GO


drop procedure if exists objecttype_logger
go

create procedure objecttype_logger /*тип объекта (карточки)*/ (
 acursession varchar(38),
 aobjecttypeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists objstatus_logger
go

create procedure objstatus_logger /*возможные логические состояния документа*/ (
 acursession varchar(38),
 aobjstatusid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists nextstate_logger
go

create procedure nextstate_logger /*матрица переходов */ (
 acursession varchar(38),
 anextstateid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists objectmode_logger
go

create procedure objectmode_logger /*режим работы*/ (
 acursession varchar(38),
 aobjectmodeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists structrestriction_logger
go

create procedure structrestriction_logger /*ораничения на доступ к разделу документа*/ (
 acursession varchar(38),
 astructrestrictionid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists methodrestriction_logger
go

create procedure methodrestriction_logger /*ограничение на использование методов раздела*/ (
 acursession varchar(38),
 amethodrestrictionid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists fieldrestriction_logger
go

create procedure fieldrestriction_logger /*ограничения на доступ к полям раздела*/ (
 acursession varchar(38),
 afieldrestrictionid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists typemenu_logger
go

create procedure typemenu_logger /*методы уровня типа*/ (
 acursession varchar(38),
 atypemenuid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists instancevalidator_logger
go

create procedure instancevalidator_logger /*проверка правильности для объекта в целом*/ (
 acursession varchar(38),
 ainstancevalidatorid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists part_logger
go

create procedure part_logger /*раздел объекта*/ (
 acursession varchar(38),
 apartid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists partmenu_logger
go

create procedure partmenu_logger /*методы уровня раздела*/ (
 acursession varchar(38),
 apartmenuid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists partparammap_logger
go

create procedure partparammap_logger /*отображение значений полей раздела на параметры метода*/ (
 acursession varchar(38),
 apartparammapid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists partview_logger
go

create procedure partview_logger /*вариант представления, который может использоваться для создания журнала*/ (
 acursession varchar(38),
 apartviewid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists viewcolumn_logger
go

create procedure viewcolumn_logger /*колонка пердставления*/ (
 acursession varchar(38),
 aviewcolumnid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists partview_lnk_logger
go

create procedure partview_lnk_logger /**/ (
 acursession varchar(38),
 apartview_lnkid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists validator_logger
go

create procedure validator_logger /*действия в впроцессе редактирования*/ (
 acursession varchar(38),
 avalidatorid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists uniqueconstraint_logger
go

create procedure uniqueconstraint_logger /*ограничение уникальности*/ (
 acursession varchar(38),
 auniqueconstraintid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists constraintfield_logger
go

create procedure constraintfield_logger /*поля ограничения*/ (
 acursession varchar(38),
 aconstraintfieldid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists extenderinterface_logger
go

create procedure extenderinterface_logger /**/ (
 acursession varchar(38),
 aextenderinterfaceid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists field_logger
go

create procedure field_logger /*поле*/ (
 acursession varchar(38),
 afieldid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists fldextenders_logger
go

create procedure fldextenders_logger /**/ (
 acursession varchar(38),
 afldextendersid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists fieldsrcdef_logger
go

create procedure fieldsrcdef_logger /*описание источника данных для полей типа referencesql */ (
 acursession varchar(38),
 afieldsrcdefid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists dinamicfilterscript_logger
go

create procedure dinamicfilterscript_logger /*выражение для построения дополнительного фильтра для ссылочных полей*/ (
 acursession varchar(38),
 adinamicfilterscriptid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists fieldexpression_logger
go

create procedure fieldexpression_logger /*выражение для вычисления поля
или значение по умолчанию*/ (
 acursession varchar(38),
 afieldexpressionid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists fieldvalidator_logger
go

create procedure fieldvalidator_logger /*логика взаимосвязей на форме при изменении поля*/ (
 acursession varchar(38),
 afieldvalidatorid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists fieldmenu_logger
go

create procedure fieldmenu_logger /*методы, ассоциированные с полем*/ (
 acursession varchar(38),
 afieldmenuid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists fieldparammap_logger
go

create procedure fieldparammap_logger /*отображение значений на параметры метода*/ (
 acursession varchar(38),
 afieldparammapid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists objecttype_parent
go
create procedure objecttype_parent /* тип объекта (карточки)*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from objecttype where  objecttypeid=arowid;
 end 
go
GO


drop procedure if exists objecttype_islocked
go
create procedure objecttype_islocked /* тип объекта (карточки) */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from objecttype where objecttypeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists objecttype_lock
go
create procedure objecttype_lock /* тип объекта (карточки) */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call objecttype_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update objecttype set lockuserid =auserid ,locksessionid=null  where objecttypeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update objecttype set lockuserid=null ,locksessionid =acursession  where objecttypeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists objecttype_unlock
go
create procedure objecttype_unlock /* тип объекта (карточки) */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call objecttype_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update objecttype set lockuserid =null  where objecttypeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update objecttype set locksessionid =null  where objecttypeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS objecttype_client_trigger
GO

create procedure objecttype_client_trigger  (
 acursession varchar(38),
 aOBJECTTYPEid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists objstatus_parent
go
create procedure objstatus_parent /* возможные логические состояния документа*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from objstatus where  objstatusid=arowid;
  set aparenttable = 'objecttype';
 end 
go
GO


drop procedure if exists objstatus_islocked
go
create procedure objstatus_islocked /* возможные логические состояния документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from objstatus where objstatusid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists objstatus_lock
go
create procedure objstatus_lock /* возможные логические состояния документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call objstatus_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update objstatus set lockuserid =auserid ,locksessionid=null  where objstatusid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update objstatus set lockuserid=null ,locksessionid =acursession  where objstatusid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists objstatus_unlock
go
create procedure objstatus_unlock /* возможные логические состояния документа */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call objstatus_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update objstatus set lockuserid =null  where objstatusid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update objstatus set locksessionid =null  where objstatusid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS objstatus_client_trigger
GO

create procedure objstatus_client_trigger  (
 acursession varchar(38),
 aOBJSTATUSid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists nextstate_parent
go
create procedure nextstate_parent /* матрица переходов */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from nextstate where  nextstateid=arowid;
  set aparenttable = 'objstatus';
 end 
go
GO


drop procedure if exists nextstate_islocked
go
create procedure nextstate_islocked /* матрица переходов  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from nextstate where nextstateid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists nextstate_lock
go
create procedure nextstate_lock /* матрица переходов  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call nextstate_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update nextstate set lockuserid =auserid ,locksessionid=null  where nextstateid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update nextstate set lockuserid=null ,locksessionid =acursession  where nextstateid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists nextstate_unlock
go
create procedure nextstate_unlock /* матрица переходов  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call nextstate_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update nextstate set lockuserid =null  where nextstateid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update nextstate set locksessionid =null  where nextstateid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS nextstate_client_trigger
GO

create procedure nextstate_client_trigger  (
 acursession varchar(38),
 aNEXTSTATEid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists objectmode_parent
go
create procedure objectmode_parent /* режим работы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from objectmode where  objectmodeid=arowid;
  set aparenttable = 'objecttype';
 end 
go
GO


drop procedure if exists objectmode_islocked
go
create procedure objectmode_islocked /* режим работы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from objectmode where objectmodeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists objectmode_lock
go
create procedure objectmode_lock /* режим работы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call objectmode_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update objectmode set lockuserid =auserid ,locksessionid=null  where objectmodeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update objectmode set lockuserid=null ,locksessionid =acursession  where objectmodeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists objectmode_unlock
go
create procedure objectmode_unlock /* режим работы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call objectmode_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update objectmode set lockuserid =null  where objectmodeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update objectmode set locksessionid =null  where objectmodeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS objectmode_client_trigger
GO

create procedure objectmode_client_trigger  (
 acursession varchar(38),
 aOBJECTMODEid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists structrestriction_parent
go
create procedure structrestriction_parent /* ораничения на доступ к разделу документа*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from structrestriction where  structrestrictionid=arowid;
  set aparenttable = 'objectmode';
 end 
go
GO


drop procedure if exists structrestriction_islocked
go
create procedure structrestriction_islocked /* ораничения на доступ к разделу документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from structrestriction where structrestrictionid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists structrestriction_lock
go
create procedure structrestriction_lock /* ораничения на доступ к разделу документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call structrestriction_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update structrestriction set lockuserid =auserid ,locksessionid=null  where structrestrictionid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update structrestriction set lockuserid=null ,locksessionid =acursession  where structrestrictionid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists structrestriction_unlock
go
create procedure structrestriction_unlock /* ораничения на доступ к разделу документа */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call structrestriction_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update structrestriction set lockuserid =null  where structrestrictionid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update structrestriction set locksessionid =null  where structrestrictionid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS structrestriction_client_trigger
GO

create procedure structrestriction_client_trigger  (
 acursession varchar(38),
 aSTRUCTRESTRICTIONid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists methodrestriction_parent
go
create procedure methodrestriction_parent /* ограничение на использование методов раздела*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from methodrestriction where  methodrestrictionid=arowid;
  set aparenttable = 'objectmode';
 end 
go
GO


drop procedure if exists methodrestriction_islocked
go
create procedure methodrestriction_islocked /* ограничение на использование методов раздела */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from methodrestriction where methodrestrictionid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists methodrestriction_lock
go
create procedure methodrestriction_lock /* ограничение на использование методов раздела */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call methodrestriction_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update methodrestriction set lockuserid =auserid ,locksessionid=null  where methodrestrictionid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update methodrestriction set lockuserid=null ,locksessionid =acursession  where methodrestrictionid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists methodrestriction_unlock
go
create procedure methodrestriction_unlock /* ограничение на использование методов раздела */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call methodrestriction_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update methodrestriction set lockuserid =null  where methodrestrictionid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update methodrestriction set locksessionid =null  where methodrestrictionid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS methodrestriction_client_trigger
GO

create procedure methodrestriction_client_trigger  (
 acursession varchar(38),
 aMETHODRESTRICTIONid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists fieldrestriction_parent
go
create procedure fieldrestriction_parent /* ограничения на доступ к полям раздела*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from fieldrestriction where  fieldrestrictionid=arowid;
  set aparenttable = 'objectmode';
 end 
go
GO


drop procedure if exists fieldrestriction_islocked
go
create procedure fieldrestriction_islocked /* ограничения на доступ к полям раздела */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from fieldrestriction where fieldrestrictionid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists fieldrestriction_lock
go
create procedure fieldrestriction_lock /* ограничения на доступ к полям раздела */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call fieldrestriction_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update fieldrestriction set lockuserid =auserid ,locksessionid=null  where fieldrestrictionid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update fieldrestriction set lockuserid=null ,locksessionid =acursession  where fieldrestrictionid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists fieldrestriction_unlock
go
create procedure fieldrestriction_unlock /* ограничения на доступ к полям раздела */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call fieldrestriction_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update fieldrestriction set lockuserid =null  where fieldrestrictionid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update fieldrestriction set locksessionid =null  where fieldrestrictionid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS fieldrestriction_client_trigger
GO

create procedure fieldrestriction_client_trigger  (
 acursession varchar(38),
 aFIELDRESTRICTIONid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists typemenu_parent
go
create procedure typemenu_parent /* методы уровня типа*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from typemenu where  typemenuid=arowid;
  set aparenttable = 'objecttype';
 end 
go
GO


drop procedure if exists typemenu_islocked
go
create procedure typemenu_islocked /* методы уровня типа */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from typemenu where typemenuid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists typemenu_lock
go
create procedure typemenu_lock /* методы уровня типа */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call typemenu_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update typemenu set lockuserid =auserid ,locksessionid=null  where typemenuid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update typemenu set lockuserid=null ,locksessionid =acursession  where typemenuid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists typemenu_unlock
go
create procedure typemenu_unlock /* методы уровня типа */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call typemenu_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update typemenu set lockuserid =null  where typemenuid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update typemenu set locksessionid =null  where typemenuid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS typemenu_client_trigger
GO

create procedure typemenu_client_trigger  (
 acursession varchar(38),
 aTYPEMENUid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists instancevalidator_parent
go
create procedure instancevalidator_parent /* проверка правильности для объекта в целом*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from instancevalidator where  instancevalidatorid=arowid;
  set aparenttable = 'objecttype';
 end 
go
GO


drop procedure if exists instancevalidator_islocked
go
create procedure instancevalidator_islocked /* проверка правильности для объекта в целом */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from instancevalidator where instancevalidatorid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists instancevalidator_lock
go
create procedure instancevalidator_lock /* проверка правильности для объекта в целом */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call instancevalidator_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update instancevalidator set lockuserid =auserid ,locksessionid=null  where instancevalidatorid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update instancevalidator set lockuserid=null ,locksessionid =acursession  where instancevalidatorid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists instancevalidator_unlock
go
create procedure instancevalidator_unlock /* проверка правильности для объекта в целом */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call instancevalidator_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update instancevalidator set lockuserid =null  where instancevalidatorid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update instancevalidator set locksessionid =null  where instancevalidatorid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS instancevalidator_client_trigger
GO

create procedure instancevalidator_client_trigger  (
 acursession varchar(38),
 aINSTANCEVALIDATORid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists part_parent
go
create procedure part_parent /* раздел объекта*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from part where  partid=arowid;
  set aparenttable = 'objecttype';
 end 
go
GO


drop procedure if exists part_islocked
go
create procedure part_islocked /* раздел объекта */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from part where partid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists part_lock
go
create procedure part_lock /* раздел объекта */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call part_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update part set lockuserid =auserid ,locksessionid=null  where partid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update part set lockuserid=null ,locksessionid =acursession  where partid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists part_unlock
go
create procedure part_unlock /* раздел объекта */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call part_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update part set lockuserid =null  where partid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update part set locksessionid =null  where partid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS part_client_trigger
GO

create procedure part_client_trigger  (
 acursession varchar(38),
 aPARTid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists partmenu_parent
go
create procedure partmenu_parent /* методы уровня раздела*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from partmenu where  partmenuid=arowid;
  set aparenttable = 'part';
 end 
go
GO


drop procedure if exists partmenu_islocked
go
create procedure partmenu_islocked /* методы уровня раздела */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from partmenu where partmenuid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists partmenu_lock
go
create procedure partmenu_lock /* методы уровня раздела */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call partmenu_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update partmenu set lockuserid =auserid ,locksessionid=null  where partmenuid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update partmenu set lockuserid=null ,locksessionid =acursession  where partmenuid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists partmenu_unlock
go
create procedure partmenu_unlock /* методы уровня раздела */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call partmenu_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update partmenu set lockuserid =null  where partmenuid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update partmenu set locksessionid =null  where partmenuid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS partmenu_client_trigger
GO

create procedure partmenu_client_trigger  (
 acursession varchar(38),
 aPARTMENUid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists partparammap_parent
go
create procedure partparammap_parent /* отображение значений полей раздела на параметры метода*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from partparammap where  partparammapid=arowid;
  set aparenttable = 'partmenu';
 end 
go
GO


drop procedure if exists partparammap_islocked
go
create procedure partparammap_islocked /* отображение значений полей раздела на параметры метода */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from partparammap where partparammapid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists partparammap_lock
go
create procedure partparammap_lock /* отображение значений полей раздела на параметры метода */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call partparammap_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update partparammap set lockuserid =auserid ,locksessionid=null  where partparammapid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update partparammap set lockuserid=null ,locksessionid =acursession  where partparammapid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists partparammap_unlock
go
create procedure partparammap_unlock /* отображение значений полей раздела на параметры метода */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call partparammap_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update partparammap set lockuserid =null  where partparammapid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update partparammap set locksessionid =null  where partparammapid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS partparammap_client_trigger
GO

create procedure partparammap_client_trigger  (
 acursession varchar(38),
 aPARTPARAMMAPid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists partview_parent
go
create procedure partview_parent /* вариант представления, который может использоваться для создания журнала*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from partview where  partviewid=arowid;
  set aparenttable = 'part';
 end 
go
GO


drop procedure if exists partview_islocked
go
create procedure partview_islocked /* вариант представления, который может использоваться для создания журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from partview where partviewid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists partview_lock
go
create procedure partview_lock /* вариант представления, который может использоваться для создания журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call partview_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update partview set lockuserid =auserid ,locksessionid=null  where partviewid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update partview set lockuserid=null ,locksessionid =acursession  where partviewid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists partview_unlock
go
create procedure partview_unlock /* вариант представления, который может использоваться для создания журнала */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call partview_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update partview set lockuserid =null  where partviewid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update partview set locksessionid =null  where partviewid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS partview_client_trigger
GO

create procedure partview_client_trigger  (
 acursession varchar(38),
 aPARTVIEWid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists viewcolumn_parent
go
create procedure viewcolumn_parent /* колонка пердставления*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from viewcolumn where  viewcolumnid=arowid;
  set aparenttable = 'partview';
 end 
go
GO


drop procedure if exists viewcolumn_islocked
go
create procedure viewcolumn_islocked /* колонка пердставления */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from viewcolumn where viewcolumnid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists viewcolumn_lock
go
create procedure viewcolumn_lock /* колонка пердставления */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call viewcolumn_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update viewcolumn set lockuserid =auserid ,locksessionid=null  where viewcolumnid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update viewcolumn set lockuserid=null ,locksessionid =acursession  where viewcolumnid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists viewcolumn_unlock
go
create procedure viewcolumn_unlock /* колонка пердставления */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call viewcolumn_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update viewcolumn set lockuserid =null  where viewcolumnid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update viewcolumn set locksessionid =null  where viewcolumnid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS viewcolumn_client_trigger
GO

create procedure viewcolumn_client_trigger  (
 acursession varchar(38),
 aViewColumnid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists partview_lnk_parent
go
create procedure partview_lnk_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from partview_lnk where  partview_lnkid=arowid;
  set aparenttable = 'partview';
 end 
go
GO


drop procedure if exists partview_lnk_islocked
go
create procedure partview_lnk_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from partview_lnk where partview_lnkid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists partview_lnk_lock
go
create procedure partview_lnk_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call partview_lnk_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update partview_lnk set lockuserid =auserid ,locksessionid=null  where partview_lnkid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update partview_lnk set lockuserid=null ,locksessionid =acursession  where partview_lnkid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists partview_lnk_unlock
go
create procedure partview_lnk_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call partview_lnk_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update partview_lnk set lockuserid =null  where partview_lnkid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update partview_lnk set locksessionid =null  where partview_lnkid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS partview_lnk_client_trigger
GO

create procedure partview_lnk_client_trigger  (
 acursession varchar(38),
 aPARTVIEW_LNKid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists validator_parent
go
create procedure validator_parent /* действия в впроцессе редактирования*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from validator where  validatorid=arowid;
  set aparenttable = 'part';
 end 
go
GO


drop procedure if exists validator_islocked
go
create procedure validator_islocked /* действия в впроцессе редактирования */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from validator where validatorid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists validator_lock
go
create procedure validator_lock /* действия в впроцессе редактирования */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call validator_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update validator set lockuserid =auserid ,locksessionid=null  where validatorid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update validator set lockuserid=null ,locksessionid =acursession  where validatorid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists validator_unlock
go
create procedure validator_unlock /* действия в впроцессе редактирования */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call validator_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update validator set lockuserid =null  where validatorid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update validator set locksessionid =null  where validatorid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS validator_client_trigger
GO

create procedure validator_client_trigger  (
 acursession varchar(38),
 aVALIDATORid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists uniqueconstraint_parent
go
create procedure uniqueconstraint_parent /* ограничение уникальности*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from uniqueconstraint where  uniqueconstraintid=arowid;
  set aparenttable = 'part';
 end 
go
GO


drop procedure if exists uniqueconstraint_islocked
go
create procedure uniqueconstraint_islocked /* ограничение уникальности */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from uniqueconstraint where uniqueconstraintid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists uniqueconstraint_lock
go
create procedure uniqueconstraint_lock /* ограничение уникальности */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call uniqueconstraint_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update uniqueconstraint set lockuserid =auserid ,locksessionid=null  where uniqueconstraintid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update uniqueconstraint set lockuserid=null ,locksessionid =acursession  where uniqueconstraintid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists uniqueconstraint_unlock
go
create procedure uniqueconstraint_unlock /* ограничение уникальности */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call uniqueconstraint_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update uniqueconstraint set lockuserid =null  where uniqueconstraintid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update uniqueconstraint set locksessionid =null  where uniqueconstraintid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS uniqueconstraint_client_trigger
GO

create procedure uniqueconstraint_client_trigger  (
 acursession varchar(38),
 aUNIQUECONSTRAINTid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists constraintfield_parent
go
create procedure constraintfield_parent /* поля ограничения*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from constraintfield where  constraintfieldid=arowid;
  set aparenttable = 'uniqueconstraint';
 end 
go
GO


drop procedure if exists constraintfield_islocked
go
create procedure constraintfield_islocked /* поля ограничения */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from constraintfield where constraintfieldid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists constraintfield_lock
go
create procedure constraintfield_lock /* поля ограничения */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call constraintfield_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update constraintfield set lockuserid =auserid ,locksessionid=null  where constraintfieldid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update constraintfield set lockuserid=null ,locksessionid =acursession  where constraintfieldid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists constraintfield_unlock
go
create procedure constraintfield_unlock /* поля ограничения */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call constraintfield_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update constraintfield set lockuserid =null  where constraintfieldid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update constraintfield set locksessionid =null  where constraintfieldid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS constraintfield_client_trigger
GO

create procedure constraintfield_client_trigger  (
 acursession varchar(38),
 aCONSTRAINTFIELDid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists extenderinterface_parent
go
create procedure extenderinterface_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from extenderinterface where  extenderinterfaceid=arowid;
  set aparenttable = 'part';
 end 
go
GO


drop procedure if exists extenderinterface_islocked
go
create procedure extenderinterface_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from extenderinterface where extenderinterfaceid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists extenderinterface_lock
go
create procedure extenderinterface_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call extenderinterface_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update extenderinterface set lockuserid =auserid ,locksessionid=null  where extenderinterfaceid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update extenderinterface set lockuserid=null ,locksessionid =acursession  where extenderinterfaceid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists extenderinterface_unlock
go
create procedure extenderinterface_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call extenderinterface_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update extenderinterface set lockuserid =null  where extenderinterfaceid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update extenderinterface set locksessionid =null  where extenderinterfaceid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS extenderinterface_client_trigger
GO

create procedure extenderinterface_client_trigger  (
 acursession varchar(38),
 aExtenderInterfaceid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists field_parent
go
create procedure field_parent /* поле*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from field where  fieldid=arowid;
  set aparenttable = 'part';
 end 
go
GO


drop procedure if exists field_islocked
go
create procedure field_islocked /* поле */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from field where fieldid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists field_lock
go
create procedure field_lock /* поле */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call field_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update field set lockuserid =auserid ,locksessionid=null  where fieldid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update field set lockuserid=null ,locksessionid =acursession  where fieldid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists field_unlock
go
create procedure field_unlock /* поле */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call field_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update field set lockuserid =null  where fieldid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update field set locksessionid =null  where fieldid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS field_client_trigger
GO

create procedure field_client_trigger  (
 acursession varchar(38),
 aFIELDid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists fldextenders_parent
go
create procedure fldextenders_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from fldextenders where  fldextendersid=arowid;
  set aparenttable = 'field';
 end 
go
GO


drop procedure if exists fldextenders_islocked
go
create procedure fldextenders_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from fldextenders where fldextendersid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists fldextenders_lock
go
create procedure fldextenders_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call fldextenders_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update fldextenders set lockuserid =auserid ,locksessionid=null  where fldextendersid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update fldextenders set lockuserid=null ,locksessionid =acursession  where fldextendersid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists fldextenders_unlock
go
create procedure fldextenders_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call fldextenders_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update fldextenders set lockuserid =null  where fldextendersid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update fldextenders set locksessionid =null  where fldextendersid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS fldextenders_client_trigger
GO

create procedure fldextenders_client_trigger  (
 acursession varchar(38),
 aFldExtendersid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists fieldsrcdef_parent
go
create procedure fieldsrcdef_parent /* описание источника данных для полей типа referencesql */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from fieldsrcdef where  fieldsrcdefid=arowid;
  set aparenttable = 'field';
 end 
go
GO


drop procedure if exists fieldsrcdef_islocked
go
create procedure fieldsrcdef_islocked /* описание источника данных для полей типа referencesql  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from fieldsrcdef where fieldsrcdefid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists fieldsrcdef_lock
go
create procedure fieldsrcdef_lock /* описание источника данных для полей типа referencesql  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call fieldsrcdef_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update fieldsrcdef set lockuserid =auserid ,locksessionid=null  where fieldsrcdefid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update fieldsrcdef set lockuserid=null ,locksessionid =acursession  where fieldsrcdefid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists fieldsrcdef_unlock
go
create procedure fieldsrcdef_unlock /* описание источника данных для полей типа referencesql  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call fieldsrcdef_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update fieldsrcdef set lockuserid =null  where fieldsrcdefid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update fieldsrcdef set locksessionid =null  where fieldsrcdefid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS fieldsrcdef_client_trigger
GO

create procedure fieldsrcdef_client_trigger  (
 acursession varchar(38),
 aFIELDSRCDEFid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists dinamicfilterscript_parent
go
create procedure dinamicfilterscript_parent /* выражение для построения дополнительного фильтра для ссылочных полей*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from dinamicfilterscript where  dinamicfilterscriptid=arowid;
  set aparenttable = 'field';
 end 
go
GO


drop procedure if exists dinamicfilterscript_islocked
go
create procedure dinamicfilterscript_islocked /* выражение для построения дополнительного фильтра для ссылочных полей */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from dinamicfilterscript where dinamicfilterscriptid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists dinamicfilterscript_lock
go
create procedure dinamicfilterscript_lock /* выражение для построения дополнительного фильтра для ссылочных полей */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call dinamicfilterscript_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update dinamicfilterscript set lockuserid =auserid ,locksessionid=null  where dinamicfilterscriptid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update dinamicfilterscript set lockuserid=null ,locksessionid =acursession  where dinamicfilterscriptid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists dinamicfilterscript_unlock
go
create procedure dinamicfilterscript_unlock /* выражение для построения дополнительного фильтра для ссылочных полей */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call dinamicfilterscript_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update dinamicfilterscript set lockuserid =null  where dinamicfilterscriptid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update dinamicfilterscript set locksessionid =null  where dinamicfilterscriptid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS dinamicfilterscript_client_trigger
GO

create procedure dinamicfilterscript_client_trigger  (
 acursession varchar(38),
 aDINAMICFILTERSCRIPTid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists fieldexpression_parent
go
create procedure fieldexpression_parent /* выражение для вычисления поля
или значение по умолчанию*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from fieldexpression where  fieldexpressionid=arowid;
  set aparenttable = 'field';
 end 
go
GO


drop procedure if exists fieldexpression_islocked
go
create procedure fieldexpression_islocked /* выражение для вычисления поля
или значение по умолчанию */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from fieldexpression where fieldexpressionid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists fieldexpression_lock
go
create procedure fieldexpression_lock /* выражение для вычисления поля
или значение по умолчанию */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call fieldexpression_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update fieldexpression set lockuserid =auserid ,locksessionid=null  where fieldexpressionid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update fieldexpression set lockuserid=null ,locksessionid =acursession  where fieldexpressionid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists fieldexpression_unlock
go
create procedure fieldexpression_unlock /* выражение для вычисления поля
или значение по умолчанию */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call fieldexpression_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update fieldexpression set lockuserid =null  where fieldexpressionid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update fieldexpression set locksessionid =null  where fieldexpressionid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS fieldexpression_client_trigger
GO

create procedure fieldexpression_client_trigger  (
 acursession varchar(38),
 aFIELDEXPRESSIONid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists fieldvalidator_parent
go
create procedure fieldvalidator_parent /* логика взаимосвязей на форме при изменении поля*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from fieldvalidator where  fieldvalidatorid=arowid;
  set aparenttable = 'field';
 end 
go
GO


drop procedure if exists fieldvalidator_islocked
go
create procedure fieldvalidator_islocked /* логика взаимосвязей на форме при изменении поля */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from fieldvalidator where fieldvalidatorid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists fieldvalidator_lock
go
create procedure fieldvalidator_lock /* логика взаимосвязей на форме при изменении поля */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call fieldvalidator_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update fieldvalidator set lockuserid =auserid ,locksessionid=null  where fieldvalidatorid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update fieldvalidator set lockuserid=null ,locksessionid =acursession  where fieldvalidatorid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists fieldvalidator_unlock
go
create procedure fieldvalidator_unlock /* логика взаимосвязей на форме при изменении поля */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call fieldvalidator_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update fieldvalidator set lockuserid =null  where fieldvalidatorid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update fieldvalidator set locksessionid =null  where fieldvalidatorid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS fieldvalidator_client_trigger
GO

create procedure fieldvalidator_client_trigger  (
 acursession varchar(38),
 aFIELDVALIDATORid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists fieldmenu_parent
go
create procedure fieldmenu_parent /* методы, ассоциированные с полем*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from fieldmenu where  fieldmenuid=arowid;
  set aparenttable = 'field';
 end 
go
GO


drop procedure if exists fieldmenu_islocked
go
create procedure fieldmenu_islocked /* методы, ассоциированные с полем */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from fieldmenu where fieldmenuid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists fieldmenu_lock
go
create procedure fieldmenu_lock /* методы, ассоциированные с полем */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call fieldmenu_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update fieldmenu set lockuserid =auserid ,locksessionid=null  where fieldmenuid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update fieldmenu set lockuserid=null ,locksessionid =acursession  where fieldmenuid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists fieldmenu_unlock
go
create procedure fieldmenu_unlock /* методы, ассоциированные с полем */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call fieldmenu_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update fieldmenu set lockuserid =null  where fieldmenuid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update fieldmenu set locksessionid =null  where fieldmenuid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS fieldmenu_client_trigger
GO

create procedure fieldmenu_client_trigger  (
 acursession varchar(38),
 aFIELDMENUid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists fieldparammap_parent
go
create procedure fieldparammap_parent /* отображение значений на параметры метода*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from fieldparammap where  fieldparammapid=arowid;
  set aparenttable = 'fieldmenu';
 end 
go
GO


drop procedure if exists fieldparammap_islocked
go
create procedure fieldparammap_islocked /* отображение значений на параметры метода */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from fieldparammap where fieldparammapid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists fieldparammap_lock
go
create procedure fieldparammap_lock /* отображение значений на параметры метода */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call fieldparammap_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update fieldparammap set lockuserid =auserid ,locksessionid=null  where fieldparammapid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update fieldparammap set lockuserid=null ,locksessionid =acursession  where fieldparammapid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists fieldparammap_unlock
go
create procedure fieldparammap_unlock /* отображение значений на параметры метода */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call fieldparammap_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update fieldparammap set lockuserid =null  where fieldparammapid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update fieldparammap set locksessionid =null  where fieldparammapid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS fieldparammap_client_trigger
GO

create procedure fieldparammap_client_trigger  (
 acursession varchar(38),
 aFIELDPARAMMAPid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists mtzapp_brief
go

create procedure mtzapp_brief  (
 acursession varchar(38),
 amtzappid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if amtzappid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from mtzapp where mtzappid=g2b(amtzappid);
 if  aec &gt;0 then
   set abrief=mtzapp_brief_f(g2b(amtzappid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists mtzapp_delete
go

create procedure mtzapp_delete /*группа взаимосвязных документов*/ (
 acursession varchar(38),
 amtzappid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from mtzapp where mtzappid=g2b(amtzappid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=mtzapp' result;
    leave body;
  end if;
 call mtzapp_logger(acursession,amtzappid) ; 
  delete from  mtzapp 
  where  mtzappid = g2b(amtzappid) ;
  delete from num_values where ownerpartname='mtzapp' and ownerrowid=g2b(amtzappid);
  end if;
    select 'ok' result;
 end 
go
GO

/*приложение*/

drop procedure if exists mtzapp_save
go

create procedure mtzapp_save /*группа взаимосвязных документов*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 amtzappid varchar(38)
,aname
 varchar (255)/* название *//* название */
,adbname
 varchar (64)/* база данных *//* база данных */
,athecomment
 text/* описание *//* описание */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from mtzapp where mtzappid=g2b(amtzappid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=mtzapp' result;
    leave body;
  end if;
 start transaction ; 
 call mtzapp_logger(acursession,amtzappid) ; 
 update  mtzapp set changestamp=now()
,
  name=aname
,
  dbname=adbname
,
  thecomment=athecomment
  where  mtzappid = g2b(amtzappid) ;


call mtzapp_client_trigger(acursession,amtzappid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=mtzapp' result;
    leave body;
  end if;
 start transaction;  
 insert into   mtzapp
 (  mtzappid 
,instanceid
,name

,dbname

,thecomment

 ) values ( g2b(amtzappid) 
,g2b(ainstanceid)
,aname

,adbname

,athecomment

 ) ;


call mtzapp_client_trigger(acursession,amtzappid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists parentpackage_brief
go

create procedure parentpackage_brief  (
 acursession varchar(38),
 aparentpackageid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aparentpackageid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from parentpackage where parentpackageid=g2b(aparentpackageid);
 if  aec &gt;0 then
   set abrief=parentpackage_brief_f(g2b(aparentpackageid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists parentpackage_delete
go

create procedure parentpackage_delete /*приложения от которых зависит данное приложение*/ (
 acursession varchar(38),
 aparentpackageid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from parentpackage where parentpackageid=g2b(aparentpackageid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=parentpackage' result;
    leave body;
  end if;
 call parentpackage_logger(acursession,aparentpackageid) ; 
  delete from  parentpackage 
  where  parentpackageid = g2b(aparentpackageid) ;
  delete from num_values where ownerpartname='parentpackage' and ownerrowid=g2b(aparentpackageid);
  end if;
    select 'ok' result;
 end 
go
GO

/*обязательные приложения*/

drop procedure if exists parentpackage_save
go

create procedure parentpackage_save /*приложения от которых зависит данное приложение*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aparentpackageid varchar(38)
,apackage varchar(38)/* приложение *//* приложение */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from parentpackage where parentpackageid=g2b(aparentpackageid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=parentpackage' result;
    leave body;
  end if;
 start transaction ; 
 call parentpackage_logger(acursession,aparentpackageid) ; 
 update  parentpackage set changestamp=now()
,
  package=g2b(apackage)
  where  parentpackageid = g2b(aparentpackageid) ;


call parentpackage_client_trigger(acursession,aparentpackageid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzmetamodel.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=parentpackage' result;
    leave body;
  end if;
 start transaction;  
 insert into   parentpackage
 (  parentpackageid 
,parentstructrowid
,package

 ) values ( g2b(aparentpackageid) 
,g2b(aparentstructrowid)
,g2b(apackage)

 ) ;


call parentpackage_client_trigger(acursession,aparentpackageid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists parentpackage_copy
go

create procedure parentpackage_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into parentpackage 
 ( parentpackageid 
,parentstructrowid
,package

 ) select 
copymap(acopyaction,b2g(parentpackageid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,package

 from parentpackage
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists mtzapp_copy
go

create procedure mtzapp_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_mtzapp cursor for
select mtzappid from mtzapp where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into mtzapp 
 ( mtzappid 
,instanceid
,name

,dbname

,thecomment

 ) select 
copymap(acopyaction,b2g(mtzappid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,dbname

,thecomment

 from mtzapp
 where instanceid =g2b( ainstanceid); 
open copy_cursor_mtzapp;
  set  fetch_done=false;
fetch copy_cursor_mtzapp into aid;
while not fetch_done do 
    call parentpackage_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_mtzapp into aid;
end while;

close copy_cursor_mtzapp;
 end 
go
GO


drop procedure if exists mtzapp_logger
go

create procedure mtzapp_logger /*группа взаимосвязных документов*/ (
 acursession varchar(38),
 amtzappid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists parentpackage_logger
go

create procedure parentpackage_logger /*приложения от которых зависит данное приложение*/ (
 acursession varchar(38),
 aparentpackageid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists mtzapp_parent
go
create procedure mtzapp_parent /* группа взаимосвязных документов*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from mtzapp where  mtzappid=arowid;
 end 
go
GO


drop procedure if exists mtzapp_islocked
go
create procedure mtzapp_islocked /* группа взаимосвязных документов */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from mtzapp where mtzappid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists mtzapp_lock
go
create procedure mtzapp_lock /* группа взаимосвязных документов */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call mtzapp_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update mtzapp set lockuserid =auserid ,locksessionid=null  where mtzappid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update mtzapp set lockuserid=null ,locksessionid =acursession  where mtzappid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists mtzapp_unlock
go
create procedure mtzapp_unlock /* группа взаимосвязных документов */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call mtzapp_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update mtzapp set lockuserid =null  where mtzappid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update mtzapp set locksessionid =null  where mtzappid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS mtzapp_client_trigger
GO

create procedure mtzapp_client_trigger  (
 acursession varchar(38),
 aMTZAPPid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists parentpackage_parent
go
create procedure parentpackage_parent /* приложения от которых зависит данное приложение*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from parentpackage where  parentpackageid=arowid;
  set aparenttable = 'mtzapp';
 end 
go
GO


drop procedure if exists parentpackage_islocked
go
create procedure parentpackage_islocked /* приложения от которых зависит данное приложение */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from parentpackage where parentpackageid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists parentpackage_lock
go
create procedure parentpackage_lock /* приложения от которых зависит данное приложение */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call parentpackage_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update parentpackage set lockuserid =auserid ,locksessionid=null  where parentpackageid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update parentpackage set lockuserid=null ,locksessionid =acursession  where parentpackageid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists parentpackage_unlock
go
create procedure parentpackage_unlock /* приложения от которых зависит данное приложение */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call parentpackage_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update parentpackage set lockuserid =null  where parentpackageid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update parentpackage set locksessionid =null  where parentpackageid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS parentpackage_client_trigger
GO

create procedure parentpackage_client_trigger  (
 acursession varchar(38),
 aParentPackageid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists journalcolumn_brief
go

create procedure journalcolumn_brief  (
 acursession varchar(38),
 ajournalcolumnid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if ajournalcolumnid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from journalcolumn where journalcolumnid=g2b(ajournalcolumnid);
 if  aec &gt;0 then
   set abrief=journalcolumn_brief_f(g2b(ajournalcolumnid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists journalcolumn_delete
go

create procedure journalcolumn_delete /*колонки журнала*/ (
 acursession varchar(38),
 ajournalcolumnid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from journalcolumn where journalcolumnid=g2b(ajournalcolumnid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=journalcolumn' result;
    leave body;
  end if;
 call journalcolumn_logger(acursession,ajournalcolumnid) ; 
  delete from  journalcolumn 
  where  journalcolumnid = g2b(ajournalcolumnid) ;
  delete from num_values where ownerpartname='journalcolumn' and ownerrowid=g2b(ajournalcolumnid);
  end if;
    select 'ok' result;
 end 
go
GO

/*колонки журнала*/

drop procedure if exists journalcolumn_save
go

create procedure journalcolumn_save /*колонки журнала*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 ajournalcolumnid varchar(38)
,asequence
 integer/* последовательность *//* последовательность */
,aname
 varchar (255)/* название *//* название */
,acolumnalignment
 integer/* выравнивание *//* выравнивание */
,acolsort
 integer/* сортировка колонки *//* сортировка колонки */
,agroupaggregation
 integer/* аггрегация при группировке *//* аггрегация при группировке */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from journalcolumn where journalcolumnid=g2b(ajournalcolumnid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=journalcolumn' result;
    leave body;
  end if;
 start transaction ; 
 call journalcolumn_logger(acursession,ajournalcolumnid) ; 
 update  journalcolumn set changestamp=now()
,
  sequence=asequence
,
  name=aname
,
  columnalignment=acolumnalignment
,
  colsort=acolsort
,
  groupaggregation=agroupaggregation
  where  journalcolumnid = g2b(ajournalcolumnid) ;


call journalcolumn_client_trigger(acursession,ajournalcolumnid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=journalcolumn' result;
    leave body;
  end if;
 start transaction;  
 insert into   journalcolumn
 (  journalcolumnid 
,instanceid
,sequence

,name

,columnalignment

,colsort

,groupaggregation

 ) values ( g2b(ajournalcolumnid) 
,g2b(ainstanceid)
,asequence

,aname

,acolumnalignment

,acolsort

,agroupaggregation

 ) ;


call journalcolumn_client_trigger(acursession,ajournalcolumnid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists jcolumnsource_brief
go

create procedure jcolumnsource_brief  (
 acursession varchar(38),
 ajcolumnsourceid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if ajcolumnsourceid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from jcolumnsource where jcolumnsourceid=g2b(ajcolumnsourceid);
 if  aec &gt;0 then
   set abrief=jcolumnsource_brief_f(g2b(ajcolumnsourceid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists jcolumnsource_delete
go

create procedure jcolumnsource_delete /*состав колонки*/ (
 acursession varchar(38),
 ajcolumnsourceid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from jcolumnsource where jcolumnsourceid=g2b(ajcolumnsourceid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=jcolumnsource' result;
    leave body;
  end if;
 call jcolumnsource_logger(acursession,ajcolumnsourceid) ; 
  delete from  jcolumnsource 
  where  jcolumnsourceid = g2b(ajcolumnsourceid) ;
  delete from num_values where ownerpartname='jcolumnsource' and ownerrowid=g2b(ajcolumnsourceid);
  end if;
    select 'ok' result;
 end 
go
GO

/*состав колонки*/

drop procedure if exists jcolumnsource_save
go

create procedure jcolumnsource_save /*состав колонки*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 ajcolumnsourceid varchar(38)
,asrcpartview varchar(38)/* представление *//* представление */
,aviewfield
 varchar (255)/* поле представления *//* поле представления */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from jcolumnsource where jcolumnsourceid=g2b(ajcolumnsourceid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=jcolumnsource' result;
    leave body;
  end if;
 start transaction ; 
 call jcolumnsource_logger(acursession,ajcolumnsourceid) ; 
 update  jcolumnsource set changestamp=now()
,
  srcpartview=g2b(asrcpartview)
,
  viewfield=aviewfield
  where  jcolumnsourceid = g2b(ajcolumnsourceid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from jcolumnsource where  parentstructrowid=g2b(aparentstructrowid) 
 and srcpartview=g2b(asrcpartview);
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=состав колонки' result;
  rollback;
  leave body;
end if;
 -- end if;

call jcolumnsource_client_trigger(acursession,ajcolumnsourceid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=jcolumnsource' result;
    leave body;
  end if;
 start transaction;  
 insert into   jcolumnsource
 (  jcolumnsourceid 
,parentstructrowid
,srcpartview

,viewfield

 ) values ( g2b(ajcolumnsourceid) 
,g2b(aparentstructrowid)
,g2b(asrcpartview)

,aviewfield

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from jcolumnsource where  parentstructrowid=g2b(aparentstructrowid) 
 and srcpartview=g2b(asrcpartview);
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=состав колонки' result;
  rollback;
  leave body;
end if;
 -- end if;

call jcolumnsource_client_trigger(acursession,ajcolumnsourceid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists jcolumnsource_copy
go

create procedure jcolumnsource_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into jcolumnsource 
 ( jcolumnsourceid 
,parentstructrowid
,srcpartview

,viewfield

 ) select 
copymap(acopyaction,b2g(jcolumnsourceid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,srcpartview

,viewfield

 from jcolumnsource
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists journalcolumn_copy
go

create procedure journalcolumn_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_journalcolumn cursor for
select journalcolumnid from journalcolumn where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into journalcolumn 
 ( journalcolumnid 
,instanceid
,sequence

,name

,columnalignment

,colsort

,groupaggregation

 ) select 
copymap(acopyaction,b2g(journalcolumnid)) 
,copymap(acopyaction,b2g(instanceid))
,sequence

,name

,columnalignment

,colsort

,groupaggregation

 from journalcolumn
 where instanceid =g2b( ainstanceid); 
open copy_cursor_journalcolumn;
  set  fetch_done=false;
fetch copy_cursor_journalcolumn into aid;
while not fetch_done do 
    call jcolumnsource_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_journalcolumn into aid;
end while;

close copy_cursor_journalcolumn;
 end 
go
GO


drop procedure if exists journalcolumn_logger
go

create procedure journalcolumn_logger /*колонки журнала*/ (
 acursession varchar(38),
 ajournalcolumnid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists jcolumnsource_logger
go

create procedure jcolumnsource_logger /*состав колонки*/ (
 acursession varchar(38),
 ajcolumnsourceid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists journalcolumn_parent
go
create procedure journalcolumn_parent /* колонки журнала*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from journalcolumn where  journalcolumnid=arowid;
 end 
go
GO


drop procedure if exists journalcolumn_islocked
go
create procedure journalcolumn_islocked /* колонки журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from journalcolumn where journalcolumnid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists journalcolumn_lock
go
create procedure journalcolumn_lock /* колонки журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call journalcolumn_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update journalcolumn set lockuserid =auserid ,locksessionid=null  where journalcolumnid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update journalcolumn set lockuserid=null ,locksessionid =acursession  where journalcolumnid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists journalcolumn_unlock
go
create procedure journalcolumn_unlock /* колонки журнала */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call journalcolumn_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update journalcolumn set lockuserid =null  where journalcolumnid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update journalcolumn set locksessionid =null  where journalcolumnid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS journalcolumn_client_trigger
GO

create procedure journalcolumn_client_trigger  (
 acursession varchar(38),
 aJournalColumnid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists jcolumnsource_parent
go
create procedure jcolumnsource_parent /* состав колонки*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from jcolumnsource where  jcolumnsourceid=arowid;
  set aparenttable = 'journalcolumn';
 end 
go
GO


drop procedure if exists jcolumnsource_islocked
go
create procedure jcolumnsource_islocked /* состав колонки */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from jcolumnsource where jcolumnsourceid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists jcolumnsource_lock
go
create procedure jcolumnsource_lock /* состав колонки */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call jcolumnsource_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update jcolumnsource set lockuserid =auserid ,locksessionid=null  where jcolumnsourceid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update jcolumnsource set lockuserid=null ,locksessionid =acursession  where jcolumnsourceid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists jcolumnsource_unlock
go
create procedure jcolumnsource_unlock /* состав колонки */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call jcolumnsource_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update jcolumnsource set lockuserid =null  where jcolumnsourceid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update jcolumnsource set locksessionid =null  where jcolumnsourceid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS jcolumnsource_client_trigger
GO

create procedure jcolumnsource_client_trigger  (
 acursession varchar(38),
 aJColumnSourceid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists journalsrc_brief
go

create procedure journalsrc_brief  (
 acursession varchar(38),
 ajournalsrcid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if ajournalsrcid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from journalsrc where journalsrcid=g2b(ajournalsrcid);
 if  aec &gt;0 then
   set abrief=journalsrc_brief_f(g2b(ajournalsrcid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists journalsrc_delete
go

create procedure journalsrc_delete /*источники журнала*/ (
 acursession varchar(38),
 ajournalsrcid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from journalsrc where journalsrcid=g2b(ajournalsrcid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=journalsrc' result;
    leave body;
  end if;
 call journalsrc_logger(acursession,ajournalsrcid) ; 
  delete from  journalsrc 
  where  journalsrcid = g2b(ajournalsrcid) ;
  delete from num_values where ownerpartname='journalsrc' and ownerrowid=g2b(ajournalsrcid);
  end if;
    select 'ok' result;
 end 
go
GO

/*источники журнала*/

drop procedure if exists journalsrc_save
go

create procedure journalsrc_save /*источники журнала*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 ajournalsrcid varchar(38)
,apartview binary(16)/* представление *//* представление */
,aonrun
 integer/* при открытии *//* при открытии */
,aopenmode
 varchar (64)/* режим открытия *//* режим открытия */
,aviewalias
 varchar (255)/* псевдоним представления *//* псевдоним представления */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from journalsrc where journalsrcid=g2b(ajournalsrcid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=journalsrc' result;
    leave body;
  end if;
 start transaction ; 
 call journalsrc_logger(acursession,ajournalsrcid) ; 
 update  journalsrc set changestamp=now()
,
  partview=apartview
,
  onrun=aonrun
,
  openmode=aopenmode
,
  viewalias=aviewalias
  where  journalsrcid = g2b(ajournalsrcid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from journalsrc where  instanceid=g2b(ainstanceid) 
 and partview=g2b(apartview);
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=источники журнала' result;
  rollback;
  leave body;
end if;
 -- end if;

call journalsrc_client_trigger(acursession,ajournalsrcid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=journalsrc' result;
    leave body;
  end if;
 start transaction;  
 insert into   journalsrc
 (  journalsrcid 
,instanceid
,partview

,onrun

,openmode

,viewalias

 ) values ( g2b(ajournalsrcid) 
,g2b(ainstanceid)
,apartview

,aonrun

,aopenmode

,aviewalias

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from journalsrc where  instanceid=g2b(ainstanceid) 
 and partview=g2b(apartview);
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=источники журнала' result;
  rollback;
  leave body;
end if;
 -- end if;

call journalsrc_client_trigger(acursession,ajournalsrcid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists journalsrc_copy
go

create procedure journalsrc_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into journalsrc 
 ( journalsrcid 
,instanceid
,partview

,onrun

,openmode

,viewalias

 ) select 
copymap(acopyaction,b2g(journalsrcid)) 
,copymap(acopyaction,b2g(instanceid))
,partview

,onrun

,openmode

,viewalias

 from journalsrc
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists journalsrc_logger
go

create procedure journalsrc_logger /*источники журнала*/ (
 acursession varchar(38),
 ajournalsrcid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists journalsrc_parent
go
create procedure journalsrc_parent /* источники журнала*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from journalsrc where  journalsrcid=arowid;
 end 
go
GO


drop procedure if exists journalsrc_islocked
go
create procedure journalsrc_islocked /* источники журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from journalsrc where journalsrcid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists journalsrc_lock
go
create procedure journalsrc_lock /* источники журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call journalsrc_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update journalsrc set lockuserid =auserid ,locksessionid=null  where journalsrcid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update journalsrc set lockuserid=null ,locksessionid =acursession  where journalsrcid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists journalsrc_unlock
go
create procedure journalsrc_unlock /* источники журнала */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call journalsrc_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update journalsrc set lockuserid =null  where journalsrcid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update journalsrc set locksessionid =null  where journalsrcid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS journalsrc_client_trigger
GO

create procedure journalsrc_client_trigger  (
 acursession varchar(38),
 aJournalSrcid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists journal_brief
go

create procedure journal_brief  (
 acursession varchar(38),
 ajournalid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if ajournalid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from journal where journalid=g2b(ajournalid);
 if  aec &gt;0 then
   set abrief=journal_brief_f(g2b(ajournalid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists journal_delete
go

create procedure journal_delete /*журнал*/ (
 acursession varchar(38),
 ajournalid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from journal where journalid=g2b(ajournalid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=journal' result;
    leave body;
  end if;
 call journal_logger(acursession,ajournalid) ; 
  delete from  journal 
  where  journalid = g2b(ajournalid) ;
  delete from num_values where ownerpartname='journal' and ownerrowid=g2b(ajournalid);
  end if;
    select 'ok' result;
 end 
go
GO

/*журнал*/

drop procedure if exists journal_save
go

create procedure journal_save /*журнал*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 ajournalid varchar(38)
,aname
 varchar (255)/* название *//* название */
,athe_alias
 varchar (32)/* псевдоним *//* псевдоним */
,athecomment
 text/* описание *//* описание */
,ajrnliconcls
 varchar (80)/* иконка журнала *//* иконка журнала */
,ausefavorites
 integer/* массовое выделение *//* массовое выделение */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from journal where journalid=g2b(ajournalid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=journal' result;
    leave body;
  end if;
 start transaction ; 
 call journal_logger(acursession,ajournalid) ; 
 update  journal set changestamp=now()
,
  name=aname
,
  the_alias=athe_alias
,
  thecomment=athecomment
,
  jrnliconcls=ajrnliconcls
,
  usefavorites=ausefavorites
  where  journalid = g2b(ajournalid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from journal where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=журнал правило=(уникальность для журнал.название)'  result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from journal where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=журнал' result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from journal where 1=1  
 and the_alias=athe_alias;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=журнал' result;
  rollback;
  leave body;
end if;
 -- end if;

call journal_client_trigger(acursession,ajournalid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzjrnl.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=journal' result;
    leave body;
  end if;
select count(*) into aec from journal where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;journal&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   journal
 (  journalid 
,instanceid
,name

,the_alias

,thecomment

,jrnliconcls

,usefavorites

 ) values ( g2b(ajournalid) 
,g2b(ainstanceid)
,aname

,athe_alias

,athecomment

,ajrnliconcls

,ausefavorites

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from journal where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=журнал правило=(уникальность для журнал.название)'  result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from journal where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=журнал' result;
  rollback;
  leave body;
end if;
select count(*) into  auniquerowcount from journal where 1=1  
 and the_alias=athe_alias;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=журнал' result;
  rollback;
  leave body;
end if;
 -- end if;

call journal_client_trigger(acursession,ajournalid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists journal_copy
go

create procedure journal_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into journal 
 ( journalid 
,instanceid
,name

,the_alias

,thecomment

,jrnliconcls

,usefavorites

 ) select 
copymap(acopyaction,b2g(journalid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,the_alias

,thecomment

,jrnliconcls

,usefavorites

 from journal
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists journal_logger
go

create procedure journal_logger /*журнал*/ (
 acursession varchar(38),
 ajournalid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists journal_parent
go
create procedure journal_parent /* журнал*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from journal where  journalid=arowid;
 end 
go
GO


drop procedure if exists journal_islocked
go
create procedure journal_islocked /* журнал */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from journal where journalid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists journal_lock
go
create procedure journal_lock /* журнал */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call journal_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update journal set lockuserid =auserid ,locksessionid=null  where journalid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update journal set lockuserid=null ,locksessionid =acursession  where journalid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists journal_unlock
go
create procedure journal_unlock /* журнал */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call journal_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update journal set lockuserid =null  where journalid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update journal set locksessionid =null  where journalid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS journal_client_trigger
GO

create procedure journal_client_trigger  (
 acursession varchar(38),
 aJournalid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_urok_sn_brief
go

create procedure iu_urok_sn_brief  (
 acursession varchar(38),
 aiu_urok_snid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_urok_snid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_urok_sn where iu_urok_snid=g2b(aiu_urok_snid);
 if  aec &gt;0 then
   set abrief=iu_urok_sn_brief_f(g2b(aiu_urok_snid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_urok_sn_delete
go

create procedure iu_urok_sn_delete /*статусы урока*/ (
 acursession varchar(38),
 aiu_urok_snid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_sn where iu_urok_snid=g2b(aiu_urok_snid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_urok_sn' result;
    leave body;
  end if;
 call iu_urok_sn_logger(acursession,aiu_urok_snid) ; 
  delete from  iu_urok_sn 
  where  iu_urok_snid = g2b(aiu_urok_snid) ;
  delete from num_values where ownerpartname='iu_urok_sn' and ownerrowid=g2b(aiu_urok_snid);
  end if;
    select 'ok' result;
 end 
go
GO

/*статусы*/

drop procedure if exists iu_urok_sn_save
go

create procedure iu_urok_sn_save /*статусы урока*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_urok_snid varchar(38)
,astatusdate
 datetime/* дата получения статуса *//* дата получения статуса */
,aurokstatus varchar(38)/* статус *//* статус */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_sn where iu_urok_snid=g2b(aiu_urok_snid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_urok_sn' result;
    leave body;
  end if;
 start transaction ; 
 call iu_urok_sn_logger(acursession,aiu_urok_snid) ; 
 update  iu_urok_sn set changestamp=now()
,
  statusdate=astatusdate
,
  urokstatus=g2b(aurokstatus)
  where  iu_urok_snid = g2b(aiu_urok_snid) ;


call iu_urok_sn_client_trigger(acursession,aiu_urok_snid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_urok_sn' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_urok_sn
 (  iu_urok_snid 
,instanceid
,statusdate

,urokstatus

 ) values ( g2b(aiu_urok_snid) 
,g2b(ainstanceid)
,astatusdate

,g2b(aurokstatus)

 ) ;


call iu_urok_sn_client_trigger(acursession,aiu_urok_snid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_urok_sn_copy
go

create procedure iu_urok_sn_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_urok_sn 
 ( iu_urok_snid 
,instanceid
,statusdate

,urokstatus

 ) select 
copymap(acopyaction,b2g(iu_urok_snid)) 
,copymap(acopyaction,b2g(instanceid))
,statusdate

,urokstatus

 from iu_urok_sn
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_urok_sn_logger
go

create procedure iu_urok_sn_logger /*статусы урока*/ (
 acursession varchar(38),
 aiu_urok_snid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_urok_sn_parent
go
create procedure iu_urok_sn_parent /* статусы урока*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_urok_sn where  iu_urok_snid=arowid;
 end 
go
GO


drop procedure if exists iu_urok_sn_islocked
go
create procedure iu_urok_sn_islocked /* статусы урока */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_urok_sn where iu_urok_snid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_urok_sn_lock
go
create procedure iu_urok_sn_lock /* статусы урока */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_urok_sn_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_urok_sn set lockuserid =auserid ,locksessionid=null  where iu_urok_snid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_urok_sn set lockuserid=null ,locksessionid =acursession  where iu_urok_snid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_urok_sn_unlock
go
create procedure iu_urok_sn_unlock /* статусы урока */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_urok_sn_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_urok_sn set lockuserid =null  where iu_urok_snid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_urok_sn set locksessionid =null  where iu_urok_snid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_urok_sn_client_trigger
GO

create procedure iu_urok_sn_client_trigger  (
 acursession varchar(38),
 aiu_urok_snid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_urok_msg_brief
go

create procedure iu_urok_msg_brief  (
 acursession varchar(38),
 aiu_urok_msgid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_urok_msgid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_urok_msg where iu_urok_msgid=g2b(aiu_urok_msgid);
 if  aec &gt;0 then
   set abrief=iu_urok_msg_brief_f(g2b(aiu_urok_msgid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_urok_msg_delete
go

create procedure iu_urok_msg_delete /*сообщения сервера по ходу процесса*/ (
 acursession varchar(38),
 aiu_urok_msgid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_msg where iu_urok_msgid=g2b(aiu_urok_msgid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_urok_msg' result;
    leave body;
  end if;
 call iu_urok_msg_logger(acursession,aiu_urok_msgid) ; 
  delete from  iu_urok_msg 
  where  iu_urok_msgid = g2b(aiu_urok_msgid) ;
  delete from num_values where ownerpartname='iu_urok_msg' and ownerrowid=g2b(aiu_urok_msgid);
  end if;
    select 'ok' result;
 end 
go
GO

/*сообщения*/

drop procedure if exists iu_urok_msg_save
go

create procedure iu_urok_msg_save /*сообщения сервера по ходу процесса*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_urok_msgid varchar(38)
,ainfo
 varchar (255)/* сообщение *//* сообщение */
,athedate
 datetime/* дата сообщения *//* дата сообщения */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_msg where iu_urok_msgid=g2b(aiu_urok_msgid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_urok_msg' result;
    leave body;
  end if;
 start transaction ; 
 call iu_urok_msg_logger(acursession,aiu_urok_msgid) ; 
 update  iu_urok_msg set changestamp=now()
,
  info=ainfo
,
  thedate=athedate
  where  iu_urok_msgid = g2b(aiu_urok_msgid) ;


call iu_urok_msg_client_trigger(acursession,aiu_urok_msgid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_urok_msg' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_urok_msg
 (  iu_urok_msgid 
,instanceid
,info

,thedate

 ) values ( g2b(aiu_urok_msgid) 
,g2b(ainstanceid)
,ainfo

,athedate

 ) ;


call iu_urok_msg_client_trigger(acursession,aiu_urok_msgid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_urok_msg_copy
go

create procedure iu_urok_msg_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_urok_msg 
 ( iu_urok_msgid 
,instanceid
,info

,thedate

 ) select 
copymap(acopyaction,b2g(iu_urok_msgid)) 
,copymap(acopyaction,b2g(instanceid))
,info

,thedate

 from iu_urok_msg
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_urok_msg_logger
go

create procedure iu_urok_msg_logger /*сообщения сервера по ходу процесса*/ (
 acursession varchar(38),
 aiu_urok_msgid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_urok_msg_parent
go
create procedure iu_urok_msg_parent /* сообщения сервера по ходу процесса*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_urok_msg where  iu_urok_msgid=arowid;
 end 
go
GO


drop procedure if exists iu_urok_msg_islocked
go
create procedure iu_urok_msg_islocked /* сообщения сервера по ходу процесса */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_urok_msg where iu_urok_msgid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_urok_msg_lock
go
create procedure iu_urok_msg_lock /* сообщения сервера по ходу процесса */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_urok_msg_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_urok_msg set lockuserid =auserid ,locksessionid=null  where iu_urok_msgid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_urok_msg set lockuserid=null ,locksessionid =acursession  where iu_urok_msgid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_urok_msg_unlock
go
create procedure iu_urok_msg_unlock /* сообщения сервера по ходу процесса */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_urok_msg_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_urok_msg set lockuserid =null  where iu_urok_msgid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_urok_msg set locksessionid =null  where iu_urok_msgid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_urok_msg_client_trigger
GO

create procedure iu_urok_msg_client_trigger  (
 acursession varchar(38),
 aiu_urok_msgid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_urok_graph_brief
go

create procedure iu_urok_graph_brief  (
 acursession varchar(38),
 aiu_urok_graphid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_urok_graphid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_urok_graph where iu_urok_graphid=g2b(aiu_urok_graphid);
 if  aec &gt;0 then
   set abrief=iu_urok_graph_brief_f(g2b(aiu_urok_graphid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_urok_graph_delete
go

create procedure iu_urok_graph_delete /*график производства*/ (
 acursession varchar(38),
 aiu_urok_graphid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_graph where iu_urok_graphid=g2b(aiu_urok_graphid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_urok_graph' result;
    leave body;
  end if;
 call iu_urok_graph_logger(acursession,aiu_urok_graphid) ; 
  delete from  iu_urok_graph 
  where  iu_urok_graphid = g2b(aiu_urok_graphid) ;
  delete from num_values where ownerpartname='iu_urok_graph' and ownerrowid=g2b(aiu_urok_graphid);
  end if;
    select 'ok' result;
 end 
go
GO

/*график производства*/

drop procedure if exists iu_urok_graph_save
go

create procedure iu_urok_graph_save /*график производства*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_urok_graphid varchar(38)
,astageenddate
 datetime/* дата завершения стадии *//* дата завершения стадии */
,athestatus varchar(38)/* состояние *//* состояние */
,astagepercent
 integer/* процент готовности *//* процент готовности */
,aplanduration
 integer/* плановая длительность *//* плановая длительность */
,apassnumber
 integer/* номер прохода *//* номер прохода */
,astagestartdate
 datetime/* дата начала стадии *//* дата начала стадии */
,aplanstartdate
 date/* плановая дата начала *//* плановая дата начала */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_graph where iu_urok_graphid=g2b(aiu_urok_graphid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_urok_graph' result;
    leave body;
  end if;
 start transaction ; 
 call iu_urok_graph_logger(acursession,aiu_urok_graphid) ; 
 update  iu_urok_graph set changestamp=now()
,
  stageenddate=astageenddate
,
  thestatus=g2b(athestatus)
,
  stagepercent=astagepercent
,
  planduration=aplanduration
,
  passnumber=apassnumber
,
  stagestartdate=astagestartdate
,
  planstartdate=aplanstartdate
  where  iu_urok_graphid = g2b(aiu_urok_graphid) ;


call iu_urok_graph_client_trigger(acursession,aiu_urok_graphid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_urok_graph' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_urok_graph
 (  iu_urok_graphid 
,instanceid
,stageenddate

,thestatus

,stagepercent

,planduration

,passnumber

,stagestartdate

,planstartdate

 ) values ( g2b(aiu_urok_graphid) 
,g2b(ainstanceid)
,astageenddate

,g2b(athestatus)

,astagepercent

,aplanduration

,apassnumber

,astagestartdate

,aplanstartdate

 ) ;


call iu_urok_graph_client_trigger(acursession,aiu_urok_graphid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_urok_graph_copy
go

create procedure iu_urok_graph_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_urok_graph 
 ( iu_urok_graphid 
,instanceid
,stageenddate

,thestatus

,stagepercent

,planduration

,passnumber

,stagestartdate

,planstartdate

 ) select 
copymap(acopyaction,b2g(iu_urok_graphid)) 
,copymap(acopyaction,b2g(instanceid))
,stageenddate

,thestatus

,stagepercent

,planduration

,passnumber

,stagestartdate

,planstartdate

 from iu_urok_graph
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_urok_graph_logger
go

create procedure iu_urok_graph_logger /*график производства*/ (
 acursession varchar(38),
 aiu_urok_graphid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_urok_graph_parent
go
create procedure iu_urok_graph_parent /* график производства*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_urok_graph where  iu_urok_graphid=arowid;
 end 
go
GO


drop procedure if exists iu_urok_graph_islocked
go
create procedure iu_urok_graph_islocked /* график производства */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_urok_graph where iu_urok_graphid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_urok_graph_lock
go
create procedure iu_urok_graph_lock /* график производства */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_urok_graph_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_urok_graph set lockuserid =auserid ,locksessionid=null  where iu_urok_graphid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_urok_graph set lockuserid=null ,locksessionid =acursession  where iu_urok_graphid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_urok_graph_unlock
go
create procedure iu_urok_graph_unlock /* график производства */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_urok_graph_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_urok_graph set lockuserid =null  where iu_urok_graphid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_urok_graph set locksessionid =null  where iu_urok_graphid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_urok_graph_client_trigger
GO

create procedure iu_urok_graph_client_trigger  (
 acursession varchar(38),
 aiu_urok_graphid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_urok_prc_brief
go

create procedure iu_urok_prc_brief  (
 acursession varchar(38),
 aiu_urok_prcid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_urok_prcid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_urok_prc where iu_urok_prcid=g2b(aiu_urok_prcid);
 if  aec &gt;0 then
   set abrief=iu_urok_prc_brief_f(g2b(aiu_urok_prcid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_urok_prc_delete
go

create procedure iu_urok_prc_delete /*состояние урока, отделено от данных урока*/ (
 acursession varchar(38),
 aiu_urok_prcid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_prc where iu_urok_prcid=g2b(aiu_urok_prcid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_urok_prc' result;
    leave body;
  end if;
 call iu_urok_prc_logger(acursession,aiu_urok_prcid) ; 
  delete from  iu_urok_prc 
  where  iu_urok_prcid = g2b(aiu_urok_prcid) ;
  delete from num_values where ownerpartname='iu_urok_prc' and ownerrowid=g2b(aiu_urok_prcid);
  end if;
    select 'ok' result;
 end 
go
GO

/*текущий этап*/

drop procedure if exists iu_urok_prc_save
go

create procedure iu_urok_prc_save /*состояние урока, отделено от данных урока*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_urok_prcid varchar(38)
,atheprocess varchar(38)/* урок *//* урок */
,atopstage varchar(38)/* этап *//* этап */
,aiu_urok_stage varchar(38)/* подэтап *//* подэтап */
,aisdone
 integer/* завершен *//* завершен */
,alaststate varchar(38)/* последний статус *//* последний статус */
,alastmessage
 varchar (255)/* последнее сообщение *//* последнее сообщение */
,amanualcontrol
 integer/* требуется управление *//* требуется управление */
,ataskdelayed
 integer/* опаздание *//* опаздание */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_prc where iu_urok_prcid=g2b(aiu_urok_prcid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_urok_prc' result;
    leave body;
  end if;
 start transaction ; 
 call iu_urok_prc_logger(acursession,aiu_urok_prcid) ; 
 update  iu_urok_prc set changestamp=now()
,
  theprocess=g2b(atheprocess)
,
  topstage=g2b(atopstage)
,
  iu_urok_stage=g2b(aiu_urok_stage)
,
  isdone=aisdone
,
  laststate=g2b(alaststate)
,
  lastmessage=alastmessage
,
  manualcontrol=amanualcontrol
,
  taskdelayed=ataskdelayed
  where  iu_urok_prcid = g2b(aiu_urok_prcid) ;


call iu_urok_prc_client_trigger(acursession,aiu_urok_prcid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_us.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_urok_prc' result;
    leave body;
  end if;
select count(*) into aec from iu_urok_prc where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_urok_prc&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_urok_prc
 (  iu_urok_prcid 
,instanceid
,theprocess

,topstage

,iu_urok_stage

,isdone

,laststate

,lastmessage

,manualcontrol

,taskdelayed

 ) values ( g2b(aiu_urok_prcid) 
,g2b(ainstanceid)
,g2b(atheprocess)

,g2b(atopstage)

,g2b(aiu_urok_stage)

,aisdone

,g2b(alaststate)

,alastmessage

,amanualcontrol

,ataskdelayed

 ) ;


call iu_urok_prc_client_trigger(acursession,aiu_urok_prcid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_urok_prc_copy
go

create procedure iu_urok_prc_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_urok_prc 
 ( iu_urok_prcid 
,instanceid
,theprocess

,topstage

,iu_urok_stage

,isdone

,laststate

,lastmessage

,manualcontrol

,taskdelayed

 ) select 
copymap(acopyaction,b2g(iu_urok_prcid)) 
,copymap(acopyaction,b2g(instanceid))
,theprocess

,topstage

,iu_urok_stage

,isdone

,laststate

,lastmessage

,manualcontrol

,taskdelayed

 from iu_urok_prc
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_urok_prc_logger
go

create procedure iu_urok_prc_logger /*состояние урока, отделено от данных урока*/ (
 acursession varchar(38),
 aiu_urok_prcid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_urok_prc_parent
go
create procedure iu_urok_prc_parent /* состояние урока, отделено от данных урока*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_urok_prc where  iu_urok_prcid=arowid;
 end 
go
GO


drop procedure if exists iu_urok_prc_islocked
go
create procedure iu_urok_prc_islocked /* состояние урока, отделено от данных урока */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_urok_prc where iu_urok_prcid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_urok_prc_lock
go
create procedure iu_urok_prc_lock /* состояние урока, отделено от данных урока */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_urok_prc_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_urok_prc set lockuserid =auserid ,locksessionid=null  where iu_urok_prcid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_urok_prc set lockuserid=null ,locksessionid =acursession  where iu_urok_prcid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_urok_prc_unlock
go
create procedure iu_urok_prc_unlock /* состояние урока, отделено от данных урока */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_urok_prc_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_urok_prc set lockuserid =null  where iu_urok_prcid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_urok_prc set locksessionid =null  where iu_urok_prcid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_urok_prc_client_trigger
GO

create procedure iu_urok_prc_client_trigger  (
 acursession varchar(38),
 aiu_urok_prcid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists folder_brief
go

create procedure folder_brief  (
 acursession varchar(38),
 afolderid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afolderid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from folder where folderid=g2b(afolderid);
 if  aec &gt;0 then
   set abrief=folder_brief_f(g2b(afolderid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists folder_delete
go

create procedure folder_delete /*папка каталога*/ (
 acursession varchar(38),
 afolderid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from folder where folderid=g2b(afolderid);
if aec&gt;0 then
 select checkoperation( acursession ,'stdinfostore.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=folder' result;
    leave body;
  end if;
 call folder_logger(acursession,afolderid) ; 
  delete from  folder 
  where  folderid = g2b(afolderid) ;
  delete from num_values where ownerpartname='folder' and ownerrowid=g2b(afolderid);
  end if;
    select 'ok' result;
 end 
go
GO

/*папка*/

drop procedure if exists folder_save
go

create procedure folder_save /*папка каталога*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 afolderid varchar(38)
,aparentrowid varchar(38) 
,aname
 varchar (255)/* название *//* название */
,afoldertype
 integer/* тип папки *//* тип папки */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from folder where folderid=g2b(afolderid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'stdinfostore.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=folder' result;
    leave body;
  end if;
 start transaction ; 
 call folder_logger(acursession,afolderid) ; 
 update  folder set changestamp=now()
,parentrowid= g2b(aparentrowid)
,
  name=aname
,
  foldertype=afoldertype
  where  folderid = g2b(afolderid) ;


call folder_client_trigger(acursession,afolderid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'stdinfostore.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=folder' result;
    leave body;
  end if;
 start transaction;  
 insert into   folder
 (  folderid 
,parentrowid
,instanceid
,name

,foldertype

 ) values ( g2b(afolderid) 
,g2b(aparentrowid)
,g2b(ainstanceid)
,aname

,afoldertype

 ) ;


call folder_client_trigger(acursession,afolderid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists shortcut_brief
go

create procedure shortcut_brief  (
 acursession varchar(38),
 ashortcutid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if ashortcutid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from shortcut where shortcutid=g2b(ashortcutid);
 if  aec &gt;0 then
   set abrief=shortcut_brief_f(g2b(ashortcutid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists shortcut_delete
go

create procedure shortcut_delete /*ярлыки документов*/ (
 acursession varchar(38),
 ashortcutid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from shortcut where shortcutid=g2b(ashortcutid);
if aec&gt;0 then
 select checkoperation( acursession ,'stdinfostore.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=shortcut' result;
    leave body;
  end if;
 call shortcut_logger(acursession,ashortcutid) ; 
  delete from  shortcut 
  where  shortcutid = g2b(ashortcutid) ;
  delete from num_values where ownerpartname='shortcut' and ownerrowid=g2b(ashortcutid);
  end if;
    select 'ok' result;
 end 
go
GO

/*документы*/

drop procedure if exists shortcut_save
go

create procedure shortcut_save /*ярлыки документов*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 ashortcutid varchar(38)
,adocitem varchar(38)/* документ *//* документ */
,astartmode
 varchar (255)/* режим *//* режим */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from shortcut where shortcutid=g2b(ashortcutid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'stdinfostore.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=shortcut' result;
    leave body;
  end if;
 start transaction ; 
 call shortcut_logger(acursession,ashortcutid) ; 
 update  shortcut set changestamp=now()
,
  docitem=g2b(adocitem)
,
  startmode=astartmode
  where  shortcutid = g2b(ashortcutid) ;


call shortcut_client_trigger(acursession,ashortcutid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'stdinfostore.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=shortcut' result;
    leave body;
  end if;
 start transaction;  
 insert into   shortcut
 (  shortcutid 
,parentstructrowid
,docitem

,startmode

 ) values ( g2b(ashortcutid) 
,g2b(aparentstructrowid)
,g2b(adocitem)

,astartmode

 ) ;


call shortcut_client_trigger(acursession,ashortcutid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists shortcut_copy
go

create procedure shortcut_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into shortcut 
 ( shortcutid 
,parentstructrowid
,docitem

,startmode

 ) select 
copymap(acopyaction,b2g(shortcutid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,docitem

,startmode

 from shortcut
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists folder_copy
go

create procedure folder_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_folder cursor for
select folderid from folder where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into folder 
 ( folderid 
,instanceid
,parentrowid
,name

,foldertype

 ) select 
copymap(acopyaction,b2g(folderid)) 
,copymap(acopyaction,b2g(instanceid))
,copymap(acopyaction,b2g(parentrowid))
,name

,foldertype

 from folder
 where instanceid =g2b( ainstanceid); 
open copy_cursor_folder;
  set  fetch_done=false;
fetch copy_cursor_folder into aid;
while not fetch_done do 
    call shortcut_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_folder into aid;
end while;

close copy_cursor_folder;
 end 
go
GO


drop procedure if exists folder_logger
go

create procedure folder_logger /*папка каталога*/ (
 acursession varchar(38),
 afolderid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists shortcut_logger
go

create procedure shortcut_logger /*ярлыки документов*/ (
 acursession varchar(38),
 ashortcutid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists folder_parent
go
create procedure folder_parent /* папка каталога*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from folder where  folderid=arowid;
 end 
go
GO


drop procedure if exists folder_islocked
go
create procedure folder_islocked /* папка каталога */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from folder where folderid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists folder_lock
go
create procedure folder_lock /* папка каталога */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call folder_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update folder set lockuserid =auserid ,locksessionid=null  where folderid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update folder set lockuserid=null ,locksessionid =acursession  where folderid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists folder_unlock
go
create procedure folder_unlock /* папка каталога */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call folder_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update folder set lockuserid =null  where folderid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update folder set locksessionid =null  where folderid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS folder_client_trigger
GO

create procedure folder_client_trigger  (
 acursession varchar(38),
 aFolderid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists shortcut_parent
go
create procedure shortcut_parent /* ярлыки документов*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from shortcut where  shortcutid=arowid;
  set aparenttable = 'folder';
 end 
go
GO


drop procedure if exists shortcut_islocked
go
create procedure shortcut_islocked /* ярлыки документов */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from shortcut where shortcutid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists shortcut_lock
go
create procedure shortcut_lock /* ярлыки документов */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call shortcut_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update shortcut set lockuserid =auserid ,locksessionid=null  where shortcutid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update shortcut set lockuserid=null ,locksessionid =acursession  where shortcutid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists shortcut_unlock
go
create procedure shortcut_unlock /* ярлыки документов */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call shortcut_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update shortcut set lockuserid =null  where shortcutid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update shortcut set locksessionid =null  where shortcutid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS shortcut_client_trigger
GO

create procedure shortcut_client_trigger  (
 acursession varchar(38),
 aShortcutid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists infostoredef_brief
go

create procedure infostoredef_brief  (
 acursession varchar(38),
 ainfostoredefid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if ainfostoredefid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from infostoredef where infostoredefid=g2b(ainfostoredefid);
 if  aec &gt;0 then
   set abrief=infostoredef_brief_f(g2b(ainfostoredefid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists infostoredef_delete
go

create procedure infostoredef_delete /*описание каталога*/ (
 acursession varchar(38),
 ainfostoredefid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from infostoredef where infostoredefid=g2b(ainfostoredefid);
if aec&gt;0 then
 select checkoperation( acursession ,'stdinfostore.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=infostoredef' result;
    leave body;
  end if;
 call infostoredef_logger(acursession,ainfostoredefid) ; 
  delete from  infostoredef 
  where  infostoredefid = g2b(ainfostoredefid) ;
  delete from num_values where ownerpartname='infostoredef' and ownerrowid=g2b(ainfostoredefid);
  end if;
    select 'ok' result;
 end 
go
GO

/*описание*/

drop procedure if exists infostoredef_save
go

create procedure infostoredef_save /*описание каталога*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 ainfostoredefid varchar(38)
,athegroup varchar(38)/* группа *//* группа */
,aname
 varchar (255)/* название *//* название */
,ainfostoretype
 integer/* тип каталога *//* тип каталога */
,atheuser varchar(38)/* пользователь *//* пользователь */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from infostoredef where infostoredefid=g2b(ainfostoredefid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'stdinfostore.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=infostoredef' result;
    leave body;
  end if;
 start transaction ; 
 call infostoredef_logger(acursession,ainfostoredefid) ; 
 update  infostoredef set changestamp=now()
,
  thegroup=g2b(athegroup)
,
  name=aname
,
  infostoretype=ainfostoretype
,
  theuser=g2b(atheuser)
  where  infostoredefid = g2b(ainfostoredefid) ;


call infostoredef_client_trigger(acursession,ainfostoredefid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'stdinfostore.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=infostoredef' result;
    leave body;
  end if;
select count(*) into aec from infostoredef where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;infostoredef&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   infostoredef
 (  infostoredefid 
,instanceid
,thegroup

,name

,infostoretype

,theuser

 ) values ( g2b(ainfostoredefid) 
,g2b(ainstanceid)
,g2b(athegroup)

,aname

,ainfostoretype

,g2b(atheuser)

 ) ;


call infostoredef_client_trigger(acursession,ainfostoredefid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists infostoredef_copy
go

create procedure infostoredef_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into infostoredef 
 ( infostoredefid 
,instanceid
,thegroup

,name

,infostoretype

,theuser

 ) select 
copymap(acopyaction,b2g(infostoredefid)) 
,copymap(acopyaction,b2g(instanceid))
,thegroup

,name

,infostoretype

,theuser

 from infostoredef
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists infostoredef_logger
go

create procedure infostoredef_logger /*описание каталога*/ (
 acursession varchar(38),
 ainfostoredefid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists infostoredef_parent
go
create procedure infostoredef_parent /* описание каталога*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from infostoredef where  infostoredefid=arowid;
 end 
go
GO


drop procedure if exists infostoredef_islocked
go
create procedure infostoredef_islocked /* описание каталога */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from infostoredef where infostoredefid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists infostoredef_lock
go
create procedure infostoredef_lock /* описание каталога */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call infostoredef_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update infostoredef set lockuserid =auserid ,locksessionid=null  where infostoredefid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update infostoredef set lockuserid=null ,locksessionid =acursession  where infostoredefid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists infostoredef_unlock
go
create procedure infostoredef_unlock /* описание каталога */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call infostoredef_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update infostoredef set lockuserid =null  where infostoredefid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update infostoredef set locksessionid =null  where infostoredefid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS infostoredef_client_trigger
GO

create procedure infostoredef_client_trigger  (
 acursession varchar(38),
 aInfoStoreDefid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_rt_def_brief
go

create procedure iud_rt_def_brief  (
 acursession varchar(38),
 aiud_rt_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_rt_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_rt_def where iud_rt_defid=g2b(aiud_rt_defid);
 if  aec &gt;0 then
   set abrief=iud_rt_def_brief_f(g2b(aiud_rt_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_rt_def_delete
go

create procedure iud_rt_def_delete /*тип ссылки на файл*/ (
 acursession varchar(38),
 aiud_rt_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_rt_def where iud_rt_defid=g2b(aiud_rt_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_rt.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_rt_def' result;
    leave body;
  end if;
 call iud_rt_def_logger(acursession,aiud_rt_defid) ; 
  delete from  iud_rt_def 
  where  iud_rt_defid = g2b(aiud_rt_defid) ;
  delete from num_values where ownerpartname='iud_rt_def' and ownerrowid=g2b(aiud_rt_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип ссылки*/

drop procedure if exists iud_rt_def_save
go

create procedure iud_rt_def_save /*тип ссылки на файл*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_rt_defid varchar(38)
,aname
 varchar (80)/* название *//* название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_rt_def where iud_rt_defid=g2b(aiud_rt_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_rt.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_rt_def' result;
    leave body;
  end if;
 start transaction ; 
 call iud_rt_def_logger(acursession,aiud_rt_defid) ; 
 update  iud_rt_def set changestamp=now()
,
  name=aname
  where  iud_rt_defid = g2b(aiud_rt_defid) ;


call iud_rt_def_client_trigger(acursession,aiud_rt_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_rt.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_rt_def' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_rt_def
 (  iud_rt_defid 
,instanceid
,name

 ) values ( g2b(aiud_rt_defid) 
,g2b(ainstanceid)
,aname

 ) ;


call iud_rt_def_client_trigger(acursession,aiud_rt_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_rt_def_copy
go

create procedure iud_rt_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_rt_def 
 ( iud_rt_defid 
,instanceid
,name

 ) select 
copymap(acopyaction,b2g(iud_rt_defid)) 
,copymap(acopyaction,b2g(instanceid))
,name

 from iud_rt_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_rt_def_logger
go

create procedure iud_rt_def_logger /*тип ссылки на файл*/ (
 acursession varchar(38),
 aiud_rt_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_rt_def_parent
go
create procedure iud_rt_def_parent /* тип ссылки на файл*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_rt_def where  iud_rt_defid=arowid;
 end 
go
GO


drop procedure if exists iud_rt_def_islocked
go
create procedure iud_rt_def_islocked /* тип ссылки на файл */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_rt_def where iud_rt_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_rt_def_lock
go
create procedure iud_rt_def_lock /* тип ссылки на файл */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_rt_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_rt_def set lockuserid =auserid ,locksessionid=null  where iud_rt_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_rt_def set lockuserid=null ,locksessionid =acursession  where iud_rt_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_rt_def_unlock
go
create procedure iud_rt_def_unlock /* тип ссылки на файл */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_rt_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_rt_def set lockuserid =null  where iud_rt_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_rt_def set locksessionid =null  where iud_rt_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_rt_def_client_trigger
GO

create procedure iud_rt_def_client_trigger  (
 acursession varchar(38),
 aiud_rt_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists the_session_brief
go

create procedure the_session_brief  (
 acursession varchar(38),
 athe_sessionid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if athe_sessionid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from the_session where the_sessionid=g2b(athe_sessionid);
 if  aec &gt;0 then
   set abrief=the_session_brief_f(g2b(athe_sessionid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists the_session_delete
go

create procedure the_session_delete /*зарегистрированные сессии пользователей*/ (
 acursession varchar(38),
 athe_sessionid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from the_session where the_sessionid=g2b(athe_sessionid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=the_session' result;
    leave body;
  end if;
 call the_session_logger(acursession,athe_sessionid) ; 
  delete from  the_session 
  where  the_sessionid = g2b(athe_sessionid) ;
  delete from num_values where ownerpartname='the_session' and ownerrowid=g2b(athe_sessionid);
  end if;
    select 'ok' result;
 end 
go
GO

/*сессия пользователя*/

drop procedure if exists the_session_save
go

create procedure the_session_save /*зарегистрированные сессии пользователей*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 athe_sessionid varchar(38)
,aapplicationid varchar(38)/* приложение *//* приложение */
,auserrole varchar(38)/* текущая роль пользователя *//* текущая роль пользователя */
,aclosedat
 datetime/* момент закрытия *//* момент закрытия */
,aclosed
 integer/* закрыта *//* закрыта */
,ausersid varchar(38)/* пользователь *//* пользователь */
,alastaccess
 datetime/* последнее подтверждение *//* последнее подтверждение */
,astartat
 datetime/* момент открытия *//* момент открытия */
,alang
 varchar (25)/* локализация *//* локализация */
,alogin
 varchar (255)/* login *//* login */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from the_session where the_sessionid=g2b(athe_sessionid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=the_session' result;
    leave body;
  end if;
 start transaction ; 
 call the_session_logger(acursession,athe_sessionid) ; 
 update  the_session set changestamp=now()
,
  applicationid=g2b(aapplicationid)
,
  userrole=g2b(auserrole)
,
  closedat=aclosedat
,
  closed=aclosed
,
  usersid=g2b(ausersid)
,
  lastaccess=alastaccess
,
  startat=astartat
,
  lang=alang
,
  login=alogin
  where  the_sessionid = g2b(athe_sessionid) ;


call the_session_client_trigger(acursession,athe_sessionid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=the_session' result;
    leave body;
  end if;
 start transaction;  
 insert into   the_session
 (  the_sessionid 
,instanceid
,applicationid

,userrole

,closedat

,closed

,usersid

,lastaccess

,startat

,lang

,login

 ) values ( g2b(athe_sessionid) 
,g2b(ainstanceid)
,g2b(aapplicationid)

,g2b(auserrole)

,aclosedat

,aclosed

,g2b(ausersid)

,alastaccess

,astartat

,alang

,alogin

 ) ;


call the_session_client_trigger(acursession,athe_sessionid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists the_session_copy
go

create procedure the_session_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into the_session 
 ( the_sessionid 
,instanceid
,applicationid

,userrole

,closedat

,closed

,usersid

,lastaccess

,startat

,lang

,login

 ) select 
copymap(acopyaction,b2g(the_sessionid)) 
,copymap(acopyaction,b2g(instanceid))
,applicationid

,userrole

,closedat

,closed

,usersid

,lastaccess

,startat

,lang

,login

 from the_session
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists the_session_logger
go

create procedure the_session_logger /*зарегистрированные сессии пользователей*/ (
 acursession varchar(38),
 athe_sessionid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists the_session_parent
go
create procedure the_session_parent /* зарегистрированные сессии пользователей*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from the_session where  the_sessionid=arowid;
 end 
go
GO


drop procedure if exists the_session_islocked
go
create procedure the_session_islocked /* зарегистрированные сессии пользователей */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from the_session where the_sessionid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists the_session_lock
go
create procedure the_session_lock /* зарегистрированные сессии пользователей */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call the_session_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update the_session set lockuserid =auserid ,locksessionid=null  where the_sessionid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update the_session set lockuserid=null ,locksessionid =acursession  where the_sessionid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists the_session_unlock
go
create procedure the_session_unlock /* зарегистрированные сессии пользователей */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call the_session_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update the_session set lockuserid =null  where the_sessionid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update the_session set locksessionid =null  where the_sessionid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS the_session_client_trigger
GO

create procedure the_session_client_trigger  (
 acursession varchar(38),
 athe_Sessionid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists sysrefcache_brief
go

create procedure sysrefcache_brief  (
 acursession varchar(38),
 asysrefcacheid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if asysrefcacheid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from sysrefcache where sysrefcacheid=g2b(asysrefcacheid);
 if  aec &gt;0 then
   set abrief=sysrefcache_brief_f(g2b(asysrefcacheid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists sysrefcache_delete
go

create procedure sysrefcache_delete /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 acursession varchar(38),
 asysrefcacheid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from sysrefcache where sysrefcacheid=g2b(asysrefcacheid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=sysrefcache' result;
    leave body;
  end if;
 call sysrefcache_logger(acursession,asysrefcacheid) ; 
  delete from  sysrefcache 
  where  sysrefcacheid = g2b(asysrefcacheid) ;
  delete from num_values where ownerpartname='sysrefcache' and ownerrowid=g2b(asysrefcacheid);
  end if;
    select 'ok' result;
 end 
go
GO

/*разрешенные владельцы*/

drop procedure if exists sysrefcache_save
go

create procedure sysrefcache_save /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 asysrefcacheid varchar(38)
,acachetype
 integer/* тип кеширования *//* тип кеширования */
,aobjectownerid binary(16)/* идентификатор владельца *//* идентификатор владельца */
,asessionid varchar(38)/* сессия *//* сессия */
,amodulename
 varchar (40)/* модуль *//* модуль */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from sysrefcache where sysrefcacheid=g2b(asysrefcacheid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=sysrefcache' result;
    leave body;
  end if;
 start transaction ; 
 call sysrefcache_logger(acursession,asysrefcacheid) ; 
 update  sysrefcache set changestamp=now()
,
  cachetype=acachetype
,
  objectownerid=aobjectownerid
,
  sessionid=g2b(asessionid)
,
  modulename=amodulename
  where  sysrefcacheid = g2b(asysrefcacheid) ;


call sysrefcache_client_trigger(acursession,asysrefcacheid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=sysrefcache' result;
    leave body;
  end if;
 start transaction;  
 insert into   sysrefcache
 (  sysrefcacheid 
,instanceid
,cachetype

,objectownerid

,sessionid

,modulename

 ) values ( g2b(asysrefcacheid) 
,g2b(ainstanceid)
,acachetype

,aobjectownerid

,g2b(asessionid)

,amodulename

 ) ;


call sysrefcache_client_trigger(acursession,asysrefcacheid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists sysrefcache_copy
go

create procedure sysrefcache_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into sysrefcache 
 ( sysrefcacheid 
,instanceid
,cachetype

,objectownerid

,sessionid

,modulename

 ) select 
copymap(acopyaction,b2g(sysrefcacheid)) 
,copymap(acopyaction,b2g(instanceid))
,cachetype

,objectownerid

,sessionid

,modulename

 from sysrefcache
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists sysrefcache_logger
go

create procedure sysrefcache_logger /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 acursession varchar(38),
 asysrefcacheid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists sysrefcache_parent
go
create procedure sysrefcache_parent /* владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from sysrefcache where  sysrefcacheid=arowid;
 end 
go
GO


drop procedure if exists sysrefcache_islocked
go
create procedure sysrefcache_islocked /* владельцы информации для к объектам которых
разрешен достуа для  текущей сесии */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from sysrefcache where sysrefcacheid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists sysrefcache_lock
go
create procedure sysrefcache_lock /* владельцы информации для к объектам которых
разрешен достуа для  текущей сесии */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call sysrefcache_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update sysrefcache set lockuserid =auserid ,locksessionid=null  where sysrefcacheid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update sysrefcache set lockuserid=null ,locksessionid =acursession  where sysrefcacheid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists sysrefcache_unlock
go
create procedure sysrefcache_unlock /* владельцы информации для к объектам которых
разрешен достуа для  текущей сесии */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call sysrefcache_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update sysrefcache set lockuserid =null  where sysrefcacheid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update sysrefcache set locksessionid =null  where sysrefcacheid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS sysrefcache_client_trigger
GO

create procedure sysrefcache_client_trigger  (
 acursession varchar(38),
 aSysRefCacheid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists syslog_brief
go

create procedure syslog_brief  (
 acursession varchar(38),
 asyslogid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if asyslogid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from syslog where syslogid=g2b(asyslogid);
 if  aec &gt;0 then
   set abrief=syslog_brief_f(g2b(asyslogid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists syslog_delete
go

create procedure syslog_delete /*журнал событий, которые произошли в системе*/ (
 acursession varchar(38),
 asyslogid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from syslog where syslogid=g2b(asyslogid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=syslog' result;
    leave body;
  end if;
 call syslog_logger(acursession,asyslogid) ; 
  delete from  syslog 
  where  syslogid = g2b(asyslogid) ;
  delete from num_values where ownerpartname='syslog' and ownerrowid=g2b(asyslogid);
  end if;
    select 'ok' result;
 end 
go
GO

/*журнал событий*/

drop procedure if exists syslog_save
go

create procedure syslog_save /*журнал событий, которые произошли в системе*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 asyslogid varchar(38)
,athesession varchar(38)/* сессия *//* сессия */
,athe_resource
 varchar (255)/* ресурс *//* ресурс */
,alogstructid
 varchar (255)/* раздел с которым происхоит действие *//* раздел с которым происхоит действие */
,averb
 varchar (80)/* действие *//* действие */
,aloginstanceid binary(16)/* идентификатор документа *//* идентификатор документа */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from syslog where syslogid=g2b(asyslogid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=syslog' result;
    leave body;
  end if;
 start transaction ; 
 call syslog_logger(acursession,asyslogid) ; 
 update  syslog set changestamp=now()
,
  thesession=g2b(athesession)
,
  the_resource=athe_resource
,
  logstructid=alogstructid
,
  verb=averb
,
  loginstanceid=aloginstanceid
  where  syslogid = g2b(asyslogid) ;


call syslog_client_trigger(acursession,asyslogid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzsystem.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=syslog' result;
    leave body;
  end if;
 start transaction;  
 insert into   syslog
 (  syslogid 
,instanceid
,thesession

,the_resource

,logstructid

,verb

,loginstanceid

 ) values ( g2b(asyslogid) 
,g2b(ainstanceid)
,g2b(athesession)

,athe_resource

,alogstructid

,averb

,aloginstanceid

 ) ;


call syslog_client_trigger(acursession,asyslogid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists syslog_copy
go

create procedure syslog_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into syslog 
 ( syslogid 
,instanceid
,thesession

,the_resource

,logstructid

,verb

,loginstanceid

 ) select 
copymap(acopyaction,b2g(syslogid)) 
,copymap(acopyaction,b2g(instanceid))
,thesession

,the_resource

,logstructid

,verb

,loginstanceid

 from syslog
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists syslog_logger
go

create procedure syslog_logger /*журнал событий, которые произошли в системе*/ (
 acursession varchar(38),
 asyslogid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists syslog_parent
go
create procedure syslog_parent /* журнал событий, которые произошли в системе*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from syslog where  syslogid=arowid;
 end 
go
GO


drop procedure if exists syslog_islocked
go
create procedure syslog_islocked /* журнал событий, которые произошли в системе */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from syslog where syslogid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists syslog_lock
go
create procedure syslog_lock /* журнал событий, которые произошли в системе */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call syslog_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update syslog set lockuserid =auserid ,locksessionid=null  where syslogid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update syslog set lockuserid=null ,locksessionid =acursession  where syslogid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists syslog_unlock
go
create procedure syslog_unlock /* журнал событий, которые произошли в системе */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call syslog_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update syslog set lockuserid =null  where syslogid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update syslog set locksessionid =null  where syslogid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS syslog_client_trigger
GO

create procedure syslog_client_trigger  (
 acursession varchar(38),
 aSysLogid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists armjournal_brief
go

create procedure armjournal_brief  (
 acursession varchar(38),
 aarmjournalid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aarmjournalid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from armjournal where armjournalid=g2b(aarmjournalid);
 if  aec &gt;0 then
   set abrief=armjournal_brief_f(g2b(aarmjournalid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists armjournal_delete
go

create procedure armjournal_delete /*описание действий журанлов*/ (
 acursession varchar(38),
 aarmjournalid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from armjournal where armjournalid=g2b(aarmjournalid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=armjournal' result;
    leave body;
  end if;
 call armjournal_logger(acursession,aarmjournalid) ; 
  delete from  armjournal 
  where  armjournalid = g2b(aarmjournalid) ;
  delete from num_values where ownerpartname='armjournal' and ownerrowid=g2b(aarmjournalid);
  end if;
    select 'ok' result;
 end 
go
GO

/*поведение журналов*/

drop procedure if exists armjournal_save
go

create procedure armjournal_save /*описание действий журанлов*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aarmjournalid varchar(38)
,athejournal varchar(38)/* журнал *//* журнал */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from armjournal where armjournalid=g2b(aarmjournalid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=armjournal' result;
    leave body;
  end if;
 start transaction ; 
 call armjournal_logger(acursession,aarmjournalid) ; 
 update  armjournal set changestamp=now()
,
  thejournal=g2b(athejournal)
  where  armjournalid = g2b(aarmjournalid) ;


call armjournal_client_trigger(acursession,aarmjournalid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=armjournal' result;
    leave body;
  end if;
 start transaction;  
 insert into   armjournal
 (  armjournalid 
,instanceid
,thejournal

 ) values ( g2b(aarmjournalid) 
,g2b(ainstanceid)
,g2b(athejournal)

 ) ;


call armjournal_client_trigger(acursession,aarmjournalid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists armjrnlrep_brief
go

create procedure armjrnlrep_brief  (
 acursession varchar(38),
 aarmjrnlrepid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aarmjrnlrepid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from armjrnlrep where armjrnlrepid=g2b(aarmjrnlrepid);
 if  aec &gt;0 then
   set abrief=armjrnlrep_brief_f(g2b(aarmjrnlrepid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists armjrnlrep_delete
go

create procedure armjrnlrep_delete /*отчеты из журнала*/ (
 acursession varchar(38),
 aarmjrnlrepid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from armjrnlrep where armjrnlrepid=g2b(aarmjrnlrepid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=armjrnlrep' result;
    leave body;
  end if;
 call armjrnlrep_logger(acursession,aarmjrnlrepid) ; 
  delete from  armjrnlrep 
  where  armjrnlrepid = g2b(aarmjrnlrepid) ;
  delete from num_values where ownerpartname='armjrnlrep' and ownerrowid=g2b(aarmjrnlrepid);
  end if;
    select 'ok' result;
 end 
go
GO

/*отчеты*/

drop procedure if exists armjrnlrep_save
go

create procedure armjrnlrep_save /*отчеты из журнала*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aarmjrnlrepid varchar(38)
,arepname
 varchar (255)/* название отчета *//* название отчета */
,athereport varchar(38)/* отчет *//* отчет */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from armjrnlrep where armjrnlrepid=g2b(aarmjrnlrepid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=armjrnlrep' result;
    leave body;
  end if;
 start transaction ; 
 call armjrnlrep_logger(acursession,aarmjrnlrepid) ; 
 update  armjrnlrep set changestamp=now()
,
  repname=arepname
,
  thereport=g2b(athereport)
  where  armjrnlrepid = g2b(aarmjrnlrepid) ;


call armjrnlrep_client_trigger(acursession,aarmjrnlrepid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=armjrnlrep' result;
    leave body;
  end if;
 start transaction;  
 insert into   armjrnlrep
 (  armjrnlrepid 
,parentstructrowid
,repname

,thereport

 ) values ( g2b(aarmjrnlrepid) 
,g2b(aparentstructrowid)
,arepname

,g2b(athereport)

 ) ;


call armjrnlrep_client_trigger(acursession,aarmjrnlrepid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists armjrnlrun_brief
go

create procedure armjrnlrun_brief  (
 acursession varchar(38),
 aarmjrnlrunid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aarmjrnlrunid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from armjrnlrun where armjrnlrunid=g2b(aarmjrnlrunid);
 if  aec &gt;0 then
   set abrief=armjrnlrun_brief_f(g2b(aarmjrnlrunid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists armjrnlrun_delete
go

create procedure armjrnlrun_delete /*дополнительные действия в журнале*/ (
 acursession varchar(38),
 aarmjrnlrunid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from armjrnlrun where armjrnlrunid=g2b(aarmjrnlrunid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=armjrnlrun' result;
    leave body;
  end if;
 call armjrnlrun_logger(acursession,aarmjrnlrunid) ; 
  delete from  armjrnlrun 
  where  armjrnlrunid = g2b(aarmjrnlrunid) ;
  delete from num_values where ownerpartname='armjrnlrun' and ownerrowid=g2b(aarmjrnlrunid);
  end if;
    select 'ok' result;
 end 
go
GO

/*действия*/

drop procedure if exists armjrnlrun_save
go

create procedure armjrnlrun_save /*дополнительные действия в журнале*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aarmjrnlrunid varchar(38)
,aname
 varchar (255)/* название *//* название */
,atheextention varchar(38)/* расширение *//* расширение */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from armjrnlrun where armjrnlrunid=g2b(aarmjrnlrunid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=armjrnlrun' result;
    leave body;
  end if;
 start transaction ; 
 call armjrnlrun_logger(acursession,aarmjrnlrunid) ; 
 update  armjrnlrun set changestamp=now()
,
  name=aname
,
  theextention=g2b(atheextention)
  where  armjrnlrunid = g2b(aarmjrnlrunid) ;


call armjrnlrun_client_trigger(acursession,aarmjrnlrunid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=armjrnlrun' result;
    leave body;
  end if;
 start transaction;  
 insert into   armjrnlrun
 (  armjrnlrunid 
,parentstructrowid
,name

,theextention

 ) values ( g2b(aarmjrnlrunid) 
,g2b(aparentstructrowid)
,aname

,g2b(atheextention)

 ) ;


call armjrnlrun_client_trigger(acursession,aarmjrnlrunid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists armjrnladd_brief
go

create procedure armjrnladd_brief  (
 acursession varchar(38),
 aarmjrnladdid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aarmjrnladdid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from armjrnladd where armjrnladdid=g2b(aarmjrnladdid);
 if  aec &gt;0 then
   set abrief=armjrnladd_brief_f(g2b(aarmjrnladdid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists armjrnladd_delete
go

create procedure armjrnladd_delete /*варианты обработки добавления*/ (
 acursession varchar(38),
 aarmjrnladdid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from armjrnladd where armjrnladdid=g2b(aarmjrnladdid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=armjrnladd' result;
    leave body;
  end if;
 call armjrnladd_logger(acursession,aarmjrnladdid) ; 
  delete from  armjrnladd 
  where  armjrnladdid = g2b(aarmjrnladdid) ;
  delete from num_values where ownerpartname='armjrnladd' and ownerrowid=g2b(aarmjrnladdid);
  end if;
    select 'ok' result;
 end 
go
GO

/*добавление*/

drop procedure if exists armjrnladd_save
go

create procedure armjrnladd_save /*варианты обработки добавления*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aarmjrnladdid varchar(38)
,aname
 varchar (255)/* название *//* название */
,atheextention varchar(38)/* расширение *//* расширение */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from armjrnladd where armjrnladdid=g2b(aarmjrnladdid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=armjrnladd' result;
    leave body;
  end if;
 start transaction ; 
 call armjrnladd_logger(acursession,aarmjrnladdid) ; 
 update  armjrnladd set changestamp=now()
,
  name=aname
,
  theextention=g2b(atheextention)
  where  armjrnladdid = g2b(aarmjrnladdid) ;


call armjrnladd_client_trigger(acursession,aarmjrnladdid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=armjrnladd' result;
    leave body;
  end if;
 start transaction;  
 insert into   armjrnladd
 (  armjrnladdid 
,parentstructrowid
,name

,theextention

 ) values ( g2b(aarmjrnladdid) 
,g2b(aparentstructrowid)
,aname

,g2b(atheextention)

 ) ;


call armjrnladd_client_trigger(acursession,aarmjrnladdid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists armjrnlrep_copy
go

create procedure armjrnlrep_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into armjrnlrep 
 ( armjrnlrepid 
,parentstructrowid
,repname

,thereport

 ) select 
copymap(acopyaction,b2g(armjrnlrepid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,repname

,thereport

 from armjrnlrep
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists armjrnlrun_copy
go

create procedure armjrnlrun_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into armjrnlrun 
 ( armjrnlrunid 
,parentstructrowid
,name

,theextention

 ) select 
copymap(acopyaction,b2g(armjrnlrunid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,theextention

 from armjrnlrun
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists armjrnladd_copy
go

create procedure armjrnladd_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into armjrnladd 
 ( armjrnladdid 
,parentstructrowid
,name

,theextention

 ) select 
copymap(acopyaction,b2g(armjrnladdid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,theextention

 from armjrnladd
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists armjournal_copy
go

create procedure armjournal_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_armjournal cursor for
select armjournalid from armjournal where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into armjournal 
 ( armjournalid 
,instanceid
,thejournal

 ) select 
copymap(acopyaction,b2g(armjournalid)) 
,copymap(acopyaction,b2g(instanceid))
,thejournal

 from armjournal
 where instanceid =g2b( ainstanceid); 
open copy_cursor_armjournal;
  set  fetch_done=false;
fetch copy_cursor_armjournal into aid;
while not fetch_done do 
    call armjrnlrep_copy(acursession,acopyaction,ainstanceid,aid);
    call armjrnlrun_copy(acursession,acopyaction,ainstanceid,aid);
    call armjrnladd_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_armjournal into aid;
end while;

close copy_cursor_armjournal;
 end 
go
GO


drop procedure if exists armjournal_logger
go

create procedure armjournal_logger /*описание действий журанлов*/ (
 acursession varchar(38),
 aarmjournalid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists armjrnlrep_logger
go

create procedure armjrnlrep_logger /*отчеты из журнала*/ (
 acursession varchar(38),
 aarmjrnlrepid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists armjrnlrun_logger
go

create procedure armjrnlrun_logger /*дополнительные действия в журнале*/ (
 acursession varchar(38),
 aarmjrnlrunid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists armjrnladd_logger
go

create procedure armjrnladd_logger /*варианты обработки добавления*/ (
 acursession varchar(38),
 aarmjrnladdid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists armjournal_parent
go
create procedure armjournal_parent /* описание действий журанлов*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from armjournal where  armjournalid=arowid;
 end 
go
GO


drop procedure if exists armjournal_islocked
go
create procedure armjournal_islocked /* описание действий журанлов */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from armjournal where armjournalid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists armjournal_lock
go
create procedure armjournal_lock /* описание действий журанлов */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call armjournal_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update armjournal set lockuserid =auserid ,locksessionid=null  where armjournalid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update armjournal set lockuserid=null ,locksessionid =acursession  where armjournalid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists armjournal_unlock
go
create procedure armjournal_unlock /* описание действий журанлов */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call armjournal_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update armjournal set lockuserid =null  where armjournalid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update armjournal set locksessionid =null  where armjournalid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS armjournal_client_trigger
GO

create procedure armjournal_client_trigger  (
 acursession varchar(38),
 aARMJournalid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists armjrnlrep_parent
go
create procedure armjrnlrep_parent /* отчеты из журнала*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from armjrnlrep where  armjrnlrepid=arowid;
  set aparenttable = 'armjournal';
 end 
go
GO


drop procedure if exists armjrnlrep_islocked
go
create procedure armjrnlrep_islocked /* отчеты из журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from armjrnlrep where armjrnlrepid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists armjrnlrep_lock
go
create procedure armjrnlrep_lock /* отчеты из журнала */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call armjrnlrep_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update armjrnlrep set lockuserid =auserid ,locksessionid=null  where armjrnlrepid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update armjrnlrep set lockuserid=null ,locksessionid =acursession  where armjrnlrepid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists armjrnlrep_unlock
go
create procedure armjrnlrep_unlock /* отчеты из журнала */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call armjrnlrep_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update armjrnlrep set lockuserid =null  where armjrnlrepid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update armjrnlrep set locksessionid =null  where armjrnlrepid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS armjrnlrep_client_trigger
GO

create procedure armjrnlrep_client_trigger  (
 acursession varchar(38),
 aARMJRNLREPid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists armjrnlrun_parent
go
create procedure armjrnlrun_parent /* дополнительные действия в журнале*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from armjrnlrun where  armjrnlrunid=arowid;
  set aparenttable = 'armjournal';
 end 
go
GO


drop procedure if exists armjrnlrun_islocked
go
create procedure armjrnlrun_islocked /* дополнительные действия в журнале */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from armjrnlrun where armjrnlrunid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists armjrnlrun_lock
go
create procedure armjrnlrun_lock /* дополнительные действия в журнале */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call armjrnlrun_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update armjrnlrun set lockuserid =auserid ,locksessionid=null  where armjrnlrunid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update armjrnlrun set lockuserid=null ,locksessionid =acursession  where armjrnlrunid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists armjrnlrun_unlock
go
create procedure armjrnlrun_unlock /* дополнительные действия в журнале */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call armjrnlrun_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update armjrnlrun set lockuserid =null  where armjrnlrunid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update armjrnlrun set locksessionid =null  where armjrnlrunid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS armjrnlrun_client_trigger
GO

create procedure armjrnlrun_client_trigger  (
 acursession varchar(38),
 aARMJRNLRUNid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists armjrnladd_parent
go
create procedure armjrnladd_parent /* варианты обработки добавления*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from armjrnladd where  armjrnladdid=arowid;
  set aparenttable = 'armjournal';
 end 
go
GO


drop procedure if exists armjrnladd_islocked
go
create procedure armjrnladd_islocked /* варианты обработки добавления */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from armjrnladd where armjrnladdid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists armjrnladd_lock
go
create procedure armjrnladd_lock /* варианты обработки добавления */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call armjrnladd_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update armjrnladd set lockuserid =auserid ,locksessionid=null  where armjrnladdid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update armjrnladd set lockuserid=null ,locksessionid =acursession  where armjrnladdid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists armjrnladd_unlock
go
create procedure armjrnladd_unlock /* варианты обработки добавления */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call armjrnladd_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update armjrnladd set lockuserid =null  where armjrnladdid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update armjrnladd set locksessionid =null  where armjrnladdid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS armjrnladd_client_trigger
GO

create procedure armjrnladd_client_trigger  (
 acursession varchar(38),
 aARMJRNLADDid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists entrypoints_brief
go

create procedure entrypoints_brief  (
 acursession varchar(38),
 aentrypointsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aentrypointsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from entrypoints where entrypointsid=g2b(aentrypointsid);
 if  aec &gt;0 then
   set abrief=entrypoints_brief_f(g2b(aentrypointsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists entrypoints_delete
go

create procedure entrypoints_delete /*меню*/ (
 acursession varchar(38),
 aentrypointsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from entrypoints where entrypointsid=g2b(aentrypointsid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=entrypoints' result;
    leave body;
  end if;
 call entrypoints_logger(acursession,aentrypointsid) ; 
  delete from  entrypoints 
  where  entrypointsid = g2b(aentrypointsid) ;
  delete from num_values where ownerpartname='entrypoints' and ownerrowid=g2b(aentrypointsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*меню*/

drop procedure if exists entrypoints_save
go

create procedure entrypoints_save /*меню*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aentrypointsid varchar(38)
,aparentrowid varchar(38) 
,asequence
 integer/* последовательность *//* последовательность */
,aname
 varchar (38)/* название *//* название */
,acaption
 varchar (255)/* заголовок *//* заголовок */
,aastoolbaritem
 integer/* включить в тулбар *//* включить в тулбар */
,aactiontype
 integer/* вариант действия *//* вариант действия */
,athefilter varchar(38)/* фильтр *//* фильтр */
,ajournal varchar(38)/* журнал *//* журнал */
,areport varchar(38)/* отчет *//* отчет */
,adocument varchar(38)/* документ *//* документ */
,amethod varchar(38)/* метод *//* метод */
,aiconfile
 varchar (2000)/* файл картинки *//* файл картинки */
,atheextention varchar(38)/* расширение *//* расширение */
,aarm varchar(38)/* арм *//* арм */
,athecomment
 text/* примечание *//* примечание */
,aobjecttype varchar(38)/* тип документа *//* тип документа */
,ajournalfixedquery
 text/* ограничения к журналу *//* ограничения к журналу */
,aallowadd
 integer/* разрешено добавление *//* разрешено добавление */
,aallowedit
 integer/* разрешено редактирование *//* разрешено редактирование */
,aallowdel
 integer/* рарешено удаление *//* рарешено удаление */
,aallowfilter
 integer/* разрешен фильтр *//* разрешен фильтр */
,aallowprint
 integer/* разрешена печать *//* разрешена печать */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from entrypoints where entrypointsid=g2b(aentrypointsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=entrypoints' result;
    leave body;
  end if;
 start transaction ; 
 call entrypoints_logger(acursession,aentrypointsid) ; 
 update  entrypoints set changestamp=now()
,parentrowid= g2b(aparentrowid)
,
  sequence=asequence
,
  name=aname
,
  caption=acaption
,
  astoolbaritem=aastoolbaritem
,
  actiontype=aactiontype
,
  thefilter=g2b(athefilter)
,
  journal=g2b(ajournal)
,
  report=g2b(areport)
,
  document=g2b(adocument)
,
  method=g2b(amethod)
,
  iconfile=aiconfile
,
  theextention=g2b(atheextention)
,
  arm=g2b(aarm)
,
  thecomment=athecomment
,
  objecttype=g2b(aobjecttype)
,
  journalfixedquery=ajournalfixedquery
,
  allowadd=aallowadd
,
  allowedit=aallowedit
,
  allowdel=aallowdel
,
  allowfilter=aallowfilter
,
  allowprint=aallowprint
  where  entrypointsid = g2b(aentrypointsid) ;


call entrypoints_client_trigger(acursession,aentrypointsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=entrypoints' result;
    leave body;
  end if;
 start transaction;  
 insert into   entrypoints
 (  entrypointsid 
,parentrowid
,instanceid
,sequence

,name

,caption

,astoolbaritem

,actiontype

,thefilter

,journal

,report

,document

,method

,iconfile

,theextention

,arm

,thecomment

,objecttype

,journalfixedquery

,allowadd

,allowedit

,allowdel

,allowfilter

,allowprint

 ) values ( g2b(aentrypointsid) 
,g2b(aparentrowid)
,g2b(ainstanceid)
,asequence

,aname

,acaption

,aastoolbaritem

,aactiontype

,g2b(athefilter)

,g2b(ajournal)

,g2b(areport)

,g2b(adocument)

,g2b(amethod)

,aiconfile

,g2b(atheextention)

,g2b(aarm)

,athecomment

,g2b(aobjecttype)

,ajournalfixedquery

,aallowadd

,aallowedit

,aallowdel

,aallowfilter

,aallowprint

 ) ;


call entrypoints_client_trigger(acursession,aentrypointsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists epfilterlink_brief
go

create procedure epfilterlink_brief  (
 acursession varchar(38),
 aepfilterlinkid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aepfilterlinkid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from epfilterlink where epfilterlinkid=g2b(aepfilterlinkid);
 if  aec &gt;0 then
   set abrief=epfilterlink_brief_f(g2b(aepfilterlinkid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists epfilterlink_delete
go

create procedure epfilterlink_delete /*привязка фильтра к журналу*/ (
 acursession varchar(38),
 aepfilterlinkid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from epfilterlink where epfilterlinkid=g2b(aepfilterlinkid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=epfilterlink' result;
    leave body;
  end if;
 call epfilterlink_logger(acursession,aepfilterlinkid) ; 
  delete from  epfilterlink 
  where  epfilterlinkid = g2b(aepfilterlinkid) ;
  delete from num_values where ownerpartname='epfilterlink' and ownerrowid=g2b(aepfilterlinkid);
  end if;
    select 'ok' result;
 end 
go
GO

/*привязка фильтра*/

drop procedure if exists epfilterlink_save
go

create procedure epfilterlink_save /*привязка фильтра к журналу*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aepfilterlinkid varchar(38)
,arowsource
 varchar (255)/* источник *//* источник */
,atheexpression
 text/* выражение *//* выражение */
,afilterfield
 varchar (255)/* поле фильтра *//* поле фильтра */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from epfilterlink where epfilterlinkid=g2b(aepfilterlinkid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=epfilterlink' result;
    leave body;
  end if;
 start transaction ; 
 call epfilterlink_logger(acursession,aepfilterlinkid) ; 
 update  epfilterlink set changestamp=now()
,
  rowsource=arowsource
,
  theexpression=atheexpression
,
  filterfield=afilterfield
  where  epfilterlinkid = g2b(aepfilterlinkid) ;


call epfilterlink_client_trigger(acursession,aepfilterlinkid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=epfilterlink' result;
    leave body;
  end if;
 start transaction;  
 insert into   epfilterlink
 (  epfilterlinkid 
,parentstructrowid
,rowsource

,theexpression

,filterfield

 ) values ( g2b(aepfilterlinkid) 
,g2b(aparentstructrowid)
,arowsource

,atheexpression

,afilterfield

 ) ;


call epfilterlink_client_trigger(acursession,aepfilterlinkid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists epfilterlink_copy
go

create procedure epfilterlink_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into epfilterlink 
 ( epfilterlinkid 
,parentstructrowid
,rowsource

,theexpression

,filterfield

 ) select 
copymap(acopyaction,b2g(epfilterlinkid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,rowsource

,theexpression

,filterfield

 from epfilterlink
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists entrypoints_copy
go

create procedure entrypoints_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_entrypoints cursor for
select entrypointsid from entrypoints where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into entrypoints 
 ( entrypointsid 
,instanceid
,parentrowid
,sequence

,name

,caption

,astoolbaritem

,actiontype

,thefilter

,journal

,report

,document

,method

,iconfile

,theextention

,arm

,thecomment

,objecttype

,journalfixedquery

,allowadd

,allowedit

,allowdel

,allowfilter

,allowprint

 ) select 
copymap(acopyaction,b2g(entrypointsid)) 
,copymap(acopyaction,b2g(instanceid))
,copymap(acopyaction,b2g(parentrowid))
,sequence

,name

,caption

,astoolbaritem

,actiontype

,thefilter

,journal

,report

,document

,method

,iconfile

,theextention

,arm

,thecomment

,objecttype

,journalfixedquery

,allowadd

,allowedit

,allowdel

,allowfilter

,allowprint

 from entrypoints
 where instanceid =g2b( ainstanceid); 
open copy_cursor_entrypoints;
  set  fetch_done=false;
fetch copy_cursor_entrypoints into aid;
while not fetch_done do 
    call epfilterlink_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_entrypoints into aid;
end while;

close copy_cursor_entrypoints;
 end 
go
GO


drop procedure if exists entrypoints_logger
go

create procedure entrypoints_logger /*меню*/ (
 acursession varchar(38),
 aentrypointsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists epfilterlink_logger
go

create procedure epfilterlink_logger /*привязка фильтра к журналу*/ (
 acursession varchar(38),
 aepfilterlinkid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists entrypoints_parent
go
create procedure entrypoints_parent /* меню*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from entrypoints where  entrypointsid=arowid;
 end 
go
GO


drop procedure if exists entrypoints_islocked
go
create procedure entrypoints_islocked /* меню */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from entrypoints where entrypointsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists entrypoints_lock
go
create procedure entrypoints_lock /* меню */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call entrypoints_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update entrypoints set lockuserid =auserid ,locksessionid=null  where entrypointsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update entrypoints set lockuserid=null ,locksessionid =acursession  where entrypointsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists entrypoints_unlock
go
create procedure entrypoints_unlock /* меню */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call entrypoints_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update entrypoints set lockuserid =null  where entrypointsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update entrypoints set locksessionid =null  where entrypointsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS entrypoints_client_trigger
GO

create procedure entrypoints_client_trigger  (
 acursession varchar(38),
 aEntryPointsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists epfilterlink_parent
go
create procedure epfilterlink_parent /* привязка фильтра к журналу*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from epfilterlink where  epfilterlinkid=arowid;
  set aparenttable = 'entrypoints';
 end 
go
GO


drop procedure if exists epfilterlink_islocked
go
create procedure epfilterlink_islocked /* привязка фильтра к журналу */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from epfilterlink where epfilterlinkid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists epfilterlink_lock
go
create procedure epfilterlink_lock /* привязка фильтра к журналу */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call epfilterlink_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update epfilterlink set lockuserid =auserid ,locksessionid=null  where epfilterlinkid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update epfilterlink set lockuserid=null ,locksessionid =acursession  where epfilterlinkid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists epfilterlink_unlock
go
create procedure epfilterlink_unlock /* привязка фильтра к журналу */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call epfilterlink_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update epfilterlink set lockuserid =null  where epfilterlinkid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update epfilterlink set locksessionid =null  where epfilterlinkid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS epfilterlink_client_trigger
GO

create procedure epfilterlink_client_trigger  (
 acursession varchar(38),
 aEPFilterLinkid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists workplace_brief
go

create procedure workplace_brief  (
 acursession varchar(38),
 aworkplaceid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aworkplaceid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from workplace where workplaceid=g2b(aworkplaceid);
 if  aec &gt;0 then
   set abrief=workplace_brief_f(g2b(aworkplaceid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists workplace_delete
go

create procedure workplace_delete /*арм*/ (
 acursession varchar(38),
 aworkplaceid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from workplace where workplaceid=g2b(aworkplaceid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=workplace' result;
    leave body;
  end if;
 call workplace_logger(acursession,aworkplaceid) ; 
  delete from  workplace 
  where  workplaceid = g2b(aworkplaceid) ;
  delete from num_values where ownerpartname='workplace' and ownerrowid=g2b(aworkplaceid);
  end if;
    select 'ok' result;
 end 
go
GO

/*арм*/

drop procedure if exists workplace_save
go

create procedure workplace_save /*арм*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aworkplaceid varchar(38)
,aname
 varchar (255)/* название *//* название */
,acaption
 varchar (255)/* заголовок *//* заголовок */
,atheversion
 varchar (30)/* версия *//* версия */
,atheplatform
 integer/* платформа реализации *//* платформа реализации */
,athecomment
 text/* примечание *//* примечание */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from workplace where workplaceid=g2b(aworkplaceid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=workplace' result;
    leave body;
  end if;
 start transaction ; 
 call workplace_logger(acursession,aworkplaceid) ; 
 update  workplace set changestamp=now()
,
  name=aname
,
  caption=acaption
,
  theversion=atheversion
,
  theplatform=atheplatform
,
  thecomment=athecomment
  where  workplaceid = g2b(aworkplaceid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from workplace where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=арм правило=(уникальность для арм.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call workplace_client_trigger(acursession,aworkplaceid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=workplace' result;
    leave body;
  end if;
select count(*) into aec from workplace where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;workplace&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   workplace
 (  workplaceid 
,instanceid
,name

,caption

,theversion

,theplatform

,thecomment

 ) values ( g2b(aworkplaceid) 
,g2b(ainstanceid)
,aname

,acaption

,atheversion

,atheplatform

,athecomment

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from workplace where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=арм правило=(уникальность для арм.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call workplace_client_trigger(acursession,aworkplaceid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists workplace_copy
go

create procedure workplace_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into workplace 
 ( workplaceid 
,instanceid
,name

,caption

,theversion

,theplatform

,thecomment

 ) select 
copymap(acopyaction,b2g(workplaceid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,caption

,theversion

,theplatform

,thecomment

 from workplace
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists workplace_logger
go

create procedure workplace_logger /*арм*/ (
 acursession varchar(38),
 aworkplaceid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists workplace_parent
go
create procedure workplace_parent /* арм*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from workplace where  workplaceid=arowid;
 end 
go
GO


drop procedure if exists workplace_islocked
go
create procedure workplace_islocked /* арм */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from workplace where workplaceid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists workplace_lock
go
create procedure workplace_lock /* арм */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call workplace_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update workplace set lockuserid =auserid ,locksessionid=null  where workplaceid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update workplace set lockuserid=null ,locksessionid =acursession  where workplaceid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists workplace_unlock
go
create procedure workplace_unlock /* арм */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call workplace_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update workplace set lockuserid =null  where workplaceid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update workplace set locksessionid =null  where workplaceid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS workplace_client_trigger
GO

create procedure workplace_client_trigger  (
 acursession varchar(38),
 aWorkPlaceid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists armtypes_brief
go

create procedure armtypes_brief  (
 acursession varchar(38),
 aarmtypesid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aarmtypesid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from armtypes where armtypesid=g2b(aarmtypesid);
 if  aec &gt;0 then
   set abrief=armtypes_brief_f(g2b(aarmtypesid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists armtypes_delete
go

create procedure armtypes_delete /*типы документов, которые подключаются в mdi режиме*/ (
 acursession varchar(38),
 aarmtypesid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from armtypes where armtypesid=g2b(aarmtypesid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=armtypes' result;
    leave body;
  end if;
 call armtypes_logger(acursession,aarmtypesid) ; 
  delete from  armtypes 
  where  armtypesid = g2b(aarmtypesid) ;
  delete from num_values where ownerpartname='armtypes' and ownerrowid=g2b(aarmtypesid);
  end if;
    select 'ok' result;
 end 
go
GO

/*список типов*/

drop procedure if exists armtypes_save
go

create procedure armtypes_save /*типы документов, которые подключаются в mdi режиме*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aarmtypesid varchar(38)
,athedocumenttype varchar(38)/* тип документа *//* тип документа */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from armtypes where armtypesid=g2b(aarmtypesid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=armtypes' result;
    leave body;
  end if;
 start transaction ; 
 call armtypes_logger(acursession,aarmtypesid) ; 
 update  armtypes set changestamp=now()
,
  thedocumenttype=g2b(athedocumenttype)
  where  armtypesid = g2b(aarmtypesid) ;


call armtypes_client_trigger(acursession,aarmtypesid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzwp.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=armtypes' result;
    leave body;
  end if;
 start transaction;  
 insert into   armtypes
 (  armtypesid 
,instanceid
,thedocumenttype

 ) values ( g2b(aarmtypesid) 
,g2b(ainstanceid)
,g2b(athedocumenttype)

 ) ;


call armtypes_client_trigger(acursession,aarmtypesid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists armtypes_copy
go

create procedure armtypes_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into armtypes 
 ( armtypesid 
,instanceid
,thedocumenttype

 ) select 
copymap(acopyaction,b2g(armtypesid)) 
,copymap(acopyaction,b2g(instanceid))
,thedocumenttype

 from armtypes
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists armtypes_logger
go

create procedure armtypes_logger /*типы документов, которые подключаются в mdi режиме*/ (
 acursession varchar(38),
 aarmtypesid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists armtypes_parent
go
create procedure armtypes_parent /* типы документов, которые подключаются в mdi режиме*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from armtypes where  armtypesid=arowid;
 end 
go
GO


drop procedure if exists armtypes_islocked
go
create procedure armtypes_islocked /* типы документов, которые подключаются в mdi режиме */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from armtypes where armtypesid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists armtypes_lock
go
create procedure armtypes_lock /* типы документов, которые подключаются в mdi режиме */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call armtypes_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update armtypes set lockuserid =auserid ,locksessionid=null  where armtypesid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update armtypes set lockuserid=null ,locksessionid =acursession  where armtypesid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists armtypes_unlock
go
create procedure armtypes_unlock /* типы документов, которые подключаются в mdi режиме */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call armtypes_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update armtypes set lockuserid =null  where armtypesid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update armtypes set locksessionid =null  where armtypesid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS armtypes_client_trigger
GO

create procedure armtypes_client_trigger  (
 acursession varchar(38),
 aARMTypesid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_crole_brief
go

create procedure iu_crole_brief  (
 acursession varchar(38),
 aiu_croleid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_croleid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_crole where iu_croleid=g2b(aiu_croleid);
 if  aec &gt;0 then
   set abrief=iu_crole_brief_f(g2b(aiu_croleid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_crole_delete
go

create procedure iu_crole_delete /*роль в процессе производства*/ (
 acursession varchar(38),
 aiu_croleid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_crole where iu_croleid=g2b(aiu_croleid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_d_urole.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_crole' result;
    leave body;
  end if;
 call iu_crole_logger(acursession,aiu_croleid) ; 
  delete from  iu_crole 
  where  iu_croleid = g2b(aiu_croleid) ;
  delete from num_values where ownerpartname='iu_crole' and ownerrowid=g2b(aiu_croleid);
  end if;
    select 'ok' result;
 end 
go
GO


drop procedure if exists iu_crole_archive
go

create procedure iu_crole_archive /*роль в процессе производства*/ (
 acursession varchar(38),
 aiu_croleid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare atmpid binary(16);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_crole where iu_croleid=g2b(aiu_croleid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_d_urole.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_crole' result;
    leave body;
  end if;
 call iu_crole_logger(acursession,aiu_croleid) ; 
  update   iu_crole set archived = 1 
  where  iu_croleid = g2b(aiu_croleid) ;
  end if;
    select 'ok' result;
 end 
go
GO

/*роль*/

drop procedure if exists iu_crole_save
go

create procedure iu_crole_save /*роль в процессе производства*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_croleid varchar(38)
,aname
 varchar (120)/* название *//* название */
,aallowsetuser
 integer/* требует явного назначения *//* требует явного назначения */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_crole where iu_croleid=g2b(aiu_croleid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_d_urole.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_crole' result;
    leave body;
  end if;
 start transaction ; 
 call iu_crole_logger(acursession,aiu_croleid) ; 
 update  iu_crole set changestamp=now()
,
  name=aname
,
  allowsetuser=aallowsetuser
  where  iu_croleid = g2b(aiu_croleid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iu_crole where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=роль правило=(уникальность для роль.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_crole_client_trigger(acursession,aiu_croleid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_d_urole.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_crole' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_crole
 (  iu_croleid 
,instanceid
,name

,allowsetuser

 ) values ( g2b(aiu_croleid) 
,g2b(ainstanceid)
,aname

,aallowsetuser

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iu_crole where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=роль правило=(уникальность для роль.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_crole_client_trigger(acursession,aiu_croleid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_crole_copy
go

create procedure iu_crole_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_crole 
 ( iu_croleid 
,instanceid
,archived
,name

,allowsetuser

 ) select 
copymap(acopyaction,b2g(iu_croleid)) 
,copymap(acopyaction,b2g(instanceid))
,archived
,name

,allowsetuser

 from iu_crole
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_crole_logger
go

create procedure iu_crole_logger /*роль в процессе производства*/ (
 acursession varchar(38),
 aiu_croleid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_crole_parent
go
create procedure iu_crole_parent /* роль в процессе производства*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_crole where  iu_croleid=arowid;
 end 
go
GO


drop procedure if exists iu_crole_islocked
go
create procedure iu_crole_islocked /* роль в процессе производства */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_crole where iu_croleid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_crole_lock
go
create procedure iu_crole_lock /* роль в процессе производства */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_crole_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_crole set lockuserid =auserid ,locksessionid=null  where iu_croleid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_crole set lockuserid=null ,locksessionid =acursession  where iu_croleid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_crole_unlock
go
create procedure iu_crole_unlock /* роль в процессе производства */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_crole_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_crole set lockuserid =null  where iu_croleid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_crole set locksessionid =null  where iu_croleid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_crole_client_trigger
GO

create procedure iu_crole_client_trigger  (
 acursession varchar(38),
 aiu_croleid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles_operations_brief
go

create procedure roles_operations_brief  (
 acursession varchar(38),
 aroles_operationsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles_operationsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles_operations where roles_operationsid=g2b(aroles_operationsid);
 if  aec &gt;0 then
   set abrief=roles_operations_brief_f(g2b(aroles_operationsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles_operations_delete
go

create procedure roles_operations_delete /*именованные операции*/ (
 acursession varchar(38),
 aroles_operationsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_operations where roles_operationsid=g2b(aroles_operationsid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles_operations' result;
    leave body;
  end if;
 call roles_operations_logger(acursession,aroles_operationsid) ; 
  delete from  roles_operations 
  where  roles_operationsid = g2b(aroles_operationsid) ;
  delete from num_values where ownerpartname='roles_operations' and ownerrowid=g2b(aroles_operationsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*доступные действия*/

drop procedure if exists roles_operations_save
go

create procedure roles_operations_save /*именованные операции*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aroles_operationsid varchar(38)
,ainfo
 varchar (256)/* описание *//* описание */
,aallowaction
 integer/* разрешено *//* разрешено */
,aname
 varchar (255)/* код *//* код */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_operations where roles_operationsid=g2b(aroles_operationsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles_operations' result;
    leave body;
  end if;
 start transaction ; 
 call roles_operations_logger(acursession,aroles_operationsid) ; 
 update  roles_operations set changestamp=now()
,
  info=ainfo
,
  allowaction=aallowaction
,
  name=aname
  where  roles_operationsid = g2b(aroles_operationsid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from roles_operations where  instanceid=g2b(ainstanceid) 
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=доступные действия правило=(операции уникальны в пределах роли)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_operations_client_trigger(acursession,aroles_operationsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles_operations' result;
    leave body;
  end if;
 start transaction;  
 insert into   roles_operations
 (  roles_operationsid 
,instanceid
,info

,allowaction

,name

 ) values ( g2b(aroles_operationsid) 
,g2b(ainstanceid)
,ainfo

,aallowaction

,aname

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from roles_operations where  instanceid=g2b(ainstanceid) 
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=доступные действия правило=(операции уникальны в пределах роли)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_operations_client_trigger(acursession,aroles_operationsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles_operations_copy
go

create procedure roles_operations_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles_operations 
 ( roles_operationsid 
,instanceid
,info

,allowaction

,name

 ) select 
copymap(acopyaction,b2g(roles_operationsid)) 
,copymap(acopyaction,b2g(instanceid))
,info

,allowaction

,name

 from roles_operations
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists roles_operations_logger
go

create procedure roles_operations_logger /*именованные операции*/ (
 acursession varchar(38),
 aroles_operationsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles_operations_parent
go
create procedure roles_operations_parent /* именованные операции*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from roles_operations where  roles_operationsid=arowid;
 end 
go
GO


drop procedure if exists roles_operations_islocked
go
create procedure roles_operations_islocked /* именованные операции */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles_operations where roles_operationsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles_operations_lock
go
create procedure roles_operations_lock /* именованные операции */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles_operations_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles_operations set lockuserid =auserid ,locksessionid=null  where roles_operationsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles_operations set lockuserid=null ,locksessionid =acursession  where roles_operationsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles_operations_unlock
go
create procedure roles_operations_unlock /* именованные операции */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles_operations_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles_operations set lockuserid =null  where roles_operationsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles_operations set locksessionid =null  where roles_operationsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles_operations_client_trigger
GO

create procedure roles_operations_client_trigger  (
 acursession varchar(38),
 aROLES_OPERATIONSid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles_wp_brief
go

create procedure roles_wp_brief  (
 acursession varchar(38),
 aroles_wpid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles_wpid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles_wp where roles_wpid=g2b(aroles_wpid);
 if  aec &gt;0 then
   set abrief=roles_wp_brief_f(g2b(aroles_wpid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles_wp_delete
go

create procedure roles_wp_delete /*доступные приложения*/ (
 acursession varchar(38),
 aroles_wpid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_wp where roles_wpid=g2b(aroles_wpid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles_wp' result;
    leave body;
  end if;
 call roles_wp_logger(acursession,aroles_wpid) ; 
  delete from  roles_wp 
  where  roles_wpid = g2b(aroles_wpid) ;
  delete from num_values where ownerpartname='roles_wp' and ownerrowid=g2b(aroles_wpid);
  end if;
    select 'ok' result;
 end 
go
GO

/*доступные приложения*/

drop procedure if exists roles_wp_save
go

create procedure roles_wp_save /*доступные приложения*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aroles_wpid varchar(38)
,awp varchar(38)/* приложение *//* приложение */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_wp where roles_wpid=g2b(aroles_wpid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles_wp' result;
    leave body;
  end if;
 start transaction ; 
 call roles_wp_logger(acursession,aroles_wpid) ; 
 update  roles_wp set changestamp=now()
,
  wp=g2b(awp)
  where  roles_wpid = g2b(aroles_wpid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from roles_wp where  instanceid=g2b(ainstanceid) 
 and wp=g2b(awp);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=доступные приложения правило=(сочетание должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_wp_client_trigger(acursession,aroles_wpid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles_wp' result;
    leave body;
  end if;
 start transaction;  
 insert into   roles_wp
 (  roles_wpid 
,instanceid
,wp

 ) values ( g2b(aroles_wpid) 
,g2b(ainstanceid)
,g2b(awp)

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from roles_wp where  instanceid=g2b(ainstanceid) 
 and wp=g2b(awp);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=доступные приложения правило=(сочетание должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_wp_client_trigger(acursession,aroles_wpid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles_act_brief
go

create procedure roles_act_brief  (
 acursession varchar(38),
 aroles_actid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles_actid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles_act where roles_actid=g2b(aroles_actid);
 if  aec &gt;0 then
   set abrief=roles_act_brief_f(g2b(aroles_actid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles_act_delete
go

create procedure roles_act_delete /*разрешенные пункты меню*/ (
 acursession varchar(38),
 aroles_actid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_act where roles_actid=g2b(aroles_actid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles_act' result;
    leave body;
  end if;
 call roles_act_logger(acursession,aroles_actid) ; 
  delete from  roles_act 
  where  roles_actid = g2b(aroles_actid) ;
  delete from num_values where ownerpartname='roles_act' and ownerrowid=g2b(aroles_actid);
  end if;
    select 'ok' result;
 end 
go
GO

/*разрешенные пункты меню*/

drop procedure if exists roles_act_save
go

create procedure roles_act_save /*разрешенные пункты меню*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aroles_actid varchar(38)
,aaccesible
 integer/* доступность *//* доступность */
,amenuname
 varchar (255)/* меню *//* меню */
,amenucode
 varchar (255)/* код пункта меню *//* код пункта меню */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_act where roles_actid=g2b(aroles_actid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles_act' result;
    leave body;
  end if;
 start transaction ; 
 call roles_act_logger(acursession,aroles_actid) ; 
 update  roles_act set changestamp=now()
,
  accesible=aaccesible
,
  menuname=amenuname
,
  menucode=amenucode
  where  roles_actid = g2b(aroles_actid) ;


call roles_act_client_trigger(acursession,aroles_actid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles_act' result;
    leave body;
  end if;
 start transaction;  
 insert into   roles_act
 (  roles_actid 
,parentstructrowid
,accesible

,menuname

,menucode

 ) values ( g2b(aroles_actid) 
,g2b(aparentstructrowid)
,aaccesible

,amenuname

,amenucode

 ) ;


call roles_act_client_trigger(acursession,aroles_actid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles_act_copy
go

create procedure roles_act_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles_act 
 ( roles_actid 
,parentstructrowid
,accesible

,menuname

,menucode

 ) select 
copymap(acopyaction,b2g(roles_actid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,accesible

,menuname

,menucode

 from roles_act
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists roles_wp_copy
go

create procedure roles_wp_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_roles_wp cursor for
select roles_wpid from roles_wp where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles_wp 
 ( roles_wpid 
,instanceid
,wp

 ) select 
copymap(acopyaction,b2g(roles_wpid)) 
,copymap(acopyaction,b2g(instanceid))
,wp

 from roles_wp
 where instanceid =g2b( ainstanceid); 
open copy_cursor_roles_wp;
  set  fetch_done=false;
fetch copy_cursor_roles_wp into aid;
while not fetch_done do 
    call roles_act_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_roles_wp into aid;
end while;

close copy_cursor_roles_wp;
 end 
go
GO


drop procedure if exists roles_wp_logger
go

create procedure roles_wp_logger /*доступные приложения*/ (
 acursession varchar(38),
 aroles_wpid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles_act_logger
go

create procedure roles_act_logger /*разрешенные пункты меню*/ (
 acursession varchar(38),
 aroles_actid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles_wp_parent
go
create procedure roles_wp_parent /* доступные приложения*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from roles_wp where  roles_wpid=arowid;
 end 
go
GO


drop procedure if exists roles_wp_islocked
go
create procedure roles_wp_islocked /* доступные приложения */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles_wp where roles_wpid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles_wp_lock
go
create procedure roles_wp_lock /* доступные приложения */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles_wp_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles_wp set lockuserid =auserid ,locksessionid=null  where roles_wpid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles_wp set lockuserid=null ,locksessionid =acursession  where roles_wpid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles_wp_unlock
go
create procedure roles_wp_unlock /* доступные приложения */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles_wp_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles_wp set lockuserid =null  where roles_wpid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles_wp set locksessionid =null  where roles_wpid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles_wp_client_trigger
GO

create procedure roles_wp_client_trigger  (
 acursession varchar(38),
 aROLES_WPid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles_act_parent
go
create procedure roles_act_parent /* разрешенные пункты меню*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from roles_act where  roles_actid=arowid;
  set aparenttable = 'roles_wp';
 end 
go
GO


drop procedure if exists roles_act_islocked
go
create procedure roles_act_islocked /* разрешенные пункты меню */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles_act where roles_actid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles_act_lock
go
create procedure roles_act_lock /* разрешенные пункты меню */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles_act_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles_act set lockuserid =auserid ,locksessionid=null  where roles_actid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles_act set lockuserid=null ,locksessionid =acursession  where roles_actid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles_act_unlock
go
create procedure roles_act_unlock /* разрешенные пункты меню */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles_act_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles_act set lockuserid =null  where roles_actid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles_act set locksessionid =null  where roles_actid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles_act_client_trigger
GO

create procedure roles_act_client_trigger  (
 acursession varchar(38),
 aROLES_ACTid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles2_module_brief
go

create procedure roles2_module_brief  (
 acursession varchar(38),
 aroles2_moduleid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles2_moduleid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles2_module where roles2_moduleid=g2b(aroles2_moduleid);
 if  aec &gt;0 then
   set abrief=roles2_module_brief_f(g2b(aroles2_moduleid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles2_module_delete
go

create procedure roles2_module_delete /**/ (
 acursession varchar(38),
 aroles2_moduleid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles2_module where roles2_moduleid=g2b(aroles2_moduleid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles2_module' result;
    leave body;
  end if;
 call roles2_module_logger(acursession,aroles2_moduleid) ; 
  delete from  roles2_module 
  where  roles2_moduleid = g2b(aroles2_moduleid) ;
  delete from num_values where ownerpartname='roles2_module' and ownerrowid=g2b(aroles2_moduleid);
  end if;
    select 'ok' result;
 end 
go
GO

/*модули*/

drop procedure if exists roles2_module_save
go

create procedure roles2_module_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aroles2_moduleid varchar(38)
,agroupname
 varchar (60)/* имя группы *//* имя группы */
,acaption
 varchar (80)/* надпись *//* надпись */
,asequence
 integer/* № п/п *//* № п/п */
,amoduleaccessible
 integer/* разрешен *//* разрешен */
,acustomizevisibility
 integer/* настраивать видимость *//* настраивать видимость */
,atheicon
 varchar (64)/* иконка *//* иконка */
,aname
 varchar (255)/* код модуля *//* код модуля */
,athecomment
 text/* описание *//* описание */
,aallobjects
 integer/* вся фирма *//* вся фирма */
,acolegsobject
 integer/* объекты коллег *//* объекты коллег */
,asubstructobjects
 integer/* подчиненные подразделения *//* подчиненные подразделения */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles2_module where roles2_moduleid=g2b(aroles2_moduleid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles2_module' result;
    leave body;
  end if;
 start transaction ; 
 call roles2_module_logger(acursession,aroles2_moduleid) ; 
 update  roles2_module set changestamp=now()
,
  groupname=agroupname
,
  caption=acaption
,
  sequence=asequence
,
  moduleaccessible=amoduleaccessible
,
  customizevisibility=acustomizevisibility
,
  theicon=atheicon
,
  name=aname
,
  thecomment=athecomment
,
  allobjects=aallobjects
,
  colegsobject=acolegsobject
,
  substructobjects=asubstructobjects
  where  roles2_moduleid = g2b(aroles2_moduleid) ;


call roles2_module_client_trigger(acursession,aroles2_moduleid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles2_module' result;
    leave body;
  end if;
 start transaction;  
 insert into   roles2_module
 (  roles2_moduleid 
,instanceid
,groupname

,caption

,sequence

,moduleaccessible

,customizevisibility

,theicon

,name

,thecomment

,allobjects

,colegsobject

,substructobjects

 ) values ( g2b(aroles2_moduleid) 
,g2b(ainstanceid)
,agroupname

,acaption

,asequence

,amoduleaccessible

,acustomizevisibility

,atheicon

,aname

,athecomment

,aallobjects

,acolegsobject

,asubstructobjects

 ) ;


call roles2_module_client_trigger(acursession,aroles2_moduleid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles2_modreport_brief
go

create procedure roles2_modreport_brief  (
 acursession varchar(38),
 aroles2_modreportid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles2_modreportid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles2_modreport where roles2_modreportid=g2b(aroles2_modreportid);
 if  aec &gt;0 then
   set abrief=roles2_modreport_brief_f(g2b(aroles2_modreportid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles2_modreport_delete
go

create procedure roles2_modreport_delete /**/ (
 acursession varchar(38),
 aroles2_modreportid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles2_modreport where roles2_modreportid=g2b(aroles2_modreportid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles2_modreport' result;
    leave body;
  end if;
 call roles2_modreport_logger(acursession,aroles2_modreportid) ; 
  delete from  roles2_modreport 
  where  roles2_modreportid = g2b(aroles2_modreportid) ;
  delete from num_values where ownerpartname='roles2_modreport' and ownerrowid=g2b(aroles2_modreportid);
  end if;
    select 'ok' result;
 end 
go
GO

/*действия и отчеты*/

drop procedure if exists roles2_modreport_save
go

create procedure roles2_modreport_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aroles2_modreportid varchar(38)
,aname
 varchar (64)/* код *//* код */
,aallowaction
 integer/* разрешен *//* разрешен */
,acaption
 varchar (80)/* надпись *//* надпись */
,asequence
 integer/* № п/п *//* № п/п */
,atheicon
 varchar (64)/* иконка *//* иконка */
,aisreport
 integer/* это отчет *//* это отчет */
,aselecttype
 integer/* вариант выбора *//* вариант выбора */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles2_modreport where roles2_modreportid=g2b(aroles2_modreportid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles2_modreport' result;
    leave body;
  end if;
 start transaction ; 
 call roles2_modreport_logger(acursession,aroles2_modreportid) ; 
 update  roles2_modreport set changestamp=now()
,
  name=aname
,
  allowaction=aallowaction
,
  caption=acaption
,
  sequence=asequence
,
  theicon=atheicon
,
  isreport=aisreport
,
  selecttype=aselecttype
  where  roles2_modreportid = g2b(aroles2_modreportid) ;


call roles2_modreport_client_trigger(acursession,aroles2_modreportid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles2_modreport' result;
    leave body;
  end if;
 start transaction;  
 insert into   roles2_modreport
 (  roles2_modreportid 
,parentstructrowid
,name

,allowaction

,caption

,sequence

,theicon

,isreport

,selecttype

 ) values ( g2b(aroles2_modreportid) 
,g2b(aparentstructrowid)
,aname

,aallowaction

,acaption

,asequence

,atheicon

,aisreport

,aselecttype

 ) ;


call roles2_modreport_client_trigger(acursession,aroles2_modreportid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles2_modreport_copy
go

create procedure roles2_modreport_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles2_modreport 
 ( roles2_modreportid 
,parentstructrowid
,name

,allowaction

,caption

,sequence

,theicon

,isreport

,selecttype

 ) select 
copymap(acopyaction,b2g(roles2_modreportid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,allowaction

,caption

,sequence

,theicon

,isreport

,selecttype

 from roles2_modreport
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists roles2_module_copy
go

create procedure roles2_module_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_roles2_module cursor for
select roles2_moduleid from roles2_module where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles2_module 
 ( roles2_moduleid 
,instanceid
,groupname

,caption

,sequence

,moduleaccessible

,customizevisibility

,theicon

,name

,thecomment

,allobjects

,colegsobject

,substructobjects

 ) select 
copymap(acopyaction,b2g(roles2_moduleid)) 
,copymap(acopyaction,b2g(instanceid))
,groupname

,caption

,sequence

,moduleaccessible

,customizevisibility

,theicon

,name

,thecomment

,allobjects

,colegsobject

,substructobjects

 from roles2_module
 where instanceid =g2b( ainstanceid); 
open copy_cursor_roles2_module;
  set  fetch_done=false;
fetch copy_cursor_roles2_module into aid;
while not fetch_done do 
    call roles2_modreport_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_roles2_module into aid;
end while;

close copy_cursor_roles2_module;
 end 
go
GO


drop procedure if exists roles2_module_logger
go

create procedure roles2_module_logger /**/ (
 acursession varchar(38),
 aroles2_moduleid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles2_modreport_logger
go

create procedure roles2_modreport_logger /**/ (
 acursession varchar(38),
 aroles2_modreportid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles2_module_parent
go
create procedure roles2_module_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from roles2_module where  roles2_moduleid=arowid;
 end 
go
GO


drop procedure if exists roles2_module_islocked
go
create procedure roles2_module_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles2_module where roles2_moduleid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles2_module_lock
go
create procedure roles2_module_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles2_module_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles2_module set lockuserid =auserid ,locksessionid=null  where roles2_moduleid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles2_module set lockuserid=null ,locksessionid =acursession  where roles2_moduleid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles2_module_unlock
go
create procedure roles2_module_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles2_module_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles2_module set lockuserid =null  where roles2_moduleid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles2_module set locksessionid =null  where roles2_moduleid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles2_module_client_trigger
GO

create procedure roles2_module_client_trigger  (
 acursession varchar(38),
 aROLES2_MODULEid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles2_modreport_parent
go
create procedure roles2_modreport_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from roles2_modreport where  roles2_modreportid=arowid;
  set aparenttable = 'roles2_module';
 end 
go
GO


drop procedure if exists roles2_modreport_islocked
go
create procedure roles2_modreport_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles2_modreport where roles2_modreportid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles2_modreport_lock
go
create procedure roles2_modreport_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles2_modreport_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles2_modreport set lockuserid =auserid ,locksessionid=null  where roles2_modreportid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles2_modreport set lockuserid=null ,locksessionid =acursession  where roles2_modreportid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles2_modreport_unlock
go
create procedure roles2_modreport_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles2_modreport_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles2_modreport set lockuserid =null  where roles2_modreportid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles2_modreport set locksessionid =null  where roles2_modreportid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles2_modreport_client_trigger
GO

create procedure roles2_modreport_client_trigger  (
 acursession varchar(38),
 aROLES2_MODREPORTid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles_doc_brief
go

create procedure roles_doc_brief  (
 acursession varchar(38),
 aroles_docid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles_docid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles_doc where roles_docid=g2b(aroles_docid);
 if  aec &gt;0 then
   set abrief=roles_doc_brief_f(g2b(aroles_docid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles_doc_delete
go

create procedure roles_doc_delete /**/ (
 acursession varchar(38),
 aroles_docid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_doc where roles_docid=g2b(aroles_docid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles_doc' result;
    leave body;
  end if;
 call roles_doc_logger(acursession,aroles_docid) ; 
  delete from  roles_doc 
  where  roles_docid = g2b(aroles_docid) ;
  delete from num_values where ownerpartname='roles_doc' and ownerrowid=g2b(aroles_docid);
  end if;
    select 'ok' result;
 end 
go
GO

/*доступные документы*/

drop procedure if exists roles_doc_save
go

create procedure roles_doc_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aroles_docid varchar(38)
,athe_document varchar(38)/* тип документа *//* тип документа */
,athe_denied
 integer/* запрещен *//* запрещен */
,aallowdeletedoc
 integer/* разрешено удаление *//* разрешено удаление */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_doc where roles_docid=g2b(aroles_docid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles_doc' result;
    leave body;
  end if;
 start transaction ; 
 call roles_doc_logger(acursession,aroles_docid) ; 
 update  roles_doc set changestamp=now()
,
  the_document=g2b(athe_document)
,
  the_denied=athe_denied
,
  allowdeletedoc=aallowdeletedoc
  where  roles_docid = g2b(aroles_docid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from roles_doc where  instanceid=g2b(ainstanceid) 
 and the_document=g2b(athe_document);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=доступные документы правило=(сочетание должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_doc_client_trigger(acursession,aroles_docid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles_doc' result;
    leave body;
  end if;
 start transaction;  
 insert into   roles_doc
 (  roles_docid 
,instanceid
,the_document

,the_denied

,allowdeletedoc

 ) values ( g2b(aroles_docid) 
,g2b(ainstanceid)
,g2b(athe_document)

,athe_denied

,aallowdeletedoc

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from roles_doc where  instanceid=g2b(ainstanceid) 
 and the_document=g2b(athe_document);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=доступные документы правило=(сочетание должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_doc_client_trigger(acursession,aroles_docid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles_doc_state_brief
go

create procedure roles_doc_state_brief  (
 acursession varchar(38),
 aroles_doc_stateid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles_doc_stateid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles_doc_state where roles_doc_stateid=g2b(aroles_doc_stateid);
 if  aec &gt;0 then
   set abrief=roles_doc_state_brief_f(g2b(aroles_doc_stateid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles_doc_state_delete
go

create procedure roles_doc_state_delete /**/ (
 acursession varchar(38),
 aroles_doc_stateid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_doc_state where roles_doc_stateid=g2b(aroles_doc_stateid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles_doc_state' result;
    leave body;
  end if;
 call roles_doc_state_logger(acursession,aroles_doc_stateid) ; 
  delete from  roles_doc_state 
  where  roles_doc_stateid = g2b(aroles_doc_stateid) ;
  delete from num_values where ownerpartname='roles_doc_state' and ownerrowid=g2b(aroles_doc_stateid);
  end if;
    select 'ok' result;
 end 
go
GO

/*доступные состояния*/

drop procedure if exists roles_doc_state_save
go

create procedure roles_doc_state_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aroles_doc_stateid varchar(38)
,athe_state varchar(38)/* состояние *//* состояние */
,athe_mode varchar(38)/* режим *//* режим */
,aallowdelete
 integer/* можно удалять *//* можно удалять */
,astatechangedisabled
 integer/* запрещена смена состояния *//* запрещена смена состояния */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_doc_state where roles_doc_stateid=g2b(aroles_doc_stateid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles_doc_state' result;
    leave body;
  end if;
 start transaction ; 
 call roles_doc_state_logger(acursession,aroles_doc_stateid) ; 
 update  roles_doc_state set changestamp=now()
,
  the_state=g2b(athe_state)
,
  the_mode=g2b(athe_mode)
,
  allowdelete=aallowdelete
,
  statechangedisabled=astatechangedisabled
  where  roles_doc_stateid = g2b(aroles_doc_stateid) ;


call roles_doc_state_client_trigger(acursession,aroles_doc_stateid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles_doc_state' result;
    leave body;
  end if;
 start transaction;  
 insert into   roles_doc_state
 (  roles_doc_stateid 
,parentstructrowid
,the_state

,the_mode

,allowdelete

,statechangedisabled

 ) values ( g2b(aroles_doc_stateid) 
,g2b(aparentstructrowid)
,g2b(athe_state)

,g2b(athe_mode)

,aallowdelete

,astatechangedisabled

 ) ;


call roles_doc_state_client_trigger(acursession,aroles_doc_stateid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles_doc_state_copy
go

create procedure roles_doc_state_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles_doc_state 
 ( roles_doc_stateid 
,parentstructrowid
,the_state

,the_mode

,allowdelete

,statechangedisabled

 ) select 
copymap(acopyaction,b2g(roles_doc_stateid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,the_state

,the_mode

,allowdelete

,statechangedisabled

 from roles_doc_state
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists roles_doc_copy
go

create procedure roles_doc_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_roles_doc cursor for
select roles_docid from roles_doc where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles_doc 
 ( roles_docid 
,instanceid
,the_document

,the_denied

,allowdeletedoc

 ) select 
copymap(acopyaction,b2g(roles_docid)) 
,copymap(acopyaction,b2g(instanceid))
,the_document

,the_denied

,allowdeletedoc

 from roles_doc
 where instanceid =g2b( ainstanceid); 
open copy_cursor_roles_doc;
  set  fetch_done=false;
fetch copy_cursor_roles_doc into aid;
while not fetch_done do 
    call roles_doc_state_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_roles_doc into aid;
end while;

close copy_cursor_roles_doc;
 end 
go
GO


drop procedure if exists roles_doc_logger
go

create procedure roles_doc_logger /**/ (
 acursession varchar(38),
 aroles_docid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles_doc_state_logger
go

create procedure roles_doc_state_logger /**/ (
 acursession varchar(38),
 aroles_doc_stateid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles_doc_parent
go
create procedure roles_doc_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from roles_doc where  roles_docid=arowid;
 end 
go
GO


drop procedure if exists roles_doc_islocked
go
create procedure roles_doc_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles_doc where roles_docid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles_doc_lock
go
create procedure roles_doc_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles_doc_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles_doc set lockuserid =auserid ,locksessionid=null  where roles_docid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles_doc set lockuserid=null ,locksessionid =acursession  where roles_docid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles_doc_unlock
go
create procedure roles_doc_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles_doc_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles_doc set lockuserid =null  where roles_docid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles_doc set locksessionid =null  where roles_docid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles_doc_client_trigger
GO

create procedure roles_doc_client_trigger  (
 acursession varchar(38),
 aROLES_DOCid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles_doc_state_parent
go
create procedure roles_doc_state_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from roles_doc_state where  roles_doc_stateid=arowid;
  set aparenttable = 'roles_doc';
 end 
go
GO


drop procedure if exists roles_doc_state_islocked
go
create procedure roles_doc_state_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles_doc_state where roles_doc_stateid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles_doc_state_lock
go
create procedure roles_doc_state_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles_doc_state_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles_doc_state set lockuserid =auserid ,locksessionid=null  where roles_doc_stateid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles_doc_state set lockuserid=null ,locksessionid =acursession  where roles_doc_stateid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles_doc_state_unlock
go
create procedure roles_doc_state_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles_doc_state_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles_doc_state set lockuserid =null  where roles_doc_stateid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles_doc_state set locksessionid =null  where roles_doc_stateid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles_doc_state_client_trigger
GO

create procedure roles_doc_state_client_trigger  (
 acursession varchar(38),
 aROLES_DOC_STATEid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles_reports_brief
go

create procedure roles_reports_brief  (
 acursession varchar(38),
 aroles_reportsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles_reportsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles_reports where roles_reportsid=g2b(aroles_reportsid);
 if  aec &gt;0 then
   set abrief=roles_reports_brief_f(g2b(aroles_reportsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles_reports_delete
go

create procedure roles_reports_delete /**/ (
 acursession varchar(38),
 aroles_reportsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_reports where roles_reportsid=g2b(aroles_reportsid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles_reports' result;
    leave body;
  end if;
 call roles_reports_logger(acursession,aroles_reportsid) ; 
  delete from  roles_reports 
  where  roles_reportsid = g2b(aroles_reportsid) ;
  delete from num_values where ownerpartname='roles_reports' and ownerrowid=g2b(aroles_reportsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*отчёты*/

drop procedure if exists roles_reports_save
go

create procedure roles_reports_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aroles_reportsid varchar(38)
,athe_report varchar(38)/* отчёт *//* отчёт */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_reports where roles_reportsid=g2b(aroles_reportsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles_reports' result;
    leave body;
  end if;
 start transaction ; 
 call roles_reports_logger(acursession,aroles_reportsid) ; 
 update  roles_reports set changestamp=now()
,
  the_report=g2b(athe_report)
  where  roles_reportsid = g2b(aroles_reportsid) ;


call roles_reports_client_trigger(acursession,aroles_reportsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles_reports' result;
    leave body;
  end if;
 start transaction;  
 insert into   roles_reports
 (  roles_reportsid 
,instanceid
,the_report

 ) values ( g2b(aroles_reportsid) 
,g2b(ainstanceid)
,g2b(athe_report)

 ) ;


call roles_reports_client_trigger(acursession,aroles_reportsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles_reports_copy
go

create procedure roles_reports_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles_reports 
 ( roles_reportsid 
,instanceid
,the_report

 ) select 
copymap(acopyaction,b2g(roles_reportsid)) 
,copymap(acopyaction,b2g(instanceid))
,the_report

 from roles_reports
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists roles_reports_logger
go

create procedure roles_reports_logger /**/ (
 acursession varchar(38),
 aroles_reportsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles_reports_parent
go
create procedure roles_reports_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from roles_reports where  roles_reportsid=arowid;
 end 
go
GO


drop procedure if exists roles_reports_islocked
go
create procedure roles_reports_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles_reports where roles_reportsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles_reports_lock
go
create procedure roles_reports_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles_reports_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles_reports set lockuserid =auserid ,locksessionid=null  where roles_reportsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles_reports set lockuserid=null ,locksessionid =acursession  where roles_reportsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles_reports_unlock
go
create procedure roles_reports_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles_reports_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles_reports set lockuserid =null  where roles_reportsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles_reports set locksessionid =null  where roles_reportsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles_reports_client_trigger
GO

create procedure roles_reports_client_trigger  (
 acursession varchar(38),
 aROLES_REPORTSid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles_user_brief
go

create procedure roles_user_brief  (
 acursession varchar(38),
 aroles_userid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles_userid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles_user where roles_userid=g2b(aroles_userid);
 if  aec &gt;0 then
   set abrief=roles_user_brief_f(g2b(aroles_userid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles_user_delete
go

create procedure roles_user_delete /*пользователи*/ (
 acursession varchar(38),
 aroles_userid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_user where roles_userid=g2b(aroles_userid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles_user' result;
    leave body;
  end if;
 call roles_user_logger(acursession,aroles_userid) ; 
  delete from  roles_user 
  where  roles_userid = g2b(aroles_userid) ;
  delete from num_values where ownerpartname='roles_user' and ownerrowid=g2b(aroles_userid);
  end if;
    select 'ok' result;
 end 
go
GO

/*пользователи*/

drop procedure if exists roles_user_save
go

create procedure roles_user_save /*пользователи*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aroles_userid varchar(38)
,atheuser varchar(38)/* пользователь *//* пользователь */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_user where roles_userid=g2b(aroles_userid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles_user' result;
    leave body;
  end if;
 start transaction ; 
 call roles_user_logger(acursession,aroles_userid) ; 
 update  roles_user set changestamp=now()
,
  theuser=g2b(atheuser)
  where  roles_userid = g2b(aroles_userid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from roles_user where  instanceid=g2b(ainstanceid) 
 and theuser=g2b(atheuser);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=пользователи правило=(сочетание должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 select count(*) into  auniquerowcount from roles_user where  instanceid=g2b(ainstanceid) 
 and theuser=g2b(atheuser);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=пользователи правило=(сочетание должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_user_client_trigger(acursession,aroles_userid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles_user' result;
    leave body;
  end if;
 start transaction;  
 insert into   roles_user
 (  roles_userid 
,instanceid
,theuser

 ) values ( g2b(aroles_userid) 
,g2b(ainstanceid)
,g2b(atheuser)

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from roles_user where  instanceid=g2b(ainstanceid) 
 and theuser=g2b(atheuser);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=пользователи правило=(сочетание должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 select count(*) into  auniquerowcount from roles_user where  instanceid=g2b(ainstanceid) 
 and theuser=g2b(atheuser);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=пользователи правило=(сочетание должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_user_client_trigger(acursession,aroles_userid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles_user_copy
go

create procedure roles_user_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles_user 
 ( roles_userid 
,instanceid
,theuser

 ) select 
copymap(acopyaction,b2g(roles_userid)) 
,copymap(acopyaction,b2g(instanceid))
,theuser

 from roles_user
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists roles_user_logger
go

create procedure roles_user_logger /*пользователи*/ (
 acursession varchar(38),
 aroles_userid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles_user_parent
go
create procedure roles_user_parent /* пользователи*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from roles_user where  roles_userid=arowid;
 end 
go
GO


drop procedure if exists roles_user_islocked
go
create procedure roles_user_islocked /* пользователи */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles_user where roles_userid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles_user_lock
go
create procedure roles_user_lock /* пользователи */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles_user_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles_user set lockuserid =auserid ,locksessionid=null  where roles_userid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles_user set lockuserid=null ,locksessionid =acursession  where roles_userid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles_user_unlock
go
create procedure roles_user_unlock /* пользователи */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles_user_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles_user set lockuserid =null  where roles_userid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles_user set locksessionid =null  where roles_userid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles_user_client_trigger
GO

create procedure roles_user_client_trigger  (
 acursession varchar(38),
 aROLES_USERid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles_map_brief
go

create procedure roles_map_brief  (
 acursession varchar(38),
 aroles_mapid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles_mapid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles_map where roles_mapid=g2b(aroles_mapid);
 if  aec &gt;0 then
   set abrief=roles_map_brief_f(g2b(aroles_mapid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles_map_delete
go

create procedure roles_map_delete /*отображение на группы защиты*/ (
 acursession varchar(38),
 aroles_mapid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_map where roles_mapid=g2b(aroles_mapid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles_map' result;
    leave body;
  end if;
 call roles_map_logger(acursession,aroles_mapid) ; 
  delete from  roles_map 
  where  roles_mapid = g2b(aroles_mapid) ;
  delete from num_values where ownerpartname='roles_map' and ownerrowid=g2b(aroles_mapid);
  end if;
    select 'ok' result;
 end 
go
GO

/*отображение на группы*/

drop procedure if exists roles_map_save
go

create procedure roles_map_save /*отображение на группы защиты*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aroles_mapid varchar(38)
,athegroup varchar(38)/* группа *//* группа */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_map where roles_mapid=g2b(aroles_mapid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles_map' result;
    leave body;
  end if;
 start transaction ; 
 call roles_map_logger(acursession,aroles_mapid) ; 
 update  roles_map set changestamp=now()
,
  thegroup=g2b(athegroup)
  where  roles_mapid = g2b(aroles_mapid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from roles_map where  instanceid=g2b(ainstanceid) 
 and thegroup=g2b(athegroup);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=отображение на группы правило=(сочетание должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_map_client_trigger(acursession,aroles_mapid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles_map' result;
    leave body;
  end if;
 start transaction;  
 insert into   roles_map
 (  roles_mapid 
,instanceid
,thegroup

 ) values ( g2b(aroles_mapid) 
,g2b(ainstanceid)
,g2b(athegroup)

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from roles_map where  instanceid=g2b(ainstanceid) 
 and thegroup=g2b(athegroup);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=отображение на группы правило=(сочетание должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_map_client_trigger(acursession,aroles_mapid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles_map_copy
go

create procedure roles_map_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles_map 
 ( roles_mapid 
,instanceid
,thegroup

 ) select 
copymap(acopyaction,b2g(roles_mapid)) 
,copymap(acopyaction,b2g(instanceid))
,thegroup

 from roles_map
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists roles_map_logger
go

create procedure roles_map_logger /*отображение на группы защиты*/ (
 acursession varchar(38),
 aroles_mapid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles_map_parent
go
create procedure roles_map_parent /* отображение на группы защиты*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from roles_map where  roles_mapid=arowid;
 end 
go
GO


drop procedure if exists roles_map_islocked
go
create procedure roles_map_islocked /* отображение на группы защиты */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles_map where roles_mapid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles_map_lock
go
create procedure roles_map_lock /* отображение на группы защиты */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles_map_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles_map set lockuserid =auserid ,locksessionid=null  where roles_mapid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles_map set lockuserid=null ,locksessionid =acursession  where roles_mapid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles_map_unlock
go
create procedure roles_map_unlock /* отображение на группы защиты */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles_map_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles_map set lockuserid =null  where roles_mapid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles_map set locksessionid =null  where roles_mapid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles_map_client_trigger
GO

create procedure roles_map_client_trigger  (
 acursession varchar(38),
 aROLES_MAPid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists roles_def_brief
go

create procedure roles_def_brief  (
 acursession varchar(38),
 aroles_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aroles_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from roles_def where roles_defid=g2b(aroles_defid);
 if  aec &gt;0 then
   set abrief=roles_def_brief_f(g2b(aroles_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists roles_def_delete
go

create procedure roles_def_delete /*определение роли*/ (
 acursession varchar(38),
 aroles_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_def where roles_defid=g2b(aroles_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=roles_def' result;
    leave body;
  end if;
 call roles_def_logger(acursession,aroles_defid) ; 
  delete from  roles_def 
  where  roles_defid = g2b(aroles_defid) ;
  delete from num_values where ownerpartname='roles_def' and ownerrowid=g2b(aroles_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*определение роли*/

drop procedure if exists roles_def_save
go

create procedure roles_def_save /*определение роли*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aroles_defid varchar(38)
,aname
 varchar (255)/* название *//* название */
,aallobjects
 integer/* вся фирма *//* вся фирма */
,acolegsobject
 integer/* объекты коллег *//* объекты коллег */
,asubstructobjects
 integer/* подчиненные подразделения *//* подчиненные подразделения */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from roles_def where roles_defid=g2b(aroles_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=roles_def' result;
    leave body;
  end if;
 start transaction ; 
 call roles_def_logger(acursession,aroles_defid) ; 
 update  roles_def set changestamp=now()
,
  name=aname
,
  allobjects=aallobjects
,
  colegsobject=acolegsobject
,
  substructobjects=asubstructobjects
  where  roles_defid = g2b(aroles_defid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from roles_def where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=определение роли правило=(название роли уникально)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_def_client_trigger(acursession,aroles_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'roles.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=roles_def' result;
    leave body;
  end if;
select count(*) into aec from roles_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;roles_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   roles_def
 (  roles_defid 
,instanceid
,name

,allobjects

,colegsobject

,substructobjects

 ) values ( g2b(aroles_defid) 
,g2b(ainstanceid)
,aname

,aallobjects

,acolegsobject

,asubstructobjects

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from roles_def where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=определение роли правило=(название роли уникально)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call roles_def_client_trigger(acursession,aroles_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists roles_def_copy
go

create procedure roles_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into roles_def 
 ( roles_defid 
,instanceid
,name

,allobjects

,colegsobject

,substructobjects

 ) select 
copymap(acopyaction,b2g(roles_defid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,allobjects

,colegsobject

,substructobjects

 from roles_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists roles_def_logger
go

create procedure roles_def_logger /*определение роли*/ (
 acursession varchar(38),
 aroles_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists roles_def_parent
go
create procedure roles_def_parent /* определение роли*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from roles_def where  roles_defid=arowid;
 end 
go
GO


drop procedure if exists roles_def_islocked
go
create procedure roles_def_islocked /* определение роли */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from roles_def where roles_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists roles_def_lock
go
create procedure roles_def_lock /* определение роли */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call roles_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update roles_def set lockuserid =auserid ,locksessionid=null  where roles_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update roles_def set lockuserid=null ,locksessionid =acursession  where roles_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists roles_def_unlock
go
create procedure roles_def_unlock /* определение роли */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call roles_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update roles_def set lockuserid =null  where roles_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update roles_def set locksessionid =null  where roles_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS roles_def_client_trigger
GO

create procedure roles_def_client_trigger  (
 acursession varchar(38),
 aROLES_DEFid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_urok_ctrl_copy
go

create procedure iu_urok_ctrl_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_urok_ctrl 
 ( iu_urok_ctrlid 
,instanceid
 ) select 
copymap(acopyaction,b2g(iu_urok_ctrlid)) 
,copymap(acopyaction,b2g(instanceid))
 from iu_urok_ctrl
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_urok_docs_brief
go

create procedure iu_urok_docs_brief  (
 acursession varchar(38),
 aiu_urok_docsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_urok_docsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_urok_docs where iu_urok_docsid=g2b(aiu_urok_docsid);
 if  aec &gt;0 then
   set abrief=iu_urok_docs_brief_f(g2b(aiu_urok_docsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_urok_docs_delete
go

create procedure iu_urok_docs_delete /*все текстовые материалы с версиями*/ (
 acursession varchar(38),
 aiu_urok_docsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_docs where iu_urok_docsid=g2b(aiu_urok_docsid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_urok_docs' result;
    leave body;
  end if;
 call iu_urok_docs_logger(acursession,aiu_urok_docsid) ; 
  delete from  iu_urok_docs 
  where  iu_urok_docsid = g2b(aiu_urok_docsid) ;
  delete from num_values where ownerpartname='iu_urok_docs' and ownerrowid=g2b(aiu_urok_docsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*материалы*/

drop procedure if exists iu_urok_docs_save
go

create procedure iu_urok_docs_save /*все текстовые материалы с версиями*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_urok_docsid varchar(38)
,adoctype varchar(38)/* тип документа *//* тип документа */
,aaddby varchar(38)/* кем добавлен *//* кем добавлен */
,aadddate
 datetime/* когда добавлен *//* когда добавлен */
,aversion
 integer/* № версии *//* № версии */
,aactiveversion
 integer/* активная версия *//* активная версия */
,afilereftype varchar(38)/* тип ссылки на файл *//* тип ссылки на файл */
,afileref varchar(255)/* файл */
,afileref_ext varchar(4) /* файл */
,afileurl varchar(255)/* url файла *//* url файла */
,afiletext
 text/* текст документа *//* текст документа */
,ainfo
 varchar (255)/* комментарий *//* комментарий */
,aorigname
 varchar (255)/* оригинальное название *//* оригинальное название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_docs where iu_urok_docsid=g2b(aiu_urok_docsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_urok_docs' result;
    leave body;
  end if;
 start transaction ; 
 call iu_urok_docs_logger(acursession,aiu_urok_docsid) ; 
 update  iu_urok_docs set changestamp=now()
,
  doctype=g2b(adoctype)
,
  addby=g2b(aaddby)
,
  adddate=aadddate
,
  version=aversion
,
  activeversion=aactiveversion
,
  filereftype=g2b(afilereftype)
,
  fileref=afileref
,fileref_ext=
afileref_ext 
,
  fileurl=afileurl
,
  filetext=afiletext
,
  info=ainfo
,
  origname=aorigname
  where  iu_urok_docsid = g2b(aiu_urok_docsid) ;


call iu_urok_docs_client_trigger(acursession,aiu_urok_docsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_urok_docs' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_urok_docs
 (  iu_urok_docsid 
,instanceid
,doctype

,addby

,adddate

,version

,activeversion

,filereftype

,fileref

,fileref_ext
,fileurl

,filetext

,info

,origname

 ) values ( g2b(aiu_urok_docsid) 
,g2b(ainstanceid)
,g2b(adoctype)

,g2b(aaddby)

,aadddate

,aversion

,aactiveversion

,g2b(afilereftype)

,afileref

,afileref_ext
,afileurl

,afiletext

,ainfo

,aorigname

 ) ;


call iu_urok_docs_client_trigger(acursession,aiu_urok_docsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_urok_docs_copy
go

create procedure iu_urok_docs_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_urok_docs 
 ( iu_urok_docsid 
,instanceid
,doctype

,addby

,adddate

,version

,activeversion

,filereftype

,fileref

,fileref_ext
,fileurl

,filetext

,info

,origname

 ) select 
copymap(acopyaction,b2g(iu_urok_docsid)) 
,copymap(acopyaction,b2g(instanceid))
,doctype

,addby

,adddate

,version

,activeversion

,filereftype

,fileref

,fileref_ext
,fileurl

,filetext

,info

,origname

 from iu_urok_docs
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_urok_docs_logger
go

create procedure iu_urok_docs_logger /*все текстовые материалы с версиями*/ (
 acursession varchar(38),
 aiu_urok_docsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_urok_docs_parent
go
create procedure iu_urok_docs_parent /* все текстовые материалы с версиями*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_urok_docs where  iu_urok_docsid=arowid;
 end 
go
GO


drop procedure if exists iu_urok_docs_islocked
go
create procedure iu_urok_docs_islocked /* все текстовые материалы с версиями */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_urok_docs where iu_urok_docsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_urok_docs_lock
go
create procedure iu_urok_docs_lock /* все текстовые материалы с версиями */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_urok_docs_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_urok_docs set lockuserid =auserid ,locksessionid=null  where iu_urok_docsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_urok_docs set lockuserid=null ,locksessionid =acursession  where iu_urok_docsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_urok_docs_unlock
go
create procedure iu_urok_docs_unlock /* все текстовые материалы с версиями */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_urok_docs_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_urok_docs set lockuserid =null  where iu_urok_docsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_urok_docs set locksessionid =null  where iu_urok_docsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_urok_docs_client_trigger
GO

create procedure iu_urok_docs_client_trigger  (
 acursession varchar(38),
 aiu_urok_docsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_urok_creators_brief
go

create procedure iu_urok_creators_brief  (
 acursession varchar(38),
 aiu_urok_creatorsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_urok_creatorsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_urok_creators where iu_urok_creatorsid=g2b(aiu_urok_creatorsid);
 if  aec &gt;0 then
   set abrief=iu_urok_creators_brief_f(g2b(aiu_urok_creatorsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_urok_creators_delete
go

create procedure iu_urok_creators_delete /*исполнители*/ (
 acursession varchar(38),
 aiu_urok_creatorsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_creators where iu_urok_creatorsid=g2b(aiu_urok_creatorsid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_urok_creators' result;
    leave body;
  end if;
 call iu_urok_creators_logger(acursession,aiu_urok_creatorsid) ; 
  delete from  iu_urok_creators 
  where  iu_urok_creatorsid = g2b(aiu_urok_creatorsid) ;
  delete from num_values where ownerpartname='iu_urok_creators' and ownerrowid=g2b(aiu_urok_creatorsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*исполнители*/

drop procedure if exists iu_urok_creators_save
go

create procedure iu_urok_creators_save /*исполнители*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_urok_creatorsid varchar(38)
,aprocessrole varchar(38)/* роль в процессе *//* роль в процессе */
,adoer varchar(38)/* исполнитель *//* исполнитель */
,adoers
 varchar (390)/* группа *//* группа */
,aselectby varchar(38)/* кем был назначен *//* кем был назначен */
,aselectday
 datetime/* дата назначения *//* дата назначения */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_creators where iu_urok_creatorsid=g2b(aiu_urok_creatorsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_urok_creators' result;
    leave body;
  end if;
 start transaction ; 
 call iu_urok_creators_logger(acursession,aiu_urok_creatorsid) ; 
 update  iu_urok_creators set changestamp=now()
,
  processrole=g2b(aprocessrole)
,
  doer=g2b(adoer)
,
  doers=adoers
,
  selectby=g2b(aselectby)
,
  selectday=aselectday
  where  iu_urok_creatorsid = g2b(aiu_urok_creatorsid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from iu_urok_creators where  instanceid=g2b(ainstanceid) 
 and processrole=g2b(aprocessrole);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=исполнители правило=(роль  уникальна в пределах урока)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_urok_creators_client_trigger(acursession,aiu_urok_creatorsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_urok_creators' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_urok_creators
 (  iu_urok_creatorsid 
,instanceid
,processrole

,doer

,doers

,selectby

,selectday

 ) values ( g2b(aiu_urok_creatorsid) 
,g2b(ainstanceid)
,g2b(aprocessrole)

,g2b(adoer)

,adoers

,g2b(aselectby)

,aselectday

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from iu_urok_creators where  instanceid=g2b(ainstanceid) 
 and processrole=g2b(aprocessrole);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=исполнители правило=(роль  уникальна в пределах урока)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_urok_creators_client_trigger(acursession,aiu_urok_creatorsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_urok_creators_copy
go

create procedure iu_urok_creators_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_urok_creators 
 ( iu_urok_creatorsid 
,instanceid
,processrole

,doer

,doers

,selectby

,selectday

 ) select 
copymap(acopyaction,b2g(iu_urok_creatorsid)) 
,copymap(acopyaction,b2g(instanceid))
,processrole

,doer

,doers

,selectby

,selectday

 from iu_urok_creators
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_urok_creators_logger
go

create procedure iu_urok_creators_logger /*исполнители*/ (
 acursession varchar(38),
 aiu_urok_creatorsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_urok_creators_parent
go
create procedure iu_urok_creators_parent /* исполнители*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_urok_creators where  iu_urok_creatorsid=arowid;
 end 
go
GO


drop procedure if exists iu_urok_creators_islocked
go
create procedure iu_urok_creators_islocked /* исполнители */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_urok_creators where iu_urok_creatorsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_urok_creators_lock
go
create procedure iu_urok_creators_lock /* исполнители */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_urok_creators_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_urok_creators set lockuserid =auserid ,locksessionid=null  where iu_urok_creatorsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_urok_creators set lockuserid=null ,locksessionid =acursession  where iu_urok_creatorsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_urok_creators_unlock
go
create procedure iu_urok_creators_unlock /* исполнители */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_urok_creators_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_urok_creators set lockuserid =null  where iu_urok_creatorsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_urok_creators set locksessionid =null  where iu_urok_creatorsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_urok_creators_client_trigger
GO

create procedure iu_urok_creators_client_trigger  (
 acursession varchar(38),
 aiu_urok_creatorsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_urok_def_brief
go

create procedure iu_urok_def_brief  (
 acursession varchar(38),
 aiu_urok_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_urok_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_urok_def where iu_urok_defid=g2b(aiu_urok_defid);
 if  aec &gt;0 then
   set abrief=iu_urok_def_brief_f(g2b(aiu_urok_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_urok_def_delete
go

create procedure iu_urok_def_delete /**/ (
 acursession varchar(38),
 aiu_urok_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_def where iu_urok_defid=g2b(aiu_urok_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_urok_def' result;
    leave body;
  end if;
 call iu_urok_def_logger(acursession,aiu_urok_defid) ; 
  delete from  iu_urok_def 
  where  iu_urok_defid = g2b(aiu_urok_defid) ;
  delete from num_values where ownerpartname='iu_urok_def' and ownerrowid=g2b(aiu_urok_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*описание*/

drop procedure if exists iu_urok_def_save
go

create procedure iu_urok_def_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_urok_defid varchar(38)
,aucode
 varchar (20)/* код урока *//* код урока */
,adatecreated
 datetime/* дата создания *//* дата создания */
,asubject varchar(38)/* предмет *//* предмет */
,atheclassnum varchar(38)/* класс *//* класс */
,aplannum
 varchar (6)/* номер по плану *//* номер по плану */
,amaketown varchar(38)/* город съемки *//* город съемки */
,aactiondate
 date/* дата съемки *//* дата съемки */
,aactiondate2
 date/* дата досъема *//* дата досъема */
,acoursetype varchar(38)/* тип курса *//* тип курса */
,artheme
 varchar (255)/* тема раздела *//* тема раздела */
,aclasstheme
 varchar (255)/* тема урока *//* тема урока */
,athequarter
 integer/* четверть *//* четверть */
,aschooldate varchar(20)/* дата в школе *//* дата в школе */
,acurator varchar(38)/* куратор *//* куратор */
,atheteacher varchar(38)/* учитель *//* учитель */
,amethodist varchar(38)/* методист *//* методист */
,amethodist2 varchar(38)/* методист 2 *//* методист 2 */
,aprocesstype varchar(38)/* тип процесса *//* тип процесса */
,ackksn varchar(38)/* финальный статус *//* финальный статус */
,atestpageref varchar(255)/* тестовая *//* тестовая */
,apubstate varchar(38)/* статус публикации *//* статус публикации */
,amainref varchar(255)/* публикация *//* публикация */
,athefilm varchar(38)/* связанный урок *//* связанный урок */
,athefilmurl varchar(255)/* связ. урок ссылка *//* связ. урок ссылка */
,ainfo
 text/* примечание *//* примечание */
,anotes
 text/* заметки *//* заметки */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_def where iu_urok_defid=g2b(aiu_urok_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_urok_def' result;
    leave body;
  end if;
 start transaction ; 
 call iu_urok_def_logger(acursession,aiu_urok_defid) ; 
 update  iu_urok_def set changestamp=now()
,
  ucode=aucode
,
  datecreated=adatecreated
,
  subject=g2b(asubject)
,
  theclassnum=g2b(atheclassnum)
,
  plannum=aplannum
,
  maketown=g2b(amaketown)
,
  actiondate=aactiondate
,
  actiondate2=aactiondate2
,
  coursetype=g2b(acoursetype)
,
  rtheme=artheme
,
  classtheme=aclasstheme
,
  thequarter=athequarter
,
  schooldate=aschooldate
,
  curator=g2b(acurator)
,
  theteacher=g2b(atheteacher)
,
  methodist=g2b(amethodist)
,
  methodist2=g2b(amethodist2)
,
  processtype=g2b(aprocesstype)
,
  ckksn=g2b(ackksn)
,
  testpageref=atestpageref
,
  pubstate=g2b(apubstate)
,
  mainref=amainref
,
  thefilm=g2b(athefilm)
,
  thefilmurl=athefilmurl
,
  info=ainfo
,
  notes=anotes
  where  iu_urok_defid = g2b(aiu_urok_defid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iu_urok_def where 1=1  
 and theclassnum=g2b(atheclassnum)
 and theteacher=g2b(atheteacher)
 and classtheme=aclasstheme
 and processtype=g2b(aprocesstype);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=описание правило=(тип процесса+ класс+ тема урока + учитель должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_urok_def_client_trigger(acursession,aiu_urok_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_urok_def' result;
    leave body;
  end if;
select count(*) into aec from iu_urok_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_urok_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_urok_def
 (  iu_urok_defid 
,instanceid
,ucode

,datecreated

,subject

,theclassnum

,plannum

,maketown

,actiondate

,actiondate2

,coursetype

,rtheme

,classtheme

,thequarter

,schooldate

,curator

,theteacher

,methodist

,methodist2

,processtype

,ckksn

,testpageref

,pubstate

,mainref

,thefilm

,thefilmurl

,info

,notes

 ) values ( g2b(aiu_urok_defid) 
,g2b(ainstanceid)
,aucode

,adatecreated

,g2b(asubject)

,g2b(atheclassnum)

,aplannum

,g2b(amaketown)

,aactiondate

,aactiondate2

,g2b(acoursetype)

,artheme

,aclasstheme

,athequarter

,aschooldate

,g2b(acurator)

,g2b(atheteacher)

,g2b(amethodist)

,g2b(amethodist2)

,g2b(aprocesstype)

,g2b(ackksn)

,atestpageref

,g2b(apubstate)

,amainref

,g2b(athefilm)

,athefilmurl

,ainfo

,anotes

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iu_urok_def where 1=1  
 and theclassnum=g2b(atheclassnum)
 and theteacher=g2b(atheteacher)
 and classtheme=aclasstheme
 and processtype=g2b(aprocesstype);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=описание правило=(тип процесса+ класс+ тема урока + учитель должно быть уникальным)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_urok_def_client_trigger(acursession,aiu_urok_defid);

 call iu_urok_initownership( acursession,ainstanceid);
 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_urok_def_copy
go

create procedure iu_urok_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_urok_def 
 ( iu_urok_defid 
,instanceid
,ucode

,datecreated

,subject

,theclassnum

,plannum

,maketown

,actiondate

,actiondate2

,coursetype

,rtheme

,classtheme

,thequarter

,schooldate

,curator

,theteacher

,methodist

,methodist2

,processtype

,ckksn

,testpageref

,pubstate

,mainref

,thefilm

,thefilmurl

,info

,notes

 ) select 
copymap(acopyaction,b2g(iu_urok_defid)) 
,copymap(acopyaction,b2g(instanceid))
,ucode

,datecreated

,subject

,theclassnum

,plannum

,maketown

,actiondate

,actiondate2

,coursetype

,rtheme

,classtheme

,thequarter

,schooldate

,curator

,theteacher

,methodist

,methodist2

,processtype

,ckksn

,testpageref

,pubstate

,mainref

,thefilm

,thefilmurl

,info

,notes

 from iu_urok_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_urok_def_logger
go

create procedure iu_urok_def_logger /**/ (
 acursession varchar(38),
 aiu_urok_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_urok_def_parent
go
create procedure iu_urok_def_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_urok_def where  iu_urok_defid=arowid;
 end 
go
GO


drop procedure if exists iu_urok_def_islocked
go
create procedure iu_urok_def_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_urok_def where iu_urok_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_urok_def_lock
go
create procedure iu_urok_def_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_urok_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_urok_def set lockuserid =auserid ,locksessionid=null  where iu_urok_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_urok_def set lockuserid=null ,locksessionid =acursession  where iu_urok_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_urok_def_unlock
go
create procedure iu_urok_def_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_urok_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_urok_def set lockuserid =null  where iu_urok_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_urok_def set locksessionid =null  where iu_urok_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_urok_def_client_trigger
GO

create procedure iu_urok_def_client_trigger  (
 acursession varchar(38),
 aiu_urok_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_urok_video_brief
go

create procedure iu_urok_video_brief  (
 acursession varchar(38),
 aiu_urok_videoid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_urok_videoid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_urok_video where iu_urok_videoid=g2b(aiu_urok_videoid);
 if  aec &gt;0 then
   set abrief=iu_urok_video_brief_f(g2b(aiu_urok_videoid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_urok_video_delete
go

create procedure iu_urok_video_delete /*видеофрагменты к уроку*/ (
 acursession varchar(38),
 aiu_urok_videoid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_video where iu_urok_videoid=g2b(aiu_urok_videoid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_urok_video' result;
    leave body;
  end if;
 call iu_urok_video_logger(acursession,aiu_urok_videoid) ; 
  delete from  iu_urok_video 
  where  iu_urok_videoid = g2b(aiu_urok_videoid) ;
  delete from num_values where ownerpartname='iu_urok_video' and ownerrowid=g2b(aiu_urok_videoid);
  end if;
    select 'ok' result;
 end 
go
GO

/*видеоматериалы*/

drop procedure if exists iu_urok_video_save
go

create procedure iu_urok_video_save /*видеофрагменты к уроку*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_urok_videoid varchar(38)
,aadddate
 datetime/* когда добавлен *//* когда добавлен */
,adoctype varchar(38)/* тип видео *//* тип видео */
,aactiveversion
 integer/* активная версия *//* активная версия */
,aaddby varchar(38)/* кем добавлен *//* кем добавлен */
,aversion
 integer/* № версии *//* № версии */
,afileurl varchar(255)/* url файла *//* url файла */
,afileref varchar(255)/* файл */
,afileref_ext varchar(4) /* файл */
,ainfo
 varchar (255)/* комментарий *//* комментарий */
,anocomments
 integer/* скрыть *//* скрыть */
,aorigname
 varchar (255)/* оригинальное название *//* оригинальное название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_urok_video where iu_urok_videoid=g2b(aiu_urok_videoid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_urok_video' result;
    leave body;
  end if;
 start transaction ; 
 call iu_urok_video_logger(acursession,aiu_urok_videoid) ; 
 update  iu_urok_video set changestamp=now()
,
  adddate=aadddate
,
  doctype=g2b(adoctype)
,
  activeversion=aactiveversion
,
  addby=g2b(aaddby)
,
  version=aversion
,
  fileurl=afileurl
,
  fileref=afileref
,fileref_ext=
afileref_ext 
,
  info=ainfo
,
  nocomments=anocomments
,
  origname=aorigname
  where  iu_urok_videoid = g2b(aiu_urok_videoid) ;


call iu_urok_video_client_trigger(acursession,aiu_urok_videoid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_urok.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_urok_video' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_urok_video
 (  iu_urok_videoid 
,instanceid
,adddate

,doctype

,activeversion

,addby

,version

,fileurl

,fileref

,fileref_ext
,info

,nocomments

,origname

 ) values ( g2b(aiu_urok_videoid) 
,g2b(ainstanceid)
,aadddate

,g2b(adoctype)

,aactiveversion

,g2b(aaddby)

,aversion

,afileurl

,afileref

,afileref_ext
,ainfo

,anocomments

,aorigname

 ) ;


call iu_urok_video_client_trigger(acursession,aiu_urok_videoid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_urok_video_copy
go

create procedure iu_urok_video_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_urok_video 
 ( iu_urok_videoid 
,instanceid
,adddate

,doctype

,activeversion

,addby

,version

,fileurl

,fileref

,fileref_ext
,info

,nocomments

,origname

 ) select 
copymap(acopyaction,b2g(iu_urok_videoid)) 
,copymap(acopyaction,b2g(instanceid))
,adddate

,doctype

,activeversion

,addby

,version

,fileurl

,fileref

,fileref_ext
,info

,nocomments

,origname

 from iu_urok_video
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_urok_video_logger
go

create procedure iu_urok_video_logger /*видеофрагменты к уроку*/ (
 acursession varchar(38),
 aiu_urok_videoid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_urok_video_parent
go
create procedure iu_urok_video_parent /* видеофрагменты к уроку*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_urok_video where  iu_urok_videoid=arowid;
 end 
go
GO


drop procedure if exists iu_urok_video_islocked
go
create procedure iu_urok_video_islocked /* видеофрагменты к уроку */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_urok_video where iu_urok_videoid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_urok_video_lock
go
create procedure iu_urok_video_lock /* видеофрагменты к уроку */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_urok_video_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_urok_video set lockuserid =auserid ,locksessionid=null  where iu_urok_videoid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_urok_video set lockuserid=null ,locksessionid =acursession  where iu_urok_videoid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_urok_video_unlock
go
create procedure iu_urok_video_unlock /* видеофрагменты к уроку */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_urok_video_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_urok_video set lockuserid =null  where iu_urok_videoid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_urok_video set locksessionid =null  where iu_urok_videoid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_urok_video_client_trigger
GO

create procedure iu_urok_video_client_trigger  (
 acursession varchar(38),
 aiu_urok_videoid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_mt_def_brief
go

create procedure iud_mt_def_brief  (
 acursession varchar(38),
 aiud_mt_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_mt_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_mt_def where iud_mt_defid=g2b(aiud_mt_defid);
 if  aec &gt;0 then
   set abrief=iud_mt_def_brief_f(g2b(aiud_mt_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_mt_def_delete
go

create procedure iud_mt_def_delete /*тип сообщения для обсуждений*/ (
 acursession varchar(38),
 aiud_mt_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_mt_def where iud_mt_defid=g2b(aiud_mt_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_mt.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_mt_def' result;
    leave body;
  end if;
 call iud_mt_def_logger(acursession,aiud_mt_defid) ; 
  delete from  iud_mt_def 
  where  iud_mt_defid = g2b(aiud_mt_defid) ;
  delete from num_values where ownerpartname='iud_mt_def' and ownerrowid=g2b(aiud_mt_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип сообщения*/

drop procedure if exists iud_mt_def_save
go

create procedure iud_mt_def_save /*тип сообщения для обсуждений*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_mt_defid varchar(38)
,aname
 varchar (120)/* название *//* название */
,amticon
 varchar (80)/* иконка *//* иконка */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_mt_def where iud_mt_defid=g2b(aiud_mt_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_mt.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_mt_def' result;
    leave body;
  end if;
 start transaction ; 
 call iud_mt_def_logger(acursession,aiud_mt_defid) ; 
 update  iud_mt_def set changestamp=now()
,
  name=aname
,
  mticon=amticon
  where  iud_mt_defid = g2b(aiud_mt_defid) ;


call iud_mt_def_client_trigger(acursession,aiud_mt_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_mt.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_mt_def' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_mt_def
 (  iud_mt_defid 
,instanceid
,name

,mticon

 ) values ( g2b(aiud_mt_defid) 
,g2b(ainstanceid)
,aname

,amticon

 ) ;


call iud_mt_def_client_trigger(acursession,aiud_mt_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_mt_def_copy
go

create procedure iud_mt_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_mt_def 
 ( iud_mt_defid 
,instanceid
,name

,mticon

 ) select 
copymap(acopyaction,b2g(iud_mt_defid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,mticon

 from iud_mt_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_mt_def_logger
go

create procedure iud_mt_def_logger /*тип сообщения для обсуждений*/ (
 acursession varchar(38),
 aiud_mt_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_mt_def_parent
go
create procedure iud_mt_def_parent /* тип сообщения для обсуждений*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_mt_def where  iud_mt_defid=arowid;
 end 
go
GO


drop procedure if exists iud_mt_def_islocked
go
create procedure iud_mt_def_islocked /* тип сообщения для обсуждений */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_mt_def where iud_mt_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_mt_def_lock
go
create procedure iud_mt_def_lock /* тип сообщения для обсуждений */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_mt_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_mt_def set lockuserid =auserid ,locksessionid=null  where iud_mt_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_mt_def set lockuserid=null ,locksessionid =acursession  where iud_mt_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_mt_def_unlock
go
create procedure iud_mt_def_unlock /* тип сообщения для обсуждений */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_mt_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_mt_def set lockuserid =null  where iud_mt_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_mt_def set locksessionid =null  where iud_mt_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_mt_def_client_trigger
GO

create procedure iud_mt_def_client_trigger  (
 acursession varchar(38),
 aiud_mt_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_sn_def_brief
go

create procedure iud_sn_def_brief  (
 acursession varchar(38),
 aiud_sn_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_sn_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_sn_def where iud_sn_defid=g2b(aiud_sn_defid);
 if  aec &gt;0 then
   set abrief=iud_sn_def_brief_f(g2b(aiud_sn_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_sn_def_delete
go

create procedure iud_sn_def_delete /*названия статусов*/ (
 acursession varchar(38),
 aiud_sn_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_sn_def where iud_sn_defid=g2b(aiud_sn_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_sn.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_sn_def' result;
    leave body;
  end if;
 call iud_sn_def_logger(acursession,aiud_sn_defid) ; 
  delete from  iud_sn_def 
  where  iud_sn_defid = g2b(aiud_sn_defid) ;
  delete from num_values where ownerpartname='iud_sn_def' and ownerrowid=g2b(aiud_sn_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*названия статусов*/

drop procedure if exists iud_sn_def_save
go

create procedure iud_sn_def_save /*названия статусов*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_sn_defid varchar(38)
,aname
 varchar (255)/* статус *//* статус */
,asequence
 integer/* порядок вывода *//* порядок вывода */
,aisfinal
 integer/* финальный статус *//* финальный статус */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_sn_def where iud_sn_defid=g2b(aiud_sn_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_sn.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_sn_def' result;
    leave body;
  end if;
 start transaction ; 
 call iud_sn_def_logger(acursession,aiud_sn_defid) ; 
 update  iud_sn_def set changestamp=now()
,
  name=aname
,
  sequence=asequence
,
  isfinal=aisfinal
  where  iud_sn_defid = g2b(aiud_sn_defid) ;


call iud_sn_def_client_trigger(acursession,aiud_sn_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_sn.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_sn_def' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_sn_def
 (  iud_sn_defid 
,instanceid
,name

,sequence

,isfinal

 ) values ( g2b(aiud_sn_defid) 
,g2b(ainstanceid)
,aname

,asequence

,aisfinal

 ) ;


call iud_sn_def_client_trigger(acursession,aiud_sn_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_sn_def_copy
go

create procedure iud_sn_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_sn_def 
 ( iud_sn_defid 
,instanceid
,name

,sequence

,isfinal

 ) select 
copymap(acopyaction,b2g(iud_sn_defid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,sequence

,isfinal

 from iud_sn_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_sn_def_logger
go

create procedure iud_sn_def_logger /*названия статусов*/ (
 acursession varchar(38),
 aiud_sn_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_sn_def_parent
go
create procedure iud_sn_def_parent /* названия статусов*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_sn_def where  iud_sn_defid=arowid;
 end 
go
GO


drop procedure if exists iud_sn_def_islocked
go
create procedure iud_sn_def_islocked /* названия статусов */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_sn_def where iud_sn_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_sn_def_lock
go
create procedure iud_sn_def_lock /* названия статусов */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_sn_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_sn_def set lockuserid =auserid ,locksessionid=null  where iud_sn_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_sn_def set lockuserid=null ,locksessionid =acursession  where iud_sn_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_sn_def_unlock
go
create procedure iud_sn_def_unlock /* названия статусов */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_sn_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_sn_def set lockuserid =null  where iud_sn_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_sn_def set locksessionid =null  where iud_sn_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_sn_def_client_trigger
GO

create procedure iud_sn_def_client_trigger  (
 acursession varchar(38),
 aiud_sn_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_filestoretype_brief
go

create procedure iud_filestoretype_brief  (
 acursession varchar(38),
 aiud_filestoretypeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_filestoretypeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_filestoretype where iud_filestoretypeid=g2b(aiud_filestoretypeid);
 if  aec &gt;0 then
   set abrief=iud_filestoretype_brief_f(g2b(aiud_filestoretypeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_filestoretype_delete
go

create procedure iud_filestoretype_delete /*тип хранения файла*/ (
 acursession varchar(38),
 aiud_filestoretypeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_filestoretype where iud_filestoretypeid=g2b(aiud_filestoretypeid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_fst.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_filestoretype' result;
    leave body;
  end if;
 call iud_filestoretype_logger(acursession,aiud_filestoretypeid) ; 
  delete from  iud_filestoretype 
  where  iud_filestoretypeid = g2b(aiud_filestoretypeid) ;
  delete from num_values where ownerpartname='iud_filestoretype' and ownerrowid=g2b(aiud_filestoretypeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип хранения файла*/

drop procedure if exists iud_filestoretype_save
go

create procedure iud_filestoretype_save /*тип хранения файла*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_filestoretypeid varchar(38)
,aname
 varchar (120)/* название *//* название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_filestoretype where iud_filestoretypeid=g2b(aiud_filestoretypeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_fst.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_filestoretype' result;
    leave body;
  end if;
 start transaction ; 
 call iud_filestoretype_logger(acursession,aiud_filestoretypeid) ; 
 update  iud_filestoretype set changestamp=now()
,
  name=aname
  where  iud_filestoretypeid = g2b(aiud_filestoretypeid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_filestoretype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=тип хранения файла правило=(уникальность для тип хранения файла.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_filestoretype_client_trigger(acursession,aiud_filestoretypeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_fst.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_filestoretype' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_filestoretype
 (  iud_filestoretypeid 
,instanceid
,name

 ) values ( g2b(aiud_filestoretypeid) 
,g2b(ainstanceid)
,aname

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_filestoretype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=тип хранения файла правило=(уникальность для тип хранения файла.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_filestoretype_client_trigger(acursession,aiud_filestoretypeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_filestoretype_copy
go

create procedure iud_filestoretype_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_filestoretype 
 ( iud_filestoretypeid 
,instanceid
,name

 ) select 
copymap(acopyaction,b2g(iud_filestoretypeid)) 
,copymap(acopyaction,b2g(instanceid))
,name

 from iud_filestoretype
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_filestoretype_logger
go

create procedure iud_filestoretype_logger /*тип хранения файла*/ (
 acursession varchar(38),
 aiud_filestoretypeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_filestoretype_parent
go
create procedure iud_filestoretype_parent /* тип хранения файла*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_filestoretype where  iud_filestoretypeid=arowid;
 end 
go
GO


drop procedure if exists iud_filestoretype_islocked
go
create procedure iud_filestoretype_islocked /* тип хранения файла */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_filestoretype where iud_filestoretypeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_filestoretype_lock
go
create procedure iud_filestoretype_lock /* тип хранения файла */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_filestoretype_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_filestoretype set lockuserid =auserid ,locksessionid=null  where iud_filestoretypeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_filestoretype set lockuserid=null ,locksessionid =acursession  where iud_filestoretypeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_filestoretype_unlock
go
create procedure iud_filestoretype_unlock /* тип хранения файла */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_filestoretype_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_filestoretype set lockuserid =null  where iud_filestoretypeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_filestoretype set locksessionid =null  where iud_filestoretypeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_filestoretype_client_trigger
GO

create procedure iud_filestoretype_client_trigger  (
 acursession varchar(38),
 aiud_filestoretypeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_predmet_brief
go

create procedure iud_predmet_brief  (
 acursession varchar(38),
 aiud_predmetid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_predmetid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_predmet where iud_predmetid=g2b(aiud_predmetid);
 if  aec &gt;0 then
   set abrief=iud_predmet_brief_f(g2b(aiud_predmetid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_predmet_delete
go

create procedure iud_predmet_delete /*школьные предметы*/ (
 acursession varchar(38),
 aiud_predmetid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_predmet where iud_predmetid=g2b(aiud_predmetid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_p.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_predmet' result;
    leave body;
  end if;
 call iud_predmet_logger(acursession,aiud_predmetid) ; 
  delete from  iud_predmet 
  where  iud_predmetid = g2b(aiud_predmetid) ;
  delete from num_values where ownerpartname='iud_predmet' and ownerrowid=g2b(aiud_predmetid);
  end if;
    select 'ok' result;
 end 
go
GO

/*предмет*/

drop procedure if exists iud_predmet_save
go

create procedure iud_predmet_save /*школьные предметы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_predmetid varchar(38)
,aname
 varchar (120)/* название *//* название */
,aprefix
 varchar (4)/* префикс *//* префикс */
,apredmeticon
 varchar (80)/* иконка *//* иконка */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_predmet where iud_predmetid=g2b(aiud_predmetid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_p.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_predmet' result;
    leave body;
  end if;
 start transaction ; 
 call iud_predmet_logger(acursession,aiud_predmetid) ; 
 update  iud_predmet set changestamp=now()
,
  name=aname
,
  prefix=aprefix
,
  predmeticon=apredmeticon
  where  iud_predmetid = g2b(aiud_predmetid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_predmet where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=предмет правило=(уникальность для предмет.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_predmet_client_trigger(acursession,aiud_predmetid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_p.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_predmet' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_predmet
 (  iud_predmetid 
,instanceid
,name

,prefix

,predmeticon

 ) values ( g2b(aiud_predmetid) 
,g2b(ainstanceid)
,aname

,aprefix

,apredmeticon

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_predmet where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=предмет правило=(уникальность для предмет.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_predmet_client_trigger(acursession,aiud_predmetid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_predmet_copy
go

create procedure iud_predmet_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_predmet 
 ( iud_predmetid 
,instanceid
,name

,prefix

,predmeticon

 ) select 
copymap(acopyaction,b2g(iud_predmetid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,prefix

,predmeticon

 from iud_predmet
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_predmet_logger
go

create procedure iud_predmet_logger /*школьные предметы*/ (
 acursession varchar(38),
 aiud_predmetid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_predmet_parent
go
create procedure iud_predmet_parent /* школьные предметы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_predmet where  iud_predmetid=arowid;
 end 
go
GO


drop procedure if exists iud_predmet_islocked
go
create procedure iud_predmet_islocked /* школьные предметы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_predmet where iud_predmetid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_predmet_lock
go
create procedure iud_predmet_lock /* школьные предметы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_predmet_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_predmet set lockuserid =auserid ,locksessionid=null  where iud_predmetid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_predmet set lockuserid=null ,locksessionid =acursession  where iud_predmetid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_predmet_unlock
go
create procedure iud_predmet_unlock /* школьные предметы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_predmet_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_predmet set lockuserid =null  where iud_predmetid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_predmet set locksessionid =null  where iud_predmetid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_predmet_client_trigger
GO

create procedure iud_predmet_client_trigger  (
 acursession varchar(38),
 aiud_predmetid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_doctype_brief
go

create procedure iud_doctype_brief  (
 acursession varchar(38),
 aiud_doctypeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_doctypeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_doctype where iud_doctypeid=g2b(aiud_doctypeid);
 if  aec &gt;0 then
   set abrief=iud_doctype_brief_f(g2b(aiud_doctypeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_doctype_delete
go

create procedure iud_doctype_delete /*тип документа*/ (
 acursession varchar(38),
 aiud_doctypeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_doctype where iud_doctypeid=g2b(aiud_doctypeid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_d_doctype.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_doctype' result;
    leave body;
  end if;
 call iud_doctype_logger(acursession,aiud_doctypeid) ; 
  delete from  iud_doctype 
  where  iud_doctypeid = g2b(aiud_doctypeid) ;
  delete from num_values where ownerpartname='iud_doctype' and ownerrowid=g2b(aiud_doctypeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип документа*/

drop procedure if exists iud_doctype_save
go

create procedure iud_doctype_save /*тип документа*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_doctypeid varchar(38)
,asequence
 integer/* порядок вывода *//* порядок вывода */
,aname
 varchar (120)/* название *//* название */
,afiletype varchar(38)/* тип файла *//* тип файла */
,aversionpolicy varchar(38)/* организация версий *//* организация версий */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_doctype where iud_doctypeid=g2b(aiud_doctypeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_d_doctype.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_doctype' result;
    leave body;
  end if;
 start transaction ; 
 call iud_doctype_logger(acursession,aiud_doctypeid) ; 
 update  iud_doctype set changestamp=now()
,
  sequence=asequence
,
  name=aname
,
  filetype=g2b(afiletype)
,
  versionpolicy=g2b(aversionpolicy)
  where  iud_doctypeid = g2b(aiud_doctypeid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_doctype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=тип документа правило=(уникальность для тип документа.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_doctype_client_trigger(acursession,aiud_doctypeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_d_doctype.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_doctype' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_doctype
 (  iud_doctypeid 
,instanceid
,sequence

,name

,filetype

,versionpolicy

 ) values ( g2b(aiud_doctypeid) 
,g2b(ainstanceid)
,asequence

,aname

,g2b(afiletype)

,g2b(aversionpolicy)

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_doctype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=тип документа правило=(уникальность для тип документа.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_doctype_client_trigger(acursession,aiud_doctypeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_doctype_copy
go

create procedure iud_doctype_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_doctype 
 ( iud_doctypeid 
,instanceid
,sequence

,name

,filetype

,versionpolicy

 ) select 
copymap(acopyaction,b2g(iud_doctypeid)) 
,copymap(acopyaction,b2g(instanceid))
,sequence

,name

,filetype

,versionpolicy

 from iud_doctype
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_doctype_logger
go

create procedure iud_doctype_logger /*тип документа*/ (
 acursession varchar(38),
 aiud_doctypeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_doctype_parent
go
create procedure iud_doctype_parent /* тип документа*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_doctype where  iud_doctypeid=arowid;
 end 
go
GO


drop procedure if exists iud_doctype_islocked
go
create procedure iud_doctype_islocked /* тип документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_doctype where iud_doctypeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_doctype_lock
go
create procedure iud_doctype_lock /* тип документа */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_doctype_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_doctype set lockuserid =auserid ,locksessionid=null  where iud_doctypeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_doctype set lockuserid=null ,locksessionid =acursession  where iud_doctypeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_doctype_unlock
go
create procedure iud_doctype_unlock /* тип документа */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_doctype_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_doctype set lockuserid =null  where iud_doctypeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_doctype set locksessionid =null  where iud_doctypeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_doctype_client_trigger
GO

create procedure iud_doctype_client_trigger  (
 acursession varchar(38),
 aiud_doctypeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists users_brief
go

create procedure users_brief  (
 acursession varchar(38),
 ausersid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if ausersid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from users where usersid=g2b(ausersid);
 if  aec &gt;0 then
   set abrief=users_brief_f(g2b(ausersid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists users_delete
go

create procedure users_delete /*пользователи*/ (
 acursession varchar(38),
 ausersid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from users where usersid=g2b(ausersid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=users' result;
    leave body;
  end if;
 call users_logger(acursession,ausersid) ; 
  delete from  users 
  where  usersid = g2b(ausersid) ;
  delete from num_values where ownerpartname='users' and ownerrowid=g2b(ausersid);
  end if;
    select 'ok' result;
 end 
go
GO

/*пользователи*/

drop procedure if exists users_save
go

create procedure users_save /*пользователи*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 ausersid varchar(38)
,afamily
 varchar (255)/* фамилия *//* фамилия */
,aname
 varchar (64)/* имя *//* имя */
,asurname
 varchar (255)/* отчество *//* отчество */
,alogin
 varchar (64)/* имя для входа *//* имя для входа */
,apassword varchar(80)/* пароль *//* пароль */
,adomainame
 varchar (255)/* доменное имя *//* доменное имя */
,aemail varchar(255)/* e-mail *//* e-mail */
,aphone
 varchar (20)/* телефон *//* телефон */
,alocalphone
 varchar (20)/* местный телефон *//* местный телефон */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from users where usersid=g2b(ausersid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=users' result;
    leave body;
  end if;
 start transaction ; 
 call users_logger(acursession,ausersid) ; 
 update  users set changestamp=now()
,
  family=afamily
,
  name=aname
,
  surname=asurname
,
  login=alogin
,
  password=apassword
,
  domainame=adomainame
,
  email=aemail
,
  phone=aphone
,
  localphone=alocalphone
  where  usersid = g2b(ausersid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from users where  instanceid=g2b(ainstanceid) 
 and login=alogin;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=пользователи' result;
  rollback;
  leave body;
end if;
 -- end if;

call users_client_trigger(acursession,ausersid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=users' result;
    leave body;
  end if;
 start transaction;  
 insert into   users
 (  usersid 
,instanceid
,family

,name

,surname

,login

,password

,domainame

,email

,phone

,localphone

 ) values ( g2b(ausersid) 
,g2b(ainstanceid)
,afamily

,aname

,asurname

,alogin

,apassword

,adomainame

,aemail

,aphone

,alocalphone

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from users where  instanceid=g2b(ainstanceid) 
 and login=alogin;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=пользователи' result;
  rollback;
  leave body;
end if;
 -- end if;

call users_client_trigger(acursession,ausersid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists users_copy
go

create procedure users_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into users 
 ( usersid 
,instanceid
,family

,name

,surname

,login

,password

,domainame

,email

,phone

,localphone

 ) select 
copymap(acopyaction,b2g(usersid)) 
,copymap(acopyaction,b2g(instanceid))
,family

,name

,surname

,login

,password

,domainame

,email

,phone

,localphone

 from users
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists users_logger
go

create procedure users_logger /*пользователи*/ (
 acursession varchar(38),
 ausersid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists users_parent
go
create procedure users_parent /* пользователи*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from users where  usersid=arowid;
 end 
go
GO


drop procedure if exists users_islocked
go
create procedure users_islocked /* пользователи */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from users where usersid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists users_lock
go
create procedure users_lock /* пользователи */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call users_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update users set lockuserid =auserid ,locksessionid=null  where usersid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update users set lockuserid=null ,locksessionid =acursession  where usersid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists users_unlock
go
create procedure users_unlock /* пользователи */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call users_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update users set lockuserid =null  where usersid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update users set locksessionid =null  where usersid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS users_client_trigger
GO

create procedure users_client_trigger  (
 acursession varchar(38),
 aUsersid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists groups_brief
go

create procedure groups_brief  (
 acursession varchar(38),
 agroupsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if agroupsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from groups where groupsid=g2b(agroupsid);
 if  aec &gt;0 then
   set abrief=groups_brief_f(g2b(agroupsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists groups_delete
go

create procedure groups_delete /*группы*/ (
 acursession varchar(38),
 agroupsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from groups where groupsid=g2b(agroupsid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=groups' result;
    leave body;
  end if;
 call groups_logger(acursession,agroupsid) ; 
  delete from  groups 
  where  groupsid = g2b(agroupsid) ;
  delete from num_values where ownerpartname='groups' and ownerrowid=g2b(agroupsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*группы*/

drop procedure if exists groups_save
go

create procedure groups_save /*группы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 agroupsid varchar(38)
,aname
 varchar (80)/* название *//* название */
,aadgroup
 varchar (255)/* группа ad *//* группа ad */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from groups where groupsid=g2b(agroupsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=groups' result;
    leave body;
  end if;
 start transaction ; 
 call groups_logger(acursession,agroupsid) ; 
 update  groups set changestamp=now()
,
  name=aname
,
  adgroup=aadgroup
  where  groupsid = g2b(agroupsid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from groups where  instanceid=g2b(ainstanceid) 
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=группы' result;
  rollback;
  leave body;
end if;
 -- end if;

call groups_client_trigger(acursession,agroupsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=groups' result;
    leave body;
  end if;
 start transaction;  
 insert into   groups
 (  groupsid 
,instanceid
,name

,adgroup

 ) values ( g2b(agroupsid) 
,g2b(ainstanceid)
,aname

,aadgroup

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from groups where  instanceid=g2b(ainstanceid) 
 and name=aname;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=группы' result;
  rollback;
  leave body;
end if;
 -- end if;

call groups_client_trigger(acursession,agroupsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists groupuser_brief
go

create procedure groupuser_brief  (
 acursession varchar(38),
 agroupuserid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if agroupuserid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from groupuser where groupuserid=g2b(agroupuserid);
 if  aec &gt;0 then
   set abrief=groupuser_brief_f(g2b(agroupuserid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists groupuser_delete
go

create procedure groupuser_delete /*состав группы*/ (
 acursession varchar(38),
 agroupuserid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from groupuser where groupuserid=g2b(agroupuserid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=groupuser' result;
    leave body;
  end if;
 call groupuser_logger(acursession,agroupuserid) ; 
  delete from  groupuser 
  where  groupuserid = g2b(agroupuserid) ;
  delete from num_values where ownerpartname='groupuser' and ownerrowid=g2b(agroupuserid);
  end if;
    select 'ok' result;
 end 
go
GO

/*состав группы*/

drop procedure if exists groupuser_save
go

create procedure groupuser_save /*состав группы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 agroupuserid varchar(38)
,atheuser varchar(38)/* пользователь *//* пользователь */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from groupuser where groupuserid=g2b(agroupuserid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=groupuser' result;
    leave body;
  end if;
 start transaction ; 
 call groupuser_logger(acursession,agroupuserid) ; 
 update  groupuser set changestamp=now()
,
  theuser=g2b(atheuser)
  where  groupuserid = g2b(agroupuserid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from groupuser where  parentstructrowid=g2b(aparentstructrowid) 
 and theuser=g2b(atheuser);
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=состав группы' result;
  rollback;
  leave body;
end if;
 -- end if;

call groupuser_client_trigger(acursession,agroupuserid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzusers.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=groupuser' result;
    leave body;
  end if;
 start transaction;  
 insert into   groupuser
 (  groupuserid 
,parentstructrowid
,theuser

 ) values ( g2b(agroupuserid) 
,g2b(aparentstructrowid)
,g2b(atheuser)

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from groupuser where  parentstructrowid=g2b(aparentstructrowid) 
 and theuser=g2b(atheuser);
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=состав группы' result;
  rollback;
  leave body;
end if;
 -- end if;

call groupuser_client_trigger(acursession,agroupuserid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists groupuser_copy
go

create procedure groupuser_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into groupuser 
 ( groupuserid 
,parentstructrowid
,theuser

 ) select 
copymap(acopyaction,b2g(groupuserid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,theuser

 from groupuser
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists groups_copy
go

create procedure groups_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_groups cursor for
select groupsid from groups where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into groups 
 ( groupsid 
,instanceid
,name

,adgroup

 ) select 
copymap(acopyaction,b2g(groupsid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,adgroup

 from groups
 where instanceid =g2b( ainstanceid); 
open copy_cursor_groups;
  set  fetch_done=false;
fetch copy_cursor_groups into aid;
while not fetch_done do 
    call groupuser_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_groups into aid;
end while;

close copy_cursor_groups;
 end 
go
GO


drop procedure if exists groups_logger
go

create procedure groups_logger /*группы*/ (
 acursession varchar(38),
 agroupsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists groupuser_logger
go

create procedure groupuser_logger /*состав группы*/ (
 acursession varchar(38),
 agroupuserid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists groups_parent
go
create procedure groups_parent /* группы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from groups where  groupsid=arowid;
 end 
go
GO


drop procedure if exists groups_islocked
go
create procedure groups_islocked /* группы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from groups where groupsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists groups_lock
go
create procedure groups_lock /* группы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call groups_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update groups set lockuserid =auserid ,locksessionid=null  where groupsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update groups set lockuserid=null ,locksessionid =acursession  where groupsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists groups_unlock
go
create procedure groups_unlock /* группы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call groups_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update groups set lockuserid =null  where groupsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update groups set locksessionid =null  where groupsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS groups_client_trigger
GO

create procedure groups_client_trigger  (
 acursession varchar(38),
 aGroupsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists groupuser_parent
go
create procedure groupuser_parent /* состав группы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from groupuser where  groupuserid=arowid;
  set aparenttable = 'groups';
 end 
go
GO


drop procedure if exists groupuser_islocked
go
create procedure groupuser_islocked /* состав группы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from groupuser where groupuserid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists groupuser_lock
go
create procedure groupuser_lock /* состав группы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call groupuser_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update groupuser set lockuserid =auserid ,locksessionid=null  where groupuserid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update groupuser set lockuserid=null ,locksessionid =acursession  where groupuserid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists groupuser_unlock
go
create procedure groupuser_unlock /* состав группы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call groupuser_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update groupuser set lockuserid =null  where groupuserid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update groupuser set locksessionid =null  where groupuserid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS groupuser_client_trigger
GO

create procedure groupuser_client_trigger  (
 acursession varchar(38),
 aGroupUserid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_clsinfo_brief
go

create procedure iu_clsinfo_brief  (
 acursession varchar(38),
 aiu_clsinfoid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_clsinfoid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_clsinfo where iu_clsinfoid=g2b(aiu_clsinfoid);
 if  aec &gt;0 then
   set abrief=iu_clsinfo_brief_f(g2b(aiu_clsinfoid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_clsinfo_delete
go

create procedure iu_clsinfo_delete /*номера классов*/ (
 acursession varchar(38),
 aiu_clsinfoid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_clsinfo where iu_clsinfoid=g2b(aiu_clsinfoid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_cls.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_clsinfo' result;
    leave body;
  end if;
 call iu_clsinfo_logger(acursession,aiu_clsinfoid) ; 
  delete from  iu_clsinfo 
  where  iu_clsinfoid = g2b(aiu_clsinfoid) ;
  delete from num_values where ownerpartname='iu_clsinfo' and ownerrowid=g2b(aiu_clsinfoid);
  end if;
    select 'ok' result;
 end 
go
GO

/*класс*/

drop procedure if exists iu_clsinfo_save
go

create procedure iu_clsinfo_save /*номера классов*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_clsinfoid varchar(38)
,aname
 varchar (10)/* класс *//* класс */
,asequence
 integer/* порядок вывода *//* порядок вывода */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_clsinfo where iu_clsinfoid=g2b(aiu_clsinfoid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_cls.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_clsinfo' result;
    leave body;
  end if;
 start transaction ; 
 call iu_clsinfo_logger(acursession,aiu_clsinfoid) ; 
 update  iu_clsinfo set changestamp=now()
,
  name=aname
,
  sequence=asequence
  where  iu_clsinfoid = g2b(aiu_clsinfoid) ;


call iu_clsinfo_client_trigger(acursession,aiu_clsinfoid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_cls.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_clsinfo' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_clsinfo
 (  iu_clsinfoid 
,instanceid
,name

,sequence

 ) values ( g2b(aiu_clsinfoid) 
,g2b(ainstanceid)
,aname

,asequence

 ) ;


call iu_clsinfo_client_trigger(acursession,aiu_clsinfoid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_clsinfo_copy
go

create procedure iu_clsinfo_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_clsinfo 
 ( iu_clsinfoid 
,instanceid
,name

,sequence

 ) select 
copymap(acopyaction,b2g(iu_clsinfoid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,sequence

 from iu_clsinfo
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_clsinfo_logger
go

create procedure iu_clsinfo_logger /*номера классов*/ (
 acursession varchar(38),
 aiu_clsinfoid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_clsinfo_parent
go
create procedure iu_clsinfo_parent /* номера классов*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_clsinfo where  iu_clsinfoid=arowid;
 end 
go
GO


drop procedure if exists iu_clsinfo_islocked
go
create procedure iu_clsinfo_islocked /* номера классов */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_clsinfo where iu_clsinfoid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_clsinfo_lock
go
create procedure iu_clsinfo_lock /* номера классов */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_clsinfo_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_clsinfo set lockuserid =auserid ,locksessionid=null  where iu_clsinfoid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_clsinfo set lockuserid=null ,locksessionid =acursession  where iu_clsinfoid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_clsinfo_unlock
go
create procedure iu_clsinfo_unlock /* номера классов */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_clsinfo_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_clsinfo set lockuserid =null  where iu_clsinfoid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_clsinfo set locksessionid =null  where iu_clsinfoid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_clsinfo_client_trigger
GO

create procedure iu_clsinfo_client_trigger  (
 acursession varchar(38),
 aiu_clsinfoid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists num_zones_brief
go

create procedure num_zones_brief  (
 acursession varchar(38),
 anum_zonesid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if anum_zonesid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from num_zones where num_zonesid=g2b(anum_zonesid);
 if  aec &gt;0 then
   set abrief=num_zones_brief_f(g2b(anum_zonesid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists num_zones_delete
go

create procedure num_zones_delete /*зоны уникальных нумеров*/ (
 acursession varchar(38),
 anum_zonesid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from num_zones where num_zonesid=g2b(anum_zonesid);
if aec&gt;0 then
 select checkoperation( acursession ,'stdnumerator.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=num_zones' result;
    leave body;
  end if;
 call num_zones_logger(acursession,anum_zonesid) ; 
  delete from  num_zones 
  where  num_zonesid = g2b(anum_zonesid) ;
  delete from num_values where ownerpartname='num_zones' and ownerrowid=g2b(anum_zonesid);
  end if;
    select 'ok' result;
 end 
go
GO

/*зоны*/

drop procedure if exists num_zones_save
go

create procedure num_zones_save /*зоны уникальных нумеров*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 anum_zonesid varchar(38)
,azonemask
 varchar (255)/* маска зоны *//* маска зоны */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from num_zones where num_zonesid=g2b(anum_zonesid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'stdnumerator.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=num_zones' result;
    leave body;
  end if;
 start transaction ; 
 call num_zones_logger(acursession,anum_zonesid) ; 
 update  num_zones set changestamp=now()
,
  zonemask=azonemask
  where  num_zonesid = g2b(anum_zonesid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from num_zones where  instanceid=g2b(ainstanceid) 
 and zonemask=azonemask;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=зоны' result;
  rollback;
  leave body;
end if;
 -- end if;

call num_zones_client_trigger(acursession,anum_zonesid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'stdnumerator.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=num_zones' result;
    leave body;
  end if;
 start transaction;  
 insert into   num_zones
 (  num_zonesid 
,instanceid
,zonemask

 ) values ( g2b(anum_zonesid) 
,g2b(ainstanceid)
,azonemask

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from num_zones where  instanceid=g2b(ainstanceid) 
 and zonemask=azonemask;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=зоны' result;
  rollback;
  leave body;
end if;
 -- end if;

call num_zones_client_trigger(acursession,anum_zonesid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists num_values_brief
go

create procedure num_values_brief  (
 acursession varchar(38),
 anum_valuesid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if anum_valuesid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from num_values where num_valuesid=g2b(anum_valuesid);
 if  aec &gt;0 then
   set abrief=num_values_brief_f(g2b(anum_valuesid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists num_values_delete
go

create procedure num_values_delete /*уникальные номера*/ (
 acursession varchar(38),
 anum_valuesid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from num_values where num_valuesid=g2b(anum_valuesid);
if aec&gt;0 then
 select checkoperation( acursession ,'stdnumerator.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=num_values' result;
    leave body;
  end if;
 call num_values_logger(acursession,anum_valuesid) ; 
  delete from  num_values 
  where  num_valuesid = g2b(anum_valuesid) ;
  delete from num_values where ownerpartname='num_values' and ownerrowid=g2b(anum_valuesid);
  end if;
    select 'ok' result;
 end 
go
GO

/*номера*/

drop procedure if exists num_values_save
go

create procedure num_values_save /*уникальные номера*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 anum_valuesid varchar(38)
,athe_value
 integer/* значение *//* значение */
,aownerpartname
 varchar (64)/* раздел *//* раздел */
,aownerrowid binary(16)/* идентификатор строки *//* идентификатор строки */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from num_values where num_valuesid=g2b(anum_valuesid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'stdnumerator.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=num_values' result;
    leave body;
  end if;
 start transaction ; 
 call num_values_logger(acursession,anum_valuesid) ; 
 update  num_values set changestamp=now()
,
  the_value=athe_value
,
  ownerpartname=aownerpartname
,
  ownerrowid=aownerrowid
  where  num_valuesid = g2b(anum_valuesid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from num_values where  parentstructrowid=g2b(aparentstructrowid) 
 and the_value=athe_value;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=номера' result;
  rollback;
  leave body;
end if;
 -- end if;

call num_values_client_trigger(acursession,anum_valuesid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'stdnumerator.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=num_values' result;
    leave body;
  end if;
 start transaction;  
 insert into   num_values
 (  num_valuesid 
,parentstructrowid
,the_value

,ownerpartname

,ownerrowid

 ) values ( g2b(anum_valuesid) 
,g2b(aparentstructrowid)
,athe_value

,aownerpartname

,aownerrowid

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from num_values where  parentstructrowid=g2b(aparentstructrowid) 
 and the_value=athe_value;
if auniquerowcount&gt;=2 then
 select 'нарущение уникальности сочетания полей. раздел=номера' result;
  rollback;
  leave body;
end if;
 -- end if;

call num_values_client_trigger(acursession,anum_valuesid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists num_values_copy
go

create procedure num_values_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into num_values 
 ( num_valuesid 
,parentstructrowid
,the_value

,ownerpartname

,ownerrowid

 ) select 
copymap(acopyaction,b2g(num_valuesid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,the_value

,ownerpartname

,ownerrowid

 from num_values
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists num_zones_copy
go

create procedure num_zones_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_num_zones cursor for
select num_zonesid from num_zones where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into num_zones 
 ( num_zonesid 
,instanceid
,zonemask

 ) select 
copymap(acopyaction,b2g(num_zonesid)) 
,copymap(acopyaction,b2g(instanceid))
,zonemask

 from num_zones
 where instanceid =g2b( ainstanceid); 
open copy_cursor_num_zones;
  set  fetch_done=false;
fetch copy_cursor_num_zones into aid;
while not fetch_done do 
    call num_values_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_num_zones into aid;
end while;

close copy_cursor_num_zones;
 end 
go
GO


drop procedure if exists num_zones_logger
go

create procedure num_zones_logger /*зоны уникальных нумеров*/ (
 acursession varchar(38),
 anum_zonesid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists num_values_logger
go

create procedure num_values_logger /*уникальные номера*/ (
 acursession varchar(38),
 anum_valuesid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists num_zones_parent
go
create procedure num_zones_parent /* зоны уникальных нумеров*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from num_zones where  num_zonesid=arowid;
 end 
go
GO


drop procedure if exists num_zones_islocked
go
create procedure num_zones_islocked /* зоны уникальных нумеров */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from num_zones where num_zonesid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists num_zones_lock
go
create procedure num_zones_lock /* зоны уникальных нумеров */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call num_zones_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update num_zones set lockuserid =auserid ,locksessionid=null  where num_zonesid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update num_zones set lockuserid=null ,locksessionid =acursession  where num_zonesid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists num_zones_unlock
go
create procedure num_zones_unlock /* зоны уникальных нумеров */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call num_zones_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update num_zones set lockuserid =null  where num_zonesid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update num_zones set locksessionid =null  where num_zonesid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS num_zones_client_trigger
GO

create procedure num_zones_client_trigger  (
 acursession varchar(38),
 aNum_zonesid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists num_values_parent
go
create procedure num_values_parent /* уникальные номера*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from num_values where  num_valuesid=arowid;
  set aparenttable = 'num_zones';
 end 
go
GO


drop procedure if exists num_values_islocked
go
create procedure num_values_islocked /* уникальные номера */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from num_values where num_valuesid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists num_values_lock
go
create procedure num_values_lock /* уникальные номера */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call num_values_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update num_values set lockuserid =auserid ,locksessionid=null  where num_valuesid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update num_values set lockuserid=null ,locksessionid =acursession  where num_valuesid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists num_values_unlock
go
create procedure num_values_unlock /* уникальные номера */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call num_values_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update num_values set lockuserid =null  where num_valuesid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update num_values set locksessionid =null  where num_valuesid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS num_values_client_trigger
GO

create procedure num_values_client_trigger  (
 acursession varchar(38),
 aNum_Valuesid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists num_head_brief
go

create procedure num_head_brief  (
 acursession varchar(38),
 anum_headid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if anum_headid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from num_head where num_headid=g2b(anum_headid);
 if  aec &gt;0 then
   set abrief=num_head_brief_f(g2b(anum_headid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists num_head_delete
go

create procedure num_head_delete /*описание нумератора*/ (
 acursession varchar(38),
 anum_headid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from num_head where num_headid=g2b(anum_headid);
if aec&gt;0 then
 select checkoperation( acursession ,'stdnumerator.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=num_head' result;
    leave body;
  end if;
 call num_head_logger(acursession,anum_headid) ; 
  delete from  num_head 
  where  num_headid = g2b(anum_headid) ;
  delete from num_values where ownerpartname='num_head' and ownerrowid=g2b(anum_headid);
  end if;
    select 'ok' result;
 end 
go
GO

/*описание*/

drop procedure if exists num_head_save
go

create procedure num_head_save /*описание нумератора*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 anum_headid varchar(38)
,aname
 varchar (80)/* название *//* название */
,ashema
 integer/* схема нумерации *//* схема нумерации */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from num_head where num_headid=g2b(anum_headid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'stdnumerator.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=num_head' result;
    leave body;
  end if;
 start transaction ; 
 call num_head_logger(acursession,anum_headid) ; 
 update  num_head set changestamp=now()
,
  name=aname
,
  shema=ashema
  where  num_headid = g2b(anum_headid) ;


call num_head_client_trigger(acursession,anum_headid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'stdnumerator.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=num_head' result;
    leave body;
  end if;
select count(*) into aec from num_head where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;num_head&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   num_head
 (  num_headid 
,instanceid
,name

,shema

 ) values ( g2b(anum_headid) 
,g2b(ainstanceid)
,aname

,ashema

 ) ;


call num_head_client_trigger(acursession,anum_headid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists num_head_copy
go

create procedure num_head_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into num_head 
 ( num_headid 
,instanceid
,name

,shema

 ) select 
copymap(acopyaction,b2g(num_headid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,shema

 from num_head
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists num_head_logger
go

create procedure num_head_logger /*описание нумератора*/ (
 acursession varchar(38),
 anum_headid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists num_head_parent
go
create procedure num_head_parent /* описание нумератора*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from num_head where  num_headid=arowid;
 end 
go
GO


drop procedure if exists num_head_islocked
go
create procedure num_head_islocked /* описание нумератора */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from num_head where num_headid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists num_head_lock
go
create procedure num_head_lock /* описание нумератора */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call num_head_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update num_head set lockuserid =auserid ,locksessionid=null  where num_headid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update num_head set lockuserid=null ,locksessionid =acursession  where num_headid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists num_head_unlock
go
create procedure num_head_unlock /* описание нумератора */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call num_head_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update num_head set lockuserid =null  where num_headid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update num_head set locksessionid =null  where num_headid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS num_head_client_trigger
GO

create procedure num_head_client_trigger  (
 acursession varchar(38),
 aNum_headid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_filetype_brief
go

create procedure iud_filetype_brief  (
 acursession varchar(38),
 aiud_filetypeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_filetypeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_filetype where iud_filetypeid=g2b(aiud_filetypeid);
 if  aec &gt;0 then
   set abrief=iud_filetype_brief_f(g2b(aiud_filetypeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_filetype_delete
go

create procedure iud_filetype_delete /*тип файла ( текст, видео и т.п.)*/ (
 acursession varchar(38),
 aiud_filetypeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_filetype where iud_filetypeid=g2b(aiud_filetypeid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_ft.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_filetype' result;
    leave body;
  end if;
 call iud_filetype_logger(acursession,aiud_filetypeid) ; 
  delete from  iud_filetype 
  where  iud_filetypeid = g2b(aiud_filetypeid) ;
  delete from num_values where ownerpartname='iud_filetype' and ownerrowid=g2b(aiud_filetypeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип файла*/

drop procedure if exists iud_filetype_save
go

create procedure iud_filetype_save /*тип файла ( текст, видео и т.п.)*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_filetypeid varchar(38)
,aname
 varchar (120)/* название *//* название */
,aallowtiming
 integer/* возможен тайминг *//* возможен тайминг */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_filetype where iud_filetypeid=g2b(aiud_filetypeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_ft.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_filetype' result;
    leave body;
  end if;
 start transaction ; 
 call iud_filetype_logger(acursession,aiud_filetypeid) ; 
 update  iud_filetype set changestamp=now()
,
  name=aname
,
  allowtiming=aallowtiming
  where  iud_filetypeid = g2b(aiud_filetypeid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_filetype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=тип файла правило=(уникальность для тип файла.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_filetype_client_trigger(acursession,aiud_filetypeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_ft.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_filetype' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_filetype
 (  iud_filetypeid 
,instanceid
,name

,allowtiming

 ) values ( g2b(aiud_filetypeid) 
,g2b(ainstanceid)
,aname

,aallowtiming

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_filetype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=тип файла правило=(уникальность для тип файла.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_filetype_client_trigger(acursession,aiud_filetypeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_filetype_copy
go

create procedure iud_filetype_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_filetype 
 ( iud_filetypeid 
,instanceid
,name

,allowtiming

 ) select 
copymap(acopyaction,b2g(iud_filetypeid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,allowtiming

 from iud_filetype
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_filetype_logger
go

create procedure iud_filetype_logger /*тип файла ( текст, видео и т.п.)*/ (
 acursession varchar(38),
 aiud_filetypeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_filetype_parent
go
create procedure iud_filetype_parent /* тип файла ( текст, видео и т.п.)*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_filetype where  iud_filetypeid=arowid;
 end 
go
GO


drop procedure if exists iud_filetype_islocked
go
create procedure iud_filetype_islocked /* тип файла ( текст, видео и т.п.) */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_filetype where iud_filetypeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_filetype_lock
go
create procedure iud_filetype_lock /* тип файла ( текст, видео и т.п.) */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_filetype_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_filetype set lockuserid =auserid ,locksessionid=null  where iud_filetypeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_filetype set lockuserid=null ,locksessionid =acursession  where iud_filetypeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_filetype_unlock
go
create procedure iud_filetype_unlock /* тип файла ( текст, видео и т.п.) */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_filetype_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_filetype set lockuserid =null  where iud_filetypeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_filetype set locksessionid =null  where iud_filetypeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_filetype_client_trigger
GO

create procedure iud_filetype_client_trigger  (
 acursession varchar(38),
 aiud_filetypeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists mtzext_def_brief
go

create procedure mtzext_def_brief  (
 acursession varchar(38),
 amtzext_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if amtzext_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from mtzext_def where mtzext_defid=g2b(amtzext_defid);
 if  aec &gt;0 then
   set abrief=mtzext_def_brief_f(g2b(amtzext_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists mtzext_def_delete
go

create procedure mtzext_def_delete /*список зарегистрированных расширений*/ (
 acursession varchar(38),
 amtzext_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from mtzext_def where mtzext_defid=g2b(amtzext_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzext.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=mtzext_def' result;
    leave body;
  end if;
 call mtzext_def_logger(acursession,amtzext_defid) ; 
  delete from  mtzext_def 
  where  mtzext_defid = g2b(amtzext_defid) ;
  delete from num_values where ownerpartname='mtzext_def' and ownerrowid=g2b(amtzext_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*описание*/

drop procedure if exists mtzext_def_save
go

create procedure mtzext_def_save /*список зарегистрированных расширений*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 amtzext_defid varchar(38)
,aname
 varchar (255)/* название *//* название */
,aexttype
 integer/* тип расширения *//* тип расширения */
,athedescription
 text/* описание *//* описание */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from mtzext_def where mtzext_defid=g2b(amtzext_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzext.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=mtzext_def' result;
    leave body;
  end if;
 start transaction ; 
 call mtzext_def_logger(acursession,amtzext_defid) ; 
 update  mtzext_def set changestamp=now()
,
  name=aname
,
  exttype=aexttype
,
  thedescription=athedescription
  where  mtzext_defid = g2b(amtzext_defid) ;


call mtzext_def_client_trigger(acursession,amtzext_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzext.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=mtzext_def' result;
    leave body;
  end if;
select count(*) into aec from mtzext_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;mtzext_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   mtzext_def
 (  mtzext_defid 
,instanceid
,name

,exttype

,thedescription

 ) values ( g2b(amtzext_defid) 
,g2b(ainstanceid)
,aname

,aexttype

,athedescription

 ) ;


call mtzext_def_client_trigger(acursession,amtzext_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists mtzext_def_copy
go

create procedure mtzext_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into mtzext_def 
 ( mtzext_defid 
,instanceid
,name

,exttype

,thedescription

 ) select 
copymap(acopyaction,b2g(mtzext_defid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,exttype

,thedescription

 from mtzext_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists mtzext_def_logger
go

create procedure mtzext_def_logger /*список зарегистрированных расширений*/ (
 acursession varchar(38),
 amtzext_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists mtzext_def_parent
go
create procedure mtzext_def_parent /* список зарегистрированных расширений*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from mtzext_def where  mtzext_defid=arowid;
 end 
go
GO


drop procedure if exists mtzext_def_islocked
go
create procedure mtzext_def_islocked /* список зарегистрированных расширений */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from mtzext_def where mtzext_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists mtzext_def_lock
go
create procedure mtzext_def_lock /* список зарегистрированных расширений */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call mtzext_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update mtzext_def set lockuserid =auserid ,locksessionid=null  where mtzext_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update mtzext_def set lockuserid=null ,locksessionid =acursession  where mtzext_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists mtzext_def_unlock
go
create procedure mtzext_def_unlock /* список зарегистрированных расширений */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call mtzext_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update mtzext_def set lockuserid =null  where mtzext_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update mtzext_def set locksessionid =null  where mtzext_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS mtzext_def_client_trigger
GO

create procedure mtzext_def_client_trigger  (
 acursession varchar(38),
 aMTZExt_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists mtzextrel_brief
go

create procedure mtzextrel_brief  (
 acursession varchar(38),
 amtzextrelid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if amtzextrelid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from mtzextrel where mtzextrelid=g2b(amtzextrelid);
 if  aec &gt;0 then
   set abrief=mtzextrel_brief_f(g2b(amtzextrelid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists mtzextrel_delete
go

create procedure mtzextrel_delete /*реализации расширения для разных разработческих плаформ*/ (
 acursession varchar(38),
 amtzextrelid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from mtzextrel where mtzextrelid=g2b(amtzextrelid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzext.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=mtzextrel' result;
    leave body;
  end if;
 call mtzextrel_logger(acursession,amtzextrelid) ; 
  delete from  mtzextrel 
  where  mtzextrelid = g2b(amtzextrelid) ;
  delete from num_values where ownerpartname='mtzextrel' and ownerrowid=g2b(amtzextrelid);
  end if;
    select 'ok' result;
 end 
go
GO

/*реализации расширения*/

drop procedure if exists mtzextrel_save
go

create procedure mtzextrel_save /*реализации расширения для разных разработческих плаформ*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 amtzextrelid varchar(38)
,atheplatform
 integer/* реализация *//* реализация */
,atheclassname
 varchar (255)/* название класса *//* название класса */
,athelibraryname
 varchar (255)/* название библиотеки *//* название библиотеки */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from mtzextrel where mtzextrelid=g2b(amtzextrelid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzext.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=mtzextrel' result;
    leave body;
  end if;
 start transaction ; 
 call mtzextrel_logger(acursession,amtzextrelid) ; 
 update  mtzextrel set changestamp=now()
,
  theplatform=atheplatform
,
  theclassname=atheclassname
,
  thelibraryname=athelibraryname
  where  mtzextrelid = g2b(amtzextrelid) ;


call mtzextrel_client_trigger(acursession,amtzextrelid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzext.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=mtzextrel' result;
    leave body;
  end if;
 start transaction;  
 insert into   mtzextrel
 (  mtzextrelid 
,instanceid
,theplatform

,theclassname

,thelibraryname

 ) values ( g2b(amtzextrelid) 
,g2b(ainstanceid)
,atheplatform

,atheclassname

,athelibraryname

 ) ;


call mtzextrel_client_trigger(acursession,amtzextrelid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists mtzextrel_copy
go

create procedure mtzextrel_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into mtzextrel 
 ( mtzextrelid 
,instanceid
,theplatform

,theclassname

,thelibraryname

 ) select 
copymap(acopyaction,b2g(mtzextrelid)) 
,copymap(acopyaction,b2g(instanceid))
,theplatform

,theclassname

,thelibraryname

 from mtzextrel
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists mtzextrel_logger
go

create procedure mtzextrel_logger /*реализации расширения для разных разработческих плаформ*/ (
 acursession varchar(38),
 amtzextrelid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists mtzextrel_parent
go
create procedure mtzextrel_parent /* реализации расширения для разных разработческих плаформ*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from mtzextrel where  mtzextrelid=arowid;
 end 
go
GO


drop procedure if exists mtzextrel_islocked
go
create procedure mtzextrel_islocked /* реализации расширения для разных разработческих плаформ */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from mtzextrel where mtzextrelid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists mtzextrel_lock
go
create procedure mtzextrel_lock /* реализации расширения для разных разработческих плаформ */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call mtzextrel_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update mtzextrel set lockuserid =auserid ,locksessionid=null  where mtzextrelid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update mtzextrel set lockuserid=null ,locksessionid =acursession  where mtzextrelid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists mtzextrel_unlock
go
create procedure mtzextrel_unlock /* реализации расширения для разных разработческих плаформ */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call mtzextrel_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update mtzextrel set lockuserid =null  where mtzextrelid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update mtzextrel set locksessionid =null  where mtzextrelid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS mtzextrel_client_trigger
GO

create procedure mtzextrel_client_trigger  (
 acursession varchar(38),
 aMTZExtRelid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_videotype_brief
go

create procedure iud_videotype_brief  (
 acursession varchar(38),
 aiud_videotypeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_videotypeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_videotype where iud_videotypeid=g2b(aiud_videotypeid);
 if  aec &gt;0 then
   set abrief=iud_videotype_brief_f(g2b(aiud_videotypeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_videotype_delete
go

create procedure iud_videotype_delete /*тип видео*/ (
 acursession varchar(38),
 aiud_videotypeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_videotype where iud_videotypeid=g2b(aiud_videotypeid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_vt.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_videotype' result;
    leave body;
  end if;
 call iud_videotype_logger(acursession,aiud_videotypeid) ; 
  delete from  iud_videotype 
  where  iud_videotypeid = g2b(aiud_videotypeid) ;
  delete from num_values where ownerpartname='iud_videotype' and ownerrowid=g2b(aiud_videotypeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип видео*/

drop procedure if exists iud_videotype_save
go

create procedure iud_videotype_save /*тип видео*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_videotypeid varchar(38)
,asequence
 integer/* порядок вывода *//* порядок вывода */
,afiletype varchar(38)/* тип файла *//* тип файла */
,aname
 varchar (120)/* название *//* название */
,aversionpolicy varchar(38)/* организация версий *//* организация версий */
,anocomments
 integer/* скрыть *//* скрыть */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_videotype where iud_videotypeid=g2b(aiud_videotypeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_vt.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_videotype' result;
    leave body;
  end if;
 start transaction ; 
 call iud_videotype_logger(acursession,aiud_videotypeid) ; 
 update  iud_videotype set changestamp=now()
,
  sequence=asequence
,
  filetype=g2b(afiletype)
,
  name=aname
,
  versionpolicy=g2b(aversionpolicy)
,
  nocomments=anocomments
  where  iud_videotypeid = g2b(aiud_videotypeid) ;


call iud_videotype_client_trigger(acursession,aiud_videotypeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_vt.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_videotype' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_videotype
 (  iud_videotypeid 
,instanceid
,sequence

,filetype

,name

,versionpolicy

,nocomments

 ) values ( g2b(aiud_videotypeid) 
,g2b(ainstanceid)
,asequence

,g2b(afiletype)

,aname

,g2b(aversionpolicy)

,anocomments

 ) ;


call iud_videotype_client_trigger(acursession,aiud_videotypeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_videotype_copy
go

create procedure iud_videotype_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_videotype 
 ( iud_videotypeid 
,instanceid
,sequence

,filetype

,name

,versionpolicy

,nocomments

 ) select 
copymap(acopyaction,b2g(iud_videotypeid)) 
,copymap(acopyaction,b2g(instanceid))
,sequence

,filetype

,name

,versionpolicy

,nocomments

 from iud_videotype
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_videotype_logger
go

create procedure iud_videotype_logger /*тип видео*/ (
 acursession varchar(38),
 aiud_videotypeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_videotype_parent
go
create procedure iud_videotype_parent /* тип видео*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_videotype where  iud_videotypeid=arowid;
 end 
go
GO


drop procedure if exists iud_videotype_islocked
go
create procedure iud_videotype_islocked /* тип видео */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_videotype where iud_videotypeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_videotype_lock
go
create procedure iud_videotype_lock /* тип видео */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_videotype_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_videotype set lockuserid =auserid ,locksessionid=null  where iud_videotypeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_videotype set lockuserid=null ,locksessionid =acursession  where iud_videotypeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_videotype_unlock
go
create procedure iud_videotype_unlock /* тип видео */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_videotype_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_videotype set lockuserid =null  where iud_videotypeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_videotype set locksessionid =null  where iud_videotypeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_videotype_client_trigger
GO

create procedure iud_videotype_client_trigger  (
 acursession varchar(38),
 aiud_videotypeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_cm_def_brief
go

create procedure iu_cm_def_brief  (
 acursession varchar(38),
 aiu_cm_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_cm_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_cm_def where iu_cm_defid=g2b(aiu_cm_defid);
 if  aec &gt;0 then
   set abrief=iu_cm_def_brief_f(g2b(aiu_cm_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_cm_def_delete
go

create procedure iu_cm_def_delete /*источник данных для комментирования*/ (
 acursession varchar(38),
 aiu_cm_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_cm_def where iu_cm_defid=g2b(aiu_cm_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_cm.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_cm_def' result;
    leave body;
  end if;
 call iu_cm_def_logger(acursession,aiu_cm_defid) ; 
  delete from  iu_cm_def 
  where  iu_cm_defid = g2b(aiu_cm_defid) ;
  delete from num_values where ownerpartname='iu_cm_def' and ownerrowid=g2b(aiu_cm_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*источник*/

drop procedure if exists iu_cm_def_save
go

create procedure iu_cm_def_save /*источник данных для комментирования*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_cm_defid varchar(38)
,atheprocess varchar(38)/* урок *//* урок */
,athevideo varchar(38)/* видео *//* видео */
,athedoc varchar(38)/* документ *//* документ */
,aisdiscussion
 integer/* обсуждение *//* обсуждение */
,athetheme
 varchar (255)/* тема *//* тема */
,athedate
 datetime/* дата *//* дата */
,atheauthor varchar(38)/* добавил *//* добавил */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_cm_def where iu_cm_defid=g2b(aiu_cm_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_cm.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_cm_def' result;
    leave body;
  end if;
 start transaction ; 
 call iu_cm_def_logger(acursession,aiu_cm_defid) ; 
 update  iu_cm_def set changestamp=now()
,
  theprocess=g2b(atheprocess)
,
  thevideo=g2b(athevideo)
,
  thedoc=g2b(athedoc)
,
  isdiscussion=aisdiscussion
,
  thetheme=athetheme
,
  thedate=athedate
,
  theauthor=g2b(atheauthor)
  where  iu_cm_defid = g2b(aiu_cm_defid) ;


call iu_cm_def_client_trigger(acursession,aiu_cm_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_cm.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_cm_def' result;
    leave body;
  end if;
select count(*) into aec from iu_cm_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_cm_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_cm_def
 (  iu_cm_defid 
,instanceid
,theprocess

,thevideo

,thedoc

,isdiscussion

,thetheme

,thedate

,theauthor

 ) values ( g2b(aiu_cm_defid) 
,g2b(ainstanceid)
,g2b(atheprocess)

,g2b(athevideo)

,g2b(athedoc)

,aisdiscussion

,athetheme

,athedate

,g2b(atheauthor)

 ) ;


call iu_cm_def_client_trigger(acursession,aiu_cm_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_cm_def_copy
go

create procedure iu_cm_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_cm_def 
 ( iu_cm_defid 
,instanceid
,theprocess

,thevideo

,thedoc

,isdiscussion

,thetheme

,thedate

,theauthor

 ) select 
copymap(acopyaction,b2g(iu_cm_defid)) 
,copymap(acopyaction,b2g(instanceid))
,theprocess

,thevideo

,thedoc

,isdiscussion

,thetheme

,thedate

,theauthor

 from iu_cm_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_cm_def_logger
go

create procedure iu_cm_def_logger /*источник данных для комментирования*/ (
 acursession varchar(38),
 aiu_cm_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_cm_def_parent
go
create procedure iu_cm_def_parent /* источник данных для комментирования*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_cm_def where  iu_cm_defid=arowid;
 end 
go
GO


drop procedure if exists iu_cm_def_islocked
go
create procedure iu_cm_def_islocked /* источник данных для комментирования */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_cm_def where iu_cm_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_cm_def_lock
go
create procedure iu_cm_def_lock /* источник данных для комментирования */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_cm_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_cm_def set lockuserid =auserid ,locksessionid=null  where iu_cm_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_cm_def set lockuserid=null ,locksessionid =acursession  where iu_cm_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_cm_def_unlock
go
create procedure iu_cm_def_unlock /* источник данных для комментирования */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_cm_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_cm_def set lockuserid =null  where iu_cm_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_cm_def set locksessionid =null  where iu_cm_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_cm_def_client_trigger
GO

create procedure iu_cm_def_client_trigger  (
 acursession varchar(38),
 aiu_cm_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_cm_time_brief
go

create procedure iu_cm_time_brief  (
 acursession varchar(38),
 aiu_cm_timeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_cm_timeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_cm_time where iu_cm_timeid=g2b(aiu_cm_timeid);
 if  aec &gt;0 then
   set abrief=iu_cm_time_brief_f(g2b(aiu_cm_timeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_cm_time_delete
go

create procedure iu_cm_time_delete /**/ (
 acursession varchar(38),
 aiu_cm_timeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_cm_time where iu_cm_timeid=g2b(aiu_cm_timeid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_cm.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_cm_time' result;
    leave body;
  end if;
 call iu_cm_time_logger(acursession,aiu_cm_timeid) ; 
  delete from  iu_cm_time 
  where  iu_cm_timeid = g2b(aiu_cm_timeid) ;
  delete from num_values where ownerpartname='iu_cm_time' and ownerrowid=g2b(aiu_cm_timeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тайминг*/

drop procedure if exists iu_cm_time_save
go

create procedure iu_cm_time_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_cm_timeid varchar(38)
,amessagetype varchar(38)/* тип сообщения *//* тип сообщения */
,athedate
 datetime/* дата *//* дата */
,atheauthor varchar(38)/* добавил *//* добавил */
,aendtime
 varchar (15)/* тайминг.конец *//* тайминг.конец */
,ainfo
 text/* сообщение *//* сообщение */
,astarttime
 varchar (15)/* тайминг.начало *//* тайминг.начало */
,aischecked
 integer/* проверен *//* проверен */
,athefile varchar(255)/* файл */
,athefile_ext varchar(4) /* файл */
,atheref varchar(255)/* ссылка *//* ссылка */
,acuratoronly
 integer/* скрытый *//* скрытый */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_cm_time where iu_cm_timeid=g2b(aiu_cm_timeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_cm.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_cm_time' result;
    leave body;
  end if;
 start transaction ; 
 call iu_cm_time_logger(acursession,aiu_cm_timeid) ; 
 update  iu_cm_time set changestamp=now()
,
  messagetype=g2b(amessagetype)
,
  thedate=athedate
,
  theauthor=g2b(atheauthor)
,
  endtime=aendtime
,
  info=ainfo
,
  starttime=astarttime
,
  ischecked=aischecked
,
  thefile=athefile
,thefile_ext=
athefile_ext 
,
  theref=atheref
,
  curatoronly=acuratoronly
  where  iu_cm_timeid = g2b(aiu_cm_timeid) ;


call iu_cm_time_client_trigger(acursession,aiu_cm_timeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_cm.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_cm_time' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_cm_time
 (  iu_cm_timeid 
,instanceid
,messagetype

,thedate

,theauthor

,endtime

,info

,starttime

,ischecked

,thefile

,thefile_ext
,theref

,curatoronly

 ) values ( g2b(aiu_cm_timeid) 
,g2b(ainstanceid)
,g2b(amessagetype)

,athedate

,g2b(atheauthor)

,aendtime

,ainfo

,astarttime

,aischecked

,athefile

,athefile_ext
,atheref

,acuratoronly

 ) ;


call iu_cm_time_client_trigger(acursession,aiu_cm_timeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_cm_time_copy
go

create procedure iu_cm_time_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_cm_time 
 ( iu_cm_timeid 
,instanceid
,messagetype

,thedate

,theauthor

,endtime

,info

,starttime

,ischecked

,thefile

,thefile_ext
,theref

,curatoronly

 ) select 
copymap(acopyaction,b2g(iu_cm_timeid)) 
,copymap(acopyaction,b2g(instanceid))
,messagetype

,thedate

,theauthor

,endtime

,info

,starttime

,ischecked

,thefile

,thefile_ext
,theref

,curatoronly

 from iu_cm_time
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_cm_time_logger
go

create procedure iu_cm_time_logger /**/ (
 acursession varchar(38),
 aiu_cm_timeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_cm_time_parent
go
create procedure iu_cm_time_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_cm_time where  iu_cm_timeid=arowid;
 end 
go
GO


drop procedure if exists iu_cm_time_islocked
go
create procedure iu_cm_time_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_cm_time where iu_cm_timeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_cm_time_lock
go
create procedure iu_cm_time_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_cm_time_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_cm_time set lockuserid =auserid ,locksessionid=null  where iu_cm_timeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_cm_time set lockuserid=null ,locksessionid =acursession  where iu_cm_timeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_cm_time_unlock
go
create procedure iu_cm_time_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_cm_time_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_cm_time set lockuserid =null  where iu_cm_timeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_cm_time set locksessionid =null  where iu_cm_timeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_cm_time_client_trigger
GO

create procedure iu_cm_time_client_trigger  (
 acursession varchar(38),
 aiu_cm_timeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_cm_msg_brief
go

create procedure iu_cm_msg_brief  (
 acursession varchar(38),
 aiu_cm_msgid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_cm_msgid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_cm_msg where iu_cm_msgid=g2b(aiu_cm_msgid);
 if  aec &gt;0 then
   set abrief=iu_cm_msg_brief_f(g2b(aiu_cm_msgid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_cm_msg_delete
go

create procedure iu_cm_msg_delete /**/ (
 acursession varchar(38),
 aiu_cm_msgid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_cm_msg where iu_cm_msgid=g2b(aiu_cm_msgid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_cm.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_cm_msg' result;
    leave body;
  end if;
 call iu_cm_msg_logger(acursession,aiu_cm_msgid) ; 
  delete from  iu_cm_msg 
  where  iu_cm_msgid = g2b(aiu_cm_msgid) ;
  delete from num_values where ownerpartname='iu_cm_msg' and ownerrowid=g2b(aiu_cm_msgid);
  end if;
    select 'ok' result;
 end 
go
GO

/*сообщения*/

drop procedure if exists iu_cm_msg_save
go

create procedure iu_cm_msg_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_cm_msgid varchar(38)
,aparentrowid varchar(38) 
,ainfo
 text/* сообщение *//* сообщение */
,amessagetype varchar(38)/* тип сообщения *//* тип сообщения */
,atheauthor varchar(38)/* добавил *//* добавил */
,athedate
 datetime/* дата *//* дата */
,athefile varchar(255)/* файл */
,athefile_ext varchar(4) /* файл */
,atheref varchar(255)/* ссылка *//* ссылка */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_cm_msg where iu_cm_msgid=g2b(aiu_cm_msgid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_cm.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_cm_msg' result;
    leave body;
  end if;
 start transaction ; 
 call iu_cm_msg_logger(acursession,aiu_cm_msgid) ; 
 update  iu_cm_msg set changestamp=now()
,parentrowid= g2b(aparentrowid)
,
  info=ainfo
,
  messagetype=g2b(amessagetype)
,
  theauthor=g2b(atheauthor)
,
  thedate=athedate
,
  thefile=athefile
,thefile_ext=
athefile_ext 
,
  theref=atheref
  where  iu_cm_msgid = g2b(aiu_cm_msgid) ;


call iu_cm_msg_client_trigger(acursession,aiu_cm_msgid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_cm.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_cm_msg' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_cm_msg
 (  iu_cm_msgid 
,parentrowid
,instanceid
,info

,messagetype

,theauthor

,thedate

,thefile

,thefile_ext
,theref

 ) values ( g2b(aiu_cm_msgid) 
,g2b(aparentrowid)
,g2b(ainstanceid)
,ainfo

,g2b(amessagetype)

,g2b(atheauthor)

,athedate

,athefile

,athefile_ext
,atheref

 ) ;


call iu_cm_msg_client_trigger(acursession,aiu_cm_msgid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_cm_msg_copy
go

create procedure iu_cm_msg_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_cm_msg 
 ( iu_cm_msgid 
,instanceid
,parentrowid
,info

,messagetype

,theauthor

,thedate

,thefile

,thefile_ext
,theref

 ) select 
copymap(acopyaction,b2g(iu_cm_msgid)) 
,copymap(acopyaction,b2g(instanceid))
,copymap(acopyaction,b2g(parentrowid))
,info

,messagetype

,theauthor

,thedate

,thefile

,thefile_ext
,theref

 from iu_cm_msg
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_cm_msg_logger
go

create procedure iu_cm_msg_logger /**/ (
 acursession varchar(38),
 aiu_cm_msgid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_cm_msg_parent
go
create procedure iu_cm_msg_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_cm_msg where  iu_cm_msgid=arowid;
 end 
go
GO


drop procedure if exists iu_cm_msg_islocked
go
create procedure iu_cm_msg_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_cm_msg where iu_cm_msgid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_cm_msg_lock
go
create procedure iu_cm_msg_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_cm_msg_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_cm_msg set lockuserid =auserid ,locksessionid=null  where iu_cm_msgid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_cm_msg set lockuserid=null ,locksessionid =acursession  where iu_cm_msgid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_cm_msg_unlock
go
create procedure iu_cm_msg_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_cm_msg_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_cm_msg set lockuserid =null  where iu_cm_msgid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_cm_msg set locksessionid =null  where iu_cm_msgid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_cm_msg_client_trigger
GO

create procedure iu_cm_msg_client_trigger  (
 acursession varchar(38),
 aiu_cm_msgid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_plevent_brief
go

create procedure iu_plevent_brief  (
 acursession varchar(38),
 aiu_pleventid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_pleventid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_plevent where iu_pleventid=g2b(aiu_pleventid);
 if  aec &gt;0 then
   set abrief=iu_plevent_brief_f(g2b(aiu_pleventid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_plevent_delete
go

create procedure iu_plevent_delete /*событие в системе*/ (
 acursession varchar(38),
 aiu_pleventid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_plevent where iu_pleventid=g2b(aiu_pleventid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_plog.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_plevent' result;
    leave body;
  end if;
 call iu_plevent_logger(acursession,aiu_pleventid) ; 
  delete from  iu_plevent 
  where  iu_pleventid = g2b(aiu_pleventid) ;
  delete from num_values where ownerpartname='iu_plevent' and ownerrowid=g2b(aiu_pleventid);
  end if;
    select 'ok' result;
 end 
go
GO

/*событие*/

drop procedure if exists iu_plevent_save
go

create procedure iu_plevent_save /*событие в системе*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_pleventid varchar(38)
,aeventtype
 varchar (255)/* тип события *//* тип события */
,ainfo
 varchar (255)/* описание *//* описание */
,adoer varchar(38)/* сотрудник *//* сотрудник */
,acreatedate
 datetime/* дата события *//* дата события */
,atheprocess varchar(38)/* урок *//* урок */
,aprocessstatus varchar(38)/* подэтап *//* подэтап */
,astatetask varchar(38)/* задача *//* задача */
,athedoc varchar(38)/* документ *//* документ */
,athevideo varchar(38)/* видео *//* видео */
,athediscussion varchar(38)/* обсуждение *//* обсуждение */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_plevent where iu_pleventid=g2b(aiu_pleventid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_plog.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_plevent' result;
    leave body;
  end if;
 start transaction ; 
 call iu_plevent_logger(acursession,aiu_pleventid) ; 
 update  iu_plevent set changestamp=now()
,
  eventtype=aeventtype
,
  info=ainfo
,
  doer=g2b(adoer)
,
  createdate=acreatedate
,
  theprocess=g2b(atheprocess)
,
  processstatus=g2b(aprocessstatus)
,
  statetask=g2b(astatetask)
,
  thedoc=g2b(athedoc)
,
  thevideo=g2b(athevideo)
,
  thediscussion=g2b(athediscussion)
  where  iu_pleventid = g2b(aiu_pleventid) ;


call iu_plevent_client_trigger(acursession,aiu_pleventid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_plog.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_plevent' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_plevent
 (  iu_pleventid 
,instanceid
,eventtype

,info

,doer

,createdate

,theprocess

,processstatus

,statetask

,thedoc

,thevideo

,thediscussion

 ) values ( g2b(aiu_pleventid) 
,g2b(ainstanceid)
,aeventtype

,ainfo

,g2b(adoer)

,acreatedate

,g2b(atheprocess)

,g2b(aprocessstatus)

,g2b(astatetask)

,g2b(athedoc)

,g2b(athevideo)

,g2b(athediscussion)

 ) ;


call iu_plevent_client_trigger(acursession,aiu_pleventid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_plevent_copy
go

create procedure iu_plevent_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_plevent 
 ( iu_pleventid 
,instanceid
,eventtype

,info

,doer

,createdate

,theprocess

,processstatus

,statetask

,thedoc

,thevideo

,thediscussion

 ) select 
copymap(acopyaction,b2g(iu_pleventid)) 
,copymap(acopyaction,b2g(instanceid))
,eventtype

,info

,doer

,createdate

,theprocess

,processstatus

,statetask

,thedoc

,thevideo

,thediscussion

 from iu_plevent
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_plevent_logger
go

create procedure iu_plevent_logger /*событие в системе*/ (
 acursession varchar(38),
 aiu_pleventid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_plevent_parent
go
create procedure iu_plevent_parent /* событие в системе*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_plevent where  iu_pleventid=arowid;
 end 
go
GO


drop procedure if exists iu_plevent_islocked
go
create procedure iu_plevent_islocked /* событие в системе */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_plevent where iu_pleventid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_plevent_lock
go
create procedure iu_plevent_lock /* событие в системе */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_plevent_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_plevent set lockuserid =auserid ,locksessionid=null  where iu_pleventid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_plevent set lockuserid=null ,locksessionid =acursession  where iu_pleventid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_plevent_unlock
go
create procedure iu_plevent_unlock /* событие в системе */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_plevent_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_plevent set lockuserid =null  where iu_pleventid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_plevent set locksessionid =null  where iu_pleventid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_plevent_client_trigger
GO

create procedure iu_plevent_client_trigger  (
 acursession varchar(38),
 aiu_pleventid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_rcfg_mod_brief
go

create procedure iu_rcfg_mod_brief  (
 acursession varchar(38),
 aiu_rcfg_modid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_rcfg_modid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_rcfg_mod where iu_rcfg_modid=g2b(aiu_rcfg_modid);
 if  aec &gt;0 then
   set abrief=iu_rcfg_mod_brief_f(g2b(aiu_rcfg_modid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_rcfg_mod_delete
go

create procedure iu_rcfg_mod_delete /**/ (
 acursession varchar(38),
 aiu_rcfg_modid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_rcfg_mod where iu_rcfg_modid=g2b(aiu_rcfg_modid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_rcfg.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_rcfg_mod' result;
    leave body;
  end if;
 call iu_rcfg_mod_logger(acursession,aiu_rcfg_modid) ; 
  delete from  iu_rcfg_mod 
  where  iu_rcfg_modid = g2b(aiu_rcfg_modid) ;
  delete from num_values where ownerpartname='iu_rcfg_mod' and ownerrowid=g2b(aiu_rcfg_modid);
  end if;
    select 'ok' result;
 end 
go
GO

/*модуль*/

drop procedure if exists iu_rcfg_mod_save
go

create procedure iu_rcfg_mod_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_rcfg_modid varchar(38)
,asequence
 integer/* № п/п *//* № п/п */
,acaption
 varchar (80)/* надпись *//* надпись */
,atheicon
 varchar (64)/* иконка *//* иконка */
,aname
 varchar (255)/* название меню *//* название меню */
,agroupname
 varchar (60)/* меню верхнего уровня *//* меню верхнего уровня */
,amoduleaccessible
 integer/* разрешен *//* разрешен */
,avisiblecontrol
 integer/* управление видимостью *//* управление видимостью */
,aallobjects
 integer/* вся фирма *//* вся фирма */
,acolegsobject
 integer/* объекты коллег *//* объекты коллег */
,asubstructobjects
 integer/* подчиненные подразделения *//* подчиненные подразделения */
,atmobjects
 integer/* учителя и методисты *//* учителя и методисты */
,amydocmode
 varchar (10)/* мои документы *//* мои документы */
,aotherdocmode
 varchar (10)/* чужие документы *//* чужие документы */
,acontroldocmode
 varchar (10)/* документы на контроле *//* документы на контроле */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_rcfg_mod where iu_rcfg_modid=g2b(aiu_rcfg_modid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_rcfg.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_rcfg_mod' result;
    leave body;
  end if;
 start transaction ; 
 call iu_rcfg_mod_logger(acursession,aiu_rcfg_modid) ; 
 update  iu_rcfg_mod set changestamp=now()
,
  sequence=asequence
,
  caption=acaption
,
  theicon=atheicon
,
  name=aname
,
  groupname=agroupname
,
  moduleaccessible=amoduleaccessible
,
  visiblecontrol=avisiblecontrol
,
  allobjects=aallobjects
,
  colegsobject=acolegsobject
,
  substructobjects=asubstructobjects
,
  tmobjects=atmobjects
,
  mydocmode=amydocmode
,
  otherdocmode=aotherdocmode
,
  controldocmode=acontroldocmode
  where  iu_rcfg_modid = g2b(aiu_rcfg_modid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from iu_rcfg_mod where  instanceid=g2b(ainstanceid) 
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=модуль правило=(модуль уникален)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_rcfg_mod_client_trigger(acursession,aiu_rcfg_modid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_rcfg.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_rcfg_mod' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_rcfg_mod
 (  iu_rcfg_modid 
,instanceid
,sequence

,caption

,theicon

,name

,groupname

,moduleaccessible

,visiblecontrol

,allobjects

,colegsobject

,substructobjects

,tmobjects

,mydocmode

,otherdocmode

,controldocmode

 ) values ( g2b(aiu_rcfg_modid) 
,g2b(ainstanceid)
,asequence

,acaption

,atheicon

,aname

,agroupname

,amoduleaccessible

,avisiblecontrol

,aallobjects

,acolegsobject

,asubstructobjects

,atmobjects

,amydocmode

,aotherdocmode

,acontroldocmode

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from iu_rcfg_mod where  instanceid=g2b(ainstanceid) 
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=модуль правило=(модуль уникален)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_rcfg_mod_client_trigger(acursession,aiu_rcfg_modid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_rcfg_mod_copy
go

create procedure iu_rcfg_mod_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_rcfg_mod 
 ( iu_rcfg_modid 
,instanceid
,sequence

,caption

,theicon

,name

,groupname

,moduleaccessible

,visiblecontrol

,allobjects

,colegsobject

,substructobjects

,tmobjects

,mydocmode

,otherdocmode

,controldocmode

 ) select 
copymap(acopyaction,b2g(iu_rcfg_modid)) 
,copymap(acopyaction,b2g(instanceid))
,sequence

,caption

,theicon

,name

,groupname

,moduleaccessible

,visiblecontrol

,allobjects

,colegsobject

,substructobjects

,tmobjects

,mydocmode

,otherdocmode

,controldocmode

 from iu_rcfg_mod
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_rcfg_mod_logger
go

create procedure iu_rcfg_mod_logger /**/ (
 acursession varchar(38),
 aiu_rcfg_modid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_rcfg_mod_parent
go
create procedure iu_rcfg_mod_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_rcfg_mod where  iu_rcfg_modid=arowid;
 end 
go
GO


drop procedure if exists iu_rcfg_mod_islocked
go
create procedure iu_rcfg_mod_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_rcfg_mod where iu_rcfg_modid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_rcfg_mod_lock
go
create procedure iu_rcfg_mod_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_rcfg_mod_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_rcfg_mod set lockuserid =auserid ,locksessionid=null  where iu_rcfg_modid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_rcfg_mod set lockuserid=null ,locksessionid =acursession  where iu_rcfg_modid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_rcfg_mod_unlock
go
create procedure iu_rcfg_mod_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_rcfg_mod_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_rcfg_mod set lockuserid =null  where iu_rcfg_modid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_rcfg_mod set locksessionid =null  where iu_rcfg_modid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_rcfg_mod_client_trigger
GO

create procedure iu_rcfg_mod_client_trigger  (
 acursession varchar(38),
 aiu_rcfg_modid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_rcfg_docmode_brief
go

create procedure iu_rcfg_docmode_brief  (
 acursession varchar(38),
 aiu_rcfg_docmodeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_rcfg_docmodeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_rcfg_docmode where iu_rcfg_docmodeid=g2b(aiu_rcfg_docmodeid);
 if  aec &gt;0 then
   set abrief=iu_rcfg_docmode_brief_f(g2b(aiu_rcfg_docmodeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_rcfg_docmode_delete
go

create procedure iu_rcfg_docmode_delete /*какую карточку документа открывать*/ (
 acursession varchar(38),
 aiu_rcfg_docmodeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_rcfg_docmode where iu_rcfg_docmodeid=g2b(aiu_rcfg_docmodeid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_rcfg.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_rcfg_docmode' result;
    leave body;
  end if;
 call iu_rcfg_docmode_logger(acursession,aiu_rcfg_docmodeid) ; 
  delete from  iu_rcfg_docmode 
  where  iu_rcfg_docmodeid = g2b(aiu_rcfg_docmodeid) ;
  delete from num_values where ownerpartname='iu_rcfg_docmode' and ownerrowid=g2b(aiu_rcfg_docmodeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*режим документа*/

drop procedure if exists iu_rcfg_docmode_save
go

create procedure iu_rcfg_docmode_save /*какую карточку документа открывать*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_rcfg_docmodeid varchar(38)
,athe_document varchar(38)/* тип документа *//* тип документа */
,aaddmode
 varchar (4)/* режим для  создания *//* режим для  создания */
,aeditmode
 varchar (4)/* режим для редактирования *//* режим для редактирования */
,aallowadd
 integer/* можно создавать *//* можно создавать */
,aallowdelete
 integer/* можно удалять *//* можно удалять */
,aallowdelegate
 integer/* можно  делегировать *//* можно  делегировать */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_rcfg_docmode where iu_rcfg_docmodeid=g2b(aiu_rcfg_docmodeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_rcfg.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_rcfg_docmode' result;
    leave body;
  end if;
 start transaction ; 
 call iu_rcfg_docmode_logger(acursession,aiu_rcfg_docmodeid) ; 
 update  iu_rcfg_docmode set changestamp=now()
,
  the_document=g2b(athe_document)
,
  addmode=aaddmode
,
  editmode=aeditmode
,
  allowadd=aallowadd
,
  allowdelete=aallowdelete
,
  allowdelegate=aallowdelegate
  where  iu_rcfg_docmodeid = g2b(aiu_rcfg_docmodeid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from iu_rcfg_docmode where  instanceid=g2b(ainstanceid) 
 and the_document=g2b(athe_document);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=режим документа правило=(тип документа уникален)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_rcfg_docmode_client_trigger(acursession,aiu_rcfg_docmodeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_rcfg.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_rcfg_docmode' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_rcfg_docmode
 (  iu_rcfg_docmodeid 
,instanceid
,the_document

,addmode

,editmode

,allowadd

,allowdelete

,allowdelegate

 ) values ( g2b(aiu_rcfg_docmodeid) 
,g2b(ainstanceid)
,g2b(athe_document)

,aaddmode

,aeditmode

,aallowadd

,aallowdelete

,aallowdelegate

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from iu_rcfg_docmode where  instanceid=g2b(ainstanceid) 
 and the_document=g2b(athe_document);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=режим документа правило=(тип документа уникален)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_rcfg_docmode_client_trigger(acursession,aiu_rcfg_docmodeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_rcfg_docmode_copy
go

create procedure iu_rcfg_docmode_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_rcfg_docmode 
 ( iu_rcfg_docmodeid 
,instanceid
,the_document

,addmode

,editmode

,allowadd

,allowdelete

,allowdelegate

 ) select 
copymap(acopyaction,b2g(iu_rcfg_docmodeid)) 
,copymap(acopyaction,b2g(instanceid))
,the_document

,addmode

,editmode

,allowadd

,allowdelete

,allowdelegate

 from iu_rcfg_docmode
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_rcfg_docmode_logger
go

create procedure iu_rcfg_docmode_logger /*какую карточку документа открывать*/ (
 acursession varchar(38),
 aiu_rcfg_docmodeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_rcfg_docmode_parent
go
create procedure iu_rcfg_docmode_parent /* какую карточку документа открывать*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_rcfg_docmode where  iu_rcfg_docmodeid=arowid;
 end 
go
GO


drop procedure if exists iu_rcfg_docmode_islocked
go
create procedure iu_rcfg_docmode_islocked /* какую карточку документа открывать */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_rcfg_docmode where iu_rcfg_docmodeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_rcfg_docmode_lock
go
create procedure iu_rcfg_docmode_lock /* какую карточку документа открывать */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_rcfg_docmode_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_rcfg_docmode set lockuserid =auserid ,locksessionid=null  where iu_rcfg_docmodeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_rcfg_docmode set lockuserid=null ,locksessionid =acursession  where iu_rcfg_docmodeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_rcfg_docmode_unlock
go
create procedure iu_rcfg_docmode_unlock /* какую карточку документа открывать */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_rcfg_docmode_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_rcfg_docmode set lockuserid =null  where iu_rcfg_docmodeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_rcfg_docmode set locksessionid =null  where iu_rcfg_docmodeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_rcfg_docmode_client_trigger
GO

create procedure iu_rcfg_docmode_client_trigger  (
 acursession varchar(38),
 aiu_rcfg_docmodeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_rcfg_def_brief
go

create procedure iu_rcfg_def_brief  (
 acursession varchar(38),
 aiu_rcfg_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_rcfg_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_rcfg_def where iu_rcfg_defid=g2b(aiu_rcfg_defid);
 if  aec &gt;0 then
   set abrief=iu_rcfg_def_brief_f(g2b(aiu_rcfg_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_rcfg_def_delete
go

create procedure iu_rcfg_def_delete /*роль для настройки*/ (
 acursession varchar(38),
 aiu_rcfg_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_rcfg_def where iu_rcfg_defid=g2b(aiu_rcfg_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_rcfg.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_rcfg_def' result;
    leave body;
  end if;
 call iu_rcfg_def_logger(acursession,aiu_rcfg_defid) ; 
  delete from  iu_rcfg_def 
  where  iu_rcfg_defid = g2b(aiu_rcfg_defid) ;
  delete from num_values where ownerpartname='iu_rcfg_def' and ownerrowid=g2b(aiu_rcfg_defid);
  end if;
    select 'ok' result;
 end 
go
GO


drop procedure if exists iu_rcfg_def_archive
go

create procedure iu_rcfg_def_archive /*роль для настройки*/ (
 acursession varchar(38),
 aiu_rcfg_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare atmpid binary(16);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_rcfg_def where iu_rcfg_defid=g2b(aiu_rcfg_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_rcfg.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_rcfg_def' result;
    leave body;
  end if;
 call iu_rcfg_def_logger(acursession,aiu_rcfg_defid) ; 
  update   iu_rcfg_def set archived = 1 
  where  iu_rcfg_defid = g2b(aiu_rcfg_defid) ;
  end if;
    select 'ok' result;
 end 
go
GO

/*роль*/

drop procedure if exists iu_rcfg_def_save
go

create procedure iu_rcfg_def_save /*роль для настройки*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_rcfg_defid varchar(38)
,atherole varchar(38)/* роль *//* роль */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_rcfg_def where iu_rcfg_defid=g2b(aiu_rcfg_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_rcfg.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_rcfg_def' result;
    leave body;
  end if;
 start transaction ; 
 call iu_rcfg_def_logger(acursession,aiu_rcfg_defid) ; 
 update  iu_rcfg_def set changestamp=now()
,
  therole=g2b(atherole)
  where  iu_rcfg_defid = g2b(aiu_rcfg_defid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iu_rcfg_def where 1=1  
 and therole=g2b(atherole);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=роль правило=(роль уникальна)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_rcfg_def_client_trigger(acursession,aiu_rcfg_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_rcfg.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_rcfg_def' result;
    leave body;
  end if;
select count(*) into aec from iu_rcfg_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_rcfg_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_rcfg_def
 (  iu_rcfg_defid 
,instanceid
,therole

 ) values ( g2b(aiu_rcfg_defid) 
,g2b(ainstanceid)
,g2b(atherole)

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iu_rcfg_def where 1=1  
 and therole=g2b(atherole);
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=роль правило=(роль уникальна)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_rcfg_def_client_trigger(acursession,aiu_rcfg_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_rcfg_def_copy
go

create procedure iu_rcfg_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_rcfg_def 
 ( iu_rcfg_defid 
,instanceid
,archived
,therole

 ) select 
copymap(acopyaction,b2g(iu_rcfg_defid)) 
,copymap(acopyaction,b2g(instanceid))
,archived
,therole

 from iu_rcfg_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_rcfg_def_logger
go

create procedure iu_rcfg_def_logger /*роль для настройки*/ (
 acursession varchar(38),
 aiu_rcfg_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_rcfg_def_parent
go
create procedure iu_rcfg_def_parent /* роль для настройки*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_rcfg_def where  iu_rcfg_defid=arowid;
 end 
go
GO


drop procedure if exists iu_rcfg_def_islocked
go
create procedure iu_rcfg_def_islocked /* роль для настройки */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_rcfg_def where iu_rcfg_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_rcfg_def_lock
go
create procedure iu_rcfg_def_lock /* роль для настройки */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_rcfg_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_rcfg_def set lockuserid =auserid ,locksessionid=null  where iu_rcfg_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_rcfg_def set lockuserid=null ,locksessionid =acursession  where iu_rcfg_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_rcfg_def_unlock
go
create procedure iu_rcfg_def_unlock /* роль для настройки */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_rcfg_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_rcfg_def set lockuserid =null  where iu_rcfg_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_rcfg_def set locksessionid =null  where iu_rcfg_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_rcfg_def_client_trigger
GO

create procedure iu_rcfg_def_client_trigger  (
 acursession varchar(38),
 aiu_rcfg_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_town_brief
go

create procedure iud_town_brief  (
 acursession varchar(38),
 aiud_townid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_townid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_town where iud_townid=g2b(aiud_townid);
 if  aec &gt;0 then
   set abrief=iud_town_brief_f(g2b(aiud_townid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_town_delete
go

create procedure iud_town_delete /*город*/ (
 acursession varchar(38),
 aiud_townid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_town where iud_townid=g2b(aiud_townid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_t.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_town' result;
    leave body;
  end if;
 call iud_town_logger(acursession,aiud_townid) ; 
  delete from  iud_town 
  where  iud_townid = g2b(aiud_townid) ;
  delete from num_values where ownerpartname='iud_town' and ownerrowid=g2b(aiud_townid);
  end if;
    select 'ok' result;
 end 
go
GO

/*город*/

drop procedure if exists iud_town_save
go

create procedure iud_town_save /*город*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_townid varchar(38)
,aname
 varchar (120)/* название *//* название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_town where iud_townid=g2b(aiud_townid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_t.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_town' result;
    leave body;
  end if;
 start transaction ; 
 call iud_town_logger(acursession,aiud_townid) ; 
 update  iud_town set changestamp=now()
,
  name=aname
  where  iud_townid = g2b(aiud_townid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_town where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=город правило=(уникальность для город.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_town_client_trigger(acursession,aiud_townid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_t.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_town' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_town
 (  iud_townid 
,instanceid
,name

 ) values ( g2b(aiud_townid) 
,g2b(ainstanceid)
,aname

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_town where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=город правило=(уникальность для город.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_town_client_trigger(acursession,aiud_townid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_town_copy
go

create procedure iud_town_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_town 
 ( iud_townid 
,instanceid
,name

 ) select 
copymap(acopyaction,b2g(iud_townid)) 
,copymap(acopyaction,b2g(instanceid))
,name

 from iud_town
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_town_logger
go

create procedure iud_town_logger /*город*/ (
 acursession varchar(38),
 aiud_townid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_town_parent
go
create procedure iud_town_parent /* город*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_town where  iud_townid=arowid;
 end 
go
GO


drop procedure if exists iud_town_islocked
go
create procedure iud_town_islocked /* город */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_town where iud_townid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_town_lock
go
create procedure iud_town_lock /* город */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_town_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_town set lockuserid =auserid ,locksessionid=null  where iud_townid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_town set lockuserid=null ,locksessionid =acursession  where iud_townid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_town_unlock
go
create procedure iud_town_unlock /* город */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_town_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_town set lockuserid =null  where iud_townid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_town set locksessionid =null  where iud_townid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_town_client_trigger
GO

create procedure iud_town_client_trigger  (
 acursession varchar(38),
 aiud_townid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_regtree_brief
go

create procedure iu_regtree_brief  (
 acursession varchar(38),
 aiu_regtreeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_regtreeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_regtree where iu_regtreeid=g2b(aiu_regtreeid);
 if  aec &gt;0 then
   set abrief=iu_regtree_brief_f(g2b(aiu_regtreeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_regtree_delete
go

create procedure iu_regtree_delete /*структура документации*/ (
 acursession varchar(38),
 aiu_regtreeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_regtree where iu_regtreeid=g2b(aiu_regtreeid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_reg.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_regtree' result;
    leave body;
  end if;
 call iu_regtree_logger(acursession,aiu_regtreeid) ; 
  delete from  iu_regtree 
  where  iu_regtreeid = g2b(aiu_regtreeid) ;
  delete from num_values where ownerpartname='iu_regtree' and ownerrowid=g2b(aiu_regtreeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*структура документации*/

drop procedure if exists iu_regtree_save
go

create procedure iu_regtree_save /*структура документации*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_regtreeid varchar(38)
,aparentrowid varchar(38) 
,aname
 varchar (120)/* название *//* название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_regtree where iu_regtreeid=g2b(aiu_regtreeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_reg.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_regtree' result;
    leave body;
  end if;
 start transaction ; 
 call iu_regtree_logger(acursession,aiu_regtreeid) ; 
 update  iu_regtree set changestamp=now()
,parentrowid= g2b(aparentrowid)
,
  name=aname
  where  iu_regtreeid = g2b(aiu_regtreeid) ;


call iu_regtree_client_trigger(acursession,aiu_regtreeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_reg.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_regtree' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_regtree
 (  iu_regtreeid 
,parentrowid
,instanceid
,name

 ) values ( g2b(aiu_regtreeid) 
,g2b(aparentrowid)
,g2b(ainstanceid)
,aname

 ) ;


call iu_regtree_client_trigger(acursession,aiu_regtreeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_regdocs_brief
go

create procedure iu_regdocs_brief  (
 acursession varchar(38),
 aiu_regdocsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_regdocsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_regdocs where iu_regdocsid=g2b(aiu_regdocsid);
 if  aec &gt;0 then
   set abrief=iu_regdocs_brief_f(g2b(aiu_regdocsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_regdocs_delete
go

create procedure iu_regdocs_delete /*документы*/ (
 acursession varchar(38),
 aiu_regdocsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_regdocs where iu_regdocsid=g2b(aiu_regdocsid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_reg.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_regdocs' result;
    leave body;
  end if;
 call iu_regdocs_logger(acursession,aiu_regdocsid) ; 
  delete from  iu_regdocs 
  where  iu_regdocsid = g2b(aiu_regdocsid) ;
  delete from num_values where ownerpartname='iu_regdocs' and ownerrowid=g2b(aiu_regdocsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*документы*/

drop procedure if exists iu_regdocs_save
go

create procedure iu_regdocs_save /*документы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aiu_regdocsid varchar(38)
,adocname
 varchar (255)/* название документа *//* название документа */
,athedoc varchar(255)/* файл */
,athedoc_ext varchar(4) /* файл */
,athecomment
 varchar (4000)/* комментарий *//* комментарий */
,aorigname
 varchar (255)/* оригинальное название *//* оригинальное название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_regdocs where iu_regdocsid=g2b(aiu_regdocsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_reg.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_regdocs' result;
    leave body;
  end if;
 start transaction ; 
 call iu_regdocs_logger(acursession,aiu_regdocsid) ; 
 update  iu_regdocs set changestamp=now()
,
  docname=adocname
,
  thedoc=athedoc
,thedoc_ext=
athedoc_ext 
,
  thecomment=athecomment
,
  origname=aorigname
  where  iu_regdocsid = g2b(aiu_regdocsid) ;


call iu_regdocs_client_trigger(acursession,aiu_regdocsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_reg.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_regdocs' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_regdocs
 (  iu_regdocsid 
,parentstructrowid
,docname

,thedoc

,thedoc_ext
,thecomment

,origname

 ) values ( g2b(aiu_regdocsid) 
,g2b(aparentstructrowid)
,adocname

,athedoc

,athedoc_ext
,athecomment

,aorigname

 ) ;


call iu_regdocs_client_trigger(acursession,aiu_regdocsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_regdocs_copy
go

create procedure iu_regdocs_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_regdocs 
 ( iu_regdocsid 
,parentstructrowid
,docname

,thedoc

,thedoc_ext
,thecomment

,origname

 ) select 
copymap(acopyaction,b2g(iu_regdocsid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,docname

,thedoc

,thedoc_ext
,thecomment

,origname

 from iu_regdocs
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists iu_regtree_copy
go

create procedure iu_regtree_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_iu_regtree cursor for
select iu_regtreeid from iu_regtree where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_regtree 
 ( iu_regtreeid 
,instanceid
,parentrowid
,name

 ) select 
copymap(acopyaction,b2g(iu_regtreeid)) 
,copymap(acopyaction,b2g(instanceid))
,copymap(acopyaction,b2g(parentrowid))
,name

 from iu_regtree
 where instanceid =g2b( ainstanceid); 
open copy_cursor_iu_regtree;
  set  fetch_done=false;
fetch copy_cursor_iu_regtree into aid;
while not fetch_done do 
    call iu_regdocs_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_iu_regtree into aid;
end while;

close copy_cursor_iu_regtree;
 end 
go
GO


drop procedure if exists iu_regtree_logger
go

create procedure iu_regtree_logger /*структура документации*/ (
 acursession varchar(38),
 aiu_regtreeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_regdocs_logger
go

create procedure iu_regdocs_logger /*документы*/ (
 acursession varchar(38),
 aiu_regdocsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_regtree_parent
go
create procedure iu_regtree_parent /* структура документации*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_regtree where  iu_regtreeid=arowid;
 end 
go
GO


drop procedure if exists iu_regtree_islocked
go
create procedure iu_regtree_islocked /* структура документации */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_regtree where iu_regtreeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_regtree_lock
go
create procedure iu_regtree_lock /* структура документации */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_regtree_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_regtree set lockuserid =auserid ,locksessionid=null  where iu_regtreeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_regtree set lockuserid=null ,locksessionid =acursession  where iu_regtreeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_regtree_unlock
go
create procedure iu_regtree_unlock /* структура документации */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_regtree_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_regtree set lockuserid =null  where iu_regtreeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_regtree set locksessionid =null  where iu_regtreeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_regtree_client_trigger
GO

create procedure iu_regtree_client_trigger  (
 acursession varchar(38),
 aiu_regtreeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_regdocs_parent
go
create procedure iu_regdocs_parent /* документы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from iu_regdocs where  iu_regdocsid=arowid;
  set aparenttable = 'iu_regtree';
 end 
go
GO


drop procedure if exists iu_regdocs_islocked
go
create procedure iu_regdocs_islocked /* документы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_regdocs where iu_regdocsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_regdocs_lock
go
create procedure iu_regdocs_lock /* документы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_regdocs_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_regdocs set lockuserid =auserid ,locksessionid=null  where iu_regdocsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_regdocs set lockuserid=null ,locksessionid =acursession  where iu_regdocsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_regdocs_unlock
go
create procedure iu_regdocs_unlock /* документы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_regdocs_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_regdocs set lockuserid =null  where iu_regdocsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_regdocs set locksessionid =null  where iu_regdocsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_regdocs_client_trigger
GO

create procedure iu_regdocs_client_trigger  (
 acursession varchar(38),
 aiu_regdocsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_status_brief
go

create procedure iu_status_brief  (
 acursession varchar(38),
 aiu_statusid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_statusid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_status where iu_statusid=g2b(aiu_statusid);
 if  aec &gt;0 then
   set abrief=iu_status_brief_f(g2b(aiu_statusid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_status_delete
go

create procedure iu_status_delete /*статус урока*/ (
 acursession varchar(38),
 aiu_statusid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_status where iu_statusid=g2b(aiu_statusid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_status' result;
    leave body;
  end if;
 call iu_status_logger(acursession,aiu_statusid) ; 
  delete from  iu_status 
  where  iu_statusid = g2b(aiu_statusid) ;
  delete from num_values where ownerpartname='iu_status' and ownerrowid=g2b(aiu_statusid);
  end if;
    select 'ok' result;
 end 
go
GO

/*подэтап*/

drop procedure if exists iu_status_save
go

create procedure iu_status_save /*статус урока*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_statusid varchar(38)
,asequence
 integer/* порядок вывода *//* порядок вывода */
,atheprocess varchar(38)/* процесс *//* процесс */
,athestage varchar(38)/* этап *//* этап */
,aname
 varchar (120)/* название *//* название */
,aisstartupstate
 integer/* это начало *//* это начало */
,aisfinishstate
 integer/* это завершение  *//* это завершение  */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_status where iu_statusid=g2b(aiu_statusid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_status' result;
    leave body;
  end if;
 start transaction ; 
 call iu_status_logger(acursession,aiu_statusid) ; 
 update  iu_status set changestamp=now()
,
  sequence=asequence
,
  theprocess=g2b(atheprocess)
,
  thestage=g2b(athestage)
,
  name=aname
,
  isstartupstate=aisstartupstate
,
  isfinishstate=aisfinishstate
  where  iu_statusid = g2b(aiu_statusid) ;


call iu_status_client_trigger(acursession,aiu_statusid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_status' result;
    leave body;
  end if;
select count(*) into aec from iu_status where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_status&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_status
 (  iu_statusid 
,instanceid
,sequence

,theprocess

,thestage

,name

,isstartupstate

,isfinishstate

 ) values ( g2b(aiu_statusid) 
,g2b(ainstanceid)
,asequence

,g2b(atheprocess)

,g2b(athestage)

,aname

,aisstartupstate

,aisfinishstate

 ) ;


call iu_status_client_trigger(acursession,aiu_statusid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_status_copy
go

create procedure iu_status_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_status 
 ( iu_statusid 
,instanceid
,sequence

,theprocess

,thestage

,name

,isstartupstate

,isfinishstate

 ) select 
copymap(acopyaction,b2g(iu_statusid)) 
,copymap(acopyaction,b2g(instanceid))
,sequence

,theprocess

,thestage

,name

,isstartupstate

,isfinishstate

 from iu_status
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_status_logger
go

create procedure iu_status_logger /*статус урока*/ (
 acursession varchar(38),
 aiu_statusid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_status_parent
go
create procedure iu_status_parent /* статус урока*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_status where  iu_statusid=arowid;
 end 
go
GO


drop procedure if exists iu_status_islocked
go
create procedure iu_status_islocked /* статус урока */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_status where iu_statusid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_status_lock
go
create procedure iu_status_lock /* статус урока */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_status_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_status set lockuserid =auserid ,locksessionid=null  where iu_statusid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_status set lockuserid=null ,locksessionid =acursession  where iu_statusid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_status_unlock
go
create procedure iu_status_unlock /* статус урока */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_status_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_status set lockuserid =null  where iu_statusid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_status set locksessionid =null  where iu_statusid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_status_client_trigger
GO

create procedure iu_status_client_trigger  (
 acursession varchar(38),
 aiu_statusid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_status_doer_brief
go

create procedure iu_status_doer_brief  (
 acursession varchar(38),
 aiu_status_doerid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_status_doerid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_status_doer where iu_status_doerid=g2b(aiu_status_doerid);
 if  aec &gt;0 then
   set abrief=iu_status_doer_brief_f(g2b(aiu_status_doerid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_status_doer_delete
go

create procedure iu_status_doer_delete /*проверка на наличие назначенных исполнителей*/ (
 acursession varchar(38),
 aiu_status_doerid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_status_doer where iu_status_doerid=g2b(aiu_status_doerid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_status_doer' result;
    leave body;
  end if;
 call iu_status_doer_logger(acursession,aiu_status_doerid) ; 
  delete from  iu_status_doer 
  where  iu_status_doerid = g2b(aiu_status_doerid) ;
  delete from num_values where ownerpartname='iu_status_doer' and ownerrowid=g2b(aiu_status_doerid);
  end if;
    select 'ok' result;
 end 
go
GO

/*необходимые исполнители*/

drop procedure if exists iu_status_doer_save
go

create procedure iu_status_doer_save /*проверка на наличие назначенных исполнителей*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_status_doerid varchar(38)
,adoertype varchar(38)/* тип исполнителя *//* тип исполнителя */
,adoerallowed
 integer/* наличие обязательно *//* наличие обязательно */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_status_doer where iu_status_doerid=g2b(aiu_status_doerid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_status_doer' result;
    leave body;
  end if;
 start transaction ; 
 call iu_status_doer_logger(acursession,aiu_status_doerid) ; 
 update  iu_status_doer set changestamp=now()
,
  doertype=g2b(adoertype)
,
  doerallowed=adoerallowed
  where  iu_status_doerid = g2b(aiu_status_doerid) ;


call iu_status_doer_client_trigger(acursession,aiu_status_doerid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_status_doer' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_status_doer
 (  iu_status_doerid 
,instanceid
,doertype

,doerallowed

 ) values ( g2b(aiu_status_doerid) 
,g2b(ainstanceid)
,g2b(adoertype)

,adoerallowed

 ) ;


call iu_status_doer_client_trigger(acursession,aiu_status_doerid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_status_doer_copy
go

create procedure iu_status_doer_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_status_doer 
 ( iu_status_doerid 
,instanceid
,doertype

,doerallowed

 ) select 
copymap(acopyaction,b2g(iu_status_doerid)) 
,copymap(acopyaction,b2g(instanceid))
,doertype

,doerallowed

 from iu_status_doer
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_status_doer_logger
go

create procedure iu_status_doer_logger /*проверка на наличие назначенных исполнителей*/ (
 acursession varchar(38),
 aiu_status_doerid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_status_doer_parent
go
create procedure iu_status_doer_parent /* проверка на наличие назначенных исполнителей*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_status_doer where  iu_status_doerid=arowid;
 end 
go
GO


drop procedure if exists iu_status_doer_islocked
go
create procedure iu_status_doer_islocked /* проверка на наличие назначенных исполнителей */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_status_doer where iu_status_doerid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_status_doer_lock
go
create procedure iu_status_doer_lock /* проверка на наличие назначенных исполнителей */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_status_doer_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_status_doer set lockuserid =auserid ,locksessionid=null  where iu_status_doerid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_status_doer set lockuserid=null ,locksessionid =acursession  where iu_status_doerid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_status_doer_unlock
go
create procedure iu_status_doer_unlock /* проверка на наличие назначенных исполнителей */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_status_doer_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_status_doer set lockuserid =null  where iu_status_doerid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_status_doer set locksessionid =null  where iu_status_doerid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_status_doer_client_trigger
GO

create procedure iu_status_doer_client_trigger  (
 acursession varchar(38),
 aiu_status_doerid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_statustask_brief
go

create procedure iu_statustask_brief  (
 acursession varchar(38),
 aiu_statustaskid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_statustaskid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_statustask where iu_statustaskid=g2b(aiu_statustaskid);
 if  aec &gt;0 then
   set abrief=iu_statustask_brief_f(g2b(aiu_statustaskid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_statustask_delete
go

create procedure iu_statustask_delete /*задачи  для данного состояния*/ (
 acursession varchar(38),
 aiu_statustaskid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_statustask where iu_statustaskid=g2b(aiu_statustaskid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_statustask' result;
    leave body;
  end if;
 call iu_statustask_logger(acursession,aiu_statustaskid) ; 
  delete from  iu_statustask 
  where  iu_statustaskid = g2b(aiu_statustaskid) ;
  delete from num_values where ownerpartname='iu_statustask' and ownerrowid=g2b(aiu_statustaskid);
  end if;
    select 'ok' result;
 end 
go
GO

/*задачи*/

drop procedure if exists iu_statustask_save
go

create procedure iu_statustask_save /*задачи  для данного состояния*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_statustaskid varchar(38)
,aname
 varchar (255)/* название задачи *//* название задачи */
,adoertype varchar(38)/* тип исполнителя *//* тип исполнителя */
,aduration_plan
 integer/* плановая длительность *//* плановая длительность */
,ainfo
 varchar (8000)/* описание *//* описание */
,acontoller varchar(38)/* кто контролирует *//* кто контролирует */
,astatusonclose varchar(38)/* статус по завершению *//* статус по завершению */
,apossiblestatuses
 varchar (255)/* альтернативные статусы *//* альтернативные статусы */
,afinishallowed
 integer/* завершение обязательно *//* завершение обязательно */
,atasksequence
 integer/* последовательность исполнения *//* последовательность исполнения */
,aafterall
 integer/* после всех предыдущих *//* после всех предыдущих */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_statustask where iu_statustaskid=g2b(aiu_statustaskid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_statustask' result;
    leave body;
  end if;
 start transaction ; 
 call iu_statustask_logger(acursession,aiu_statustaskid) ; 
 update  iu_statustask set changestamp=now()
,
  name=aname
,
  doertype=g2b(adoertype)
,
  duration_plan=aduration_plan
,
  info=ainfo
,
  contoller=g2b(acontoller)
,
  statusonclose=g2b(astatusonclose)
,
  possiblestatuses=apossiblestatuses
,
  finishallowed=afinishallowed
,
  tasksequence=atasksequence
,
  afterall=aafterall
  where  iu_statustaskid = g2b(aiu_statustaskid) ;


call iu_statustask_client_trigger(acursession,aiu_statustaskid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_statustask' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_statustask
 (  iu_statustaskid 
,instanceid
,name

,doertype

,duration_plan

,info

,contoller

,statusonclose

,possiblestatuses

,finishallowed

,tasksequence

,afterall

 ) values ( g2b(aiu_statustaskid) 
,g2b(ainstanceid)
,aname

,g2b(adoertype)

,aduration_plan

,ainfo

,g2b(acontoller)

,g2b(astatusonclose)

,apossiblestatuses

,afinishallowed

,atasksequence

,aafterall

 ) ;


call iu_statustask_client_trigger(acursession,aiu_statustaskid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_state_tasklink_brief
go

create procedure iu_state_tasklink_brief  (
 acursession varchar(38),
 aiu_state_tasklinkid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_state_tasklinkid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_state_tasklink where iu_state_tasklinkid=g2b(aiu_state_tasklinkid);
 if  aec &gt;0 then
   set abrief=iu_state_tasklink_brief_f(g2b(aiu_state_tasklinkid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_state_tasklink_delete
go

create procedure iu_state_tasklink_delete /*какие ссылки надо включить в описание задачи*/ (
 acursession varchar(38),
 aiu_state_tasklinkid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_state_tasklink where iu_state_tasklinkid=g2b(aiu_state_tasklinkid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_state_tasklink' result;
    leave body;
  end if;
 call iu_state_tasklink_logger(acursession,aiu_state_tasklinkid) ; 
  delete from  iu_state_tasklink 
  where  iu_state_tasklinkid = g2b(aiu_state_tasklinkid) ;
  delete from num_values where ownerpartname='iu_state_tasklink' and ownerrowid=g2b(aiu_state_tasklinkid);
  end if;
    select 'ok' result;
 end 
go
GO

/*ссылки к задаче*/

drop procedure if exists iu_state_tasklink_save
go

create procedure iu_state_tasklink_save /*какие ссылки надо включить в описание задачи*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aiu_state_tasklinkid varchar(38)
,adoctype varchar(38)/* тип документа *//* тип документа */
,aallversions
 integer/* все версии *//* все версии */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_state_tasklink where iu_state_tasklinkid=g2b(aiu_state_tasklinkid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_state_tasklink' result;
    leave body;
  end if;
 start transaction ; 
 call iu_state_tasklink_logger(acursession,aiu_state_tasklinkid) ; 
 update  iu_state_tasklink set changestamp=now()
,
  doctype=g2b(adoctype)
,
  allversions=aallversions
  where  iu_state_tasklinkid = g2b(aiu_state_tasklinkid) ;


call iu_state_tasklink_client_trigger(acursession,aiu_state_tasklinkid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_state_tasklink' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_state_tasklink
 (  iu_state_tasklinkid 
,parentstructrowid
,doctype

,allversions

 ) values ( g2b(aiu_state_tasklinkid) 
,g2b(aparentstructrowid)
,g2b(adoctype)

,aallversions

 ) ;


call iu_state_tasklink_client_trigger(acursession,aiu_state_tasklinkid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_state_tasklink_copy
go

create procedure iu_state_tasklink_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_state_tasklink 
 ( iu_state_tasklinkid 
,parentstructrowid
,doctype

,allversions

 ) select 
copymap(acopyaction,b2g(iu_state_tasklinkid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,doctype

,allversions

 from iu_state_tasklink
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists iu_statustask_copy
go

create procedure iu_statustask_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_iu_statustask cursor for
select iu_statustaskid from iu_statustask where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_statustask 
 ( iu_statustaskid 
,instanceid
,name

,doertype

,duration_plan

,info

,contoller

,statusonclose

,possiblestatuses

,finishallowed

,tasksequence

,afterall

 ) select 
copymap(acopyaction,b2g(iu_statustaskid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,doertype

,duration_plan

,info

,contoller

,statusonclose

,possiblestatuses

,finishallowed

,tasksequence

,afterall

 from iu_statustask
 where instanceid =g2b( ainstanceid); 
open copy_cursor_iu_statustask;
  set  fetch_done=false;
fetch copy_cursor_iu_statustask into aid;
while not fetch_done do 
    call iu_state_tasklink_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_iu_statustask into aid;
end while;

close copy_cursor_iu_statustask;
 end 
go
GO


drop procedure if exists iu_statustask_logger
go

create procedure iu_statustask_logger /*задачи  для данного состояния*/ (
 acursession varchar(38),
 aiu_statustaskid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_state_tasklink_logger
go

create procedure iu_state_tasklink_logger /*какие ссылки надо включить в описание задачи*/ (
 acursession varchar(38),
 aiu_state_tasklinkid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_statustask_parent
go
create procedure iu_statustask_parent /* задачи  для данного состояния*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_statustask where  iu_statustaskid=arowid;
 end 
go
GO


drop procedure if exists iu_statustask_islocked
go
create procedure iu_statustask_islocked /* задачи  для данного состояния */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_statustask where iu_statustaskid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_statustask_lock
go
create procedure iu_statustask_lock /* задачи  для данного состояния */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_statustask_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_statustask set lockuserid =auserid ,locksessionid=null  where iu_statustaskid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_statustask set lockuserid=null ,locksessionid =acursession  where iu_statustaskid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_statustask_unlock
go
create procedure iu_statustask_unlock /* задачи  для данного состояния */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_statustask_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_statustask set lockuserid =null  where iu_statustaskid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_statustask set locksessionid =null  where iu_statustaskid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_statustask_client_trigger
GO

create procedure iu_statustask_client_trigger  (
 acursession varchar(38),
 aiu_statustaskid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_state_tasklink_parent
go
create procedure iu_state_tasklink_parent /* какие ссылки надо включить в описание задачи*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from iu_state_tasklink where  iu_state_tasklinkid=arowid;
  set aparenttable = 'iu_statustask';
 end 
go
GO


drop procedure if exists iu_state_tasklink_islocked
go
create procedure iu_state_tasklink_islocked /* какие ссылки надо включить в описание задачи */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_state_tasklink where iu_state_tasklinkid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_state_tasklink_lock
go
create procedure iu_state_tasklink_lock /* какие ссылки надо включить в описание задачи */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_state_tasklink_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_state_tasklink set lockuserid =auserid ,locksessionid=null  where iu_state_tasklinkid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_state_tasklink set lockuserid=null ,locksessionid =acursession  where iu_state_tasklinkid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_state_tasklink_unlock
go
create procedure iu_state_tasklink_unlock /* какие ссылки надо включить в описание задачи */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_state_tasklink_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_state_tasklink set lockuserid =null  where iu_state_tasklinkid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_state_tasklink set locksessionid =null  where iu_state_tasklinkid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_state_tasklink_client_trigger
GO

create procedure iu_state_tasklink_client_trigger  (
 acursession varchar(38),
 aiu_state_tasklinkid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_stausdoc_brief
go

create procedure iu_stausdoc_brief  (
 acursession varchar(38),
 aiu_stausdocid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_stausdocid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_stausdoc where iu_stausdocid=g2b(aiu_stausdocid);
 if  aec &gt;0 then
   set abrief=iu_stausdoc_brief_f(g2b(aiu_stausdocid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_stausdoc_delete
go

create procedure iu_stausdoc_delete /*проверка на полноту пакета документов*/ (
 acursession varchar(38),
 aiu_stausdocid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_stausdoc where iu_stausdocid=g2b(aiu_stausdocid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_stausdoc' result;
    leave body;
  end if;
 call iu_stausdoc_logger(acursession,aiu_stausdocid) ; 
  delete from  iu_stausdoc 
  where  iu_stausdocid = g2b(aiu_stausdocid) ;
  delete from num_values where ownerpartname='iu_stausdoc' and ownerrowid=g2b(aiu_stausdocid);
  end if;
    select 'ok' result;
 end 
go
GO

/*пакет документов*/

drop procedure if exists iu_stausdoc_save
go

create procedure iu_stausdoc_save /*проверка на полноту пакета документов*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_stausdocid varchar(38)
,adoctype varchar(38)/* тип документа *//* тип документа */
,aallowdoc
 integer/* требовать наличия при проверке *//* требовать наличия при проверке */
,aname
 varchar (255)/* название документа *//* название документа */
,ainfo
 varchar (255)/* дополнительное описание *//* дополнительное описание */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_stausdoc where iu_stausdocid=g2b(aiu_stausdocid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_stausdoc' result;
    leave body;
  end if;
 start transaction ; 
 call iu_stausdoc_logger(acursession,aiu_stausdocid) ; 
 update  iu_stausdoc set changestamp=now()
,
  doctype=g2b(adoctype)
,
  allowdoc=aallowdoc
,
  name=aname
,
  info=ainfo
  where  iu_stausdocid = g2b(aiu_stausdocid) ;


call iu_stausdoc_client_trigger(acursession,aiu_stausdocid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_stausdoc' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_stausdoc
 (  iu_stausdocid 
,instanceid
,doctype

,allowdoc

,name

,info

 ) values ( g2b(aiu_stausdocid) 
,g2b(ainstanceid)
,g2b(adoctype)

,aallowdoc

,aname

,ainfo

 ) ;


call iu_stausdoc_client_trigger(acursession,aiu_stausdocid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_stausdoc_copy
go

create procedure iu_stausdoc_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_stausdoc 
 ( iu_stausdocid 
,instanceid
,doctype

,allowdoc

,name

,info

 ) select 
copymap(acopyaction,b2g(iu_stausdocid)) 
,copymap(acopyaction,b2g(instanceid))
,doctype

,allowdoc

,name

,info

 from iu_stausdoc
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_stausdoc_logger
go

create procedure iu_stausdoc_logger /*проверка на полноту пакета документов*/ (
 acursession varchar(38),
 aiu_stausdocid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_stausdoc_parent
go
create procedure iu_stausdoc_parent /* проверка на полноту пакета документов*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_stausdoc where  iu_stausdocid=arowid;
 end 
go
GO


drop procedure if exists iu_stausdoc_islocked
go
create procedure iu_stausdoc_islocked /* проверка на полноту пакета документов */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_stausdoc where iu_stausdocid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_stausdoc_lock
go
create procedure iu_stausdoc_lock /* проверка на полноту пакета документов */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_stausdoc_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_stausdoc set lockuserid =auserid ,locksessionid=null  where iu_stausdocid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_stausdoc set lockuserid=null ,locksessionid =acursession  where iu_stausdocid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_stausdoc_unlock
go
create procedure iu_stausdoc_unlock /* проверка на полноту пакета документов */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_stausdoc_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_stausdoc set lockuserid =null  where iu_stausdocid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_stausdoc set locksessionid =null  where iu_stausdocid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_stausdoc_client_trigger
GO

create procedure iu_stausdoc_client_trigger  (
 acursession varchar(38),
 aiu_stausdocid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_statusnext_brief
go

create procedure iu_statusnext_brief  (
 acursession varchar(38),
 aiu_statusnextid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_statusnextid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_statusnext where iu_statusnextid=g2b(aiu_statusnextid);
 if  aec &gt;0 then
   set abrief=iu_statusnext_brief_f(g2b(aiu_statusnextid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_statusnext_delete
go

create procedure iu_statusnext_delete /*возможные переходы*/ (
 acursession varchar(38),
 aiu_statusnextid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_statusnext where iu_statusnextid=g2b(aiu_statusnextid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_statusnext' result;
    leave body;
  end if;
 call iu_statusnext_logger(acursession,aiu_statusnextid) ; 
  delete from  iu_statusnext 
  where  iu_statusnextid = g2b(aiu_statusnextid) ;
  delete from num_values where ownerpartname='iu_statusnext' and ownerrowid=g2b(aiu_statusnextid);
  end if;
    select 'ok' result;
 end 
go
GO

/*возможные переходы*/

drop procedure if exists iu_statusnext_save
go

create procedure iu_statusnext_save /*возможные переходы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_statusnextid varchar(38)
,anextstatus varchar(38)/* следующий подэтап *//* следующий подэтап */
,astatusafter varchar(38)/* статус по завершению *//* статус по завершению */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_statusnext where iu_statusnextid=g2b(aiu_statusnextid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_statusnext' result;
    leave body;
  end if;
 start transaction ; 
 call iu_statusnext_logger(acursession,aiu_statusnextid) ; 
 update  iu_statusnext set changestamp=now()
,
  nextstatus=g2b(anextstatus)
,
  statusafter=g2b(astatusafter)
  where  iu_statusnextid = g2b(aiu_statusnextid) ;


call iu_statusnext_client_trigger(acursession,aiu_statusnextid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_statusnext' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_statusnext
 (  iu_statusnextid 
,instanceid
,nextstatus

,statusafter

 ) values ( g2b(aiu_statusnextid) 
,g2b(ainstanceid)
,g2b(anextstatus)

,g2b(astatusafter)

 ) ;


call iu_statusnext_client_trigger(acursession,aiu_statusnextid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_statuschanger_brief
go

create procedure iu_statuschanger_brief  (
 acursession varchar(38),
 aiu_statuschangerid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_statuschangerid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_statuschanger where iu_statuschangerid=g2b(aiu_statuschangerid);
 if  aec &gt;0 then
   set abrief=iu_statuschanger_brief_f(g2b(aiu_statuschangerid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_statuschanger_delete
go

create procedure iu_statuschanger_delete /*может перевести*/ (
 acursession varchar(38),
 aiu_statuschangerid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_statuschanger where iu_statuschangerid=g2b(aiu_statuschangerid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_statuschanger' result;
    leave body;
  end if;
 call iu_statuschanger_logger(acursession,aiu_statuschangerid) ; 
  delete from  iu_statuschanger 
  where  iu_statuschangerid = g2b(aiu_statuschangerid) ;
  delete from num_values where ownerpartname='iu_statuschanger' and ownerrowid=g2b(aiu_statuschangerid);
  end if;
    select 'ok' result;
 end 
go
GO

/*может перевести*/

drop procedure if exists iu_statuschanger_save
go

create procedure iu_statuschanger_save /*может перевести*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aiu_statuschangerid varchar(38)
,awhocan varchar(38)/* роль в процессе *//* роль в процессе */
,acheckdocuments
 integer/* с проверкой документов *//* с проверкой документов */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_statuschanger where iu_statuschangerid=g2b(aiu_statuschangerid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_statuschanger' result;
    leave body;
  end if;
 start transaction ; 
 call iu_statuschanger_logger(acursession,aiu_statuschangerid) ; 
 update  iu_statuschanger set changestamp=now()
,
  whocan=g2b(awhocan)
,
  checkdocuments=acheckdocuments
  where  iu_statuschangerid = g2b(aiu_statuschangerid) ;


call iu_statuschanger_client_trigger(acursession,aiu_statuschangerid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_s.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_statuschanger' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_statuschanger
 (  iu_statuschangerid 
,parentstructrowid
,whocan

,checkdocuments

 ) values ( g2b(aiu_statuschangerid) 
,g2b(aparentstructrowid)
,g2b(awhocan)

,acheckdocuments

 ) ;


call iu_statuschanger_client_trigger(acursession,aiu_statuschangerid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_statuschanger_copy
go

create procedure iu_statuschanger_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_statuschanger 
 ( iu_statuschangerid 
,parentstructrowid
,whocan

,checkdocuments

 ) select 
copymap(acopyaction,b2g(iu_statuschangerid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,whocan

,checkdocuments

 from iu_statuschanger
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists iu_statusnext_copy
go

create procedure iu_statusnext_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_iu_statusnext cursor for
select iu_statusnextid from iu_statusnext where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_statusnext 
 ( iu_statusnextid 
,instanceid
,nextstatus

,statusafter

 ) select 
copymap(acopyaction,b2g(iu_statusnextid)) 
,copymap(acopyaction,b2g(instanceid))
,nextstatus

,statusafter

 from iu_statusnext
 where instanceid =g2b( ainstanceid); 
open copy_cursor_iu_statusnext;
  set  fetch_done=false;
fetch copy_cursor_iu_statusnext into aid;
while not fetch_done do 
    call iu_statuschanger_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_iu_statusnext into aid;
end while;

close copy_cursor_iu_statusnext;
 end 
go
GO


drop procedure if exists iu_statusnext_logger
go

create procedure iu_statusnext_logger /*возможные переходы*/ (
 acursession varchar(38),
 aiu_statusnextid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_statuschanger_logger
go

create procedure iu_statuschanger_logger /*может перевести*/ (
 acursession varchar(38),
 aiu_statuschangerid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_statusnext_parent
go
create procedure iu_statusnext_parent /* возможные переходы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_statusnext where  iu_statusnextid=arowid;
 end 
go
GO


drop procedure if exists iu_statusnext_islocked
go
create procedure iu_statusnext_islocked /* возможные переходы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_statusnext where iu_statusnextid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_statusnext_lock
go
create procedure iu_statusnext_lock /* возможные переходы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_statusnext_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_statusnext set lockuserid =auserid ,locksessionid=null  where iu_statusnextid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_statusnext set lockuserid=null ,locksessionid =acursession  where iu_statusnextid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_statusnext_unlock
go
create procedure iu_statusnext_unlock /* возможные переходы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_statusnext_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_statusnext set lockuserid =null  where iu_statusnextid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_statusnext set locksessionid =null  where iu_statusnextid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_statusnext_client_trigger
GO

create procedure iu_statusnext_client_trigger  (
 acursession varchar(38),
 aiu_statusnextid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_statuschanger_parent
go
create procedure iu_statuschanger_parent /* может перевести*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from iu_statuschanger where  iu_statuschangerid=arowid;
  set aparenttable = 'iu_statusnext';
 end 
go
GO


drop procedure if exists iu_statuschanger_islocked
go
create procedure iu_statuschanger_islocked /* может перевести */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_statuschanger where iu_statuschangerid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_statuschanger_lock
go
create procedure iu_statuschanger_lock /* может перевести */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_statuschanger_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_statuschanger set lockuserid =auserid ,locksessionid=null  where iu_statuschangerid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_statuschanger set lockuserid=null ,locksessionid =acursession  where iu_statuschangerid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_statuschanger_unlock
go
create procedure iu_statuschanger_unlock /* может перевести */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_statuschanger_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_statuschanger set lockuserid =null  where iu_statuschangerid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_statuschanger set locksessionid =null  where iu_statuschangerid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_statuschanger_client_trigger
GO

create procedure iu_statuschanger_client_trigger  (
 acursession varchar(38),
 aiu_statuschangerid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists mtz2job_def_brief
go

create procedure mtz2job_def_brief  (
 acursession varchar(38),
 amtz2job_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if amtz2job_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from mtz2job_def where mtz2job_defid=g2b(amtz2job_defid);
 if  aec &gt;0 then
   set abrief=mtz2job_def_brief_f(g2b(amtz2job_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists mtz2job_def_delete
go

create procedure mtz2job_def_delete /*описание отложенного события*/ (
 acursession varchar(38),
 amtz2job_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from mtz2job_def where mtz2job_defid=g2b(amtz2job_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtz2job.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=mtz2job_def' result;
    leave body;
  end if;
 call mtz2job_def_logger(acursession,amtz2job_defid) ; 
  delete from  mtz2job_def 
  where  mtz2job_defid = g2b(amtz2job_defid) ;
  delete from num_values where ownerpartname='mtz2job_def' and ownerrowid=g2b(amtz2job_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*отложенное событие*/

drop procedure if exists mtz2job_def_save
go

create procedure mtz2job_def_save /*описание отложенного события*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 amtz2job_defid varchar(38)
,aeventdate
 datetime/* отложено до *//* отложено до */
,aeventype
 varchar (255)/* тип события *//* тип события */
,athruobject varchar(38)/* объект - причина события *//* объект - причина события */
,athrustate binary(16)/* состояние - причина *//* состояние - причина */
,anextstate binary(16)/* состояние после обработки *//* состояние после обработки */
,aprocessdate
 datetime/* момент обработки *//* момент обработки */
,aprocessed
 integer/* обработан *//* обработан */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from mtz2job_def where mtz2job_defid=g2b(amtz2job_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtz2job.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=mtz2job_def' result;
    leave body;
  end if;
 start transaction ; 
 call mtz2job_def_logger(acursession,amtz2job_defid) ; 
 update  mtz2job_def set changestamp=now()
,
  eventdate=aeventdate
,
  eventype=aeventype
,
  thruobject=g2b(athruobject)
,
  thrustate=athrustate
,
  nextstate=anextstate
,
  processdate=aprocessdate
,
  processed=aprocessed
  where  mtz2job_defid = g2b(amtz2job_defid) ;


call mtz2job_def_client_trigger(acursession,amtz2job_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtz2job.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=mtz2job_def' result;
    leave body;
  end if;
 start transaction;  
 insert into   mtz2job_def
 (  mtz2job_defid 
,instanceid
,eventdate

,eventype

,thruobject

,thrustate

,nextstate

,processdate

,processed

 ) values ( g2b(amtz2job_defid) 
,g2b(ainstanceid)
,aeventdate

,aeventype

,g2b(athruobject)

,athrustate

,anextstate

,aprocessdate

,aprocessed

 ) ;


call mtz2job_def_client_trigger(acursession,amtz2job_defid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists mtz2job_def_copy
go

create procedure mtz2job_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into mtz2job_def 
 ( mtz2job_defid 
,instanceid
,eventdate

,eventype

,thruobject

,thrustate

,nextstate

,processdate

,processed

 ) select 
copymap(acopyaction,b2g(mtz2job_defid)) 
,copymap(acopyaction,b2g(instanceid))
,eventdate

,eventype

,thruobject

,thrustate

,nextstate

,processdate

,processed

 from mtz2job_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists mtz2job_def_logger
go

create procedure mtz2job_def_logger /*описание отложенного события*/ (
 acursession varchar(38),
 amtz2job_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists mtz2job_def_parent
go
create procedure mtz2job_def_parent /* описание отложенного события*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from mtz2job_def where  mtz2job_defid=arowid;
 end 
go
GO


drop procedure if exists mtz2job_def_islocked
go
create procedure mtz2job_def_islocked /* описание отложенного события */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from mtz2job_def where mtz2job_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists mtz2job_def_lock
go
create procedure mtz2job_def_lock /* описание отложенного события */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call mtz2job_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update mtz2job_def set lockuserid =auserid ,locksessionid=null  where mtz2job_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update mtz2job_def set lockuserid=null ,locksessionid =acursession  where mtz2job_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists mtz2job_def_unlock
go
create procedure mtz2job_def_unlock /* описание отложенного события */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call mtz2job_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update mtz2job_def set lockuserid =null  where mtz2job_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update mtz2job_def set locksessionid =null  where mtz2job_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS mtz2job_def_client_trigger
GO

create procedure mtz2job_def_client_trigger  (
 acursession varchar(38),
 aMTZ2JOB_DEFid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_ctype_brief
go

create procedure iud_ctype_brief  (
 acursession varchar(38),
 aiud_ctypeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_ctypeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_ctype where iud_ctypeid=g2b(aiud_ctypeid);
 if  aec &gt;0 then
   set abrief=iud_ctype_brief_f(g2b(aiud_ctypeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_ctype_delete
go

create procedure iud_ctype_delete /*тип курса*/ (
 acursession varchar(38),
 aiud_ctypeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_ctype where iud_ctypeid=g2b(aiud_ctypeid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_c.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_ctype' result;
    leave body;
  end if;
 call iud_ctype_logger(acursession,aiud_ctypeid) ; 
  delete from  iud_ctype 
  where  iud_ctypeid = g2b(aiud_ctypeid) ;
  delete from num_values where ownerpartname='iud_ctype' and ownerrowid=g2b(aiud_ctypeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*тип курса*/

drop procedure if exists iud_ctype_save
go

create procedure iud_ctype_save /*тип курса*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_ctypeid varchar(38)
,aname
 varchar (120)/* название *//* название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_ctype where iud_ctypeid=g2b(aiud_ctypeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_c.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_ctype' result;
    leave body;
  end if;
 start transaction ; 
 call iud_ctype_logger(acursession,aiud_ctypeid) ; 
 update  iud_ctype set changestamp=now()
,
  name=aname
  where  iud_ctypeid = g2b(aiud_ctypeid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_ctype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=тип курса правило=(уникальность для тип курса.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_ctype_client_trigger(acursession,aiud_ctypeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_c.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_ctype' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_ctype
 (  iud_ctypeid 
,instanceid
,name

 ) values ( g2b(aiud_ctypeid) 
,g2b(ainstanceid)
,aname

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
select count(*) into  auniquerowcount from iud_ctype where 1=1  
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=тип курса правило=(уникальность для тип курса.название)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iud_ctype_client_trigger(acursession,aiud_ctypeid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_ctype_copy
go

create procedure iud_ctype_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_ctype 
 ( iud_ctypeid 
,instanceid
,name

 ) select 
copymap(acopyaction,b2g(iud_ctypeid)) 
,copymap(acopyaction,b2g(instanceid))
,name

 from iud_ctype
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_ctype_logger
go

create procedure iud_ctype_logger /*тип курса*/ (
 acursession varchar(38),
 aiud_ctypeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_ctype_parent
go
create procedure iud_ctype_parent /* тип курса*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_ctype where  iud_ctypeid=arowid;
 end 
go
GO


drop procedure if exists iud_ctype_islocked
go
create procedure iud_ctype_islocked /* тип курса */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_ctype where iud_ctypeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_ctype_lock
go
create procedure iud_ctype_lock /* тип курса */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_ctype_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_ctype set lockuserid =auserid ,locksessionid=null  where iud_ctypeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_ctype set lockuserid=null ,locksessionid =acursession  where iud_ctypeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_ctype_unlock
go
create procedure iud_ctype_unlock /* тип курса */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_ctype_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_ctype set lockuserid =null  where iud_ctypeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_ctype set locksessionid =null  where iud_ctypeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_ctype_client_trigger
GO

create procedure iud_ctype_client_trigger  (
 acursession varchar(38),
 aiud_ctypeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iud_spub_brief
go

create procedure iud_spub_brief  (
 acursession varchar(38),
 aiud_spubid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiud_spubid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iud_spub where iud_spubid=g2b(aiud_spubid);
 if  aec &gt;0 then
   set abrief=iud_spub_brief_f(g2b(aiud_spubid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iud_spub_delete
go

create procedure iud_spub_delete /*статус публикации*/ (
 acursession varchar(38),
 aiud_spubid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_spub where iud_spubid=g2b(aiud_spubid);
if aec&gt;0 then
 select checkoperation( acursession ,'iud_sp.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iud_spub' result;
    leave body;
  end if;
 call iud_spub_logger(acursession,aiud_spubid) ; 
  delete from  iud_spub 
  where  iud_spubid = g2b(aiud_spubid) ;
  delete from num_values where ownerpartname='iud_spub' and ownerrowid=g2b(aiud_spubid);
  end if;
    select 'ok' result;
 end 
go
GO

/*статус публикации*/

drop procedure if exists iud_spub_save
go

create procedure iud_spub_save /*статус публикации*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiud_spubid varchar(38)
,aname
 varchar (120)/* название *//* название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iud_spub where iud_spubid=g2b(aiud_spubid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iud_sp.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iud_spub' result;
    leave body;
  end if;
 start transaction ; 
 call iud_spub_logger(acursession,aiud_spubid) ; 
 update  iud_spub set changestamp=now()
,
  name=aname
  where  iud_spubid = g2b(aiud_spubid) ;


call iud_spub_client_trigger(acursession,aiud_spubid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iud_sp.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iud_spub' result;
    leave body;
  end if;
 start transaction;  
 insert into   iud_spub
 (  iud_spubid 
,instanceid
,name

 ) values ( g2b(aiud_spubid) 
,g2b(ainstanceid)
,aname

 ) ;


call iud_spub_client_trigger(acursession,aiud_spubid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iud_spub_copy
go

create procedure iud_spub_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iud_spub 
 ( iud_spubid 
,instanceid
,name

 ) select 
copymap(acopyaction,b2g(iud_spubid)) 
,copymap(acopyaction,b2g(instanceid))
,name

 from iud_spub
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iud_spub_logger
go

create procedure iud_spub_logger /*статус публикации*/ (
 acursession varchar(38),
 aiud_spubid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iud_spub_parent
go
create procedure iud_spub_parent /* статус публикации*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iud_spub where  iud_spubid=arowid;
 end 
go
GO


drop procedure if exists iud_spub_islocked
go
create procedure iud_spub_islocked /* статус публикации */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iud_spub where iud_spubid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iud_spub_lock
go
create procedure iud_spub_lock /* статус публикации */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iud_spub_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iud_spub set lockuserid =auserid ,locksessionid=null  where iud_spubid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iud_spub set lockuserid=null ,locksessionid =acursession  where iud_spubid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iud_spub_unlock
go
create procedure iud_spub_unlock /* статус публикации */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iud_spub_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iud_spub set lockuserid =null  where iud_spubid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iud_spub set locksessionid =null  where iud_spubid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iud_spub_client_trigger
GO

create procedure iud_spub_client_trigger  (
 acursession varchar(38),
 aiud_spubid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists filterfieldgroup_brief
go

create procedure filterfieldgroup_brief  (
 acursession varchar(38),
 afilterfieldgroupid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afilterfieldgroupid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from filterfieldgroup where filterfieldgroupid=g2b(afilterfieldgroupid);
 if  aec &gt;0 then
   set abrief=filterfieldgroup_brief_f(g2b(afilterfieldgroupid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists filterfieldgroup_delete
go

create procedure filterfieldgroup_delete /*группа полей фильтра*/ (
 acursession varchar(38),
 afilterfieldgroupid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from filterfieldgroup where filterfieldgroupid=g2b(afilterfieldgroupid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzfltr.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=filterfieldgroup' result;
    leave body;
  end if;
 call filterfieldgroup_logger(acursession,afilterfieldgroupid) ; 
  delete from  filterfieldgroup 
  where  filterfieldgroupid = g2b(afilterfieldgroupid) ;
  delete from num_values where ownerpartname='filterfieldgroup' and ownerrowid=g2b(afilterfieldgroupid);
  end if;
    select 'ok' result;
 end 
go
GO

/*группа полей фильтра*/

drop procedure if exists filterfieldgroup_save
go

create procedure filterfieldgroup_save /*группа полей фильтра*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 afilterfieldgroupid varchar(38)
,asequence
 integer/* последовательность *//* последовательность */
,aname
 varchar (64)/* название *//* название */
,acaption
 varchar (255)/* заголовок *//* заголовок */
,aallowignore
 integer/* можно отключать *//* можно отключать */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from filterfieldgroup where filterfieldgroupid=g2b(afilterfieldgroupid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzfltr.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=filterfieldgroup' result;
    leave body;
  end if;
 start transaction ; 
 call filterfieldgroup_logger(acursession,afilterfieldgroupid) ; 
 update  filterfieldgroup set changestamp=now()
,
  sequence=asequence
,
  name=aname
,
  caption=acaption
,
  allowignore=aallowignore
  where  filterfieldgroupid = g2b(afilterfieldgroupid) ;


call filterfieldgroup_client_trigger(acursession,afilterfieldgroupid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzfltr.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=filterfieldgroup' result;
    leave body;
  end if;
 start transaction;  
 insert into   filterfieldgroup
 (  filterfieldgroupid 
,instanceid
,sequence

,name

,caption

,allowignore

 ) values ( g2b(afilterfieldgroupid) 
,g2b(ainstanceid)
,asequence

,aname

,acaption

,aallowignore

 ) ;


call filterfieldgroup_client_trigger(acursession,afilterfieldgroupid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists fileterfield_brief
go

create procedure fileterfield_brief  (
 acursession varchar(38),
 afileterfieldid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afileterfieldid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from fileterfield where fileterfieldid=g2b(afileterfieldid);
 if  aec &gt;0 then
   set abrief=fileterfield_brief_f(g2b(afileterfieldid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists fileterfield_delete
go

create procedure fileterfield_delete /*поле фильтра*/ (
 acursession varchar(38),
 afileterfieldid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fileterfield where fileterfieldid=g2b(afileterfieldid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzfltr.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=fileterfield' result;
    leave body;
  end if;
 call fileterfield_logger(acursession,afileterfieldid) ; 
  delete from  fileterfield 
  where  fileterfieldid = g2b(afileterfieldid) ;
  delete from num_values where ownerpartname='fileterfield' and ownerrowid=g2b(afileterfieldid);
  end if;
    select 'ok' result;
 end 
go
GO

/*поле фильтра*/

drop procedure if exists fileterfield_save
go

create procedure fileterfield_save /*поле фильтра*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 afileterfieldid varchar(38)
,asequence
 integer/* последовательность *//* последовательность */
,aname
 varchar (255)/* название *//* название */
,acaption
 varchar (255)/* заголовок *//* заголовок */
,afieldtype varchar(38)/* тип поля *//* тип поля */
,afieldsize
 integer/* размер *//* размер */
,areftype
 integer/* тип ссылки *//* тип ссылки */
,areftotype varchar(38)/* тип, куда ссылаемся *//* тип, куда ссылаемся */
,areftopart varchar(38)/* раздел, куда ссылаемся *//* раздел, куда ссылаемся */
,avaluearray
 integer/* массив значений *//* массив значений */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from fileterfield where fileterfieldid=g2b(afileterfieldid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzfltr.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=fileterfield' result;
    leave body;
  end if;
 start transaction ; 
 call fileterfield_logger(acursession,afileterfieldid) ; 
 update  fileterfield set changestamp=now()
,
  sequence=asequence
,
  name=aname
,
  caption=acaption
,
  fieldtype=g2b(afieldtype)
,
  fieldsize=afieldsize
,
  reftype=areftype
,
  reftotype=g2b(areftotype)
,
  reftopart=g2b(areftopart)
,
  valuearray=avaluearray
  where  fileterfieldid = g2b(afileterfieldid) ;


call fileterfield_client_trigger(acursession,afileterfieldid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzfltr.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=fileterfield' result;
    leave body;
  end if;
 start transaction;  
 insert into   fileterfield
 (  fileterfieldid 
,parentstructrowid
,sequence

,name

,caption

,fieldtype

,fieldsize

,reftype

,reftotype

,reftopart

,valuearray

 ) values ( g2b(afileterfieldid) 
,g2b(aparentstructrowid)
,asequence

,aname

,acaption

,g2b(afieldtype)

,afieldsize

,areftype

,g2b(areftotype)

,g2b(areftopart)

,avaluearray

 ) ;


call fileterfield_client_trigger(acursession,afileterfieldid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists fileterfield_copy
go

create procedure fileterfield_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into fileterfield 
 ( fileterfieldid 
,parentstructrowid
,sequence

,name

,caption

,fieldtype

,fieldsize

,reftype

,reftotype

,reftopart

,valuearray

 ) select 
copymap(acopyaction,b2g(fileterfieldid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,sequence

,name

,caption

,fieldtype

,fieldsize

,reftype

,reftotype

,reftopart

,valuearray

 from fileterfield
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists filterfieldgroup_copy
go

create procedure filterfieldgroup_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_filterfieldgroup cursor for
select filterfieldgroupid from filterfieldgroup where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into filterfieldgroup 
 ( filterfieldgroupid 
,instanceid
,sequence

,name

,caption

,allowignore

 ) select 
copymap(acopyaction,b2g(filterfieldgroupid)) 
,copymap(acopyaction,b2g(instanceid))
,sequence

,name

,caption

,allowignore

 from filterfieldgroup
 where instanceid =g2b( ainstanceid); 
open copy_cursor_filterfieldgroup;
  set  fetch_done=false;
fetch copy_cursor_filterfieldgroup into aid;
while not fetch_done do 
    call fileterfield_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_filterfieldgroup into aid;
end while;

close copy_cursor_filterfieldgroup;
 end 
go
GO


drop procedure if exists filterfieldgroup_logger
go

create procedure filterfieldgroup_logger /*группа полей фильтра*/ (
 acursession varchar(38),
 afilterfieldgroupid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists fileterfield_logger
go

create procedure fileterfield_logger /*поле фильтра*/ (
 acursession varchar(38),
 afileterfieldid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists filterfieldgroup_parent
go
create procedure filterfieldgroup_parent /* группа полей фильтра*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from filterfieldgroup where  filterfieldgroupid=arowid;
 end 
go
GO


drop procedure if exists filterfieldgroup_islocked
go
create procedure filterfieldgroup_islocked /* группа полей фильтра */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from filterfieldgroup where filterfieldgroupid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists filterfieldgroup_lock
go
create procedure filterfieldgroup_lock /* группа полей фильтра */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call filterfieldgroup_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update filterfieldgroup set lockuserid =auserid ,locksessionid=null  where filterfieldgroupid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update filterfieldgroup set lockuserid=null ,locksessionid =acursession  where filterfieldgroupid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists filterfieldgroup_unlock
go
create procedure filterfieldgroup_unlock /* группа полей фильтра */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call filterfieldgroup_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update filterfieldgroup set lockuserid =null  where filterfieldgroupid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update filterfieldgroup set locksessionid =null  where filterfieldgroupid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS filterfieldgroup_client_trigger
GO

create procedure filterfieldgroup_client_trigger  (
 acursession varchar(38),
 aFilterFieldGroupid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists fileterfield_parent
go
create procedure fileterfield_parent /* поле фильтра*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from fileterfield where  fileterfieldid=arowid;
  set aparenttable = 'filterfieldgroup';
 end 
go
GO


drop procedure if exists fileterfield_islocked
go
create procedure fileterfield_islocked /* поле фильтра */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from fileterfield where fileterfieldid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists fileterfield_lock
go
create procedure fileterfield_lock /* поле фильтра */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call fileterfield_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update fileterfield set lockuserid =auserid ,locksessionid=null  where fileterfieldid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update fileterfield set lockuserid=null ,locksessionid =acursession  where fileterfieldid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists fileterfield_unlock
go
create procedure fileterfield_unlock /* поле фильтра */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call fileterfield_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update fileterfield set lockuserid =null  where fileterfieldid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update fileterfield set locksessionid =null  where fileterfieldid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS fileterfield_client_trigger
GO

create procedure fileterfield_client_trigger  (
 acursession varchar(38),
 aFileterFieldid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists filters_brief
go

create procedure filters_brief  (
 acursession varchar(38),
 afiltersid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if afiltersid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from filters where filtersid=g2b(afiltersid);
 if  aec &gt;0 then
   set abrief=filters_brief_f(g2b(afiltersid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists filters_delete
go

create procedure filters_delete /*фильтр*/ (
 acursession varchar(38),
 afiltersid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from filters where filtersid=g2b(afiltersid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzfltr.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=filters' result;
    leave body;
  end if;
 call filters_logger(acursession,afiltersid) ; 
  delete from  filters 
  where  filtersid = g2b(afiltersid) ;
  delete from num_values where ownerpartname='filters' and ownerrowid=g2b(afiltersid);
  end if;
    select 'ok' result;
 end 
go
GO

/*фильтр*/

drop procedure if exists filters_save
go

create procedure filters_save /*фильтр*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 afiltersid varchar(38)
,aname
 varchar (255)/* название *//* название */
,athecaption
 varchar (80)/* заголовок *//* заголовок */
,athecomment
 text/* описание *//* описание */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from filters where filtersid=g2b(afiltersid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzfltr.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=filters' result;
    leave body;
  end if;
 start transaction ; 
 call filters_logger(acursession,afiltersid) ; 
 update  filters set changestamp=now()
,
  name=aname
,
  thecaption=athecaption
,
  thecomment=athecomment
  where  filtersid = g2b(afiltersid) ;


call filters_client_trigger(acursession,afiltersid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzfltr.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=filters' result;
    leave body;
  end if;
select count(*) into aec from filters where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;filters&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   filters
 (  filtersid 
,instanceid
,name

,thecaption

,thecomment

 ) values ( g2b(afiltersid) 
,g2b(ainstanceid)
,aname

,athecaption

,athecomment

 ) ;


call filters_client_trigger(acursession,afiltersid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists filters_copy
go

create procedure filters_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into filters 
 ( filtersid 
,instanceid
,name

,thecaption

,thecomment

 ) select 
copymap(acopyaction,b2g(filtersid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,thecaption

,thecomment

 from filters
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists filters_logger
go

create procedure filters_logger /*фильтр*/ (
 acursession varchar(38),
 afiltersid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists filters_parent
go
create procedure filters_parent /* фильтр*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from filters where  filtersid=arowid;
 end 
go
GO


drop procedure if exists filters_islocked
go
create procedure filters_islocked /* фильтр */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from filters where filtersid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists filters_lock
go
create procedure filters_lock /* фильтр */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call filters_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update filters set lockuserid =auserid ,locksessionid=null  where filtersid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update filters set lockuserid=null ,locksessionid =acursession  where filtersid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists filters_unlock
go
create procedure filters_unlock /* фильтр */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call filters_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update filters set lockuserid =null  where filtersid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update filters set locksessionid =null  where filtersid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS filters_client_trigger
GO

create procedure filters_client_trigger  (
 acursession varchar(38),
 aFiltersid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_int_modules_brief
go

create procedure iu_int_modules_brief  (
 acursession varchar(38),
 aiu_int_modulesid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_int_modulesid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_int_modules where iu_int_modulesid=g2b(aiu_int_modulesid);
 if  aec &gt;0 then
   set abrief=iu_int_modules_brief_f(g2b(aiu_int_modulesid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_int_modules_delete
go

create procedure iu_int_modules_delete /**/ (
 acursession varchar(38),
 aiu_int_modulesid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_int_modules where iu_int_modulesid=g2b(aiu_int_modulesid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_int.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_int_modules' result;
    leave body;
  end if;
 call iu_int_modules_logger(acursession,aiu_int_modulesid) ; 
  delete from  iu_int_modules 
  where  iu_int_modulesid = g2b(aiu_int_modulesid) ;
  delete from num_values where ownerpartname='iu_int_modules' and ownerrowid=g2b(aiu_int_modulesid);
  end if;
    select 'ok' result;
 end 
go
GO

/*модуль*/

drop procedure if exists iu_int_modules_save
go

create procedure iu_int_modules_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_int_modulesid varchar(38)
,asequence
 integer/* № п/п *//* № п/п */
,atheicon
 varchar (64)/* иконка *//* иконка */
,agroupname
 varchar (60)/* меню верхнего урровня *//* меню верхнего урровня */
,aname
 varchar (255)/* название меню *//* название меню */
,acaption
 varchar (80)/* надпись *//* надпись */
,avisiblecontrol
 integer/* управление видимостью *//* управление видимостью */
,acontroldocmode
 varchar (10)/* документы на контроле *//* документы на контроле */
,aotherdocmode
 varchar (10)/* чужие документы *//* чужие документы */
,amydocmode
 varchar (10)/* мои документы *//* мои документы */
,aallobjects
 integer/* вся фирма *//* вся фирма */
,acolegsobject
 integer/* объекты коллег *//* объекты коллег */
,asubstructobjects
 integer/* подчиненные подразделения *//* подчиненные подразделения */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_int_modules where iu_int_modulesid=g2b(aiu_int_modulesid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_int.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_int_modules' result;
    leave body;
  end if;
 start transaction ; 
 call iu_int_modules_logger(acursession,aiu_int_modulesid) ; 
 update  iu_int_modules set changestamp=now()
,
  sequence=asequence
,
  theicon=atheicon
,
  groupname=agroupname
,
  name=aname
,
  caption=acaption
,
  visiblecontrol=avisiblecontrol
,
  controldocmode=acontroldocmode
,
  otherdocmode=aotherdocmode
,
  mydocmode=amydocmode
,
  allobjects=aallobjects
,
  colegsobject=acolegsobject
,
  substructobjects=asubstructobjects
  where  iu_int_modulesid = g2b(aiu_int_modulesid) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from iu_int_modules where  instanceid=g2b(ainstanceid) 
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=модуль правило=(модуль уникален)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_int_modules_client_trigger(acursession,aiu_int_modulesid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_int.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_int_modules' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_int_modules
 (  iu_int_modulesid 
,instanceid
,sequence

,theicon

,groupname

,name

,caption

,visiblecontrol

,controldocmode

,otherdocmode

,mydocmode

,allobjects

,colegsobject

,substructobjects

 ) values ( g2b(aiu_int_modulesid) 
,g2b(ainstanceid)
,asequence

,atheicon

,agroupname

,aname

,acaption

,avisiblecontrol

,acontroldocmode

,aotherdocmode

,amydocmode

,aallobjects

,acolegsobject

,asubstructobjects

 ) ;
-- if asessuserlogin&lt;&gt;'replicator'  then
 select count(*) into  auniquerowcount from iu_int_modules where  instanceid=g2b(ainstanceid) 
 and name=aname;
if auniquerowcount&gt;=2 then
  select 'нарущение уникальности сочетания полей.  раздел=модуль правило=(модуль уникален)'  result;
  rollback;
  leave body;
end if;
 -- end if;

call iu_int_modules_client_trigger(acursession,aiu_int_modulesid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_int_modules_copy
go

create procedure iu_int_modules_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_int_modules 
 ( iu_int_modulesid 
,instanceid
,sequence

,theicon

,groupname

,name

,caption

,visiblecontrol

,controldocmode

,otherdocmode

,mydocmode

,allobjects

,colegsobject

,substructobjects

 ) select 
copymap(acopyaction,b2g(iu_int_modulesid)) 
,copymap(acopyaction,b2g(instanceid))
,sequence

,theicon

,groupname

,name

,caption

,visiblecontrol

,controldocmode

,otherdocmode

,mydocmode

,allobjects

,colegsobject

,substructobjects

 from iu_int_modules
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_int_modules_logger
go

create procedure iu_int_modules_logger /**/ (
 acursession varchar(38),
 aiu_int_modulesid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_int_modules_parent
go
create procedure iu_int_modules_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_int_modules where  iu_int_modulesid=arowid;
 end 
go
GO


drop procedure if exists iu_int_modules_islocked
go
create procedure iu_int_modules_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_int_modules where iu_int_modulesid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_int_modules_lock
go
create procedure iu_int_modules_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_int_modules_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_int_modules set lockuserid =auserid ,locksessionid=null  where iu_int_modulesid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_int_modules set lockuserid=null ,locksessionid =acursession  where iu_int_modulesid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_int_modules_unlock
go
create procedure iu_int_modules_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_int_modules_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_int_modules set lockuserid =null  where iu_int_modulesid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_int_modules set locksessionid =null  where iu_int_modulesid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_int_modules_client_trigger
GO

create procedure iu_int_modules_client_trigger  (
 acursession varchar(38),
 aiu_int_modulesid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_task_brief
go

create procedure iu_task_brief  (
 acursession varchar(38),
 aiu_taskid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_taskid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_task where iu_taskid=g2b(aiu_taskid);
 if  aec &gt;0 then
   set abrief=iu_task_brief_f(g2b(aiu_taskid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_task_delete
go

create procedure iu_task_delete /*описание задачи*/ (
 acursession varchar(38),
 aiu_taskid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_task where iu_taskid=g2b(aiu_taskid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_task' result;
    leave body;
  end if;
 call iu_task_logger(acursession,aiu_taskid) ; 
  delete from  iu_task 
  where  iu_taskid = g2b(aiu_taskid) ;
  delete from num_values where ownerpartname='iu_task' and ownerrowid=g2b(aiu_taskid);
  end if;
    select 'ok' result;
 end 
go
GO

/*задача*/

drop procedure if exists iu_task_save
go

create procedure iu_task_save /*описание задачи*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_taskid varchar(38)
,adoer varchar(38)/* исполнитель *//* исполнитель */
,acontoller varchar(38)/* кто контролирует *//* кто контролирует */
,asubj
 varchar (255)/* название *//* название */
,acreatedate
 datetime/* дата создания *//* дата создания */
,aplanenddate
 datetime/* плановый срок *//* плановый срок */
,ainfo
 varchar (4000)/* описание *//* описание */
,amanualtask
 integer/* выдана вручную *//* выдана вручную */
,atheprocess varchar(38)/* урок *//* урок */
,adoer_comment
 varchar (255)/* комментарий к задаче *//* комментарий к задаче */
,adoer_states varchar(38)/* статус *//* статус */
,acontroller_comment
 varchar (255)/* комментарий контролера *//* комментарий контролера */
,ataskfinished
 integer/* завершена *//* завершена */
,aischecked
 integer/* проверена *//* проверена */
,afinishdate
 datetime/* дата завершения *//* дата завершения */
,ataskcancelled
 integer/* отменена *//* отменена */
,asenttodoer
 datetime/* отослано исполнителю *//* отослано исполнителю */
,aisdelegated
 integer/* делегирована *//* делегирована */
,aprocessstatus varchar(38)/* подэтап *//* подэтап */
,astatetask varchar(38)/* задача *//* задача */
,adelegatefrom varchar(38)/* делегирована из *//* делегирована из */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_task where iu_taskid=g2b(aiu_taskid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_task' result;
    leave body;
  end if;
 start transaction ; 
 call iu_task_logger(acursession,aiu_taskid) ; 
 update  iu_task set changestamp=now()
,
  doer=g2b(adoer)
,
  contoller=g2b(acontoller)
,
  subj=asubj
,
  createdate=acreatedate
,
  planenddate=aplanenddate
,
  info=ainfo
,
  manualtask=amanualtask
,
  theprocess=g2b(atheprocess)
,
  doer_comment=adoer_comment
,
  doer_states=g2b(adoer_states)
,
  controller_comment=acontroller_comment
,
  taskfinished=ataskfinished
,
  ischecked=aischecked
,
  finishdate=afinishdate
,
  taskcancelled=ataskcancelled
,
  senttodoer=asenttodoer
,
  isdelegated=aisdelegated
,
  processstatus=g2b(aprocessstatus)
,
  statetask=g2b(astatetask)
,
  delegatefrom=g2b(adelegatefrom)
  where  iu_taskid = g2b(aiu_taskid) ;


call iu_task_client_trigger(acursession,aiu_taskid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_task' result;
    leave body;
  end if;
select count(*) into aec from iu_task where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_task&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_task
 (  iu_taskid 
,instanceid
,doer

,contoller

,subj

,createdate

,planenddate

,info

,manualtask

,theprocess

,doer_comment

,doer_states

,controller_comment

,taskfinished

,ischecked

,finishdate

,taskcancelled

,senttodoer

,isdelegated

,processstatus

,statetask

,delegatefrom

 ) values ( g2b(aiu_taskid) 
,g2b(ainstanceid)
,g2b(adoer)

,g2b(acontoller)

,asubj

,acreatedate

,aplanenddate

,ainfo

,amanualtask

,g2b(atheprocess)

,adoer_comment

,g2b(adoer_states)

,acontroller_comment

,ataskfinished

,aischecked

,afinishdate

,ataskcancelled

,asenttodoer

,aisdelegated

,g2b(aprocessstatus)

,g2b(astatetask)

,g2b(adelegatefrom)

 ) ;


call iu_task_client_trigger(acursession,aiu_taskid);

 call iu_t_initownership( acursession,ainstanceid);
 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_task_copy
go

create procedure iu_task_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_task 
 ( iu_taskid 
,instanceid
,doer

,contoller

,subj

,createdate

,planenddate

,info

,manualtask

,theprocess

,doer_comment

,doer_states

,controller_comment

,taskfinished

,ischecked

,finishdate

,taskcancelled

,senttodoer

,isdelegated

,processstatus

,statetask

,delegatefrom

 ) select 
copymap(acopyaction,b2g(iu_taskid)) 
,copymap(acopyaction,b2g(instanceid))
,doer

,contoller

,subj

,createdate

,planenddate

,info

,manualtask

,theprocess

,doer_comment

,doer_states

,controller_comment

,taskfinished

,ischecked

,finishdate

,taskcancelled

,senttodoer

,isdelegated

,processstatus

,statetask

,delegatefrom

 from iu_task
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_task_logger
go

create procedure iu_task_logger /*описание задачи*/ (
 acursession varchar(38),
 aiu_taskid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_task_parent
go
create procedure iu_task_parent /* описание задачи*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_task where  iu_taskid=arowid;
 end 
go
GO


drop procedure if exists iu_task_islocked
go
create procedure iu_task_islocked /* описание задачи */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_task where iu_taskid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_task_lock
go
create procedure iu_task_lock /* описание задачи */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_task_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_task set lockuserid =auserid ,locksessionid=null  where iu_taskid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_task set lockuserid=null ,locksessionid =acursession  where iu_taskid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_task_unlock
go
create procedure iu_task_unlock /* описание задачи */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_task_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_task set lockuserid =null  where iu_taskid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_task set locksessionid =null  where iu_taskid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_task_client_trigger
GO

create procedure iu_task_client_trigger  (
 acursession varchar(38),
 aiu_taskid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_taskattach_brief
go

create procedure iu_taskattach_brief  (
 acursession varchar(38),
 aiu_taskattachid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_taskattachid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_taskattach where iu_taskattachid=g2b(aiu_taskattachid);
 if  aec &gt;0 then
   set abrief=iu_taskattach_brief_f(g2b(aiu_taskattachid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_taskattach_delete
go

create procedure iu_taskattach_delete /*новые материалы*/ (
 acursession varchar(38),
 aiu_taskattachid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_taskattach where iu_taskattachid=g2b(aiu_taskattachid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_taskattach' result;
    leave body;
  end if;
 call iu_taskattach_logger(acursession,aiu_taskattachid) ; 
  delete from  iu_taskattach 
  where  iu_taskattachid = g2b(aiu_taskattachid) ;
  delete from num_values where ownerpartname='iu_taskattach' and ownerrowid=g2b(aiu_taskattachid);
  end if;
    select 'ok' result;
 end 
go
GO

/*новые материалы*/

drop procedure if exists iu_taskattach_save
go

create procedure iu_taskattach_save /*новые материалы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_taskattachid varchar(38)
,adtype varchar(38)/* тип документа *//* тип документа */
,afilereftype varchar(38)/* тип ссылки на файл *//* тип ссылки на файл */
,atheref varchar(255)/* файл */
,atheref_ext varchar(4) /* файл */
,afileurl varchar(255)/* url файла *//* url файла */
,afiletext
 text/* текст документа *//* текст документа */
,ainfo
 varchar (255)/* комментарий *//* комментарий */
,aorigname
 varchar (255)/* оригинальное название *//* оригинальное название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_taskattach where iu_taskattachid=g2b(aiu_taskattachid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_taskattach' result;
    leave body;
  end if;
 start transaction ; 
 call iu_taskattach_logger(acursession,aiu_taskattachid) ; 
 update  iu_taskattach set changestamp=now()
,
  dtype=g2b(adtype)
,
  filereftype=g2b(afilereftype)
,
  theref=atheref
,theref_ext=
atheref_ext 
,
  fileurl=afileurl
,
  filetext=afiletext
,
  info=ainfo
,
  origname=aorigname
  where  iu_taskattachid = g2b(aiu_taskattachid) ;


call iu_taskattach_client_trigger(acursession,aiu_taskattachid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_taskattach' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_taskattach
 (  iu_taskattachid 
,instanceid
,dtype

,filereftype

,theref

,theref_ext
,fileurl

,filetext

,info

,origname

 ) values ( g2b(aiu_taskattachid) 
,g2b(ainstanceid)
,g2b(adtype)

,g2b(afilereftype)

,atheref

,atheref_ext
,afileurl

,afiletext

,ainfo

,aorigname

 ) ;


call iu_taskattach_client_trigger(acursession,aiu_taskattachid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_taskattach_copy
go

create procedure iu_taskattach_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_taskattach 
 ( iu_taskattachid 
,instanceid
,dtype

,filereftype

,theref

,theref_ext
,fileurl

,filetext

,info

,origname

 ) select 
copymap(acopyaction,b2g(iu_taskattachid)) 
,copymap(acopyaction,b2g(instanceid))
,dtype

,filereftype

,theref

,theref_ext
,fileurl

,filetext

,info

,origname

 from iu_taskattach
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_taskattach_logger
go

create procedure iu_taskattach_logger /*новые материалы*/ (
 acursession varchar(38),
 aiu_taskattachid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_taskattach_parent
go
create procedure iu_taskattach_parent /* новые материалы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_taskattach where  iu_taskattachid=arowid;
 end 
go
GO


drop procedure if exists iu_taskattach_islocked
go
create procedure iu_taskattach_islocked /* новые материалы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_taskattach where iu_taskattachid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_taskattach_lock
go
create procedure iu_taskattach_lock /* новые материалы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_taskattach_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_taskattach set lockuserid =auserid ,locksessionid=null  where iu_taskattachid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_taskattach set lockuserid=null ,locksessionid =acursession  where iu_taskattachid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_taskattach_unlock
go
create procedure iu_taskattach_unlock /* новые материалы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_taskattach_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_taskattach set lockuserid =null  where iu_taskattachid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_taskattach set locksessionid =null  where iu_taskattachid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_taskattach_client_trigger
GO

create procedure iu_taskattach_client_trigger  (
 acursession varchar(38),
 aiu_taskattachid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_taskvideo_brief
go

create procedure iu_taskvideo_brief  (
 acursession varchar(38),
 aiu_taskvideoid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_taskvideoid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_taskvideo where iu_taskvideoid=g2b(aiu_taskvideoid);
 if  aec &gt;0 then
   set abrief=iu_taskvideo_brief_f(g2b(aiu_taskvideoid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_taskvideo_delete
go

create procedure iu_taskvideo_delete /*новые видео*/ (
 acursession varchar(38),
 aiu_taskvideoid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_taskvideo where iu_taskvideoid=g2b(aiu_taskvideoid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_taskvideo' result;
    leave body;
  end if;
 call iu_taskvideo_logger(acursession,aiu_taskvideoid) ; 
  delete from  iu_taskvideo 
  where  iu_taskvideoid = g2b(aiu_taskvideoid) ;
  delete from num_values where ownerpartname='iu_taskvideo' and ownerrowid=g2b(aiu_taskvideoid);
  end if;
    select 'ok' result;
 end 
go
GO

/*новые видео*/

drop procedure if exists iu_taskvideo_save
go

create procedure iu_taskvideo_save /*новые видео*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_taskvideoid varchar(38)
,adoctype varchar(38)/* тип видео *//* тип видео */
,aadddate
 datetime/* когда добавлен *//* когда добавлен */
,aactiveversion
 integer/* активная версия *//* активная версия */
,afileref varchar(255)/* файл */
,afileref_ext varchar(4) /* файл */
,aaddby varchar(38)/* кем добавлен *//* кем добавлен */
,ainfo
 varchar (255)/* комментарий *//* комментарий */
,afileurl varchar(255)/* url файла *//* url файла */
,aversion
 integer/* № версии *//* № версии */
,anocomments
 integer/* скрыть *//* скрыть */
,aorigname
 varchar (255)/* оригинальное название *//* оригинальное название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_taskvideo where iu_taskvideoid=g2b(aiu_taskvideoid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_taskvideo' result;
    leave body;
  end if;
 start transaction ; 
 call iu_taskvideo_logger(acursession,aiu_taskvideoid) ; 
 update  iu_taskvideo set changestamp=now()
,
  doctype=g2b(adoctype)
,
  adddate=aadddate
,
  activeversion=aactiveversion
,
  fileref=afileref
,fileref_ext=
afileref_ext 
,
  addby=g2b(aaddby)
,
  info=ainfo
,
  fileurl=afileurl
,
  version=aversion
,
  nocomments=anocomments
,
  origname=aorigname
  where  iu_taskvideoid = g2b(aiu_taskvideoid) ;


call iu_taskvideo_client_trigger(acursession,aiu_taskvideoid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_taskvideo' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_taskvideo
 (  iu_taskvideoid 
,instanceid
,doctype

,adddate

,activeversion

,fileref

,fileref_ext
,addby

,info

,fileurl

,version

,nocomments

,origname

 ) values ( g2b(aiu_taskvideoid) 
,g2b(ainstanceid)
,g2b(adoctype)

,aadddate

,aactiveversion

,afileref

,afileref_ext
,g2b(aaddby)

,ainfo

,afileurl

,aversion

,anocomments

,aorigname

 ) ;


call iu_taskvideo_client_trigger(acursession,aiu_taskvideoid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_taskvideo_copy
go

create procedure iu_taskvideo_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_taskvideo 
 ( iu_taskvideoid 
,instanceid
,doctype

,adddate

,activeversion

,fileref

,fileref_ext
,addby

,info

,fileurl

,version

,nocomments

,origname

 ) select 
copymap(acopyaction,b2g(iu_taskvideoid)) 
,copymap(acopyaction,b2g(instanceid))
,doctype

,adddate

,activeversion

,fileref

,fileref_ext
,addby

,info

,fileurl

,version

,nocomments

,origname

 from iu_taskvideo
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_taskvideo_logger
go

create procedure iu_taskvideo_logger /*новые видео*/ (
 acursession varchar(38),
 aiu_taskvideoid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_taskvideo_parent
go
create procedure iu_taskvideo_parent /* новые видео*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_taskvideo where  iu_taskvideoid=arowid;
 end 
go
GO


drop procedure if exists iu_taskvideo_islocked
go
create procedure iu_taskvideo_islocked /* новые видео */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_taskvideo where iu_taskvideoid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_taskvideo_lock
go
create procedure iu_taskvideo_lock /* новые видео */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_taskvideo_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_taskvideo set lockuserid =auserid ,locksessionid=null  where iu_taskvideoid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_taskvideo set lockuserid=null ,locksessionid =acursession  where iu_taskvideoid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_taskvideo_unlock
go
create procedure iu_taskvideo_unlock /* новые видео */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_taskvideo_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_taskvideo set lockuserid =null  where iu_taskvideoid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_taskvideo set locksessionid =null  where iu_taskvideoid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_taskvideo_client_trigger
GO

create procedure iu_taskvideo_client_trigger  (
 acursession varchar(38),
 aiu_taskvideoid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_taskrefs_brief
go

create procedure iu_taskrefs_brief  (
 acursession varchar(38),
 aiu_taskrefsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_taskrefsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_taskrefs where iu_taskrefsid=g2b(aiu_taskrefsid);
 if  aec &gt;0 then
   set abrief=iu_taskrefs_brief_f(g2b(aiu_taskrefsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_taskrefs_delete
go

create procedure iu_taskrefs_delete /**/ (
 acursession varchar(38),
 aiu_taskrefsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_taskrefs where iu_taskrefsid=g2b(aiu_taskrefsid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_taskrefs' result;
    leave body;
  end if;
 call iu_taskrefs_logger(acursession,aiu_taskrefsid) ; 
  delete from  iu_taskrefs 
  where  iu_taskrefsid = g2b(aiu_taskrefsid) ;
  delete from num_values where ownerpartname='iu_taskrefs' and ownerrowid=g2b(aiu_taskrefsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*вложения*/

drop procedure if exists iu_taskrefs_save
go

create procedure iu_taskrefs_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_taskrefsid varchar(38)
,adtypename
 varchar (255)/* тип документа *//* тип документа */
,afilereftype varchar(38)/* тип ссылки на файл *//* тип ссылки на файл */
,atheref varchar(255)/* файл */
,atheref_ext varchar(4) /* файл */
,afileurl varchar(255)/* url файла *//* url файла */
,afiletext
 text/* текст документа *//* текст документа */
,ainfo
 varchar (255)/* комментарий *//* комментарий */
,aversion
 integer/* № версии *//* № версии */
,aaddby varchar(38)/* кем добавлен *//* кем добавлен */
,aadddate
 datetime/* когда добавлен *//* когда добавлен */
,aorigname
 varchar (255)/* оригинальное название *//* оригинальное название */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_taskrefs where iu_taskrefsid=g2b(aiu_taskrefsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_taskrefs' result;
    leave body;
  end if;
 start transaction ; 
 call iu_taskrefs_logger(acursession,aiu_taskrefsid) ; 
 update  iu_taskrefs set changestamp=now()
,
  dtypename=adtypename
,
  filereftype=g2b(afilereftype)
,
  theref=atheref
,theref_ext=
atheref_ext 
,
  fileurl=afileurl
,
  filetext=afiletext
,
  info=ainfo
,
  version=aversion
,
  addby=g2b(aaddby)
,
  adddate=aadddate
,
  origname=aorigname
  where  iu_taskrefsid = g2b(aiu_taskrefsid) ;


call iu_taskrefs_client_trigger(acursession,aiu_taskrefsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_t.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_taskrefs' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_taskrefs
 (  iu_taskrefsid 
,instanceid
,dtypename

,filereftype

,theref

,theref_ext
,fileurl

,filetext

,info

,version

,addby

,adddate

,origname

 ) values ( g2b(aiu_taskrefsid) 
,g2b(ainstanceid)
,adtypename

,g2b(afilereftype)

,atheref

,atheref_ext
,afileurl

,afiletext

,ainfo

,aversion

,g2b(aaddby)

,aadddate

,aorigname

 ) ;


call iu_taskrefs_client_trigger(acursession,aiu_taskrefsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_taskrefs_copy
go

create procedure iu_taskrefs_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_taskrefs 
 ( iu_taskrefsid 
,instanceid
,dtypename

,filereftype

,theref

,theref_ext
,fileurl

,filetext

,info

,version

,addby

,adddate

,origname

 ) select 
copymap(acopyaction,b2g(iu_taskrefsid)) 
,copymap(acopyaction,b2g(instanceid))
,dtypename

,filereftype

,theref

,theref_ext
,fileurl

,filetext

,info

,version

,addby

,adddate

,origname

 from iu_taskrefs
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_taskrefs_logger
go

create procedure iu_taskrefs_logger /**/ (
 acursession varchar(38),
 aiu_taskrefsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_taskrefs_parent
go
create procedure iu_taskrefs_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_taskrefs where  iu_taskrefsid=arowid;
 end 
go
GO


drop procedure if exists iu_taskrefs_islocked
go
create procedure iu_taskrefs_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_taskrefs where iu_taskrefsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_taskrefs_lock
go
create procedure iu_taskrefs_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_taskrefs_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_taskrefs set lockuserid =auserid ,locksessionid=null  where iu_taskrefsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_taskrefs set lockuserid=null ,locksessionid =acursession  where iu_taskrefsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_taskrefs_unlock
go
create procedure iu_taskrefs_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_taskrefs_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_taskrefs set lockuserid =null  where iu_taskrefsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_taskrefs set locksessionid =null  where iu_taskrefsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_taskrefs_client_trigger
GO

create procedure iu_taskrefs_client_trigger  (
 acursession varchar(38),
 aiu_taskrefsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_l_def_brief
go

create procedure iu_l_def_brief  (
 acursession varchar(38),
 aiu_l_defid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_l_defid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_l_def where iu_l_defid=g2b(aiu_l_defid);
 if  aec &gt;0 then
   set abrief=iu_l_def_brief_f(g2b(aiu_l_defid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_l_def_delete
go

create procedure iu_l_def_delete /*сообщение*/ (
 acursession varchar(38),
 aiu_l_defid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_l_def where iu_l_defid=g2b(aiu_l_defid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_l.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_l_def' result;
    leave body;
  end if;
 call iu_l_def_logger(acursession,aiu_l_defid) ; 
  delete from  iu_l_def 
  where  iu_l_defid = g2b(aiu_l_defid) ;
  delete from num_values where ownerpartname='iu_l_def' and ownerrowid=g2b(aiu_l_defid);
  end if;
    select 'ok' result;
 end 
go
GO

/*сообщение*/

drop procedure if exists iu_l_def_save
go

create procedure iu_l_def_save /*сообщение*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_l_defid varchar(38)
,asender varchar(38)/* отправитель *//* отправитель */
,adoer varchar(38)/* кому *//* кому */
,ainfo
 text/* описание *//* описание */
,acreatedate
 datetime/* дата создания *//* дата создания */
,areaddate
 datetime/* прочитана *//* прочитана */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_l_def where iu_l_defid=g2b(aiu_l_defid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_l.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_l_def' result;
    leave body;
  end if;
 start transaction ; 
 call iu_l_def_logger(acursession,aiu_l_defid) ; 
 update  iu_l_def set changestamp=now()
,
  sender=g2b(asender)
,
  doer=g2b(adoer)
,
  info=ainfo
,
  createdate=acreatedate
,
  readdate=areaddate
  where  iu_l_defid = g2b(aiu_l_defid) ;


call iu_l_def_client_trigger(acursession,aiu_l_defid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_l.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_l_def' result;
    leave body;
  end if;
select count(*) into aec from iu_l_def where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_l_def&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_l_def
 (  iu_l_defid 
,instanceid
,sender

,doer

,info

,createdate

,readdate

 ) values ( g2b(aiu_l_defid) 
,g2b(ainstanceid)
,g2b(asender)

,g2b(adoer)

,ainfo

,acreatedate

,areaddate

 ) ;


call iu_l_def_client_trigger(acursession,aiu_l_defid);

 call iu_l_initownership( acursession,ainstanceid);
 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_l_def_copy
go

create procedure iu_l_def_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_l_def 
 ( iu_l_defid 
,instanceid
,sender

,doer

,info

,createdate

,readdate

 ) select 
copymap(acopyaction,b2g(iu_l_defid)) 
,copymap(acopyaction,b2g(instanceid))
,sender

,doer

,info

,createdate

,readdate

 from iu_l_def
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_l_def_logger
go

create procedure iu_l_def_logger /*сообщение*/ (
 acursession varchar(38),
 aiu_l_defid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_l_def_parent
go
create procedure iu_l_def_parent /* сообщение*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_l_def where  iu_l_defid=arowid;
 end 
go
GO


drop procedure if exists iu_l_def_islocked
go
create procedure iu_l_def_islocked /* сообщение */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_l_def where iu_l_defid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_l_def_lock
go
create procedure iu_l_def_lock /* сообщение */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_l_def_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_l_def set lockuserid =auserid ,locksessionid=null  where iu_l_defid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_l_def set lockuserid=null ,locksessionid =acursession  where iu_l_defid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_l_def_unlock
go
create procedure iu_l_def_unlock /* сообщение */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_l_def_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_l_def set lockuserid =null  where iu_l_defid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_l_def set locksessionid =null  where iu_l_defid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_l_def_client_trigger
GO

create procedure iu_l_def_client_trigger  (
 acursession varchar(38),
 aiu_l_defid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_tm_records_brief
go

create procedure iu_tm_records_brief  (
 acursession varchar(38),
 aiu_tm_recordsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_tm_recordsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_tm_records where iu_tm_recordsid=g2b(aiu_tm_recordsid);
 if  aec &gt;0 then
   set abrief=iu_tm_records_brief_f(g2b(aiu_tm_recordsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_tm_records_delete
go

create procedure iu_tm_records_delete /**/ (
 acursession varchar(38),
 aiu_tm_recordsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tm_records where iu_tm_recordsid=g2b(aiu_tm_recordsid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_tm_records' result;
    leave body;
  end if;
 call iu_tm_records_logger(acursession,aiu_tm_recordsid) ; 
  delete from  iu_tm_records 
  where  iu_tm_recordsid = g2b(aiu_tm_recordsid) ;
  delete from num_values where ownerpartname='iu_tm_records' and ownerrowid=g2b(aiu_tm_recordsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*досье*/

drop procedure if exists iu_tm_records_save
go

create procedure iu_tm_records_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_tm_recordsid varchar(38)
,apassport
 varchar (255)/* паспортные данные *//* паспортные данные */
,ainn
 varchar (12)/* инн *//* инн */
,asnils
 varchar (50)/* снилс *//* снилс */
,abankinfo
 varchar (255)/* банковские реквизиты *//* банковские реквизиты */
,ascanpassport varchar(255)/* паспорт */
,ascanpassport_ext varchar(4) /* паспорт */
,ascaninn varchar(255)/* инн */
,ascaninn_ext varchar(4) /* инн */
,ascansnils varchar(255)/* снилс */
,ascansnils_ext varchar(4) /* снилс */
,ainfo
 varchar (4000)/* информация *//* информация */
,atmfile varchar(255)/* файл */
,atmfile_ext varchar(4) /* файл */
,athecomment
 varchar (4000)/*   *//*   */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tm_records where iu_tm_recordsid=g2b(aiu_tm_recordsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_tm_records' result;
    leave body;
  end if;
 start transaction ; 
 call iu_tm_records_logger(acursession,aiu_tm_recordsid) ; 
 update  iu_tm_records set changestamp=now()
,
  passport=apassport
,
  inn=ainn
,
  snils=asnils
,
  bankinfo=abankinfo
,
  scanpassport=ascanpassport
,scanpassport_ext=
ascanpassport_ext 
,
  scaninn=ascaninn
,scaninn_ext=
ascaninn_ext 
,
  scansnils=ascansnils
,scansnils_ext=
ascansnils_ext 
,
  info=ainfo
,
  tmfile=atmfile
,tmfile_ext=
atmfile_ext 
,
  thecomment=athecomment
  where  iu_tm_recordsid = g2b(aiu_tm_recordsid) ;


call iu_tm_records_client_trigger(acursession,aiu_tm_recordsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_tm_records' result;
    leave body;
  end if;
select count(*) into aec from iu_tm_records where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_tm_records&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_tm_records
 (  iu_tm_recordsid 
,instanceid
,passport

,inn

,snils

,bankinfo

,scanpassport

,scanpassport_ext
,scaninn

,scaninn_ext
,scansnils

,scansnils_ext
,info

,tmfile

,tmfile_ext
,thecomment

 ) values ( g2b(aiu_tm_recordsid) 
,g2b(ainstanceid)
,apassport

,ainn

,asnils

,abankinfo

,ascanpassport

,ascanpassport_ext
,ascaninn

,ascaninn_ext
,ascansnils

,ascansnils_ext
,ainfo

,atmfile

,atmfile_ext
,athecomment

 ) ;


call iu_tm_records_client_trigger(acursession,aiu_tm_recordsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_tm_records_copy
go

create procedure iu_tm_records_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_tm_records 
 ( iu_tm_recordsid 
,instanceid
,passport

,inn

,snils

,bankinfo

,scanpassport

,scanpassport_ext
,scaninn

,scaninn_ext
,scansnils

,scansnils_ext
,info

,tmfile

,tmfile_ext
,thecomment

 ) select 
copymap(acopyaction,b2g(iu_tm_recordsid)) 
,copymap(acopyaction,b2g(instanceid))
,passport

,inn

,snils

,bankinfo

,scanpassport

,scanpassport_ext
,scaninn

,scaninn_ext
,scansnils

,scansnils_ext
,info

,tmfile

,tmfile_ext
,thecomment

 from iu_tm_records
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_tm_records_logger
go

create procedure iu_tm_records_logger /**/ (
 acursession varchar(38),
 aiu_tm_recordsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_tm_records_parent
go
create procedure iu_tm_records_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_tm_records where  iu_tm_recordsid=arowid;
 end 
go
GO


drop procedure if exists iu_tm_records_islocked
go
create procedure iu_tm_records_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_tm_records where iu_tm_recordsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_tm_records_lock
go
create procedure iu_tm_records_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_tm_records_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_tm_records set lockuserid =auserid ,locksessionid=null  where iu_tm_recordsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_tm_records set lockuserid=null ,locksessionid =acursession  where iu_tm_recordsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_tm_records_unlock
go
create procedure iu_tm_records_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_tm_records_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_tm_records set lockuserid =null  where iu_tm_recordsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_tm_records set locksessionid =null  where iu_tm_recordsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_tm_records_client_trigger
GO

create procedure iu_tm_records_client_trigger  (
 acursession varchar(38),
 aiu_tm_recordsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_tmdef_brief
go

create procedure iu_tmdef_brief  (
 acursession varchar(38),
 aiu_tmdefid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_tmdefid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_tmdef where iu_tmdefid=g2b(aiu_tmdefid);
 if  aec &gt;0 then
   set abrief=iu_tmdef_brief_f(g2b(aiu_tmdefid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_tmdef_delete
go

create procedure iu_tmdef_delete /*информация об учителях и методистах*/ (
 acursession varchar(38),
 aiu_tmdefid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tmdef where iu_tmdefid=g2b(aiu_tmdefid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_tmdef' result;
    leave body;
  end if;
 call iu_tmdef_logger(acursession,aiu_tmdefid) ; 
  delete from  iu_tmdef 
  where  iu_tmdefid = g2b(aiu_tmdefid) ;
  delete from num_values where ownerpartname='iu_tmdef' and ownerrowid=g2b(aiu_tmdefid);
  end if;
    select 'ok' result;
 end 
go
GO


drop procedure if exists iu_tmdef_archive
go

create procedure iu_tmdef_archive /*информация об учителях и методистах*/ (
 acursession varchar(38),
 aiu_tmdefid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare atmpid binary(16);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tmdef where iu_tmdefid=g2b(aiu_tmdefid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_tmdef' result;
    leave body;
  end if;
 call iu_tmdef_logger(acursession,aiu_tmdefid) ; 
  update   iu_tmdef set archived = 1 
  where  iu_tmdefid = g2b(aiu_tmdefid) ;
  end if;
    select 'ok' result;
 end 
go
GO

/*информация*/

drop procedure if exists iu_tmdef_save
go

create procedure iu_tmdef_save /*информация об учителях и методистах*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_tmdefid varchar(38)
,alastname
 varchar (120)/* фамилия *//* фамилия */
,aname
 varchar (120)/* имя *//* имя */
,asurname
 varchar (120)/* отчество *//* отчество */
,asubjects
 varchar (400)/* предметы *//* предметы */
,aclasses
 varchar (80)/* классы *//* классы */
,athephone
 varchar (40)/* телефон *//* телефон */
,aemail
 varchar (60)/* e-mail *//* e-mail */
,asendtomail
 integer/* оповещать по почте *//* оповещать по почте */
,aregal
 varchar (250)/* регалии *//* регалии */
,aismethodist
 integer/* методист *//* методист */
,athetown varchar(38)/* город *//* город */
,aworkat
 varchar (250)/* место работы *//* место работы */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tmdef where iu_tmdefid=g2b(aiu_tmdefid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_tmdef' result;
    leave body;
  end if;
 start transaction ; 
 call iu_tmdef_logger(acursession,aiu_tmdefid) ; 
 update  iu_tmdef set changestamp=now()
,
  lastname=alastname
,
  name=aname
,
  surname=asurname
,
  subjects=asubjects
,
  classes=aclasses
,
  thephone=athephone
,
  email=aemail
,
  sendtomail=asendtomail
,
  regal=aregal
,
  ismethodist=aismethodist
,
  thetown=g2b(athetown)
,
  workat=aworkat
  where  iu_tmdefid = g2b(aiu_tmdefid) ;


call iu_tmdef_client_trigger(acursession,aiu_tmdefid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_tmdef' result;
    leave body;
  end if;
select count(*) into aec from iu_tmdef where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_tmdef&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_tmdef
 (  iu_tmdefid 
,instanceid
,lastname

,name

,surname

,subjects

,classes

,thephone

,email

,sendtomail

,regal

,ismethodist

,thetown

,workat

 ) values ( g2b(aiu_tmdefid) 
,g2b(ainstanceid)
,alastname

,aname

,asurname

,asubjects

,aclasses

,athephone

,aemail

,asendtomail

,aregal

,aismethodist

,g2b(athetown)

,aworkat

 ) ;


call iu_tmdef_client_trigger(acursession,aiu_tmdefid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_tmdef_copy
go

create procedure iu_tmdef_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_tmdef 
 ( iu_tmdefid 
,instanceid
,archived
,lastname

,name

,surname

,subjects

,classes

,thephone

,email

,sendtomail

,regal

,ismethodist

,thetown

,workat

 ) select 
copymap(acopyaction,b2g(iu_tmdefid)) 
,copymap(acopyaction,b2g(instanceid))
,archived
,lastname

,name

,surname

,subjects

,classes

,thephone

,email

,sendtomail

,regal

,ismethodist

,thetown

,workat

 from iu_tmdef
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_tmdef_logger
go

create procedure iu_tmdef_logger /*информация об учителях и методистах*/ (
 acursession varchar(38),
 aiu_tmdefid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_tmdef_parent
go
create procedure iu_tmdef_parent /* информация об учителях и методистах*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_tmdef where  iu_tmdefid=arowid;
 end 
go
GO


drop procedure if exists iu_tmdef_islocked
go
create procedure iu_tmdef_islocked /* информация об учителях и методистах */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_tmdef where iu_tmdefid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_tmdef_lock
go
create procedure iu_tmdef_lock /* информация об учителях и методистах */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_tmdef_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_tmdef set lockuserid =auserid ,locksessionid=null  where iu_tmdefid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_tmdef set lockuserid=null ,locksessionid =acursession  where iu_tmdefid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_tmdef_unlock
go
create procedure iu_tmdef_unlock /* информация об учителях и методистах */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_tmdef_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_tmdef set lockuserid =null  where iu_tmdefid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_tmdef set locksessionid =null  where iu_tmdefid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_tmdef_client_trigger
GO

create procedure iu_tmdef_client_trigger  (
 acursession varchar(38),
 aiu_tmdefid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_tmcadr_brief
go

create procedure iu_tmcadr_brief  (
 acursession varchar(38),
 aiu_tmcadrid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_tmcadrid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_tmcadr where iu_tmcadrid=g2b(aiu_tmcadrid);
 if  aec &gt;0 then
   set abrief=iu_tmcadr_brief_f(g2b(aiu_tmcadrid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_tmcadr_delete
go

create procedure iu_tmcadr_delete /**/ (
 acursession varchar(38),
 aiu_tmcadrid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tmcadr where iu_tmcadrid=g2b(aiu_tmcadrid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_tmcadr' result;
    leave body;
  end if;
 call iu_tmcadr_logger(acursession,aiu_tmcadrid) ; 
  delete from  iu_tmcadr 
  where  iu_tmcadrid = g2b(aiu_tmcadrid) ;
  delete from num_values where ownerpartname='iu_tmcadr' and ownerrowid=g2b(aiu_tmcadrid);
  end if;
    select 'ok' result;
 end 
go
GO

/*мастер-кадры и костюмы*/

drop procedure if exists iu_tmcadr_save
go

create procedure iu_tmcadr_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_tmcadrid varchar(38)
,aphoto varchar(255)/* фото */
,aphoto_ext varchar(4) /* фото */
,ainfo
 varchar (4000)/* примечание *//* примечание */
,amastercadr
 integer/* мастер-кадр *//* мастер-кадр */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tmcadr where iu_tmcadrid=g2b(aiu_tmcadrid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_tmcadr' result;
    leave body;
  end if;
 start transaction ; 
 call iu_tmcadr_logger(acursession,aiu_tmcadrid) ; 
 update  iu_tmcadr set changestamp=now()
,
  photo=aphoto
,photo_ext=
aphoto_ext 
,
  info=ainfo
,
  mastercadr=amastercadr
  where  iu_tmcadrid = g2b(aiu_tmcadrid) ;


call iu_tmcadr_client_trigger(acursession,aiu_tmcadrid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_tmcadr' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_tmcadr
 (  iu_tmcadrid 
,instanceid
,photo

,photo_ext
,info

,mastercadr

 ) values ( g2b(aiu_tmcadrid) 
,g2b(ainstanceid)
,aphoto

,aphoto_ext
,ainfo

,amastercadr

 ) ;


call iu_tmcadr_client_trigger(acursession,aiu_tmcadrid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_tmcadr_copy
go

create procedure iu_tmcadr_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_tmcadr 
 ( iu_tmcadrid 
,instanceid
,photo

,photo_ext
,info

,mastercadr

 ) select 
copymap(acopyaction,b2g(iu_tmcadrid)) 
,copymap(acopyaction,b2g(instanceid))
,photo

,photo_ext
,info

,mastercadr

 from iu_tmcadr
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_tmcadr_logger
go

create procedure iu_tmcadr_logger /**/ (
 acursession varchar(38),
 aiu_tmcadrid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_tmcadr_parent
go
create procedure iu_tmcadr_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_tmcadr where  iu_tmcadrid=arowid;
 end 
go
GO


drop procedure if exists iu_tmcadr_islocked
go
create procedure iu_tmcadr_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_tmcadr where iu_tmcadrid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_tmcadr_lock
go
create procedure iu_tmcadr_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_tmcadr_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_tmcadr set lockuserid =auserid ,locksessionid=null  where iu_tmcadrid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_tmcadr set lockuserid=null ,locksessionid =acursession  where iu_tmcadrid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_tmcadr_unlock
go
create procedure iu_tmcadr_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_tmcadr_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_tmcadr set lockuserid =null  where iu_tmcadrid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_tmcadr set locksessionid =null  where iu_tmcadrid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_tmcadr_client_trigger
GO

create procedure iu_tmcadr_client_trigger  (
 acursession varchar(38),
 aiu_tmcadrid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_tm_act_brief
go

create procedure iu_tm_act_brief  (
 acursession varchar(38),
 aiu_tm_actid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_tm_actid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_tm_act where iu_tm_actid=g2b(aiu_tm_actid);
 if  aec &gt;0 then
   set abrief=iu_tm_act_brief_f(g2b(aiu_tm_actid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_tm_act_delete
go

create procedure iu_tm_act_delete /**/ (
 acursession varchar(38),
 aiu_tm_actid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tm_act where iu_tm_actid=g2b(aiu_tm_actid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_tm_act' result;
    leave body;
  end if;
 call iu_tm_act_logger(acursession,aiu_tm_actid) ; 
  delete from  iu_tm_act 
  where  iu_tm_actid = g2b(aiu_tm_actid) ;
  delete from num_values where ownerpartname='iu_tm_act' and ownerrowid=g2b(aiu_tm_actid);
  end if;
    select 'ok' result;
 end 
go
GO

/*акты*/

drop procedure if exists iu_tm_act_save
go

create procedure iu_tm_act_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_tm_actid varchar(38)
,aaktnum
 varchar (120)/* номер акта *//* номер акта */
,aaktfile varchar(255)/* файл акта */
,aaktfile_ext varchar(4) /* файл акта */
,apaymentdate
 date/* дата оплаты *//* дата оплаты */
,apayment
 double/* сумма оплаты *//* сумма оплаты */
,aquantity
 integer/* количество уроков *//* количество уроков */
,athecomment
 varchar (4000)/*   *//*   */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tm_act where iu_tm_actid=g2b(aiu_tm_actid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_tm_act' result;
    leave body;
  end if;
 start transaction ; 
 call iu_tm_act_logger(acursession,aiu_tm_actid) ; 
 update  iu_tm_act set changestamp=now()
,
  aktnum=aaktnum
,
  aktfile=aaktfile
,aktfile_ext=
aaktfile_ext 
,
  paymentdate=apaymentdate
,
  payment=apayment
,
  quantity=aquantity
,
  thecomment=athecomment
  where  iu_tm_actid = g2b(aiu_tm_actid) ;


call iu_tm_act_client_trigger(acursession,aiu_tm_actid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_tm_act' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_tm_act
 (  iu_tm_actid 
,instanceid
,aktnum

,aktfile

,aktfile_ext
,paymentdate

,payment

,quantity

,thecomment

 ) values ( g2b(aiu_tm_actid) 
,g2b(ainstanceid)
,aaktnum

,aaktfile

,aaktfile_ext
,apaymentdate

,apayment

,aquantity

,athecomment

 ) ;


call iu_tm_act_client_trigger(acursession,aiu_tm_actid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_tm_actfile_brief
go

create procedure iu_tm_actfile_brief  (
 acursession varchar(38),
 aiu_tm_actfileid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_tm_actfileid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_tm_actfile where iu_tm_actfileid=g2b(aiu_tm_actfileid);
 if  aec &gt;0 then
   set abrief=iu_tm_actfile_brief_f(g2b(aiu_tm_actfileid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_tm_actfile_delete
go

create procedure iu_tm_actfile_delete /**/ (
 acursession varchar(38),
 aiu_tm_actfileid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tm_actfile where iu_tm_actfileid=g2b(aiu_tm_actfileid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_tm_actfile' result;
    leave body;
  end if;
 call iu_tm_actfile_logger(acursession,aiu_tm_actfileid) ; 
  delete from  iu_tm_actfile 
  where  iu_tm_actfileid = g2b(aiu_tm_actfileid) ;
  delete from num_values where ownerpartname='iu_tm_actfile' and ownerrowid=g2b(aiu_tm_actfileid);
  end if;
    select 'ok' result;
 end 
go
GO

/*файлы к акту*/

drop procedure if exists iu_tm_actfile_save
go

create procedure iu_tm_actfile_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 aiu_tm_actfileid varchar(38)
,adtype varchar(38)/* тип документа *//* тип документа */
,atheref varchar(255)/* файл */
,atheref_ext varchar(4) /* файл */
,ainfo
 varchar (255)/* комментарий *//* комментарий */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tm_actfile where iu_tm_actfileid=g2b(aiu_tm_actfileid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_tm_actfile' result;
    leave body;
  end if;
 start transaction ; 
 call iu_tm_actfile_logger(acursession,aiu_tm_actfileid) ; 
 update  iu_tm_actfile set changestamp=now()
,
  dtype=g2b(adtype)
,
  theref=atheref
,theref_ext=
atheref_ext 
,
  info=ainfo
  where  iu_tm_actfileid = g2b(aiu_tm_actfileid) ;


call iu_tm_actfile_client_trigger(acursession,aiu_tm_actfileid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_tm_actfile' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_tm_actfile
 (  iu_tm_actfileid 
,parentstructrowid
,dtype

,theref

,theref_ext
,info

 ) values ( g2b(aiu_tm_actfileid) 
,g2b(aparentstructrowid)
,g2b(adtype)

,atheref

,atheref_ext
,ainfo

 ) ;


call iu_tm_actfile_client_trigger(acursession,aiu_tm_actfileid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_tm_actfile_copy
go

create procedure iu_tm_actfile_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_tm_actfile 
 ( iu_tm_actfileid 
,parentstructrowid
,dtype

,theref

,theref_ext
,info

 ) select 
copymap(acopyaction,b2g(iu_tm_actfileid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,dtype

,theref

,theref_ext
,info

 from iu_tm_actfile
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists iu_tm_act_copy
go

create procedure iu_tm_act_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_iu_tm_act cursor for
select iu_tm_actid from iu_tm_act where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_tm_act 
 ( iu_tm_actid 
,instanceid
,aktnum

,aktfile

,aktfile_ext
,paymentdate

,payment

,quantity

,thecomment

 ) select 
copymap(acopyaction,b2g(iu_tm_actid)) 
,copymap(acopyaction,b2g(instanceid))
,aktnum

,aktfile

,aktfile_ext
,paymentdate

,payment

,quantity

,thecomment

 from iu_tm_act
 where instanceid =g2b( ainstanceid); 
open copy_cursor_iu_tm_act;
  set  fetch_done=false;
fetch copy_cursor_iu_tm_act into aid;
while not fetch_done do 
    call iu_tm_actfile_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_iu_tm_act into aid;
end while;

close copy_cursor_iu_tm_act;
 end 
go
GO


drop procedure if exists iu_tm_act_logger
go

create procedure iu_tm_act_logger /**/ (
 acursession varchar(38),
 aiu_tm_actid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_tm_actfile_logger
go

create procedure iu_tm_actfile_logger /**/ (
 acursession varchar(38),
 aiu_tm_actfileid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_tm_act_parent
go
create procedure iu_tm_act_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_tm_act where  iu_tm_actid=arowid;
 end 
go
GO


drop procedure if exists iu_tm_act_islocked
go
create procedure iu_tm_act_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_tm_act where iu_tm_actid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_tm_act_lock
go
create procedure iu_tm_act_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_tm_act_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_tm_act set lockuserid =auserid ,locksessionid=null  where iu_tm_actid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_tm_act set lockuserid=null ,locksessionid =acursession  where iu_tm_actid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_tm_act_unlock
go
create procedure iu_tm_act_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_tm_act_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_tm_act set lockuserid =null  where iu_tm_actid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_tm_act set locksessionid =null  where iu_tm_actid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_tm_act_client_trigger
GO

create procedure iu_tm_act_client_trigger  (
 acursession varchar(38),
 aiu_tm_actid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_tm_actfile_parent
go
create procedure iu_tm_actfile_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from iu_tm_actfile where  iu_tm_actfileid=arowid;
  set aparenttable = 'iu_tm_act';
 end 
go
GO


drop procedure if exists iu_tm_actfile_islocked
go
create procedure iu_tm_actfile_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_tm_actfile where iu_tm_actfileid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_tm_actfile_lock
go
create procedure iu_tm_actfile_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_tm_actfile_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_tm_actfile set lockuserid =auserid ,locksessionid=null  where iu_tm_actfileid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_tm_actfile set lockuserid=null ,locksessionid =acursession  where iu_tm_actfileid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_tm_actfile_unlock
go
create procedure iu_tm_actfile_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_tm_actfile_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_tm_actfile set lockuserid =null  where iu_tm_actfileid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_tm_actfile set locksessionid =null  where iu_tm_actfileid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_tm_actfile_client_trigger
GO

create procedure iu_tm_actfile_client_trigger  (
 acursession varchar(38),
 aiu_tm_actfileid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_tm_dog_brief
go

create procedure iu_tm_dog_brief  (
 acursession varchar(38),
 aiu_tm_dogid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_tm_dogid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_tm_dog where iu_tm_dogid=g2b(aiu_tm_dogid);
 if  aec &gt;0 then
   set abrief=iu_tm_dog_brief_f(g2b(aiu_tm_dogid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_tm_dog_delete
go

create procedure iu_tm_dog_delete /**/ (
 acursession varchar(38),
 aiu_tm_dogid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tm_dog where iu_tm_dogid=g2b(aiu_tm_dogid);
if aec&gt;0 then
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_tm_dog' result;
    leave body;
  end if;
 call iu_tm_dog_logger(acursession,aiu_tm_dogid) ; 
  delete from  iu_tm_dog 
  where  iu_tm_dogid = g2b(aiu_tm_dogid) ;
  delete from num_values where ownerpartname='iu_tm_dog' and ownerrowid=g2b(aiu_tm_dogid);
  end if;
    select 'ok' result;
 end 
go
GO

/*договора*/

drop procedure if exists iu_tm_dog_save
go

create procedure iu_tm_dog_save /**/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_tm_dogid varchar(38)
,athedate
 date/* дата договора *//* дата договора */
,athenumber
 varchar (50)/* номер договора *//* номер договора */
,adogfile varchar(255)/* файл договора */
,adogfile_ext varchar(4) /* файл договора */
,ainfo
 varchar (1024)/* примечание *//* примечание */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_tm_dog where iu_tm_dogid=g2b(aiu_tm_dogid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_tm_dog' result;
    leave body;
  end if;
 start transaction ; 
 call iu_tm_dog_logger(acursession,aiu_tm_dogid) ; 
 update  iu_tm_dog set changestamp=now()
,
  thedate=athedate
,
  thenumber=athenumber
,
  dogfile=adogfile
,dogfile_ext=
adogfile_ext 
,
  info=ainfo
  where  iu_tm_dogid = g2b(aiu_tm_dogid) ;


call iu_tm_dog_client_trigger(acursession,aiu_tm_dogid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_tm.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_tm_dog' result;
    leave body;
  end if;
 start transaction;  
 insert into   iu_tm_dog
 (  iu_tm_dogid 
,instanceid
,thedate

,thenumber

,dogfile

,dogfile_ext
,info

 ) values ( g2b(aiu_tm_dogid) 
,g2b(ainstanceid)
,athedate

,athenumber

,adogfile

,adogfile_ext
,ainfo

 ) ;


call iu_tm_dog_client_trigger(acursession,aiu_tm_dogid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_tm_dog_copy
go

create procedure iu_tm_dog_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_tm_dog 
 ( iu_tm_dogid 
,instanceid
,thedate

,thenumber

,dogfile

,dogfile_ext
,info

 ) select 
copymap(acopyaction,b2g(iu_tm_dogid)) 
,copymap(acopyaction,b2g(instanceid))
,thedate

,thenumber

,dogfile

,dogfile_ext
,info

 from iu_tm_dog
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_tm_dog_logger
go

create procedure iu_tm_dog_logger /**/ (
 acursession varchar(38),
 aiu_tm_dogid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_tm_dog_parent
go
create procedure iu_tm_dog_parent /* */ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_tm_dog where  iu_tm_dogid=arowid;
 end 
go
GO


drop procedure if exists iu_tm_dog_islocked
go
create procedure iu_tm_dog_islocked /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_tm_dog where iu_tm_dogid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_tm_dog_lock
go
create procedure iu_tm_dog_lock /*  */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_tm_dog_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_tm_dog set lockuserid =auserid ,locksessionid=null  where iu_tm_dogid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_tm_dog set lockuserid=null ,locksessionid =acursession  where iu_tm_dogid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_tm_dog_unlock
go
create procedure iu_tm_dog_unlock /*  */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_tm_dog_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_tm_dog set lockuserid =null  where iu_tm_dogid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_tm_dog set locksessionid =null  where iu_tm_dogid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_tm_dog_client_trigger
GO

create procedure iu_tm_dog_client_trigger  (
 acursession varchar(38),
 aiu_tm_dogid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists rptstruct_brief
go

create procedure rptstruct_brief  (
 acursession varchar(38),
 arptstructid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if arptstructid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from rptstruct where rptstructid=g2b(arptstructid);
 if  aec &gt;0 then
   set abrief=rptstruct_brief_f(g2b(arptstructid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists rptstruct_delete
go

create procedure rptstruct_delete /*секции*/ (
 acursession varchar(38),
 arptstructid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from rptstruct where rptstructid=g2b(arptstructid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=rptstruct' result;
    leave body;
  end if;
 call rptstruct_logger(acursession,arptstructid) ; 
  delete from  rptstruct 
  where  rptstructid = g2b(arptstructid) ;
  delete from num_values where ownerpartname='rptstruct' and ownerrowid=g2b(arptstructid);
  end if;
    select 'ok' result;
 end 
go
GO

/*секции*/

drop procedure if exists rptstruct_save
go

create procedure rptstruct_save /*секции*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 arptstructid varchar(38)
,aparentrowid varchar(38) 
,aname
 varchar (64)/* название *//* название */
,acaption
 varchar (255)/* заголовок *//* заголовок */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from rptstruct where rptstructid=g2b(arptstructid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=rptstruct' result;
    leave body;
  end if;
 start transaction ; 
 call rptstruct_logger(acursession,arptstructid) ; 
 update  rptstruct set changestamp=now()
,parentrowid= g2b(aparentrowid)
,
  name=aname
,
  caption=acaption
  where  rptstructid = g2b(arptstructid) ;


call rptstruct_client_trigger(acursession,arptstructid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=rptstruct' result;
    leave body;
  end if;
 start transaction;  
 insert into   rptstruct
 (  rptstructid 
,parentrowid
,instanceid
,name

,caption

 ) values ( g2b(arptstructid) 
,g2b(aparentrowid)
,g2b(ainstanceid)
,aname

,acaption

 ) ;


call rptstruct_client_trigger(acursession,arptstructid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists rptfields_brief
go

create procedure rptfields_brief  (
 acursession varchar(38),
 arptfieldsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if arptfieldsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from rptfields where rptfieldsid=g2b(arptfieldsid);
 if  aec &gt;0 then
   set abrief=rptfields_brief_f(g2b(arptfieldsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists rptfields_delete
go

create procedure rptfields_delete /*поля секции*/ (
 acursession varchar(38),
 arptfieldsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from rptfields where rptfieldsid=g2b(arptfieldsid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=rptfields' result;
    leave body;
  end if;
 call rptfields_logger(acursession,arptfieldsid) ; 
  delete from  rptfields 
  where  rptfieldsid = g2b(arptfieldsid) ;
  delete from num_values where ownerpartname='rptfields' and ownerrowid=g2b(arptfieldsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*поля секции*/

drop procedure if exists rptfields_save
go

create procedure rptfields_save /*поля секции*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aparentstructrowid varchar(38) ,
 arptfieldsid varchar(38)
,aname
 varchar (64)/* название *//* название */
,afieldtype varchar(38)/* тип поля *//* тип поля */
,afieldsize
 integer/* размер *//* размер */
,acaption
 varchar (255)/* заголовок *//* заголовок */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from rptfields where rptfieldsid=g2b(arptfieldsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=rptfields' result;
    leave body;
  end if;
 start transaction ; 
 call rptfields_logger(acursession,arptfieldsid) ; 
 update  rptfields set changestamp=now()
,
  name=aname
,
  fieldtype=g2b(afieldtype)
,
  fieldsize=afieldsize
,
  caption=acaption
  where  rptfieldsid = g2b(arptfieldsid) ;


call rptfields_client_trigger(acursession,arptfieldsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=rptfields' result;
    leave body;
  end if;
 start transaction;  
 insert into   rptfields
 (  rptfieldsid 
,parentstructrowid
,name

,fieldtype

,fieldsize

,caption

 ) values ( g2b(arptfieldsid) 
,g2b(aparentstructrowid)
,aname

,g2b(afieldtype)

,afieldsize

,acaption

 ) ;


call rptfields_client_trigger(acursession,arptfieldsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists rptfields_copy
go

create procedure rptfields_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
, aparentstructrowid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into rptfields 
 ( rptfieldsid 
,parentstructrowid
,name

,fieldtype

,fieldsize

,caption

 ) select 
copymap(acopyaction,b2g(rptfieldsid)) 
,copymap(acopyaction,b2g(parentstructrowid))
,name

,fieldtype

,fieldsize

,caption

 from rptfields
 where parentstructrowid =g2b(aparentstructrowid); 
 end 
go
GO


drop procedure if exists rptstruct_copy
go

create procedure rptstruct_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
declare aid binary(16);
declare fetch_done int default false;
declare copy_cursor_rptstruct cursor for
select rptstructid from rptstruct where 
instanceid =ainstanceid;
 declare continue handler for not found set fetch_done = true;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into rptstruct 
 ( rptstructid 
,instanceid
,parentrowid
,name

,caption

 ) select 
copymap(acopyaction,b2g(rptstructid)) 
,copymap(acopyaction,b2g(instanceid))
,copymap(acopyaction,b2g(parentrowid))
,name

,caption

 from rptstruct
 where instanceid =g2b( ainstanceid); 
open copy_cursor_rptstruct;
  set  fetch_done=false;
fetch copy_cursor_rptstruct into aid;
while not fetch_done do 
    call rptfields_copy(acursession,acopyaction,ainstanceid,aid);
  set  fetch_done=false;
    fetch copy_cursor_rptstruct into aid;
end while;

close copy_cursor_rptstruct;
 end 
go
GO


drop procedure if exists rptstruct_logger
go

create procedure rptstruct_logger /*секции*/ (
 acursession varchar(38),
 arptstructid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists rptfields_logger
go

create procedure rptfields_logger /*поля секции*/ (
 acursession varchar(38),
 arptfieldsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists rptstruct_parent
go
create procedure rptstruct_parent /* секции*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from rptstruct where  rptstructid=arowid;
 end 
go
GO


drop procedure if exists rptstruct_islocked
go
create procedure rptstruct_islocked /* секции */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from rptstruct where rptstructid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists rptstruct_lock
go
create procedure rptstruct_lock /* секции */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call rptstruct_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update rptstruct set lockuserid =auserid ,locksessionid=null  where rptstructid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update rptstruct set lockuserid=null ,locksessionid =acursession  where rptstructid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists rptstruct_unlock
go
create procedure rptstruct_unlock /* секции */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call rptstruct_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update rptstruct set lockuserid =null  where rptstructid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update rptstruct set locksessionid =null  where rptstructid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS rptstruct_client_trigger
GO

create procedure rptstruct_client_trigger  (
 acursession varchar(38),
 aRPTStructid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists rptfields_parent
go
create procedure rptfields_parent /* поля секции*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  select parentstructrowid into aparentid from rptfields where  rptfieldsid=arowid;
  set aparenttable = 'rptstruct';
 end 
go
GO


drop procedure if exists rptfields_islocked
go
create procedure rptfields_islocked /* поля секции */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from rptfields where rptfieldsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists rptfields_lock
go
create procedure rptfields_lock /* поля секции */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call rptfields_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update rptfields set lockuserid =auserid ,locksessionid=null  where rptfieldsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update rptfields set lockuserid=null ,locksessionid =acursession  where rptfieldsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists rptfields_unlock
go
create procedure rptfields_unlock /* поля секции */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call rptfields_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update rptfields set lockuserid =null  where rptfieldsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update rptfields set locksessionid =null  where rptfieldsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS rptfields_client_trigger
GO

create procedure rptfields_client_trigger  (
 acursession varchar(38),
 aRPTFieldsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists rptformula_brief
go

create procedure rptformula_brief  (
 acursession varchar(38),
 arptformulaid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if arptformulaid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from rptformula where rptformulaid=g2b(arptformulaid);
 if  aec &gt;0 then
   set abrief=rptformula_brief_f(g2b(arptformulaid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists rptformula_delete
go

create procedure rptformula_delete /*формулы*/ (
 acursession varchar(38),
 arptformulaid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from rptformula where rptformulaid=g2b(arptformulaid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=rptformula' result;
    leave body;
  end if;
 call rptformula_logger(acursession,arptformulaid) ; 
  delete from  rptformula 
  where  rptformulaid = g2b(arptformulaid) ;
  delete from num_values where ownerpartname='rptformula' and ownerrowid=g2b(arptformulaid);
  end if;
    select 'ok' result;
 end 
go
GO

/*формулы*/

drop procedure if exists rptformula_save
go

create procedure rptformula_save /*формулы*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 arptformulaid varchar(38)
,aname
 varchar (64)/* название *//* название */
,acode
 text/* выражение *//* выражение */
,aplatform varchar(38)/* платформа *//* платформа */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from rptformula where rptformulaid=g2b(arptformulaid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=rptformula' result;
    leave body;
  end if;
 start transaction ; 
 call rptformula_logger(acursession,arptformulaid) ; 
 update  rptformula set changestamp=now()
,
  name=aname
,
  code=acode
,
  platform=g2b(aplatform)
  where  rptformulaid = g2b(arptformulaid) ;


call rptformula_client_trigger(acursession,arptformulaid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=rptformula' result;
    leave body;
  end if;
 start transaction;  
 insert into   rptformula
 (  rptformulaid 
,instanceid
,name

,code

,platform

 ) values ( g2b(arptformulaid) 
,g2b(ainstanceid)
,aname

,acode

,g2b(aplatform)

 ) ;


call rptformula_client_trigger(acursession,arptformulaid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists rptformula_copy
go

create procedure rptformula_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into rptformula 
 ( rptformulaid 
,instanceid
,name

,code

,platform

 ) select 
copymap(acopyaction,b2g(rptformulaid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,code

,platform

 from rptformula
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists rptformula_logger
go

create procedure rptformula_logger /*формулы*/ (
 acursession varchar(38),
 arptformulaid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists rptformula_parent
go
create procedure rptformula_parent /* формулы*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from rptformula where  rptformulaid=arowid;
 end 
go
GO


drop procedure if exists rptformula_islocked
go
create procedure rptformula_islocked /* формулы */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from rptformula where rptformulaid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists rptformula_lock
go
create procedure rptformula_lock /* формулы */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call rptformula_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update rptformula set lockuserid =auserid ,locksessionid=null  where rptformulaid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update rptformula set lockuserid=null ,locksessionid =acursession  where rptformulaid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists rptformula_unlock
go
create procedure rptformula_unlock /* формулы */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call rptformula_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update rptformula set lockuserid =null  where rptformulaid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update rptformula set locksessionid =null  where rptformulaid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS rptformula_client_trigger
GO

create procedure rptformula_client_trigger  (
 acursession varchar(38),
 aRPTFormulaid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists reports_brief
go

create procedure reports_brief  (
 acursession varchar(38),
 areportsid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if areportsid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from reports where reportsid=g2b(areportsid);
 if  aec &gt;0 then
   set abrief=reports_brief_f(g2b(areportsid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists reports_delete
go

create procedure reports_delete /*описание*/ (
 acursession varchar(38),
 areportsid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from reports where reportsid=g2b(areportsid);
if aec&gt;0 then
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=reports' result;
    leave body;
  end if;
 call reports_logger(acursession,areportsid) ; 
  delete from  reports 
  where  reportsid = g2b(areportsid) ;
  delete from num_values where ownerpartname='reports' and ownerrowid=g2b(areportsid);
  end if;
    select 'ok' result;
 end 
go
GO

/*описание*/

drop procedure if exists reports_save
go

create procedure reports_save /*описание*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 areportsid varchar(38)
,aname
 varchar (255)/* название *//* название */
,areportfile varchar(255)/* файл отчета */
,areportfile_ext varchar(4) /* файл отчета */
,acaption
 varchar (255)/* заголовок *//* заголовок */
,apreparemethod varchar(38)/* метод для формирования *//* метод для формирования */
,areporttype
 integer/* тип отчета *//* тип отчета */
,athereportext varchar(38)/* расширение для создания отчета *//* расширение для создания отчета */
,areportview
 varchar (255)/* базовый запрос *//* базовый запрос */
,athecomment
 text/* описание *//* описание */
)  body: begin  
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from reports where reportsid=g2b(areportsid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=reports' result;
    leave body;
  end if;
 start transaction ; 
 call reports_logger(acursession,areportsid) ; 
 update  reports set changestamp=now()
,
  name=aname
,
  reportfile=areportfile
,reportfile_ext=
areportfile_ext 
,
  caption=acaption
,
  preparemethod=g2b(apreparemethod)
,
  reporttype=areporttype
,
  thereportext=g2b(athereportext)
,
  reportview=areportview
,
  thecomment=athecomment
  where  reportsid = g2b(areportsid) ;


call reports_client_trigger(acursession,areportsid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'mtzrprt.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=reports' result;
    leave body;
  end if;
select count(*) into aec from reports where 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;reports&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   reports
 (  reportsid 
,instanceid
,name

,reportfile

,reportfile_ext
,caption

,preparemethod

,reporttype

,thereportext

,reportview

,thecomment

 ) values ( g2b(areportsid) 
,g2b(ainstanceid)
,aname

,areportfile

,areportfile_ext
,acaption

,g2b(apreparemethod)

,areporttype

,g2b(athereportext)

,areportview

,athecomment

 ) ;


call reports_client_trigger(acursession,areportsid);

 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists reports_copy
go

create procedure reports_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into reports 
 ( reportsid 
,instanceid
,name

,reportfile

,reportfile_ext
,caption

,preparemethod

,reporttype

,thereportext

,reportview

,thecomment

 ) select 
copymap(acopyaction,b2g(reportsid)) 
,copymap(acopyaction,b2g(instanceid))
,name

,reportfile

,reportfile_ext
,caption

,preparemethod

,reporttype

,thereportext

,reportview

,thecomment

 from reports
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists reports_logger
go

create procedure reports_logger /*описание*/ (
 acursession varchar(38),
 areportsid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists reports_parent
go
create procedure reports_parent /* описание*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from reports where  reportsid=arowid;
 end 
go
GO


drop procedure if exists reports_islocked
go
create procedure reports_islocked /* описание */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from reports where reportsid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists reports_lock
go
create procedure reports_lock /* описание */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call reports_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update reports set lockuserid =auserid ,locksessionid=null  where reportsid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update reports set lockuserid=null ,locksessionid =acursession  where reportsid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists reports_unlock
go
create procedure reports_unlock /* описание */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call reports_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update reports set lockuserid =null  where reportsid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update reports set locksessionid =null  where reportsid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS reports_client_trigger
GO

create procedure reports_client_trigger  (
 acursession varchar(38),
 aReportsid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO


drop procedure if exists iu_subsribe_gettotemp
go

create procedure iu_subsribe_gettotemp (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
delete from iu_subsribe_temp
 where  sessionid=g2b(acursession) and instanceid =g2b(ainstanceid); 
 insert into iu_subsribe_temp 
 (timestamp,changestamp,sessionid, iu_subsribeid 
,instanceid
,subscriber

,isactive

,scandate

,eventtype

,theprocess

,processstatus

,statetask

,doer

,thedoc

,thevideo

,thediscussion

 ) select 
timestamp,changestamp,g2b(acursession),iu_subsribeid 
,instanceid
,subscriber

,isactive

,scandate

,eventtype

,theprocess

,processstatus

,statetask

,doer

,thedoc

,thevideo

,thediscussion

 from iu_subsribe
 where instanceid =g2b(ainstanceid); 
 end 
go
GO


drop procedure if exists iu_subsribe_commitfromtemp
go

create procedure iu_subsribe_commitfromtemp (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
delete from iu_subsribe
 where   instanceid =g2b(ainstanceid); 
 insert into iu_subsribe 
 (timestamp, changestamp,iu_subsribeid 
,instanceid
,subscriber

,isactive

,scandate

,eventtype

,theprocess

,processstatus

,statetask

,doer

,thedoc

,thevideo

,thediscussion

 ) select 
timestamp, changestamp,iu_subsribeid 
,instanceid
,subscriber

,isactive

,scandate

,eventtype

,theprocess

,processstatus

,statetask

,doer

,thedoc

,thevideo

,thediscussion

 from iu_subsribe_temp
 where  sessionid=g2b(acursession) and instanceid =g2b(ainstanceid); 
 end 
go
GO


drop procedure if exists iu_subsribe_droptempdata
go

create procedure iu_subsribe_droptempdata (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
delete from iu_subsribe_temp
 where  sessionid=g2b(acursession) and instanceid =g2b(ainstanceid); 
 end 
go
GO


drop procedure if exists iu_subsribe_brief
go

create procedure iu_subsribe_brief  (
 acursession varchar(38),
 aiu_subsribeid varchar(38),
out abrief varchar(255)
) body: begin  
 declare aaccess int;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aec int;
 declare alang2 varchar(25);
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     set abrief=''; leave body;
  end if;
 select lang into alang2 from the_session where the_sessionid=g2b(acursession);
 if aiu_subsribeid is null then set abrief=''; leave body; end if;
 select  count(*) into aec from iu_subsribe where iu_subsribeid=g2b(aiu_subsribeid);
 if  aec &gt;0 then
   set abrief=iu_subsribe_brief_f(g2b(aiu_subsribeid), alang2);
 else
   set abrief= 'неверный идентификатор';
 end if;
 set abrief=left(abrief,255);
end 
go
GO


drop procedure if exists iu_subsribe_delete
go

create procedure iu_subsribe_delete /*подписка на событие*/ (
 acursession varchar(38),
 aiu_subsribeid varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare asyslogid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare atmpid binary(16);
 declare aec int;
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0 then
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_subsribe_temp  where sessionid=g2b(acursession) and iu_subsribeid = g2b(aiu_subsribeid) ;
if aec&gt;0 then
 select checkoperation( acursession ,'iu_subs.edit') into aaccess;
 if aaccess=0  then
    select 'удаление строк не разрешено. раздел=iu_subsribe' result;
    leave body;
  end if;
 call iu_subsribe_logger(acursession,aiu_subsribeid) ; 
  delete from  iu_subsribe_temp 
  where sessionid=g2b(acursession) and iu_subsribeid = g2b(aiu_subsribeid) ;
  delete from num_values where ownerpartname='iu_subsribe' and ownerrowid=g2b(aiu_subsribeid);
  end if;
    select 'ok' result;
 end 
go
GO

/*подписка на событие*/

drop procedure if exists iu_subsribe_save
go

create procedure iu_subsribe_save /*подписка на событие*/ (
 acursession varchar(38),
ainstanceid varchar(38) ,
 aiu_subsribeid varchar(38)
,asubscriber varchar(38)/* подписчик *//* подписчик */
,aisactive
 integer/* подписка активна *//* подписка активна */
,ascandate
 datetime/* время последней обработки *//* время последней обработки */
,aeventtype
 varchar (255)/* тип события *//* тип события */
,atheprocess varchar(38)/* урок *//* урок */
,aprocessstatus varchar(38)/* подэтап *//* подэтап */
,astatetask varchar(38)/* задача *//* задача */
,adoer varchar(38)/* сотрудник *//* сотрудник */
,athedoc varchar(38)/* документ *//* документ */
,athevideo varchar(38)/* видео *//* видео */
,athediscussion varchar(38)/* обсуждение *//* обсуждение */
)  body: begin  
declare asyslogid binary(16);
 declare auniquerowcount integer;
 declare atmpstr varchar(255);
 declare atmpid binary(16);
 declare aaccess int;
 declare asysinstid binary(16);
 declare asessuserid binary(16);
 declare amlf_partid binary(16);
 declare asessuserlogin varchar(40);
 declare aec int;
 select usersid into asessuserid from the_session where the_sessionid=g2b(acursession);
 select login into asessuserlogin from users where usersid=g2b(asessuserid);
 select instanceid into asysinstid from instance where objtype='mtzsystem';
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
  select 'сессия уже завершена.' result;
    leave body;
  end if;
/*if exists */ select  count(*) into aec from iu_subsribe_temp where sessionid=g2b(acursession) and iu_subsribeid=g2b(aiu_subsribeid);
if aec &gt;0 then
 --  update  --
 --  verify access  --
 select checkoperation( acursession ,'iu_subs.edit') into aaccess;
 if aaccess=0  then
    select 'изменение строк не разрешено. раздел=iu_subsribe' result;
    leave body;
  end if;
 start transaction ; 
 call iu_subsribe_logger(acursession,aiu_subsribeid) ; 
 update  iu_subsribe_temp set changestamp=now()
,
  subscriber=g2b(asubscriber)
,
  isactive=aisactive
,
  scandate=ascandate
,
  eventtype=aeventtype
,
  theprocess=g2b(atheprocess)
,
  processstatus=g2b(aprocessstatus)
,
  statetask=g2b(astatetask)
,
  doer=g2b(adoer)
,
  thedoc=g2b(athedoc)
,
  thevideo=g2b(athevideo)
,
  thediscussion=g2b(athediscussion)
  where  sessionid=g2b(acursession) and iu_subsribeid = g2b(aiu_subsribeid) ;


call iu_subsribe_client_trigger(acursession,aiu_subsribeid);

 else
 --  insert  --
 --  verify access  --
 select checkoperation( acursession ,'iu_subs.edit') into aaccess;
 if aaccess=0  then
    select 'добавление строк не разрешено. раздел=iu_subsribe' result;
    leave body;
  end if;
select count(*) into aec from iu_subsribe_temp where  sessionid=g2b(acursession) and 
instanceid=g2b(ainstanceid);
if aec &gt;0 then 
    select 'невозможно создать вторую строку в однострочной сессии. раздел: &lt;iu_subsribe&gt;' result;
    rollback;
    leave body;
 end if;
 start transaction;  
 insert into   iu_subsribe_temp
 ( sessionid, iu_subsribeid 
,instanceid
,subscriber

,isactive

,scandate

,eventtype

,theprocess

,processstatus

,statetask

,doer

,thedoc

,thevideo

,thediscussion

 ) values ( g2b(acursession), g2b(aiu_subsribeid) 
,g2b(ainstanceid)
,g2b(asubscriber)

,aisactive

,ascandate

,aeventtype

,g2b(atheprocess)

,g2b(aprocessstatus)

,g2b(astatetask)

,g2b(adoer)

,g2b(athedoc)

,g2b(athevideo)

,g2b(athediscussion)

 ) ;


call iu_subsribe_client_trigger(acursession,aiu_subsribeid);

 call iu_subs_initownership( acursession,ainstanceid);
 end if;
 commit; 
select 'ok' result;
 end 
go
GO


drop procedure if exists iu_subsribe_copy
go

create procedure iu_subsribe_copy (
 acursession varchar(38),
 acopyaction varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    leave body;
 end if;
 insert into iu_subsribe 
 ( iu_subsribeid 
,instanceid
,subscriber

,isactive

,scandate

,eventtype

,theprocess

,processstatus

,statetask

,doer

,thedoc

,thevideo

,thediscussion

 ) select 
copymap(acopyaction,b2g(iu_subsribeid)) 
,copymap(acopyaction,b2g(instanceid))
,subscriber

,isactive

,scandate

,eventtype

,theprocess

,processstatus

,statetask

,doer

,thedoc

,thevideo

,thediscussion

 from iu_subsribe
 where instanceid =g2b( ainstanceid); 
 end 
go
GO


drop procedure if exists iu_subsribe_logger
go

create procedure iu_subsribe_logger /*подписка на событие*/ (
 acursession varchar(38),
 aiu_subsribeid varchar(38)
)  body: begin  
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
    leave body;
 end if;
 end 
go
GO


drop procedure if exists iu_subsribe_parent
go
create procedure iu_subsribe_parent /* подписка на событие*/ (
 acursession varchar(38),
 arowid binary(16) ,
out  aparentid binary(16),
out aparenttable varchar(255)
) body:begin  
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
  set aparenttable = 'instance';
  select instanceid into aparentid from iu_subsribe where  iu_subsribeid=arowid;
 end 
go
GO


drop procedure if exists iu_subsribe_islocked
go
create procedure iu_subsribe_islocked /* подписка на событие */ (
 acursession varchar(38),
 arowid binary(16) ,
 out aislocked integer
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare alockuserid binary(16);
 declare alocksessionid binary(16);
 declare aparenttable varchar(255); 
declare aec  int;
 set aislocked = 0;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select  usersid into auserid  from the_session where the_sessionid=acursession;
 select  lockuserid,locksessionid into alockuserid, alocksessionid from iu_subsribe where iu_subsribeid=arowid;
 /* verify this row */
 if not alockuserid is null  then
   if  alockuserid &lt;&gt; auserid  then
     set aislocked = 4; /* checkout by another user */
     leave body;
   else 
     set aislocked = 2; /* checkout by caller */
     leave body;
   end if;  
 end if;  
 if not alocksessionid is null then 
   if  alocksessionid &lt;&gt; acursession  then
     set aislocked = 3 ;/* lockes by another user */
     leave body;
   else 
     set aislocked = 1; /* locked by caller */
     leave body;
   end if;  
 end if;  
 set aislocked = 0; 
 end 
 go
GO


drop procedure if exists iu_subsribe_lock
go
create procedure iu_subsribe_lock /* подписка на событие */ (
 acursession varchar(38),
 arowid binary(16) ,
 alockmode integer 
) body:begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare atmpid binary(16);
 declare aaccess integer;
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select auserid = usersid  from the_session where the_sessionid=acursession;
 call iu_subsribe_islocked( acursession,arowid,aislocked);
 if aislocked &gt;=3  then
    leave body;
  end if;
   if  alockmode =2  then
    update iu_subsribe set lockuserid =auserid ,locksessionid=null  where iu_subsribeid=arowid;
     leave body;
   end if;
   if  alockmode =1  then
    update iu_subsribe set lockuserid=null ,locksessionid =acursession  where iu_subsribeid=arowid;
     leave body;
   end if;
 end 
 go 
GO


drop procedure if exists iu_subsribe_unlock
go
create procedure iu_subsribe_unlock /* подписка на событие */ (
 acursession varchar(38),
 arowid binary(16) 
) body: begin  
 declare aparentid binary(16);
 declare auserid binary(16);
 declare aislocked integer;
 declare aparenttable varchar(255); 
declare aec  int;
select count(*) into aec from the_session where the_sessionid=acursession and closed=0 ;
if aec=0  then
    leave body;
end if;
 select usersid into auserid  from the_session where the_sessionid=acursession;
 call iu_subsribe_islocked( acursession,arowid,aislocked );
 if aislocked &gt;=3  then
    leave body;
   end if;
   if  aislocked =2  then
    update iu_subsribe set lockuserid =null  where iu_subsribeid=arowid;
    leave body;
   end if;
   if  aislocked =1  then
    update iu_subsribe set locksessionid =null  where iu_subsribeid=arowid;
    leave body;
   end if;
 end 
go
GO


drop procedure IF EXISTS iu_subsribe_client_trigger
GO

create procedure iu_subsribe_client_trigger  (
 acursession varchar(38),
 aiu_subsribeid varchar(38)
) 
 begin  
   declare aBRIEF varchar(255);
  set aBRIEF='to do';
end 
GO
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--Methods" BlockCode=" 
/* SessionTouch  Поддержание сессии*/

drop procedure IF EXISTS SessionTouch
GO
create procedure SessionTouch

(aCURSESSION BINARY(16)/* Идентификатор сессии */

)
 
body:begin

update the_session set lastaccess=now() where the_sessionid=acursession and closed=0;



end
GO
/* GetServerTime  текущее время сервера*/

drop procedure IF EXISTS GetServerTime
GO
create procedure GetServerTime

( out aServerTime DATETIME/* Текущее время */

)
 
body:begin

set aServerTime=now();


end
GO
/* Logout  Завершение сессии*/

drop procedure IF EXISTS Logout
GO
create procedure Logout

(aCURSESSION BINARY(16)/* Идентификатор сессии */

)
 
body:begin
declare
existsCnt integer;

select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt &gt;0 then
    update INSTANCE set LockSessionID =null where LockSessionID=acursession ;
    update the_session set closed=1,closedAt=now(), changeStamp=now() where     
    the_sessionid=acursession;
 End if;

end
GO
/* Login  Открытие сессии*/

drop procedure IF EXISTS Login
GO
create procedure Login

( out aTHE_SESSION BINARY(16)/* Идентификатор новой сессии */

,aPWD VARCHAR(80)/* Пароль */

,aUSR VARCHAR (64)/* Имя пользователя */

)
 
body:begin
 declare aID binary(16); 
    declare aUSERSID binary(16); 
    declare asysid binary(16); 
    declare existsCnt int;  

set asysid = null; 

select instanceid into asysid from instance where objtype = 'MTZSYSTEM'; 

set athe_session=null  ; 

if aPWD is null then 
 select count(*) into existsCnt from users where Login=ausr and Password is null; 
  if existsCNt =1 then 
    select USERSID into ausersid from users where Login=ausr and Password is null; 
    set  aID=G2B(UUID()); 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,now(),ausersid,0,now()); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,now(),ausersid,0,now()); 
       end if; 
	   set athe_session=aid; 
  End if; 
else 
 
  select count(*) into existsCnt from users where Login=ausr and Password =aPWD; 
  if existsCNt =1   then 
   select USERSID into ausersid from users where Login=ausr and Password =aPWD; 
   set  aID=G2B(UUID())  ; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,now()); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,now(),ausersid,0,now()); 
       end if; 
       set athe_session=aid; 
  else 
    select count(*) into existsCnt from users where DomaiName=ausr and aPWD='INTEGRATED'; 
    if existsCNt =1 
    then 
     select USERSID into ausersid from users where DomaiName =ausr ; 
     set aid=G2B(UUID()); 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,now(),ausersid,0,now()); 
 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,now(),ausersid,0,now()); 
       end if; 
     set athe_session=aid; 
    End if; 
  end if; 
end if; 

end
GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Kernel views" File="">
    <BlockHolder BlockName="--body" BlockCode=" 


drop view if exists v_instance
go
create view v_instance as
select b2g(`instance`.`instanceid`) as `instanceid`,`instance`.`lockuserid` as `lockuserid`,`instance`.`locksessionid` as `locksessionid`,`instance`.`securitystyleid` as `securitystyleid`,`instance`.`name` as `name`,`instance`.`objtype` as `objtype`,`instance`.`ownerpartname` as `ownerpartname`,`instance`.`ownerrowid` as `ownerrowid`,`instance`.`status` as `status`,`instance`.`archived` as `archived`,`objstatus`.`name` as `statusname`,`objstatus`.`isarchive` as `isarchive` from (`instance` left join `objstatus` on((`instance`.`status` = `objstatus`.`objstatusid`)));
go
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Views--" File="">
    <BlockHolder BlockName="--Views--" BlockCode=" 


drop view if exists v_autoiud_stagedef
go
create view v_autoiud_stagedef as 
select   b2g(iud_stagedef. iud_stagedefid) iud_stagedefid,iud_stagedef. changestamp changestamp
, 
iud_stagedef.name 
iud_stagedef_name 
, 
iud_stagedef.stageicon 
iud_stagedef_stageicon 
, 
iud_stagedef.sequence 
iud_stagedef_sequence 
, b2g(iud_stagedef.instanceid) instanceid 
, iud_stagedef.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_stagedef.iud_stagedefid) id 
, 'iud_stagedef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_stagedef
 join INSTANCE on iud_stagedef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_stagedef_ru_ru
go
create view v_autoiud_stagedef_ru_ru as 
select   b2g(iud_stagedef. iud_stagedefid) iud_stagedefid,iud_stagedef. changestamp changestamp
, 
iud_stagedef.name 
iud_stagedef_name 
, 
iud_stagedef.stageicon 
iud_stagedef_stageicon 
, 
iud_stagedef.sequence 
iud_stagedef_sequence 
, b2g(iud_stagedef.instanceid) instanceid 
, iud_stagedef.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_stagedef.iud_stagedefid) id 
, 'iud_stagedef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_stagedef
 join INSTANCE on iud_stagedef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_stagedef_en_us
go
create view v_autoiud_stagedef_en_us as 
select   b2g(iud_stagedef. iud_stagedefid) iud_stagedefid,iud_stagedef. changestamp changestamp
, 
iud_stagedef.name 
iud_stagedef_name 
, 
iud_stagedef.stageicon 
iud_stagedef_stageicon 
, 
iud_stagedef.sequence 
iud_stagedef_sequence 
, b2g(iud_stagedef.instanceid) instanceid 
, iud_stagedef.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_stagedef.iud_stagedefid) id 
, 'iud_stagedef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_stagedef
 join INSTANCE on iud_stagedef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_adt_doc
go
create view v_autoiud_adt_doc as 
select   b2g(iud_adt_doc. iud_adt_docid) iud_adt_docid,iud_adt_doc. changestamp changestamp
, 
iud_adt_doc.name 
iud_adt_doc_name 
, b2g(iud_adt_doc.instanceid) instanceid 
, iud_adt_doc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_adt_doc.iud_adt_docid) id 
, 'iud_adt_doc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_adt_doc
 join INSTANCE on iud_adt_doc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_adt_doc_ru_ru
go
create view v_autoiud_adt_doc_ru_ru as 
select   b2g(iud_adt_doc. iud_adt_docid) iud_adt_docid,iud_adt_doc. changestamp changestamp
, 
iud_adt_doc.name 
iud_adt_doc_name 
, b2g(iud_adt_doc.instanceid) instanceid 
, iud_adt_doc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_adt_doc.iud_adt_docid) id 
, 'iud_adt_doc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_adt_doc
 join INSTANCE on iud_adt_doc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_adt_doc_en_us
go
create view v_autoiud_adt_doc_en_us as 
select   b2g(iud_adt_doc. iud_adt_docid) iud_adt_docid,iud_adt_doc. changestamp changestamp
, 
iud_adt_doc.name 
iud_adt_doc_name 
, b2g(iud_adt_doc.instanceid) instanceid 
, iud_adt_doc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_adt_doc.iud_adt_docid) id 
, 'iud_adt_doc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_adt_doc
 join INSTANCE on iud_adt_doc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_orgtree
go
create view v_autoiu_orgtree as 
select   b2g(iu_orgtree. iu_orgtreeid) iu_orgtreeid,iu_orgtree. changestamp changestamp
, 
iu_orgtree.name 
iu_orgtree_name 
, b2g(iu_orgtree.instanceid) instanceid 
, iu_orgtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_orgtree.iu_orgtreeid) id 
, 'iu_orgtree' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_orgtree
 join INSTANCE on iu_orgtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_orgtree_ru_ru
go
create view v_autoiu_orgtree_ru_ru as 
select   b2g(iu_orgtree. iu_orgtreeid) iu_orgtreeid,iu_orgtree. changestamp changestamp
, 
iu_orgtree.name 
iu_orgtree_name 
, b2g(iu_orgtree.instanceid) instanceid 
, iu_orgtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_orgtree.iu_orgtreeid) id 
, 'iu_orgtree' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_orgtree
 join INSTANCE on iu_orgtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_orgtree_en_us
go
create view v_autoiu_orgtree_en_us as 
select   b2g(iu_orgtree. iu_orgtreeid) iu_orgtreeid,iu_orgtree. changestamp changestamp
, 
iu_orgtree.name 
iu_orgtree_name 
, b2g(iu_orgtree.instanceid) instanceid 
, iu_orgtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_orgtree.iu_orgtreeid) id 
, 'iu_orgtree' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_orgtree
 join INSTANCE on iu_orgtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_orgusr
go
create view v_autoiu_orgusr as 
select   b2g(iu_orgusr. iu_orgusrid) iu_orgusrid,iu_orgusr. changestamp changestamp, b2g(iu_orgtreeid) iu_orgtreeid
, 
 iu_orgusr.ismanager  
iu_orgusr_ismanager_val, 
 case iu_orgusr.ismanager 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_orgusr_ismanager 
, 
 b2g(iu_orgusr.orguser)  
iu_orgusr_orguser_id, 
 iu_u_def_brief_f(iu_orgusr.orguser, null) 
iu_orgusr_orguser 
, b2g(iu_orgtree.instanceid) instanceid 
, iu_orgtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_orgusr.iu_orgusrid) id 
, 'iu_orgusr' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_orgusr
 join iu_orgtree on iu_orgtree.iu_orgtreeID=iu_orgusr.ParentStructRowID 
 join INSTANCE on iu_orgtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_orgusr_ru_ru
go
create view v_autoiu_orgusr_ru_ru as 
select   b2g(iu_orgusr. iu_orgusrid) iu_orgusrid,iu_orgusr. changestamp changestamp, b2g(iu_orgtreeid) iu_orgtreeid
, 
 iu_orgusr.ismanager  
iu_orgusr_ismanager_val, 
 case iu_orgusr.ismanager 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_orgusr_ismanager 
, 
 b2g(iu_orgusr.orguser)  
iu_orgusr_orguser_id, 
 iu_u_def_brief_f(iu_orgusr.orguser, 'ru_ru') 
iu_orgusr_orguser 
, b2g(iu_orgtree.instanceid) instanceid 
, iu_orgtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_orgusr.iu_orgusrid) id 
, 'iu_orgusr' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_orgusr
 join iu_orgtree on iu_orgtree.iu_orgtreeID=iu_orgusr.ParentStructRowID 
 join INSTANCE on iu_orgtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_orgusr_en_us
go
create view v_autoiu_orgusr_en_us as 
select   b2g(iu_orgusr. iu_orgusrid) iu_orgusrid,iu_orgusr. changestamp changestamp, b2g(iu_orgtreeid) iu_orgtreeid
, 
 iu_orgusr.ismanager  
iu_orgusr_ismanager_val, 
 case iu_orgusr.ismanager 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_orgusr_ismanager 
, 
 b2g(iu_orgusr.orguser)  
iu_orgusr_orguser_id, 
 iu_u_def_brief_f(iu_orgusr.orguser, 'en_us') 
iu_orgusr_orguser 
, b2g(iu_orgtree.instanceid) instanceid 
, iu_orgtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_orgusr.iu_orgusrid) id 
, 'iu_orgusr' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_orgusr
 join iu_orgtree on iu_orgtree.iu_orgtreeID=iu_orgusr.ParentStructRowID 
 join INSTANCE on iu_orgtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_u_def
go
create view v_autoiu_u_def as 
select   b2g(iu_u_def. iu_u_defid) iu_u_defid,iu_u_def. changestamp changestamp
, 
iu_u_def.lastname 
iu_u_def_lastname 
, 
iu_u_def.login 
iu_u_def_login 
, 
 b2g(iu_u_def.thetown)  
iu_u_def_thetown_id, 
 iud_town_brief_f(iu_u_def.thetown, null) 
iu_u_def_thetown 
, 
iu_u_def.email 
iu_u_def_email 
, 
iu_u_def.name 
iu_u_def_name 
, 
 b2g(iu_u_def.currole)  
iu_u_def_currole_id, 
 iu_crole_brief_f(iu_u_def.currole, null) 
iu_u_def_currole 
, 
iu_u_def.surname 
iu_u_def_surname 
, 
iu_u_def.thephone 
iu_u_def_thephone 
, 
iu_u_def.lastsend 
iu_u_def_lastsend 
, 
 iu_u_def.freelancer  
iu_u_def_freelancer_val, 
 case iu_u_def.freelancer 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_u_def_freelancer 
, 
 iu_u_def.sendtomail  
iu_u_def_sendtomail_val, 
 case iu_u_def.sendtomail 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_u_def_sendtomail 
, b2g(iu_u_def.instanceid) instanceid 
, iu_u_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_u_def.iu_u_defid) id 
, 'iu_u_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_u_def
 join INSTANCE on iu_u_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_u_def_ru_ru
go
create view v_autoiu_u_def_ru_ru as 
select   b2g(iu_u_def. iu_u_defid) iu_u_defid,iu_u_def. changestamp changestamp
, 
iu_u_def.lastname 
iu_u_def_lastname 
, 
iu_u_def.login 
iu_u_def_login 
, 
 b2g(iu_u_def.thetown)  
iu_u_def_thetown_id, 
 iud_town_brief_f(iu_u_def.thetown, 'ru_ru') 
iu_u_def_thetown 
, 
iu_u_def.email 
iu_u_def_email 
, 
iu_u_def.name 
iu_u_def_name 
, 
 b2g(iu_u_def.currole)  
iu_u_def_currole_id, 
 iu_crole_brief_f(iu_u_def.currole, 'ru_ru') 
iu_u_def_currole 
, 
iu_u_def.surname 
iu_u_def_surname 
, 
iu_u_def.thephone 
iu_u_def_thephone 
, 
iu_u_def.lastsend 
iu_u_def_lastsend 
, 
 iu_u_def.freelancer  
iu_u_def_freelancer_val, 
 case iu_u_def.freelancer 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_u_def_freelancer 
, 
 iu_u_def.sendtomail  
iu_u_def_sendtomail_val, 
 case iu_u_def.sendtomail 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_u_def_sendtomail 
, b2g(iu_u_def.instanceid) instanceid 
, iu_u_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_u_def.iu_u_defid) id 
, 'iu_u_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_u_def
 join INSTANCE on iu_u_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_u_def_en_us
go
create view v_autoiu_u_def_en_us as 
select   b2g(iu_u_def. iu_u_defid) iu_u_defid,iu_u_def. changestamp changestamp
, 
iu_u_def.lastname 
iu_u_def_lastname 
, 
iu_u_def.login 
iu_u_def_login 
, 
 b2g(iu_u_def.thetown)  
iu_u_def_thetown_id, 
 iud_town_brief_f(iu_u_def.thetown, 'en_us') 
iu_u_def_thetown 
, 
iu_u_def.email 
iu_u_def_email 
, 
iu_u_def.name 
iu_u_def_name 
, 
 b2g(iu_u_def.currole)  
iu_u_def_currole_id, 
 iu_crole_brief_f(iu_u_def.currole, 'en_us') 
iu_u_def_currole 
, 
iu_u_def.surname 
iu_u_def_surname 
, 
iu_u_def.thephone 
iu_u_def_thephone 
, 
iu_u_def.lastsend 
iu_u_def_lastsend 
, 
 iu_u_def.freelancer  
iu_u_def_freelancer_val, 
 case iu_u_def.freelancer 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_u_def_freelancer 
, 
 iu_u_def.sendtomail  
iu_u_def_sendtomail_val, 
 case iu_u_def.sendtomail 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_u_def_sendtomail 
, b2g(iu_u_def.instanceid) instanceid 
, iu_u_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_u_def.iu_u_defid) id 
, 'iu_u_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_u_def
 join INSTANCE on iu_u_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_process_def
go
create view v_autoiud_process_def as 
select   b2g(iud_process_def. iud_process_defid) iud_process_defid,iud_process_def. changestamp changestamp
, 
iud_process_def.name 
iud_process_def_name 
, b2g(iud_process_def.instanceid) instanceid 
, iud_process_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_process_def.iud_process_defid) id 
, 'iud_process_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_process_def
 join INSTANCE on iud_process_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_process_def_ru_ru
go
create view v_autoiud_process_def_ru_ru as 
select   b2g(iud_process_def. iud_process_defid) iud_process_defid,iud_process_def. changestamp changestamp
, 
iud_process_def.name 
iud_process_def_name 
, b2g(iud_process_def.instanceid) instanceid 
, iud_process_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_process_def.iud_process_defid) id 
, 'iud_process_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_process_def
 join INSTANCE on iud_process_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_process_def_en_us
go
create view v_autoiud_process_def_en_us as 
select   b2g(iud_process_def. iud_process_defid) iud_process_defid,iud_process_def. changestamp changestamp
, 
iud_process_def.name 
iud_process_def_name 
, b2g(iud_process_def.instanceid) instanceid 
, iud_process_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_process_def.iud_process_defid) id 
, 'iud_process_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_process_def
 join INSTANCE on iud_process_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenpackage
go
create view v_autogenpackage as 
select   b2g(genpackage. genpackageid) genpackageid,genpackage. changestamp changestamp
, 
genpackage.name 
genpackage_name 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(genpackage.genpackageid) id 
, 'genpackage' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENPACKAGE
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenpackage_ru_ru
go
create view v_autogenpackage_ru_ru as 
select   b2g(genpackage. genpackageid) genpackageid,genpackage. changestamp changestamp
, 
genpackage.name 
genpackage_name 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(genpackage.genpackageid) id 
, 'genpackage' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENPACKAGE
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenpackage_en_us
go
create view v_autogenpackage_en_us as 
select   b2g(genpackage. genpackageid) genpackageid,genpackage. changestamp changestamp
, 
genpackage.name 
genpackage_name 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(genpackage.genpackageid) id 
, 'genpackage' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENPACKAGE
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenerator_target
go
create view v_autogenerator_target as 
select   b2g(generator_target. generator_targetid) generator_targetid,generator_target. changestamp changestamp, b2g(genpackageid) genpackageid
, 
 generator_target.generatorstyle  
generator_target_generatorstyle_val, 
 case generator_target.generatorstyle 
when 0 then 'один тип'
when 1 then 'все типы сразу'
 else '' 
 end  
generator_target_generatorstyle 
, 
 generator_target.targettype  
generator_target_targettype_val, 
 case generator_target.targettype 
when 0 then 'субд'
when 3 then 'документация'
when 1 then 'модель'
when 2 then 'приложение'
when 4 then 'арм'
 else '' 
 end  
generator_target_targettype 
, 
generator_target.name 
generator_target_name 
, 
generator_target.queuename 
generator_target_queuename 
, 
generator_target.generatorprogid 
generator_target_generatorprogid 
, 
 generator_target.thedevelopmentenv  
generator_target_thedevelopmentenv_val, 
 case generator_target.thedevelopmentenv 
when 3 then 'other'
when 1 then 'dotnet'
when 2 then 'java'
when 0 then 'vb6'
 else '' 
 end  
generator_target_thedevelopmentenv 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(generator_target.generator_targetid) id 
, 'generator_target' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENERATOR_TARGET
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenerator_target_ru_ru
go
create view v_autogenerator_target_ru_ru as 
select   b2g(generator_target. generator_targetid) generator_targetid,generator_target. changestamp changestamp, b2g(genpackageid) genpackageid
, 
 generator_target.generatorstyle  
generator_target_generatorstyle_val, 
 case generator_target.generatorstyle 
when 0 then 'один тип'
when 1 then 'все типы сразу'
 else '' 
 end  
generator_target_generatorstyle 
, 
 generator_target.targettype  
generator_target_targettype_val, 
 case generator_target.targettype 
when 0 then 'субд'
when 3 then 'документация'
when 1 then 'модель'
when 2 then 'приложение'
when 4 then 'арм'
 else '' 
 end  
generator_target_targettype 
, 
generator_target.name 
generator_target_name 
, 
generator_target.queuename 
generator_target_queuename 
, 
generator_target.generatorprogid 
generator_target_generatorprogid 
, 
 generator_target.thedevelopmentenv  
generator_target_thedevelopmentenv_val, 
 case generator_target.thedevelopmentenv 
when 3 then 'other'
when 1 then 'dotnet'
when 2 then 'java'
when 0 then 'vb6'
 else '' 
 end  
generator_target_thedevelopmentenv 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(generator_target.generator_targetid) id 
, 'generator_target' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENERATOR_TARGET
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenerator_target_en_us
go
create view v_autogenerator_target_en_us as 
select   b2g(generator_target. generator_targetid) generator_targetid,generator_target. changestamp changestamp, b2g(genpackageid) genpackageid
, 
 generator_target.generatorstyle  
generator_target_generatorstyle_val, 
 case generator_target.generatorstyle 
when 0 then 'один тип'
when 1 then 'все типы сразу'
 else '' 
 end  
generator_target_generatorstyle 
, 
 generator_target.targettype  
generator_target_targettype_val, 
 case generator_target.targettype 
when 0 then 'субд'
when 3 then 'документация'
when 1 then 'модель'
when 2 then 'приложение'
when 4 then 'арм'
 else '' 
 end  
generator_target_targettype 
, 
generator_target.name 
generator_target_name 
, 
generator_target.queuename 
generator_target_queuename 
, 
generator_target.generatorprogid 
generator_target_generatorprogid 
, 
 generator_target.thedevelopmentenv  
generator_target_thedevelopmentenv_val, 
 case generator_target.thedevelopmentenv 
when 3 then 'other'
when 1 then 'dotnet'
when 2 then 'java'
when 0 then 'vb6'
 else '' 
 end  
generator_target_thedevelopmentenv 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(generator_target.generator_targetid) id 
, 'generator_target' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENERATOR_TARGET
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenreference
go
create view v_autogenreference as 
select   b2g(genreference. genreferenceid) genreferenceid,genreference. changestamp changestamp, b2g(generator_targetid) generator_targetid, b2g(genpackageid) genpackageid
, 
genreference.versionmajor 
genreference_versionmajor 
, 
genreference.versionminor 
genreference_versionminor 
, 
genreference.refclassid 
genreference_refclassid 
, 
genreference.name 
genreference_name 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(genreference.genreferenceid) id 
, 'genreference' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENREFERENCE
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENREFERENCE.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenreference_ru_ru
go
create view v_autogenreference_ru_ru as 
select   b2g(genreference. genreferenceid) genreferenceid,genreference. changestamp changestamp, b2g(generator_targetid) generator_targetid, b2g(genpackageid) genpackageid
, 
genreference.versionmajor 
genreference_versionmajor 
, 
genreference.versionminor 
genreference_versionminor 
, 
genreference.refclassid 
genreference_refclassid 
, 
genreference.name 
genreference_name 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(genreference.genreferenceid) id 
, 'genreference' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENREFERENCE
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENREFERENCE.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenreference_en_us
go
create view v_autogenreference_en_us as 
select   b2g(genreference. genreferenceid) genreferenceid,genreference. changestamp changestamp, b2g(generator_targetid) generator_targetid, b2g(genpackageid) genpackageid
, 
genreference.versionmajor 
genreference_versionmajor 
, 
genreference.versionminor 
genreference_versionminor 
, 
genreference.refclassid 
genreference_refclassid 
, 
genreference.name 
genreference_name 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(genreference.genreferenceid) id 
, 'genreference' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENREFERENCE
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENREFERENCE.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenmanualcode
go
create view v_autogenmanualcode as 
select   b2g(genmanualcode. genmanualcodeid) genmanualcodeid,genmanualcode. changestamp changestamp, b2g(generator_targetid) generator_targetid, b2g(genpackageid) genpackageid
, 
genmanualcode.name 
genmanualcode_name 
, 
genmanualcode.code 
genmanualcode_code 
, 
genmanualcode.the_alias 
genmanualcode_the_alias 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(genmanualcode.genmanualcodeid) id 
, 'genmanualcode' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENMANUALCODE
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENMANUALCODE.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenmanualcode_ru_ru
go
create view v_autogenmanualcode_ru_ru as 
select   b2g(genmanualcode. genmanualcodeid) genmanualcodeid,genmanualcode. changestamp changestamp, b2g(generator_targetid) generator_targetid, b2g(genpackageid) genpackageid
, 
genmanualcode.name 
genmanualcode_name 
, 
genmanualcode.code 
genmanualcode_code 
, 
genmanualcode.the_alias 
genmanualcode_the_alias 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(genmanualcode.genmanualcodeid) id 
, 'genmanualcode' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENMANUALCODE
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENMANUALCODE.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogenmanualcode_en_us
go
create view v_autogenmanualcode_en_us as 
select   b2g(genmanualcode. genmanualcodeid) genmanualcodeid,genmanualcode. changestamp changestamp, b2g(generator_targetid) generator_targetid, b2g(genpackageid) genpackageid
, 
genmanualcode.name 
genmanualcode_name 
, 
genmanualcode.code 
genmanualcode_code 
, 
genmanualcode.the_alias 
genmanualcode_the_alias 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(genmanualcode.genmanualcodeid) id 
, 'genmanualcode' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENMANUALCODE
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENMANUALCODE.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogencontrols
go
create view v_autogencontrols as 
select   b2g(gencontrols. gencontrolsid) gencontrolsid,gencontrols. changestamp changestamp, b2g(generator_targetid) generator_targetid, b2g(genpackageid) genpackageid
, 
gencontrols.versionmajor 
gencontrols_versionmajor 
, 
gencontrols.versionminor 
gencontrols_versionminor 
, 
gencontrols.controlclassid 
gencontrols_controlclassid 
, 
gencontrols.controlprogid 
gencontrols_controlprogid 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(gencontrols.gencontrolsid) id 
, 'gencontrols' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENCONTROLS
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENCONTROLS.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogencontrols_ru_ru
go
create view v_autogencontrols_ru_ru as 
select   b2g(gencontrols. gencontrolsid) gencontrolsid,gencontrols. changestamp changestamp, b2g(generator_targetid) generator_targetid, b2g(genpackageid) genpackageid
, 
gencontrols.versionmajor 
gencontrols_versionmajor 
, 
gencontrols.versionminor 
gencontrols_versionminor 
, 
gencontrols.controlclassid 
gencontrols_controlclassid 
, 
gencontrols.controlprogid 
gencontrols_controlprogid 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(gencontrols.gencontrolsid) id 
, 'gencontrols' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENCONTROLS
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENCONTROLS.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogencontrols_en_us
go
create view v_autogencontrols_en_us as 
select   b2g(gencontrols. gencontrolsid) gencontrolsid,gencontrols. changestamp changestamp, b2g(generator_targetid) generator_targetid, b2g(genpackageid) genpackageid
, 
gencontrols.versionmajor 
gencontrols_versionmajor 
, 
gencontrols.versionminor 
gencontrols_versionminor 
, 
gencontrols.controlclassid 
gencontrols_controlclassid 
, 
gencontrols.controlprogid 
gencontrols_controlprogid 
, b2g(genpackage.instanceid) instanceid 
, genpackage.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(gencontrols.gencontrolsid) id 
, 'gencontrols' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GENCONTROLS
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENCONTROLS.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autolocalizeinfo
go
create view v_autolocalizeinfo as 
select   b2g(localizeinfo. localizeinfoid) localizeinfoid,localizeinfo. changestamp changestamp
, 
localizeinfo.langfull 
localizeinfo_langfull 
, 
localizeinfo.langshort 
localizeinfo_langshort 
, b2g(localizeinfo.instanceid) instanceid 
, localizeinfo.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(localizeinfo.localizeinfoid) id 
, 'localizeinfo' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from LocalizeInfo
 join INSTANCE on LocalizeInfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autolocalizeinfo_ru_ru
go
create view v_autolocalizeinfo_ru_ru as 
select   b2g(localizeinfo. localizeinfoid) localizeinfoid,localizeinfo. changestamp changestamp
, 
localizeinfo.langfull 
localizeinfo_langfull 
, 
localizeinfo.langshort 
localizeinfo_langshort 
, b2g(localizeinfo.instanceid) instanceid 
, localizeinfo.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(localizeinfo.localizeinfoid) id 
, 'localizeinfo' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from LocalizeInfo
 join INSTANCE on LocalizeInfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autolocalizeinfo_en_us
go
create view v_autolocalizeinfo_en_us as 
select   b2g(localizeinfo. localizeinfoid) localizeinfoid,localizeinfo. changestamp changestamp
, 
localizeinfo.langfull 
localizeinfo_langfull 
, 
localizeinfo.langshort 
localizeinfo_langshort 
, b2g(localizeinfo.instanceid) instanceid 
, localizeinfo.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(localizeinfo.localizeinfoid) id 
, 'localizeinfo' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from LocalizeInfo
 join INSTANCE on LocalizeInfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldtype
go
create view v_autofieldtype as 
select   b2g(fieldtype. fieldtypeid) fieldtypeid,fieldtype. changestamp changestamp
, 
 fieldtype.delayedsave  
fieldtype_delayedsave_val, 
 case fieldtype.delayedsave 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldtype_delayedsave 
, 
fieldtype.minimum 
fieldtype_minimum 
, 
 fieldtype.allowsize  
fieldtype_allowsize_val, 
 case fieldtype.allowsize 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldtype_allowsize 
, 
 fieldtype.allowlikesearch  
fieldtype_allowlikesearch_val, 
 case fieldtype.allowlikesearch 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldtype_allowlikesearch 
, 
fieldtype.maximum 
fieldtype_maximum 
, 
fieldtype.the_comment 
fieldtype_the_comment 
, 
fieldtype.name 
fieldtype_name 
, 
 fieldtype.gridsorttype  
fieldtype_gridsorttype_val, 
 case fieldtype.gridsorttype 
when 0 then 'as string'
when 1 then 'as numeric'
when 2 then 'as date'
 else '' 
 end  
fieldtype_gridsorttype 
, 
 fieldtype.typestyle  
fieldtype_typestyle_val, 
 case fieldtype.typestyle 
when 4 then 'ссылка'
when 1 then 'выражение'
when 5 then 'элемент оформления'
when 3 then 'интервал'
when 2 then 'перечисление'
when 0 then 'скалярный тип'
 else '' 
 end  
fieldtype_typestyle 
, b2g(fieldtype.instanceid) instanceid 
, fieldtype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldtype.fieldtypeid) id 
, 'fieldtype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDTYPE
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldtype_ru_ru
go
create view v_autofieldtype_ru_ru as 
select   b2g(fieldtype. fieldtypeid) fieldtypeid,fieldtype. changestamp changestamp
, 
 fieldtype.delayedsave  
fieldtype_delayedsave_val, 
 case fieldtype.delayedsave 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldtype_delayedsave 
, 
fieldtype.minimum 
fieldtype_minimum 
, 
 fieldtype.allowsize  
fieldtype_allowsize_val, 
 case fieldtype.allowsize 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldtype_allowsize 
, 
 fieldtype.allowlikesearch  
fieldtype_allowlikesearch_val, 
 case fieldtype.allowlikesearch 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldtype_allowlikesearch 
, 
fieldtype.maximum 
fieldtype_maximum 
, 
fieldtype.the_comment 
fieldtype_the_comment 
, 
fieldtype.name 
fieldtype_name 
, 
 fieldtype.gridsorttype  
fieldtype_gridsorttype_val, 
 case fieldtype.gridsorttype 
when 0 then 'as string'
when 1 then 'as numeric'
when 2 then 'as date'
 else '' 
 end  
fieldtype_gridsorttype 
, 
 fieldtype.typestyle  
fieldtype_typestyle_val, 
 case fieldtype.typestyle 
when 4 then 'ссылка'
when 1 then 'выражение'
when 5 then 'элемент оформления'
when 3 then 'интервал'
when 2 then 'перечисление'
when 0 then 'скалярный тип'
 else '' 
 end  
fieldtype_typestyle 
, b2g(fieldtype.instanceid) instanceid 
, fieldtype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldtype.fieldtypeid) id 
, 'fieldtype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDTYPE
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldtype_en_us
go
create view v_autofieldtype_en_us as 
select   b2g(fieldtype. fieldtypeid) fieldtypeid,fieldtype. changestamp changestamp
, 
 fieldtype.delayedsave  
fieldtype_delayedsave_val, 
 case fieldtype.delayedsave 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldtype_delayedsave 
, 
fieldtype.minimum 
fieldtype_minimum 
, 
 fieldtype.allowsize  
fieldtype_allowsize_val, 
 case fieldtype.allowsize 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldtype_allowsize 
, 
 fieldtype.allowlikesearch  
fieldtype_allowlikesearch_val, 
 case fieldtype.allowlikesearch 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldtype_allowlikesearch 
, 
fieldtype.maximum 
fieldtype_maximum 
, 
fieldtype.the_comment 
fieldtype_the_comment 
, 
fieldtype.name 
fieldtype_name 
, 
 fieldtype.gridsorttype  
fieldtype_gridsorttype_val, 
 case fieldtype.gridsorttype 
when 0 then 'as string'
when 1 then 'as numeric'
when 2 then 'as date'
 else '' 
 end  
fieldtype_gridsorttype 
, 
 fieldtype.typestyle  
fieldtype_typestyle_val, 
 case fieldtype.typestyle 
when 4 then 'ссылка'
when 1 then 'выражение'
when 5 then 'элемент оформления'
when 3 then 'интервал'
when 2 then 'перечисление'
when 0 then 'скалярный тип'
 else '' 
 end  
fieldtype_typestyle 
, b2g(fieldtype.instanceid) instanceid 
, fieldtype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldtype.fieldtypeid) id 
, 'fieldtype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDTYPE
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoenumitem
go
create view v_autoenumitem as 
select   b2g(enumitem. enumitemid) enumitemid,enumitem. changestamp changestamp, b2g(fieldtypeid) fieldtypeid
, 
enumitem.name 
enumitem_name 
, 
enumitem.nameincode 
enumitem_nameincode 
, 
enumitem.namevalue 
enumitem_namevalue 
, b2g(fieldtype.instanceid) instanceid 
, fieldtype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(enumitem.enumitemid) id 
, 'enumitem' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ENUMITEM
 join FIELDTYPE on FIELDTYPE.FIELDTYPEID=ENUMITEM.ParentStructRowID 
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoenumitem_ru_ru
go
create view v_autoenumitem_ru_ru as 
select   b2g(enumitem. enumitemid) enumitemid,enumitem. changestamp changestamp, b2g(fieldtypeid) fieldtypeid
, 
enumitem.name 
enumitem_name 
, 
enumitem.nameincode 
enumitem_nameincode 
, 
enumitem.namevalue 
enumitem_namevalue 
, b2g(fieldtype.instanceid) instanceid 
, fieldtype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(enumitem.enumitemid) id 
, 'enumitem' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ENUMITEM
 join FIELDTYPE on FIELDTYPE.FIELDTYPEID=ENUMITEM.ParentStructRowID 
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoenumitem_en_us
go
create view v_autoenumitem_en_us as 
select   b2g(enumitem. enumitemid) enumitemid,enumitem. changestamp changestamp, b2g(fieldtypeid) fieldtypeid
, 
enumitem.name 
enumitem_name 
, 
enumitem.nameincode 
enumitem_nameincode 
, 
enumitem.namevalue 
enumitem_namevalue 
, b2g(fieldtype.instanceid) instanceid 
, fieldtype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(enumitem.enumitemid) id 
, 'enumitem' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ENUMITEM
 join FIELDTYPE on FIELDTYPE.FIELDTYPEID=ENUMITEM.ParentStructRowID 
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldtypemap
go
create view v_autofieldtypemap as 
select   b2g(fieldtypemap. fieldtypemapid) fieldtypemapid,fieldtypemap. changestamp changestamp, b2g(fieldtypeid) fieldtypeid
, 
 b2g(fieldtypemap.target)  
fieldtypemap_target_id, 
 generator_target_brief_f(fieldtypemap.target, null) 
fieldtypemap_target 
, 
fieldtypemap.fixedsize 
fieldtypemap_fixedsize 
, 
fieldtypemap.stoagetype 
fieldtypemap_stoagetype 
, b2g(fieldtype.instanceid) instanceid 
, fieldtype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldtypemap.fieldtypemapid) id 
, 'fieldtypemap' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDTYPEMAP
 join FIELDTYPE on FIELDTYPE.FIELDTYPEID=FIELDTYPEMAP.ParentStructRowID 
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldtypemap_ru_ru
go
create view v_autofieldtypemap_ru_ru as 
select   b2g(fieldtypemap. fieldtypemapid) fieldtypemapid,fieldtypemap. changestamp changestamp, b2g(fieldtypeid) fieldtypeid
, 
 b2g(fieldtypemap.target)  
fieldtypemap_target_id, 
 generator_target_brief_f(fieldtypemap.target, 'ru_ru') 
fieldtypemap_target 
, 
fieldtypemap.fixedsize 
fieldtypemap_fixedsize 
, 
fieldtypemap.stoagetype 
fieldtypemap_stoagetype 
, b2g(fieldtype.instanceid) instanceid 
, fieldtype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldtypemap.fieldtypemapid) id 
, 'fieldtypemap' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDTYPEMAP
 join FIELDTYPE on FIELDTYPE.FIELDTYPEID=FIELDTYPEMAP.ParentStructRowID 
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldtypemap_en_us
go
create view v_autofieldtypemap_en_us as 
select   b2g(fieldtypemap. fieldtypemapid) fieldtypemapid,fieldtypemap. changestamp changestamp, b2g(fieldtypeid) fieldtypeid
, 
 b2g(fieldtypemap.target)  
fieldtypemap_target_id, 
 generator_target_brief_f(fieldtypemap.target, 'en_us') 
fieldtypemap_target 
, 
fieldtypemap.fixedsize 
fieldtypemap_fixedsize 
, 
fieldtypemap.stoagetype 
fieldtypemap_stoagetype 
, b2g(fieldtype.instanceid) instanceid 
, fieldtype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldtypemap.fieldtypemapid) id 
, 'fieldtypemap' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDTYPEMAP
 join FIELDTYPE on FIELDTYPE.FIELDTYPEID=FIELDTYPEMAP.ParentStructRowID 
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autosharedmethod
go
create view v_autosharedmethod as 
select   b2g(sharedmethod. sharedmethodid) sharedmethodid,sharedmethod. changestamp changestamp
, 
 b2g(sharedmethod.returntype)  
sharedmethod_returntype_id, 
 fieldtype_brief_f(sharedmethod.returntype, null) 
sharedmethod_returntype 
, 
sharedmethod.name 
sharedmethod_name 
, 
sharedmethod.the_comment 
sharedmethod_the_comment 
, b2g(sharedmethod.instanceid) instanceid 
, sharedmethod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(sharedmethod.sharedmethodid) id 
, 'sharedmethod' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SHAREDMETHOD
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autosharedmethod_ru_ru
go
create view v_autosharedmethod_ru_ru as 
select   b2g(sharedmethod. sharedmethodid) sharedmethodid,sharedmethod. changestamp changestamp
, 
 b2g(sharedmethod.returntype)  
sharedmethod_returntype_id, 
 fieldtype_brief_f(sharedmethod.returntype, 'ru_ru') 
sharedmethod_returntype 
, 
sharedmethod.name 
sharedmethod_name 
, 
sharedmethod.the_comment 
sharedmethod_the_comment 
, b2g(sharedmethod.instanceid) instanceid 
, sharedmethod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(sharedmethod.sharedmethodid) id 
, 'sharedmethod' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SHAREDMETHOD
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autosharedmethod_en_us
go
create view v_autosharedmethod_en_us as 
select   b2g(sharedmethod. sharedmethodid) sharedmethodid,sharedmethod. changestamp changestamp
, 
 b2g(sharedmethod.returntype)  
sharedmethod_returntype_id, 
 fieldtype_brief_f(sharedmethod.returntype, 'en_us') 
sharedmethod_returntype 
, 
sharedmethod.name 
sharedmethod_name 
, 
sharedmethod.the_comment 
sharedmethod_the_comment 
, b2g(sharedmethod.instanceid) instanceid 
, sharedmethod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(sharedmethod.sharedmethodid) id 
, 'sharedmethod' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SHAREDMETHOD
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoscript
go
create view v_autoscript as 
select   b2g(script. scriptid) scriptid,script. changestamp changestamp, b2g(sharedmethodid) sharedmethodid
, 
 b2g(script.target)  
script_target_id, 
 generator_target_brief_f(script.target, null) 
script_target 
, 
script.code 
script_code 
, b2g(sharedmethod.instanceid) instanceid 
, sharedmethod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(script.scriptid) id 
, 'script' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SCRIPT
 join SHAREDMETHOD on SHAREDMETHOD.SHAREDMETHODID=SCRIPT.ParentStructRowID 
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoscript_ru_ru
go
create view v_autoscript_ru_ru as 
select   b2g(script. scriptid) scriptid,script. changestamp changestamp, b2g(sharedmethodid) sharedmethodid
, 
 b2g(script.target)  
script_target_id, 
 generator_target_brief_f(script.target, 'ru_ru') 
script_target 
, 
script.code 
script_code 
, b2g(sharedmethod.instanceid) instanceid 
, sharedmethod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(script.scriptid) id 
, 'script' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SCRIPT
 join SHAREDMETHOD on SHAREDMETHOD.SHAREDMETHODID=SCRIPT.ParentStructRowID 
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoscript_en_us
go
create view v_autoscript_en_us as 
select   b2g(script. scriptid) scriptid,script. changestamp changestamp, b2g(sharedmethodid) sharedmethodid
, 
 b2g(script.target)  
script_target_id, 
 generator_target_brief_f(script.target, 'en_us') 
script_target 
, 
script.code 
script_code 
, b2g(sharedmethod.instanceid) instanceid 
, sharedmethod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(script.scriptid) id 
, 'script' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SCRIPT
 join SHAREDMETHOD on SHAREDMETHOD.SHAREDMETHODID=SCRIPT.ParentStructRowID 
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoparameters
go
create view v_autoparameters as 
select   b2g(parameters. parametersid) parametersid,parameters. changestamp changestamp, b2g(scriptid) scriptid, b2g(sharedmethodid) sharedmethodid
, 
 b2g(parameters.reftotype)  
parameters_reftotype_id, 
 objecttype_brief_f(parameters.reftotype, null) 
parameters_reftotype 
, 
parameters.sequence 
parameters_sequence 
, 
parameters.datasize 
parameters_datasize 
, 
 b2g(parameters.reftopart)  
parameters_reftopart_id, 
 part_brief_f(parameters.reftopart, null) 
parameters_reftopart 
, 
 parameters.referencetype  
parameters_referencetype_val, 
 case parameters.referencetype 
when 3 then 'на источник данных'
when 0 then 'скалярное поле ( не ссылка)'
when 2 then 'на строку раздела'
when 1 then 'на объект '
 else '' 
 end  
parameters_referencetype 
, 
parameters.caption 
parameters_caption 
, 
 parameters.outparam  
parameters_outparam_val, 
 case parameters.outparam 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
parameters_outparam 
, 
 b2g(parameters.typeofparm)  
parameters_typeofparm_id, 
 fieldtype_brief_f(parameters.typeofparm, null) 
parameters_typeofparm 
, 
parameters.name 
parameters_name 
, 
 parameters.allownull  
parameters_allownull_val, 
 case parameters.allownull 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
parameters_allownull 
, b2g(sharedmethod.instanceid) instanceid 
, sharedmethod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(parameters.parametersid) id 
, 'parameters' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARAMETERS
 join SCRIPT on SCRIPT.SCRIPTID=PARAMETERS.ParentStructRowID 
 join SHAREDMETHOD on SHAREDMETHOD.SHAREDMETHODID=SCRIPT.ParentStructRowID 
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoparameters_ru_ru
go
create view v_autoparameters_ru_ru as 
select   b2g(parameters. parametersid) parametersid,parameters. changestamp changestamp, b2g(scriptid) scriptid, b2g(sharedmethodid) sharedmethodid
, 
 b2g(parameters.reftotype)  
parameters_reftotype_id, 
 objecttype_brief_f(parameters.reftotype, 'ru_ru') 
parameters_reftotype 
, 
parameters.sequence 
parameters_sequence 
, 
parameters.datasize 
parameters_datasize 
, 
 b2g(parameters.reftopart)  
parameters_reftopart_id, 
 part_brief_f(parameters.reftopart, 'ru_ru') 
parameters_reftopart 
, 
 parameters.referencetype  
parameters_referencetype_val, 
 case parameters.referencetype 
when 3 then 'на источник данных'
when 0 then 'скалярное поле ( не ссылка)'
when 2 then 'на строку раздела'
when 1 then 'на объект '
 else '' 
 end  
parameters_referencetype 
, 
parameters.caption 
parameters_caption 
, 
 parameters.outparam  
parameters_outparam_val, 
 case parameters.outparam 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
parameters_outparam 
, 
 b2g(parameters.typeofparm)  
parameters_typeofparm_id, 
 fieldtype_brief_f(parameters.typeofparm, 'ru_ru') 
parameters_typeofparm 
, 
parameters.name 
parameters_name 
, 
 parameters.allownull  
parameters_allownull_val, 
 case parameters.allownull 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
parameters_allownull 
, b2g(sharedmethod.instanceid) instanceid 
, sharedmethod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(parameters.parametersid) id 
, 'parameters' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARAMETERS
 join SCRIPT on SCRIPT.SCRIPTID=PARAMETERS.ParentStructRowID 
 join SHAREDMETHOD on SHAREDMETHOD.SHAREDMETHODID=SCRIPT.ParentStructRowID 
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoparameters_en_us
go
create view v_autoparameters_en_us as 
select   b2g(parameters. parametersid) parametersid,parameters. changestamp changestamp, b2g(scriptid) scriptid, b2g(sharedmethodid) sharedmethodid
, 
 b2g(parameters.reftotype)  
parameters_reftotype_id, 
 objecttype_brief_f(parameters.reftotype, 'en_us') 
parameters_reftotype 
, 
parameters.sequence 
parameters_sequence 
, 
parameters.datasize 
parameters_datasize 
, 
 b2g(parameters.reftopart)  
parameters_reftopart_id, 
 part_brief_f(parameters.reftopart, 'en_us') 
parameters_reftopart 
, 
 parameters.referencetype  
parameters_referencetype_val, 
 case parameters.referencetype 
when 3 then 'на источник данных'
when 0 then 'скалярное поле ( не ссылка)'
when 2 then 'на строку раздела'
when 1 then 'на объект '
 else '' 
 end  
parameters_referencetype 
, 
parameters.caption 
parameters_caption 
, 
 parameters.outparam  
parameters_outparam_val, 
 case parameters.outparam 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
parameters_outparam 
, 
 b2g(parameters.typeofparm)  
parameters_typeofparm_id, 
 fieldtype_brief_f(parameters.typeofparm, 'en_us') 
parameters_typeofparm 
, 
parameters.name 
parameters_name 
, 
 parameters.allownull  
parameters_allownull_val, 
 case parameters.allownull 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
parameters_allownull 
, b2g(sharedmethod.instanceid) instanceid 
, sharedmethod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(parameters.parametersid) id 
, 'parameters' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARAMETERS
 join SCRIPT on SCRIPT.SCRIPTID=PARAMETERS.ParentStructRowID 
 join SHAREDMETHOD on SHAREDMETHOD.SHAREDMETHODID=SCRIPT.ParentStructRowID 
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoobjecttype
go
create view v_autoobjecttype as 
select   b2g(objecttype. objecttypeid) objecttypeid,objecttype. changestamp changestamp
, 
objecttype.objiconcls 
objecttype_objiconcls 
, 
 b2g(objecttype.package)  
objecttype_package_id, 
 mtzapp_brief_f(objecttype.package, null) 
objecttype_package 
, 
 objecttype.replicatype  
objecttype_replicatype_val, 
 case objecttype.replicatype 
when 1 then 'построчно'
when 0 then 'весь документ'
when 2 then 'локальный'
 else '' 
 end  
objecttype_replicatype 
, 
objecttype.the_comment 
objecttype_the_comment 
, 
 b2g(objecttype.onrun)  
objecttype_onrun_id, 
 typemenu_brief_f(objecttype.onrun, null) 
objecttype_onrun 
, 
 b2g(objecttype.chooseview)  
objecttype_chooseview_id, 
 partview_brief_f(objecttype.chooseview, null) 
objecttype_chooseview 
, 
 objecttype.commitfullobject  
objecttype_commitfullobject_val, 
 case objecttype.commitfullobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_commitfullobject 
, 
 objecttype.usearchiving  
objecttype_usearchiving_val, 
 case objecttype.usearchiving 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_usearchiving 
, 
 objecttype.useownership  
objecttype_useownership_val, 
 case objecttype.useownership 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_useownership 
, 
 b2g(objecttype.oncreate)  
objecttype_oncreate_id, 
 typemenu_brief_f(objecttype.oncreate, null) 
objecttype_oncreate 
, 
 objecttype.allowreftoobject  
objecttype_allowreftoobject_val, 
 case objecttype.allowreftoobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_allowreftoobject 
, 
objecttype.thecomment 
objecttype_thecomment 
, 
objecttype.name 
objecttype_name 
, 
 objecttype.allowsearch  
objecttype_allowsearch_val, 
 case objecttype.allowsearch 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_allowsearch 
, 
 b2g(objecttype.ondelete)  
objecttype_ondelete_id, 
 typemenu_brief_f(objecttype.ondelete, null) 
objecttype_ondelete 
, 
 objecttype.issingleinstance  
objecttype_issingleinstance_val, 
 case objecttype.issingleinstance 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_issingleinstance 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(objecttype.objecttypeid) id 
, 'objecttype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from OBJECTTYPE
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoobjecttype_ru_ru
go
create view v_autoobjecttype_ru_ru as 
select   b2g(objecttype. objecttypeid) objecttypeid,objecttype. changestamp changestamp
, 
objecttype.objiconcls 
objecttype_objiconcls 
, 
 b2g(objecttype.package)  
objecttype_package_id, 
 mtzapp_brief_f(objecttype.package, 'ru_ru') 
objecttype_package 
, 
 objecttype.replicatype  
objecttype_replicatype_val, 
 case objecttype.replicatype 
when 1 then 'построчно'
when 0 then 'весь документ'
when 2 then 'локальный'
 else '' 
 end  
objecttype_replicatype 
, 
objecttype.the_comment 
objecttype_the_comment 
, 
 b2g(objecttype.onrun)  
objecttype_onrun_id, 
 typemenu_brief_f(objecttype.onrun, 'ru_ru') 
objecttype_onrun 
, 
 b2g(objecttype.chooseview)  
objecttype_chooseview_id, 
 partview_brief_f(objecttype.chooseview, 'ru_ru') 
objecttype_chooseview 
, 
 objecttype.commitfullobject  
objecttype_commitfullobject_val, 
 case objecttype.commitfullobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_commitfullobject 
, 
 objecttype.usearchiving  
objecttype_usearchiving_val, 
 case objecttype.usearchiving 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_usearchiving 
, 
 objecttype.useownership  
objecttype_useownership_val, 
 case objecttype.useownership 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_useownership 
, 
 b2g(objecttype.oncreate)  
objecttype_oncreate_id, 
 typemenu_brief_f(objecttype.oncreate, 'ru_ru') 
objecttype_oncreate 
, 
 objecttype.allowreftoobject  
objecttype_allowreftoobject_val, 
 case objecttype.allowreftoobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_allowreftoobject 
, 
objecttype.thecomment 
objecttype_thecomment 
, 
objecttype.name 
objecttype_name 
, 
 objecttype.allowsearch  
objecttype_allowsearch_val, 
 case objecttype.allowsearch 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_allowsearch 
, 
 b2g(objecttype.ondelete)  
objecttype_ondelete_id, 
 typemenu_brief_f(objecttype.ondelete, 'ru_ru') 
objecttype_ondelete 
, 
 objecttype.issingleinstance  
objecttype_issingleinstance_val, 
 case objecttype.issingleinstance 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_issingleinstance 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(objecttype.objecttypeid) id 
, 'objecttype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from OBJECTTYPE
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoobjecttype_en_us
go
create view v_autoobjecttype_en_us as 
select   b2g(objecttype. objecttypeid) objecttypeid,objecttype. changestamp changestamp
, 
objecttype.objiconcls 
objecttype_objiconcls 
, 
 b2g(objecttype.package)  
objecttype_package_id, 
 mtzapp_brief_f(objecttype.package, 'en_us') 
objecttype_package 
, 
 objecttype.replicatype  
objecttype_replicatype_val, 
 case objecttype.replicatype 
when 1 then 'построчно'
when 0 then 'весь документ'
when 2 then 'локальный'
 else '' 
 end  
objecttype_replicatype 
, 
objecttype.the_comment 
objecttype_the_comment 
, 
 b2g(objecttype.onrun)  
objecttype_onrun_id, 
 typemenu_brief_f(objecttype.onrun, 'en_us') 
objecttype_onrun 
, 
 b2g(objecttype.chooseview)  
objecttype_chooseview_id, 
 partview_brief_f(objecttype.chooseview, 'en_us') 
objecttype_chooseview 
, 
 objecttype.commitfullobject  
objecttype_commitfullobject_val, 
 case objecttype.commitfullobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_commitfullobject 
, 
 objecttype.usearchiving  
objecttype_usearchiving_val, 
 case objecttype.usearchiving 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_usearchiving 
, 
 objecttype.useownership  
objecttype_useownership_val, 
 case objecttype.useownership 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_useownership 
, 
 b2g(objecttype.oncreate)  
objecttype_oncreate_id, 
 typemenu_brief_f(objecttype.oncreate, 'en_us') 
objecttype_oncreate 
, 
 objecttype.allowreftoobject  
objecttype_allowreftoobject_val, 
 case objecttype.allowreftoobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_allowreftoobject 
, 
objecttype.thecomment 
objecttype_thecomment 
, 
objecttype.name 
objecttype_name 
, 
 objecttype.allowsearch  
objecttype_allowsearch_val, 
 case objecttype.allowsearch 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_allowsearch 
, 
 b2g(objecttype.ondelete)  
objecttype_ondelete_id, 
 typemenu_brief_f(objecttype.ondelete, 'en_us') 
objecttype_ondelete 
, 
 objecttype.issingleinstance  
objecttype_issingleinstance_val, 
 case objecttype.issingleinstance 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objecttype_issingleinstance 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(objecttype.objecttypeid) id 
, 'objecttype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from OBJECTTYPE
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoobjstatus
go
create view v_autoobjstatus as 
select   b2g(objstatus. objstatusid) objstatusid,objstatus. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
objstatus.the_comment 
objstatus_the_comment 
, 
 objstatus.isstartup  
objstatus_isstartup_val, 
 case objstatus.isstartup 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objstatus_isstartup 
, 
objstatus.name 
objstatus_name 
, 
 objstatus.isarchive  
objstatus_isarchive_val, 
 case objstatus.isarchive 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objstatus_isarchive 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(objstatus.objstatusid) id 
, 'objstatus' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from OBJSTATUS
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJSTATUS.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoobjstatus_ru_ru
go
create view v_autoobjstatus_ru_ru as 
select   b2g(objstatus. objstatusid) objstatusid,objstatus. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
objstatus.the_comment 
objstatus_the_comment 
, 
 objstatus.isstartup  
objstatus_isstartup_val, 
 case objstatus.isstartup 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objstatus_isstartup 
, 
objstatus.name 
objstatus_name 
, 
 objstatus.isarchive  
objstatus_isarchive_val, 
 case objstatus.isarchive 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objstatus_isarchive 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(objstatus.objstatusid) id 
, 'objstatus' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from OBJSTATUS
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJSTATUS.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoobjstatus_en_us
go
create view v_autoobjstatus_en_us as 
select   b2g(objstatus. objstatusid) objstatusid,objstatus. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
objstatus.the_comment 
objstatus_the_comment 
, 
 objstatus.isstartup  
objstatus_isstartup_val, 
 case objstatus.isstartup 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objstatus_isstartup 
, 
objstatus.name 
objstatus_name 
, 
 objstatus.isarchive  
objstatus_isarchive_val, 
 case objstatus.isarchive 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objstatus_isarchive 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(objstatus.objstatusid) id 
, 'objstatus' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from OBJSTATUS
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJSTATUS.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonextstate
go
create view v_autonextstate as 
select   b2g(nextstate. nextstateid) nextstateid,nextstate. changestamp changestamp, b2g(objstatusid) objstatusid, b2g(objecttypeid) objecttypeid
, 
 b2g(nextstate.thestate)  
nextstate_thestate_id, 
 objstatus_brief_f(nextstate.thestate, null) 
nextstate_thestate 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(nextstate.nextstateid) id 
, 'nextstate' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from NEXTSTATE
 join OBJSTATUS on OBJSTATUS.OBJSTATUSID=NEXTSTATE.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJSTATUS.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonextstate_ru_ru
go
create view v_autonextstate_ru_ru as 
select   b2g(nextstate. nextstateid) nextstateid,nextstate. changestamp changestamp, b2g(objstatusid) objstatusid, b2g(objecttypeid) objecttypeid
, 
 b2g(nextstate.thestate)  
nextstate_thestate_id, 
 objstatus_brief_f(nextstate.thestate, 'ru_ru') 
nextstate_thestate 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(nextstate.nextstateid) id 
, 'nextstate' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from NEXTSTATE
 join OBJSTATUS on OBJSTATUS.OBJSTATUSID=NEXTSTATE.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJSTATUS.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonextstate_en_us
go
create view v_autonextstate_en_us as 
select   b2g(nextstate. nextstateid) nextstateid,nextstate. changestamp changestamp, b2g(objstatusid) objstatusid, b2g(objecttypeid) objecttypeid
, 
 b2g(nextstate.thestate)  
nextstate_thestate_id, 
 objstatus_brief_f(nextstate.thestate, 'en_us') 
nextstate_thestate 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(nextstate.nextstateid) id 
, 'nextstate' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from NEXTSTATE
 join OBJSTATUS on OBJSTATUS.OBJSTATUSID=NEXTSTATE.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJSTATUS.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoobjectmode
go
create view v_autoobjectmode as 
select   b2g(objectmode. objectmodeid) objectmodeid,objectmode. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
objectmode.name 
objectmode_name 
, 
objectmode.thecomment 
objectmode_thecomment 
, 
 objectmode.defaultmode  
objectmode_defaultmode_val, 
 case objectmode.defaultmode 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objectmode_defaultmode 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(objectmode.objectmodeid) id 
, 'objectmode' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from OBJECTMODE
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoobjectmode_ru_ru
go
create view v_autoobjectmode_ru_ru as 
select   b2g(objectmode. objectmodeid) objectmodeid,objectmode. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
objectmode.name 
objectmode_name 
, 
objectmode.thecomment 
objectmode_thecomment 
, 
 objectmode.defaultmode  
objectmode_defaultmode_val, 
 case objectmode.defaultmode 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objectmode_defaultmode 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(objectmode.objectmodeid) id 
, 'objectmode' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from OBJECTMODE
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoobjectmode_en_us
go
create view v_autoobjectmode_en_us as 
select   b2g(objectmode. objectmodeid) objectmodeid,objectmode. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
objectmode.name 
objectmode_name 
, 
objectmode.thecomment 
objectmode_thecomment 
, 
 objectmode.defaultmode  
objectmode_defaultmode_val, 
 case objectmode.defaultmode 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
objectmode_defaultmode 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(objectmode.objectmodeid) id 
, 'objectmode' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from OBJECTMODE
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autostructrestriction
go
create view v_autostructrestriction as 
select   b2g(structrestriction. structrestrictionid) structrestrictionid,structrestriction. changestamp changestamp, b2g(objectmodeid) objectmodeid, b2g(objecttypeid) objecttypeid
, 
 structrestriction.allowdelete  
structrestriction_allowdelete_val, 
 case structrestriction.allowdelete 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowdelete 
, 
 structrestriction.allowadd  
structrestriction_allowadd_val, 
 case structrestriction.allowadd 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowadd 
, 
 b2g(structrestriction.struct)  
structrestriction_struct_id, 
 part_brief_f(structrestriction.struct, null) 
structrestriction_struct 
, 
 structrestriction.allowedit  
structrestriction_allowedit_val, 
 case structrestriction.allowedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowedit 
, 
 structrestriction.allowread  
structrestriction_allowread_val, 
 case structrestriction.allowread 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowread 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(structrestriction.structrestrictionid) id 
, 'structrestriction' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from STRUCTRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=STRUCTRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autostructrestriction_ru_ru
go
create view v_autostructrestriction_ru_ru as 
select   b2g(structrestriction. structrestrictionid) structrestrictionid,structrestriction. changestamp changestamp, b2g(objectmodeid) objectmodeid, b2g(objecttypeid) objecttypeid
, 
 structrestriction.allowdelete  
structrestriction_allowdelete_val, 
 case structrestriction.allowdelete 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowdelete 
, 
 structrestriction.allowadd  
structrestriction_allowadd_val, 
 case structrestriction.allowadd 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowadd 
, 
 b2g(structrestriction.struct)  
structrestriction_struct_id, 
 part_brief_f(structrestriction.struct, 'ru_ru') 
structrestriction_struct 
, 
 structrestriction.allowedit  
structrestriction_allowedit_val, 
 case structrestriction.allowedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowedit 
, 
 structrestriction.allowread  
structrestriction_allowread_val, 
 case structrestriction.allowread 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowread 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(structrestriction.structrestrictionid) id 
, 'structrestriction' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from STRUCTRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=STRUCTRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autostructrestriction_en_us
go
create view v_autostructrestriction_en_us as 
select   b2g(structrestriction. structrestrictionid) structrestrictionid,structrestriction. changestamp changestamp, b2g(objectmodeid) objectmodeid, b2g(objecttypeid) objecttypeid
, 
 structrestriction.allowdelete  
structrestriction_allowdelete_val, 
 case structrestriction.allowdelete 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowdelete 
, 
 structrestriction.allowadd  
structrestriction_allowadd_val, 
 case structrestriction.allowadd 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowadd 
, 
 b2g(structrestriction.struct)  
structrestriction_struct_id, 
 part_brief_f(structrestriction.struct, 'en_us') 
structrestriction_struct 
, 
 structrestriction.allowedit  
structrestriction_allowedit_val, 
 case structrestriction.allowedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowedit 
, 
 structrestriction.allowread  
structrestriction_allowread_val, 
 case structrestriction.allowread 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
structrestriction_allowread 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(structrestriction.structrestrictionid) id 
, 'structrestriction' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from STRUCTRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=STRUCTRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automethodrestriction
go
create view v_automethodrestriction as 
select   b2g(methodrestriction. methodrestrictionid) methodrestrictionid,methodrestriction. changestamp changestamp, b2g(objectmodeid) objectmodeid, b2g(objecttypeid) objecttypeid
, 
 methodrestriction.isrestricted  
methodrestriction_isrestricted_val, 
 case methodrestriction.isrestricted 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
methodrestriction_isrestricted 
, 
 b2g(methodrestriction.method)  
methodrestriction_method_id, 
 sharedmethod_brief_f(methodrestriction.method, null) 
methodrestriction_method 
, 
 b2g(methodrestriction.part)  
methodrestriction_part_id, 
 part_brief_f(methodrestriction.part, null) 
methodrestriction_part 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(methodrestriction.methodrestrictionid) id 
, 'methodrestriction' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from METHODRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=METHODRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automethodrestriction_ru_ru
go
create view v_automethodrestriction_ru_ru as 
select   b2g(methodrestriction. methodrestrictionid) methodrestrictionid,methodrestriction. changestamp changestamp, b2g(objectmodeid) objectmodeid, b2g(objecttypeid) objecttypeid
, 
 methodrestriction.isrestricted  
methodrestriction_isrestricted_val, 
 case methodrestriction.isrestricted 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
methodrestriction_isrestricted 
, 
 b2g(methodrestriction.method)  
methodrestriction_method_id, 
 sharedmethod_brief_f(methodrestriction.method, 'ru_ru') 
methodrestriction_method 
, 
 b2g(methodrestriction.part)  
methodrestriction_part_id, 
 part_brief_f(methodrestriction.part, 'ru_ru') 
methodrestriction_part 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(methodrestriction.methodrestrictionid) id 
, 'methodrestriction' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from METHODRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=METHODRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automethodrestriction_en_us
go
create view v_automethodrestriction_en_us as 
select   b2g(methodrestriction. methodrestrictionid) methodrestrictionid,methodrestriction. changestamp changestamp, b2g(objectmodeid) objectmodeid, b2g(objecttypeid) objecttypeid
, 
 methodrestriction.isrestricted  
methodrestriction_isrestricted_val, 
 case methodrestriction.isrestricted 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
methodrestriction_isrestricted 
, 
 b2g(methodrestriction.method)  
methodrestriction_method_id, 
 sharedmethod_brief_f(methodrestriction.method, 'en_us') 
methodrestriction_method 
, 
 b2g(methodrestriction.part)  
methodrestriction_part_id, 
 part_brief_f(methodrestriction.part, 'en_us') 
methodrestriction_part 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(methodrestriction.methodrestrictionid) id 
, 'methodrestriction' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from METHODRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=METHODRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldrestriction
go
create view v_autofieldrestriction as 
select   b2g(fieldrestriction. fieldrestrictionid) fieldrestrictionid,fieldrestriction. changestamp changestamp, b2g(objectmodeid) objectmodeid, b2g(objecttypeid) objecttypeid
, 
 fieldrestriction.allowread  
fieldrestriction_allowread_val, 
 case fieldrestriction.allowread 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldrestriction_allowread 
, 
 fieldrestriction.allowmodify  
fieldrestriction_allowmodify_val, 
 case fieldrestriction.allowmodify 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldrestriction_allowmodify 
, 
 b2g(fieldrestriction.thefield)  
fieldrestriction_thefield_id, 
 field_brief_f(fieldrestriction.thefield, null) 
fieldrestriction_thefield 
, 
 fieldrestriction.mandatoryfield  
fieldrestriction_mandatoryfield_val, 
 case fieldrestriction.mandatoryfield 
when -1 then 'не существенно'
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldrestriction_mandatoryfield 
, 
 b2g(fieldrestriction.thepart)  
fieldrestriction_thepart_id, 
 part_brief_f(fieldrestriction.thepart, null) 
fieldrestriction_thepart 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldrestriction.fieldrestrictionid) id 
, 'fieldrestriction' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=FIELDRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldrestriction_ru_ru
go
create view v_autofieldrestriction_ru_ru as 
select   b2g(fieldrestriction. fieldrestrictionid) fieldrestrictionid,fieldrestriction. changestamp changestamp, b2g(objectmodeid) objectmodeid, b2g(objecttypeid) objecttypeid
, 
 fieldrestriction.allowread  
fieldrestriction_allowread_val, 
 case fieldrestriction.allowread 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldrestriction_allowread 
, 
 fieldrestriction.allowmodify  
fieldrestriction_allowmodify_val, 
 case fieldrestriction.allowmodify 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldrestriction_allowmodify 
, 
 b2g(fieldrestriction.thefield)  
fieldrestriction_thefield_id, 
 field_brief_f(fieldrestriction.thefield, 'ru_ru') 
fieldrestriction_thefield 
, 
 fieldrestriction.mandatoryfield  
fieldrestriction_mandatoryfield_val, 
 case fieldrestriction.mandatoryfield 
when -1 then 'не существенно'
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldrestriction_mandatoryfield 
, 
 b2g(fieldrestriction.thepart)  
fieldrestriction_thepart_id, 
 part_brief_f(fieldrestriction.thepart, 'ru_ru') 
fieldrestriction_thepart 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldrestriction.fieldrestrictionid) id 
, 'fieldrestriction' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=FIELDRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldrestriction_en_us
go
create view v_autofieldrestriction_en_us as 
select   b2g(fieldrestriction. fieldrestrictionid) fieldrestrictionid,fieldrestriction. changestamp changestamp, b2g(objectmodeid) objectmodeid, b2g(objecttypeid) objecttypeid
, 
 fieldrestriction.allowread  
fieldrestriction_allowread_val, 
 case fieldrestriction.allowread 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldrestriction_allowread 
, 
 fieldrestriction.allowmodify  
fieldrestriction_allowmodify_val, 
 case fieldrestriction.allowmodify 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldrestriction_allowmodify 
, 
 b2g(fieldrestriction.thefield)  
fieldrestriction_thefield_id, 
 field_brief_f(fieldrestriction.thefield, 'en_us') 
fieldrestriction_thefield 
, 
 fieldrestriction.mandatoryfield  
fieldrestriction_mandatoryfield_val, 
 case fieldrestriction.mandatoryfield 
when -1 then 'не существенно'
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldrestriction_mandatoryfield 
, 
 b2g(fieldrestriction.thepart)  
fieldrestriction_thepart_id, 
 part_brief_f(fieldrestriction.thepart, 'en_us') 
fieldrestriction_thepart 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldrestriction.fieldrestrictionid) id 
, 'fieldrestriction' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=FIELDRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autotypemenu
go
create view v_autotypemenu as 
select   b2g(typemenu. typemenuid) typemenuid,typemenu. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
typemenu.name 
typemenu_name 
, 
typemenu.tooltip 
typemenu_tooltip 
, 
 b2g(typemenu.the_action)  
typemenu_the_action_id, 
 sharedmethod_brief_f(typemenu.the_action, null) 
typemenu_the_action 
, 
 typemenu.ismenuitem  
typemenu_ismenuitem_val, 
 case typemenu.ismenuitem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
typemenu_ismenuitem 
, 
typemenu.hotkey 
typemenu_hotkey 
, 
 typemenu.istoolbarbutton  
typemenu_istoolbarbutton_val, 
 case typemenu.istoolbarbutton 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
typemenu_istoolbarbutton 
, 
typemenu.caption 
typemenu_caption 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(typemenu.typemenuid) id 
, 'typemenu' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from TYPEMENU
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=TYPEMENU.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autotypemenu_ru_ru
go
create view v_autotypemenu_ru_ru as 
select   b2g(typemenu. typemenuid) typemenuid,typemenu. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
typemenu.name 
typemenu_name 
, 
typemenu.tooltip 
typemenu_tooltip 
, 
 b2g(typemenu.the_action)  
typemenu_the_action_id, 
 sharedmethod_brief_f(typemenu.the_action, 'ru_ru') 
typemenu_the_action 
, 
 typemenu.ismenuitem  
typemenu_ismenuitem_val, 
 case typemenu.ismenuitem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
typemenu_ismenuitem 
, 
typemenu.hotkey 
typemenu_hotkey 
, 
 typemenu.istoolbarbutton  
typemenu_istoolbarbutton_val, 
 case typemenu.istoolbarbutton 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
typemenu_istoolbarbutton 
, 
typemenu.caption 
typemenu_caption 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(typemenu.typemenuid) id 
, 'typemenu' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from TYPEMENU
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=TYPEMENU.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autotypemenu_en_us
go
create view v_autotypemenu_en_us as 
select   b2g(typemenu. typemenuid) typemenuid,typemenu. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
typemenu.name 
typemenu_name 
, 
typemenu.tooltip 
typemenu_tooltip 
, 
 b2g(typemenu.the_action)  
typemenu_the_action_id, 
 sharedmethod_brief_f(typemenu.the_action, 'en_us') 
typemenu_the_action 
, 
 typemenu.ismenuitem  
typemenu_ismenuitem_val, 
 case typemenu.ismenuitem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
typemenu_ismenuitem 
, 
typemenu.hotkey 
typemenu_hotkey 
, 
 typemenu.istoolbarbutton  
typemenu_istoolbarbutton_val, 
 case typemenu.istoolbarbutton 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
typemenu_istoolbarbutton 
, 
typemenu.caption 
typemenu_caption 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(typemenu.typemenuid) id 
, 'typemenu' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from TYPEMENU
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=TYPEMENU.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoinstancevalidator
go
create view v_autoinstancevalidator as 
select   b2g(instancevalidator. instancevalidatorid) instancevalidatorid,instancevalidator. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
instancevalidator.code 
instancevalidator_code 
, 
 b2g(instancevalidator.target)  
instancevalidator_target_id, 
 generator_target_brief_f(instancevalidator.target, null) 
instancevalidator_target 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(instancevalidator.instancevalidatorid) id 
, 'instancevalidator' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from INSTANCEVALIDATOR
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=INSTANCEVALIDATOR.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoinstancevalidator_ru_ru
go
create view v_autoinstancevalidator_ru_ru as 
select   b2g(instancevalidator. instancevalidatorid) instancevalidatorid,instancevalidator. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
instancevalidator.code 
instancevalidator_code 
, 
 b2g(instancevalidator.target)  
instancevalidator_target_id, 
 generator_target_brief_f(instancevalidator.target, 'ru_ru') 
instancevalidator_target 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(instancevalidator.instancevalidatorid) id 
, 'instancevalidator' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from INSTANCEVALIDATOR
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=INSTANCEVALIDATOR.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoinstancevalidator_en_us
go
create view v_autoinstancevalidator_en_us as 
select   b2g(instancevalidator. instancevalidatorid) instancevalidatorid,instancevalidator. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
instancevalidator.code 
instancevalidator_code 
, 
 b2g(instancevalidator.target)  
instancevalidator_target_id, 
 generator_target_brief_f(instancevalidator.target, 'en_us') 
instancevalidator_target 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(instancevalidator.instancevalidatorid) id 
, 'instancevalidator' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from INSTANCEVALIDATOR
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=INSTANCEVALIDATOR.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopart
go
create view v_autopart as 
select   b2g(part. partid) partid,part. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
 b2g(part.extenderobject)  
part_extenderobject_id, 
 instance_brief_f(part.extenderobject , null) 
part_extenderobject 
, 
part.the_comment 
part_the_comment 
, 
part.rulebrief 
part_rulebrief 
, 
part.name 
part_name 
, 
part.particoncls 
part_particoncls 
, 
 b2g(part.ondelete)  
part_ondelete_id, 
 partmenu_brief_f(part.ondelete, null) 
part_ondelete 
, 
 b2g(part.onrun)  
part_onrun_id, 
 partmenu_brief_f(part.onrun, null) 
part_onrun 
, 
 b2g(part.onsave)  
part_onsave_id, 
 partmenu_brief_f(part.onsave, null) 
part_onsave 
, 
part.shablonbrief 
part_shablonbrief 
, 
 part.isjormalchange  
part_isjormalchange_val, 
 case part.isjormalchange 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_isjormalchange 
, 
part.caption 
part_caption 
, 
part.sequence 
part_sequence 
, 
 part.manualregister  
part_manualregister_val, 
 case part.manualregister 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_manualregister 
, 
 part.nolog  
part_nolog_val, 
 case part.nolog 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_nolog 
, 
 part.addbehaivor  
part_addbehaivor_val, 
 case part.addbehaivor 
when 0 then 'addform'
when 2 then 'runaction'
when 1 then 'refreshonly'
 else '' 
 end  
part_addbehaivor 
, 
 part.integerpkey  
part_integerpkey_val, 
 case part.integerpkey 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_integerpkey 
, 
 b2g(part.oncreate)  
part_oncreate_id, 
 partmenu_brief_f(part.oncreate, null) 
part_oncreate 
, 
 part.parttype  
part_parttype_val, 
 case part.parttype 
when 1 then 'коллекция'
when 2 then 'дерево'
when 0 then 'строка'
when 4 then 'расширение с данными'
when 3 then 'расширение'
 else '' 
 end  
part_parttype 
, 
 part.usearchiving  
part_usearchiving_val, 
 case part.usearchiving 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_usearchiving 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(part.partid) id 
, 'part' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PART
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopart_ru_ru
go
create view v_autopart_ru_ru as 
select   b2g(part. partid) partid,part. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
 b2g(part.extenderobject)  
part_extenderobject_id, 
 instance_brief_f(part.extenderobject, 'ru_ru') 
part_extenderobject 
, 
part.the_comment 
part_the_comment 
, 
part.rulebrief 
part_rulebrief 
, 
part.name 
part_name 
, 
part.particoncls 
part_particoncls 
, 
 b2g(part.ondelete)  
part_ondelete_id, 
 partmenu_brief_f(part.ondelete, 'ru_ru') 
part_ondelete 
, 
 b2g(part.onrun)  
part_onrun_id, 
 partmenu_brief_f(part.onrun, 'ru_ru') 
part_onrun 
, 
 b2g(part.onsave)  
part_onsave_id, 
 partmenu_brief_f(part.onsave, 'ru_ru') 
part_onsave 
, 
part.shablonbrief 
part_shablonbrief 
, 
 part.isjormalchange  
part_isjormalchange_val, 
 case part.isjormalchange 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_isjormalchange 
, 
part.caption 
part_caption 
, 
part.sequence 
part_sequence 
, 
 part.manualregister  
part_manualregister_val, 
 case part.manualregister 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_manualregister 
, 
 part.nolog  
part_nolog_val, 
 case part.nolog 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_nolog 
, 
 part.addbehaivor  
part_addbehaivor_val, 
 case part.addbehaivor 
when 0 then 'addform'
when 2 then 'runaction'
when 1 then 'refreshonly'
 else '' 
 end  
part_addbehaivor 
, 
 part.integerpkey  
part_integerpkey_val, 
 case part.integerpkey 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_integerpkey 
, 
 b2g(part.oncreate)  
part_oncreate_id, 
 partmenu_brief_f(part.oncreate, 'ru_ru') 
part_oncreate 
, 
 part.parttype  
part_parttype_val, 
 case part.parttype 
when 1 then 'коллекция'
when 2 then 'дерево'
when 0 then 'строка'
when 4 then 'расширение с данными'
when 3 then 'расширение'
 else '' 
 end  
part_parttype 
, 
 part.usearchiving  
part_usearchiving_val, 
 case part.usearchiving 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_usearchiving 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(part.partid) id 
, 'part' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PART
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopart_en_us
go
create view v_autopart_en_us as 
select   b2g(part. partid) partid,part. changestamp changestamp, b2g(objecttypeid) objecttypeid
, 
 b2g(part.extenderobject)  
part_extenderobject_id, 
 instance_brief_f(part.extenderobject, 'en_us') 
part_extenderobject 
, 
part.the_comment 
part_the_comment 
, 
part.rulebrief 
part_rulebrief 
, 
part.name 
part_name 
, 
part.particoncls 
part_particoncls 
, 
 b2g(part.ondelete)  
part_ondelete_id, 
 partmenu_brief_f(part.ondelete, 'en_us') 
part_ondelete 
, 
 b2g(part.onrun)  
part_onrun_id, 
 partmenu_brief_f(part.onrun, 'en_us') 
part_onrun 
, 
 b2g(part.onsave)  
part_onsave_id, 
 partmenu_brief_f(part.onsave, 'en_us') 
part_onsave 
, 
part.shablonbrief 
part_shablonbrief 
, 
 part.isjormalchange  
part_isjormalchange_val, 
 case part.isjormalchange 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_isjormalchange 
, 
part.caption 
part_caption 
, 
part.sequence 
part_sequence 
, 
 part.manualregister  
part_manualregister_val, 
 case part.manualregister 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_manualregister 
, 
 part.nolog  
part_nolog_val, 
 case part.nolog 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_nolog 
, 
 part.addbehaivor  
part_addbehaivor_val, 
 case part.addbehaivor 
when 0 then 'addform'
when 2 then 'runaction'
when 1 then 'refreshonly'
 else '' 
 end  
part_addbehaivor 
, 
 part.integerpkey  
part_integerpkey_val, 
 case part.integerpkey 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_integerpkey 
, 
 b2g(part.oncreate)  
part_oncreate_id, 
 partmenu_brief_f(part.oncreate, 'en_us') 
part_oncreate 
, 
 part.parttype  
part_parttype_val, 
 case part.parttype 
when 1 then 'коллекция'
when 2 then 'дерево'
when 0 then 'строка'
when 4 then 'расширение с данными'
when 3 then 'расширение'
 else '' 
 end  
part_parttype 
, 
 part.usearchiving  
part_usearchiving_val, 
 case part.usearchiving 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
part_usearchiving 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(part.partid) id 
, 'part' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PART
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartmenu
go
create view v_autopartmenu as 
select   b2g(partmenu. partmenuid) partmenuid,partmenu. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 partmenu.istoolbarbutton  
partmenu_istoolbarbutton_val, 
 case partmenu.istoolbarbutton 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partmenu_istoolbarbutton 
, 
 b2g(partmenu.the_action)  
partmenu_the_action_id, 
 sharedmethod_brief_f(partmenu.the_action, null) 
partmenu_the_action 
, 
partmenu.name 
partmenu_name 
, 
 partmenu.ismenuitem  
partmenu_ismenuitem_val, 
 case partmenu.ismenuitem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partmenu_ismenuitem 
, 
partmenu.caption 
partmenu_caption 
, 
partmenu.hotkey 
partmenu_hotkey 
, 
partmenu.tooltip 
partmenu_tooltip 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partmenu.partmenuid) id 
, 'partmenu' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTMENU
 join PART on PART.PARTID=PARTMENU.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartmenu_ru_ru
go
create view v_autopartmenu_ru_ru as 
select   b2g(partmenu. partmenuid) partmenuid,partmenu. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 partmenu.istoolbarbutton  
partmenu_istoolbarbutton_val, 
 case partmenu.istoolbarbutton 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partmenu_istoolbarbutton 
, 
 b2g(partmenu.the_action)  
partmenu_the_action_id, 
 sharedmethod_brief_f(partmenu.the_action, 'ru_ru') 
partmenu_the_action 
, 
partmenu.name 
partmenu_name 
, 
 partmenu.ismenuitem  
partmenu_ismenuitem_val, 
 case partmenu.ismenuitem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partmenu_ismenuitem 
, 
partmenu.caption 
partmenu_caption 
, 
partmenu.hotkey 
partmenu_hotkey 
, 
partmenu.tooltip 
partmenu_tooltip 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partmenu.partmenuid) id 
, 'partmenu' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTMENU
 join PART on PART.PARTID=PARTMENU.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartmenu_en_us
go
create view v_autopartmenu_en_us as 
select   b2g(partmenu. partmenuid) partmenuid,partmenu. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 partmenu.istoolbarbutton  
partmenu_istoolbarbutton_val, 
 case partmenu.istoolbarbutton 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partmenu_istoolbarbutton 
, 
 b2g(partmenu.the_action)  
partmenu_the_action_id, 
 sharedmethod_brief_f(partmenu.the_action, 'en_us') 
partmenu_the_action 
, 
partmenu.name 
partmenu_name 
, 
 partmenu.ismenuitem  
partmenu_ismenuitem_val, 
 case partmenu.ismenuitem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partmenu_ismenuitem 
, 
partmenu.caption 
partmenu_caption 
, 
partmenu.hotkey 
partmenu_hotkey 
, 
partmenu.tooltip 
partmenu_tooltip 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partmenu.partmenuid) id 
, 'partmenu' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTMENU
 join PART on PART.PARTID=PARTMENU.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartparammap
go
create view v_autopartparammap as 
select   b2g(partparammap. partparammapid) partparammapid,partparammap. changestamp changestamp, b2g(partmenuid) partmenuid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 partparammap.noedit  
partparammap_noedit_val, 
 case partparammap.noedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partparammap_noedit 
, 
partparammap.fieldname 
partparammap_fieldname 
, 
partparammap.paramname 
partparammap_paramname 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partparammap.partparammapid) id 
, 'partparammap' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTPARAMMAP
 join PARTMENU on PARTMENU.PARTMENUID=PARTPARAMMAP.ParentStructRowID 
 join PART on PART.PARTID=PARTMENU.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartparammap_ru_ru
go
create view v_autopartparammap_ru_ru as 
select   b2g(partparammap. partparammapid) partparammapid,partparammap. changestamp changestamp, b2g(partmenuid) partmenuid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 partparammap.noedit  
partparammap_noedit_val, 
 case partparammap.noedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partparammap_noedit 
, 
partparammap.fieldname 
partparammap_fieldname 
, 
partparammap.paramname 
partparammap_paramname 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partparammap.partparammapid) id 
, 'partparammap' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTPARAMMAP
 join PARTMENU on PARTMENU.PARTMENUID=PARTPARAMMAP.ParentStructRowID 
 join PART on PART.PARTID=PARTMENU.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartparammap_en_us
go
create view v_autopartparammap_en_us as 
select   b2g(partparammap. partparammapid) partparammapid,partparammap. changestamp changestamp, b2g(partmenuid) partmenuid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 partparammap.noedit  
partparammap_noedit_val, 
 case partparammap.noedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partparammap_noedit 
, 
partparammap.fieldname 
partparammap_fieldname 
, 
partparammap.paramname 
partparammap_paramname 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partparammap.partparammapid) id 
, 'partparammap' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTPARAMMAP
 join PARTMENU on PARTMENU.PARTMENUID=PARTPARAMMAP.ParentStructRowID 
 join PART on PART.PARTID=PARTMENU.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartview
go
create view v_autopartview as 
select   b2g(partview. partviewid) partviewid,partview. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
partview.the_alias 
partview_the_alias 
, 
partview.filterfield3 
partview_filterfield3 
, 
partview.filterfield2 
partview_filterfield2 
, 
 partview.forchoose  
partview_forchoose_val, 
 case partview.forchoose 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partview_forchoose 
, 
partview.filterfield1 
partview_filterfield1 
, 
partview.name 
partview_name 
, 
partview.filterfield0 
partview_filterfield0 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partview.partviewid) id 
, 'partview' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTVIEW
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartview_ru_ru
go
create view v_autopartview_ru_ru as 
select   b2g(partview. partviewid) partviewid,partview. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
partview.the_alias 
partview_the_alias 
, 
partview.filterfield3 
partview_filterfield3 
, 
partview.filterfield2 
partview_filterfield2 
, 
 partview.forchoose  
partview_forchoose_val, 
 case partview.forchoose 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partview_forchoose 
, 
partview.filterfield1 
partview_filterfield1 
, 
partview.name 
partview_name 
, 
partview.filterfield0 
partview_filterfield0 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partview.partviewid) id 
, 'partview' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTVIEW
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartview_en_us
go
create view v_autopartview_en_us as 
select   b2g(partview. partviewid) partviewid,partview. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
partview.the_alias 
partview_the_alias 
, 
partview.filterfield3 
partview_filterfield3 
, 
partview.filterfield2 
partview_filterfield2 
, 
 partview.forchoose  
partview_forchoose_val, 
 case partview.forchoose 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
partview_forchoose 
, 
partview.filterfield1 
partview_filterfield1 
, 
partview.name 
partview_name 
, 
partview.filterfield0 
partview_filterfield0 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partview.partviewid) id 
, 'partview' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTVIEW
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoviewcolumn
go
create view v_autoviewcolumn as 
select   b2g(viewcolumn. viewcolumnid) viewcolumnid,viewcolumn. changestamp changestamp, b2g(partviewid) partviewid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
viewcolumn.name 
viewcolumn_name 
, 
 viewcolumn.forcombo  
viewcolumn_forcombo_val, 
 case viewcolumn.forcombo 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
viewcolumn_forcombo 
, 
 b2g(viewcolumn.frompart)  
viewcolumn_frompart_id, 
 part_brief_f(viewcolumn.frompart, null) 
viewcolumn_frompart 
, 
viewcolumn.expression 
viewcolumn_expression 
, 
viewcolumn.the_alias 
viewcolumn_the_alias 
, 
 viewcolumn.aggregation  
viewcolumn_aggregation_val, 
 case viewcolumn.aggregation 
when 3 then 'sum'
when 1 then 'avg'
when 6 then 'custom'
when 0 then 'none'
when 2 then 'count'
when 5 then 'max'
when 4 then 'min'
 else '' 
 end  
viewcolumn_aggregation 
, 
 b2g(viewcolumn.field)  
viewcolumn_field_id, 
 field_brief_f(viewcolumn.field, null) 
viewcolumn_field 
, 
viewcolumn.sequence 
viewcolumn_sequence 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(viewcolumn.viewcolumnid) id 
, 'viewcolumn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ViewColumn
 join PARTVIEW on PARTVIEW.PARTVIEWID=ViewColumn.ParentStructRowID 
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoviewcolumn_ru_ru
go
create view v_autoviewcolumn_ru_ru as 
select   b2g(viewcolumn. viewcolumnid) viewcolumnid,viewcolumn. changestamp changestamp, b2g(partviewid) partviewid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
viewcolumn.name 
viewcolumn_name 
, 
 viewcolumn.forcombo  
viewcolumn_forcombo_val, 
 case viewcolumn.forcombo 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
viewcolumn_forcombo 
, 
 b2g(viewcolumn.frompart)  
viewcolumn_frompart_id, 
 part_brief_f(viewcolumn.frompart, 'ru_ru') 
viewcolumn_frompart 
, 
viewcolumn.expression 
viewcolumn_expression 
, 
viewcolumn.the_alias 
viewcolumn_the_alias 
, 
 viewcolumn.aggregation  
viewcolumn_aggregation_val, 
 case viewcolumn.aggregation 
when 3 then 'sum'
when 1 then 'avg'
when 6 then 'custom'
when 0 then 'none'
when 2 then 'count'
when 5 then 'max'
when 4 then 'min'
 else '' 
 end  
viewcolumn_aggregation 
, 
 b2g(viewcolumn.field)  
viewcolumn_field_id, 
 field_brief_f(viewcolumn.field, 'ru_ru') 
viewcolumn_field 
, 
viewcolumn.sequence 
viewcolumn_sequence 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(viewcolumn.viewcolumnid) id 
, 'viewcolumn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ViewColumn
 join PARTVIEW on PARTVIEW.PARTVIEWID=ViewColumn.ParentStructRowID 
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoviewcolumn_en_us
go
create view v_autoviewcolumn_en_us as 
select   b2g(viewcolumn. viewcolumnid) viewcolumnid,viewcolumn. changestamp changestamp, b2g(partviewid) partviewid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
viewcolumn.name 
viewcolumn_name 
, 
 viewcolumn.forcombo  
viewcolumn_forcombo_val, 
 case viewcolumn.forcombo 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
viewcolumn_forcombo 
, 
 b2g(viewcolumn.frompart)  
viewcolumn_frompart_id, 
 part_brief_f(viewcolumn.frompart, 'en_us') 
viewcolumn_frompart 
, 
viewcolumn.expression 
viewcolumn_expression 
, 
viewcolumn.the_alias 
viewcolumn_the_alias 
, 
 viewcolumn.aggregation  
viewcolumn_aggregation_val, 
 case viewcolumn.aggregation 
when 3 then 'sum'
when 1 then 'avg'
when 6 then 'custom'
when 0 then 'none'
when 2 then 'count'
when 5 then 'max'
when 4 then 'min'
 else '' 
 end  
viewcolumn_aggregation 
, 
 b2g(viewcolumn.field)  
viewcolumn_field_id, 
 field_brief_f(viewcolumn.field, 'en_us') 
viewcolumn_field 
, 
viewcolumn.sequence 
viewcolumn_sequence 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(viewcolumn.viewcolumnid) id 
, 'viewcolumn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ViewColumn
 join PARTVIEW on PARTVIEW.PARTVIEWID=ViewColumn.ParentStructRowID 
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartview_lnk
go
create view v_autopartview_lnk as 
select   b2g(partview_lnk. partview_lnkid) partview_lnkid,partview_lnk. changestamp changestamp, b2g(partviewid) partviewid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 partview_lnk.reftype  
partview_lnk_reftype_val, 
 case partview_lnk.reftype 
when 0 then 'нет'
when 4 then 'связка parentstructrowid  (в передлах объекта)'
when 3 then 'связка instanceid (в передлах объекта)'
when 1 then 'ссылка на объект'
when 2 then 'ссылка на строку'
 else '' 
 end  
partview_lnk_reftype 
, 
 b2g(partview_lnk.thejoindestination)  
partview_lnk_thejoindestination_id, 
 viewcolumn_brief_f(partview_lnk.thejoindestination, null) 
partview_lnk_thejoindestination 
, 
 b2g(partview_lnk.theview)  
partview_lnk_theview_id, 
 partview_brief_f(partview_lnk.theview, null) 
partview_lnk_theview 
, 
partview_lnk.seq 
partview_lnk_seq 
, 
 b2g(partview_lnk.thejoinsource)  
partview_lnk_thejoinsource_id, 
 viewcolumn_brief_f(partview_lnk.thejoinsource, null) 
partview_lnk_thejoinsource 
, 
partview_lnk.handjoin 
partview_lnk_handjoin 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partview_lnk.partview_lnkid) id 
, 'partview_lnk' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTVIEW_LNK
 join PARTVIEW on PARTVIEW.PARTVIEWID=PARTVIEW_LNK.ParentStructRowID 
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartview_lnk_ru_ru
go
create view v_autopartview_lnk_ru_ru as 
select   b2g(partview_lnk. partview_lnkid) partview_lnkid,partview_lnk. changestamp changestamp, b2g(partviewid) partviewid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 partview_lnk.reftype  
partview_lnk_reftype_val, 
 case partview_lnk.reftype 
when 0 then 'нет'
when 4 then 'связка parentstructrowid  (в передлах объекта)'
when 3 then 'связка instanceid (в передлах объекта)'
when 1 then 'ссылка на объект'
when 2 then 'ссылка на строку'
 else '' 
 end  
partview_lnk_reftype 
, 
 b2g(partview_lnk.thejoindestination)  
partview_lnk_thejoindestination_id, 
 viewcolumn_brief_f(partview_lnk.thejoindestination, 'ru_ru') 
partview_lnk_thejoindestination 
, 
 b2g(partview_lnk.theview)  
partview_lnk_theview_id, 
 partview_brief_f(partview_lnk.theview, 'ru_ru') 
partview_lnk_theview 
, 
partview_lnk.seq 
partview_lnk_seq 
, 
 b2g(partview_lnk.thejoinsource)  
partview_lnk_thejoinsource_id, 
 viewcolumn_brief_f(partview_lnk.thejoinsource, 'ru_ru') 
partview_lnk_thejoinsource 
, 
partview_lnk.handjoin 
partview_lnk_handjoin 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partview_lnk.partview_lnkid) id 
, 'partview_lnk' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTVIEW_LNK
 join PARTVIEW on PARTVIEW.PARTVIEWID=PARTVIEW_LNK.ParentStructRowID 
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autopartview_lnk_en_us
go
create view v_autopartview_lnk_en_us as 
select   b2g(partview_lnk. partview_lnkid) partview_lnkid,partview_lnk. changestamp changestamp, b2g(partviewid) partviewid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 partview_lnk.reftype  
partview_lnk_reftype_val, 
 case partview_lnk.reftype 
when 0 then 'нет'
when 4 then 'связка parentstructrowid  (в передлах объекта)'
when 3 then 'связка instanceid (в передлах объекта)'
when 1 then 'ссылка на объект'
when 2 then 'ссылка на строку'
 else '' 
 end  
partview_lnk_reftype 
, 
 b2g(partview_lnk.thejoindestination)  
partview_lnk_thejoindestination_id, 
 viewcolumn_brief_f(partview_lnk.thejoindestination, 'en_us') 
partview_lnk_thejoindestination 
, 
 b2g(partview_lnk.theview)  
partview_lnk_theview_id, 
 partview_brief_f(partview_lnk.theview, 'en_us') 
partview_lnk_theview 
, 
partview_lnk.seq 
partview_lnk_seq 
, 
 b2g(partview_lnk.thejoinsource)  
partview_lnk_thejoinsource_id, 
 viewcolumn_brief_f(partview_lnk.thejoinsource, 'en_us') 
partview_lnk_thejoinsource 
, 
partview_lnk.handjoin 
partview_lnk_handjoin 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(partview_lnk.partview_lnkid) id 
, 'partview_lnk' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from PARTVIEW_LNK
 join PARTVIEW on PARTVIEW.PARTVIEWID=PARTVIEW_LNK.ParentStructRowID 
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autovalidator
go
create view v_autovalidator as 
select   b2g(validator. validatorid) validatorid,validator. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(validator.target)  
validator_target_id, 
 generator_target_brief_f(validator.target, null) 
validator_target 
, 
validator.code 
validator_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(validator.validatorid) id 
, 'validator' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from VALIDATOR
 join PART on PART.PARTID=VALIDATOR.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autovalidator_ru_ru
go
create view v_autovalidator_ru_ru as 
select   b2g(validator. validatorid) validatorid,validator. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(validator.target)  
validator_target_id, 
 generator_target_brief_f(validator.target, 'ru_ru') 
validator_target 
, 
validator.code 
validator_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(validator.validatorid) id 
, 'validator' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from VALIDATOR
 join PART on PART.PARTID=VALIDATOR.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autovalidator_en_us
go
create view v_autovalidator_en_us as 
select   b2g(validator. validatorid) validatorid,validator. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(validator.target)  
validator_target_id, 
 generator_target_brief_f(validator.target, 'en_us') 
validator_target 
, 
validator.code 
validator_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(validator.validatorid) id 
, 'validator' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from VALIDATOR
 join PART on PART.PARTID=VALIDATOR.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autouniqueconstraint
go
create view v_autouniqueconstraint as 
select   b2g(uniqueconstraint. uniqueconstraintid) uniqueconstraintid,uniqueconstraint. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
uniqueconstraint.name 
uniqueconstraint_name 
, 
 uniqueconstraint.perparent  
uniqueconstraint_perparent_val, 
 case uniqueconstraint.perparent 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
uniqueconstraint_perparent 
, 
uniqueconstraint.thecomment 
uniqueconstraint_thecomment 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(uniqueconstraint.uniqueconstraintid) id 
, 'uniqueconstraint' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from UNIQUECONSTRAINT
 join PART on PART.PARTID=UNIQUECONSTRAINT.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autouniqueconstraint_ru_ru
go
create view v_autouniqueconstraint_ru_ru as 
select   b2g(uniqueconstraint. uniqueconstraintid) uniqueconstraintid,uniqueconstraint. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
uniqueconstraint.name 
uniqueconstraint_name 
, 
 uniqueconstraint.perparent  
uniqueconstraint_perparent_val, 
 case uniqueconstraint.perparent 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
uniqueconstraint_perparent 
, 
uniqueconstraint.thecomment 
uniqueconstraint_thecomment 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(uniqueconstraint.uniqueconstraintid) id 
, 'uniqueconstraint' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from UNIQUECONSTRAINT
 join PART on PART.PARTID=UNIQUECONSTRAINT.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autouniqueconstraint_en_us
go
create view v_autouniqueconstraint_en_us as 
select   b2g(uniqueconstraint. uniqueconstraintid) uniqueconstraintid,uniqueconstraint. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
uniqueconstraint.name 
uniqueconstraint_name 
, 
 uniqueconstraint.perparent  
uniqueconstraint_perparent_val, 
 case uniqueconstraint.perparent 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
uniqueconstraint_perparent 
, 
uniqueconstraint.thecomment 
uniqueconstraint_thecomment 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(uniqueconstraint.uniqueconstraintid) id 
, 'uniqueconstraint' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from UNIQUECONSTRAINT
 join PART on PART.PARTID=UNIQUECONSTRAINT.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoconstraintfield
go
create view v_autoconstraintfield as 
select   b2g(constraintfield. constraintfieldid) constraintfieldid,constraintfield. changestamp changestamp, b2g(uniqueconstraintid) uniqueconstraintid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(constraintfield.thefield)  
constraintfield_thefield_id, 
 field_brief_f(constraintfield.thefield, null) 
constraintfield_thefield 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(constraintfield.constraintfieldid) id 
, 'constraintfield' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from CONSTRAINTFIELD
 join UNIQUECONSTRAINT on UNIQUECONSTRAINT.UNIQUECONSTRAINTID=CONSTRAINTFIELD.ParentStructRowID 
 join PART on PART.PARTID=UNIQUECONSTRAINT.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoconstraintfield_ru_ru
go
create view v_autoconstraintfield_ru_ru as 
select   b2g(constraintfield. constraintfieldid) constraintfieldid,constraintfield. changestamp changestamp, b2g(uniqueconstraintid) uniqueconstraintid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(constraintfield.thefield)  
constraintfield_thefield_id, 
 field_brief_f(constraintfield.thefield, 'ru_ru') 
constraintfield_thefield 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(constraintfield.constraintfieldid) id 
, 'constraintfield' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from CONSTRAINTFIELD
 join UNIQUECONSTRAINT on UNIQUECONSTRAINT.UNIQUECONSTRAINTID=CONSTRAINTFIELD.ParentStructRowID 
 join PART on PART.PARTID=UNIQUECONSTRAINT.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoconstraintfield_en_us
go
create view v_autoconstraintfield_en_us as 
select   b2g(constraintfield. constraintfieldid) constraintfieldid,constraintfield. changestamp changestamp, b2g(uniqueconstraintid) uniqueconstraintid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(constraintfield.thefield)  
constraintfield_thefield_id, 
 field_brief_f(constraintfield.thefield, 'en_us') 
constraintfield_thefield 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(constraintfield.constraintfieldid) id 
, 'constraintfield' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from CONSTRAINTFIELD
 join UNIQUECONSTRAINT on UNIQUECONSTRAINT.UNIQUECONSTRAINTID=CONSTRAINTFIELD.ParentStructRowID 
 join PART on PART.PARTID=UNIQUECONSTRAINT.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoextenderinterface
go
create view v_autoextenderinterface as 
select   b2g(extenderinterface. extenderinterfaceid) extenderinterfaceid,extenderinterface. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
extenderinterface.theconfig 
extenderinterface_theconfig 
, 
extenderinterface.thename 
extenderinterface_thename 
, 
 b2g(extenderinterface.targetplatform)  
extenderinterface_targetplatform_id, 
 generator_target_brief_f(extenderinterface.targetplatform, null) 
extenderinterface_targetplatform 
, 
extenderinterface.theobject 
extenderinterface_theobject 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(extenderinterface.extenderinterfaceid) id 
, 'extenderinterface' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ExtenderInterface
 join PART on PART.PARTID=ExtenderInterface.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoextenderinterface_ru_ru
go
create view v_autoextenderinterface_ru_ru as 
select   b2g(extenderinterface. extenderinterfaceid) extenderinterfaceid,extenderinterface. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
extenderinterface.theconfig 
extenderinterface_theconfig 
, 
extenderinterface.thename 
extenderinterface_thename 
, 
 b2g(extenderinterface.targetplatform)  
extenderinterface_targetplatform_id, 
 generator_target_brief_f(extenderinterface.targetplatform, 'ru_ru') 
extenderinterface_targetplatform 
, 
extenderinterface.theobject 
extenderinterface_theobject 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(extenderinterface.extenderinterfaceid) id 
, 'extenderinterface' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ExtenderInterface
 join PART on PART.PARTID=ExtenderInterface.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoextenderinterface_en_us
go
create view v_autoextenderinterface_en_us as 
select   b2g(extenderinterface. extenderinterfaceid) extenderinterfaceid,extenderinterface. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
extenderinterface.theconfig 
extenderinterface_theconfig 
, 
extenderinterface.thename 
extenderinterface_thename 
, 
 b2g(extenderinterface.targetplatform)  
extenderinterface_targetplatform_id, 
 generator_target_brief_f(extenderinterface.targetplatform, 'en_us') 
extenderinterface_targetplatform 
, 
extenderinterface.theobject 
extenderinterface_theobject 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(extenderinterface.extenderinterfaceid) id 
, 'extenderinterface' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ExtenderInterface
 join PART on PART.PARTID=ExtenderInterface.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofield
go
create view v_autofield as 
select   b2g(field. fieldid) fieldid,field. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
field.caption 
field_caption 
, 
 field.allownull  
field_allownull_val, 
 case field.allownull 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_allownull 
, 
field.fieldgroupbox 
field_fieldgroupbox 
, 
field.thestyle 
field_thestyle 
, 
field.thenameclass 
field_thenameclass 
, 
field.datasize 
field_datasize 
, 
 b2g(field.numberdatefield)  
field_numberdatefield_id, 
 field_brief_f(field.numberdatefield, null) 
field_numberdatefield 
, 
 field.isautonumber  
field_isautonumber_val, 
 case field.isautonumber 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_isautonumber 
, 
 b2g(field.thenumerator)  
field_thenumerator_id, 
 instance_brief_f(field.thenumerator , null) 
field_thenumerator 
, 
 field.createrefonly  
field_createrefonly_val, 
 case field.createrefonly 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_createrefonly 
, 
field.themask 
field_themask 
, 
field.thecomment 
field_thecomment 
, 
field.tabname 
field_tabname 
, 
 field.isbrief  
field_isbrief_val, 
 case field.isbrief 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_isbrief 
, 
 field.referencetype  
field_referencetype_val, 
 case field.referencetype 
when 3 then 'на источник данных'
when 0 then 'скалярное поле ( не ссылка)'
when 2 then 'на строку раздела'
when 1 then 'на объект '
 else '' 
 end  
field_referencetype 
, 
 b2g(field.reftotype)  
field_reftotype_id, 
 objecttype_brief_f(field.reftotype, null) 
field_reftotype 
, 
 b2g(field.reftopart)  
field_reftopart_id, 
 part_brief_f(field.reftopart, null) 
field_reftopart 
, 
 field.istabbrief  
field_istabbrief_val, 
 case field.istabbrief 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_istabbrief 
, 
 b2g(field.fieldtype)  
field_fieldtype_id, 
 fieldtype_brief_f(field.fieldtype, null) 
field_fieldtype 
, 
field.zonetemplate 
field_zonetemplate 
, 
 field.internalreference  
field_internalreference_val, 
 case field.internalreference 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_internalreference 
, 
field.sequence 
field_sequence 
, 
field.name 
field_name 
, 
field.shablonbrief 
field_shablonbrief 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(field.fieldid) id 
, 'field' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELD
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofield_ru_ru
go
create view v_autofield_ru_ru as 
select   b2g(field. fieldid) fieldid,field. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
field.caption 
field_caption 
, 
 field.allownull  
field_allownull_val, 
 case field.allownull 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_allownull 
, 
field.fieldgroupbox 
field_fieldgroupbox 
, 
field.thestyle 
field_thestyle 
, 
field.thenameclass 
field_thenameclass 
, 
field.datasize 
field_datasize 
, 
 b2g(field.numberdatefield)  
field_numberdatefield_id, 
 field_brief_f(field.numberdatefield, 'ru_ru') 
field_numberdatefield 
, 
 field.isautonumber  
field_isautonumber_val, 
 case field.isautonumber 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_isautonumber 
, 
 b2g(field.thenumerator)  
field_thenumerator_id, 
 instance_brief_f(field.thenumerator, 'ru_ru') 
field_thenumerator 
, 
 field.createrefonly  
field_createrefonly_val, 
 case field.createrefonly 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_createrefonly 
, 
field.themask 
field_themask 
, 
field.thecomment 
field_thecomment 
, 
field.tabname 
field_tabname 
, 
 field.isbrief  
field_isbrief_val, 
 case field.isbrief 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_isbrief 
, 
 field.referencetype  
field_referencetype_val, 
 case field.referencetype 
when 3 then 'на источник данных'
when 0 then 'скалярное поле ( не ссылка)'
when 2 then 'на строку раздела'
when 1 then 'на объект '
 else '' 
 end  
field_referencetype 
, 
 b2g(field.reftotype)  
field_reftotype_id, 
 objecttype_brief_f(field.reftotype, 'ru_ru') 
field_reftotype 
, 
 b2g(field.reftopart)  
field_reftopart_id, 
 part_brief_f(field.reftopart, 'ru_ru') 
field_reftopart 
, 
 field.istabbrief  
field_istabbrief_val, 
 case field.istabbrief 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_istabbrief 
, 
 b2g(field.fieldtype)  
field_fieldtype_id, 
 fieldtype_brief_f(field.fieldtype, 'ru_ru') 
field_fieldtype 
, 
field.zonetemplate 
field_zonetemplate 
, 
 field.internalreference  
field_internalreference_val, 
 case field.internalreference 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_internalreference 
, 
field.sequence 
field_sequence 
, 
field.name 
field_name 
, 
field.shablonbrief 
field_shablonbrief 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(field.fieldid) id 
, 'field' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELD
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofield_en_us
go
create view v_autofield_en_us as 
select   b2g(field. fieldid) fieldid,field. changestamp changestamp, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
field.caption 
field_caption 
, 
 field.allownull  
field_allownull_val, 
 case field.allownull 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_allownull 
, 
field.fieldgroupbox 
field_fieldgroupbox 
, 
field.thestyle 
field_thestyle 
, 
field.thenameclass 
field_thenameclass 
, 
field.datasize 
field_datasize 
, 
 b2g(field.numberdatefield)  
field_numberdatefield_id, 
 field_brief_f(field.numberdatefield, 'en_us') 
field_numberdatefield 
, 
 field.isautonumber  
field_isautonumber_val, 
 case field.isautonumber 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_isautonumber 
, 
 b2g(field.thenumerator)  
field_thenumerator_id, 
 instance_brief_f(field.thenumerator, 'en_us') 
field_thenumerator 
, 
 field.createrefonly  
field_createrefonly_val, 
 case field.createrefonly 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_createrefonly 
, 
field.themask 
field_themask 
, 
field.thecomment 
field_thecomment 
, 
field.tabname 
field_tabname 
, 
 field.isbrief  
field_isbrief_val, 
 case field.isbrief 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_isbrief 
, 
 field.referencetype  
field_referencetype_val, 
 case field.referencetype 
when 3 then 'на источник данных'
when 0 then 'скалярное поле ( не ссылка)'
when 2 then 'на строку раздела'
when 1 then 'на объект '
 else '' 
 end  
field_referencetype 
, 
 b2g(field.reftotype)  
field_reftotype_id, 
 objecttype_brief_f(field.reftotype, 'en_us') 
field_reftotype 
, 
 b2g(field.reftopart)  
field_reftopart_id, 
 part_brief_f(field.reftopart, 'en_us') 
field_reftopart 
, 
 field.istabbrief  
field_istabbrief_val, 
 case field.istabbrief 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_istabbrief 
, 
 b2g(field.fieldtype)  
field_fieldtype_id, 
 fieldtype_brief_f(field.fieldtype, 'en_us') 
field_fieldtype 
, 
field.zonetemplate 
field_zonetemplate 
, 
 field.internalreference  
field_internalreference_val, 
 case field.internalreference 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
field_internalreference 
, 
field.sequence 
field_sequence 
, 
field.name 
field_name 
, 
field.shablonbrief 
field_shablonbrief 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(field.fieldid) id 
, 'field' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELD
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofldextenders
go
create view v_autofldextenders as 
select   b2g(fldextenders. fldextendersid) fldextendersid,fldextenders. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(fldextenders.targetplatform)  
fldextenders_targetplatform_id, 
 generator_target_brief_f(fldextenders.targetplatform, null) 
fldextenders_targetplatform 
, 
fldextenders.theconfig 
fldextenders_theconfig 
, 
fldextenders.thename 
fldextenders_thename 
, 
fldextenders.theobject 
fldextenders_theobject 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fldextenders.fldextendersid) id 
, 'fldextenders' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FldExtenders
 join FIELD on FIELD.FIELDID=FldExtenders.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofldextenders_ru_ru
go
create view v_autofldextenders_ru_ru as 
select   b2g(fldextenders. fldextendersid) fldextendersid,fldextenders. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(fldextenders.targetplatform)  
fldextenders_targetplatform_id, 
 generator_target_brief_f(fldextenders.targetplatform, 'ru_ru') 
fldextenders_targetplatform 
, 
fldextenders.theconfig 
fldextenders_theconfig 
, 
fldextenders.thename 
fldextenders_thename 
, 
fldextenders.theobject 
fldextenders_theobject 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fldextenders.fldextendersid) id 
, 'fldextenders' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FldExtenders
 join FIELD on FIELD.FIELDID=FldExtenders.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofldextenders_en_us
go
create view v_autofldextenders_en_us as 
select   b2g(fldextenders. fldextendersid) fldextendersid,fldextenders. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(fldextenders.targetplatform)  
fldextenders_targetplatform_id, 
 generator_target_brief_f(fldextenders.targetplatform, 'en_us') 
fldextenders_targetplatform 
, 
fldextenders.theconfig 
fldextenders_theconfig 
, 
fldextenders.thename 
fldextenders_thename 
, 
fldextenders.theobject 
fldextenders_theobject 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fldextenders.fldextendersid) id 
, 'fldextenders' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FldExtenders
 join FIELD on FIELD.FIELDID=FldExtenders.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldsrcdef
go
create view v_autofieldsrcdef as 
select   b2g(fieldsrcdef. fieldsrcdefid) fieldsrcdefid,fieldsrcdef. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
fieldsrcdef.idfield 
fieldsrcdef_idfield 
, 
fieldsrcdef.briefstring 
fieldsrcdef_briefstring 
, 
 fieldsrcdef.dontshowdialog  
fieldsrcdef_dontshowdialog_val, 
 case fieldsrcdef.dontshowdialog 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldsrcdef_dontshowdialog 
, 
fieldsrcdef.filterstring 
fieldsrcdef_filterstring 
, 
fieldsrcdef.descriptionstring 
fieldsrcdef_descriptionstring 
, 
fieldsrcdef.datasource 
fieldsrcdef_datasource 
, 
fieldsrcdef.provider 
fieldsrcdef_provider 
, 
fieldsrcdef.connectionstring 
fieldsrcdef_connectionstring 
, 
fieldsrcdef.sortfield 
fieldsrcdef_sortfield 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldsrcdef.fieldsrcdefid) id 
, 'fieldsrcdef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDSRCDEF
 join FIELD on FIELD.FIELDID=FIELDSRCDEF.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldsrcdef_ru_ru
go
create view v_autofieldsrcdef_ru_ru as 
select   b2g(fieldsrcdef. fieldsrcdefid) fieldsrcdefid,fieldsrcdef. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
fieldsrcdef.idfield 
fieldsrcdef_idfield 
, 
fieldsrcdef.briefstring 
fieldsrcdef_briefstring 
, 
 fieldsrcdef.dontshowdialog  
fieldsrcdef_dontshowdialog_val, 
 case fieldsrcdef.dontshowdialog 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldsrcdef_dontshowdialog 
, 
fieldsrcdef.filterstring 
fieldsrcdef_filterstring 
, 
fieldsrcdef.descriptionstring 
fieldsrcdef_descriptionstring 
, 
fieldsrcdef.datasource 
fieldsrcdef_datasource 
, 
fieldsrcdef.provider 
fieldsrcdef_provider 
, 
fieldsrcdef.connectionstring 
fieldsrcdef_connectionstring 
, 
fieldsrcdef.sortfield 
fieldsrcdef_sortfield 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldsrcdef.fieldsrcdefid) id 
, 'fieldsrcdef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDSRCDEF
 join FIELD on FIELD.FIELDID=FIELDSRCDEF.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldsrcdef_en_us
go
create view v_autofieldsrcdef_en_us as 
select   b2g(fieldsrcdef. fieldsrcdefid) fieldsrcdefid,fieldsrcdef. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
fieldsrcdef.idfield 
fieldsrcdef_idfield 
, 
fieldsrcdef.briefstring 
fieldsrcdef_briefstring 
, 
 fieldsrcdef.dontshowdialog  
fieldsrcdef_dontshowdialog_val, 
 case fieldsrcdef.dontshowdialog 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldsrcdef_dontshowdialog 
, 
fieldsrcdef.filterstring 
fieldsrcdef_filterstring 
, 
fieldsrcdef.descriptionstring 
fieldsrcdef_descriptionstring 
, 
fieldsrcdef.datasource 
fieldsrcdef_datasource 
, 
fieldsrcdef.provider 
fieldsrcdef_provider 
, 
fieldsrcdef.connectionstring 
fieldsrcdef_connectionstring 
, 
fieldsrcdef.sortfield 
fieldsrcdef_sortfield 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldsrcdef.fieldsrcdefid) id 
, 'fieldsrcdef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDSRCDEF
 join FIELD on FIELD.FIELDID=FIELDSRCDEF.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autodinamicfilterscript
go
create view v_autodinamicfilterscript as 
select   b2g(dinamicfilterscript. dinamicfilterscriptid) dinamicfilterscriptid,dinamicfilterscript. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(dinamicfilterscript.target)  
dinamicfilterscript_target_id, 
 generator_target_brief_f(dinamicfilterscript.target, null) 
dinamicfilterscript_target 
, 
dinamicfilterscript.code 
dinamicfilterscript_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(dinamicfilterscript.dinamicfilterscriptid) id 
, 'dinamicfilterscript' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from DINAMICFILTERSCRIPT
 join FIELD on FIELD.FIELDID=DINAMICFILTERSCRIPT.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autodinamicfilterscript_ru_ru
go
create view v_autodinamicfilterscript_ru_ru as 
select   b2g(dinamicfilterscript. dinamicfilterscriptid) dinamicfilterscriptid,dinamicfilterscript. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(dinamicfilterscript.target)  
dinamicfilterscript_target_id, 
 generator_target_brief_f(dinamicfilterscript.target, 'ru_ru') 
dinamicfilterscript_target 
, 
dinamicfilterscript.code 
dinamicfilterscript_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(dinamicfilterscript.dinamicfilterscriptid) id 
, 'dinamicfilterscript' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from DINAMICFILTERSCRIPT
 join FIELD on FIELD.FIELDID=DINAMICFILTERSCRIPT.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autodinamicfilterscript_en_us
go
create view v_autodinamicfilterscript_en_us as 
select   b2g(dinamicfilterscript. dinamicfilterscriptid) dinamicfilterscriptid,dinamicfilterscript. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(dinamicfilterscript.target)  
dinamicfilterscript_target_id, 
 generator_target_brief_f(dinamicfilterscript.target, 'en_us') 
dinamicfilterscript_target 
, 
dinamicfilterscript.code 
dinamicfilterscript_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(dinamicfilterscript.dinamicfilterscriptid) id 
, 'dinamicfilterscript' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from DINAMICFILTERSCRIPT
 join FIELD on FIELD.FIELDID=DINAMICFILTERSCRIPT.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldexpression
go
create view v_autofieldexpression as 
select   b2g(fieldexpression. fieldexpressionid) fieldexpressionid,fieldexpression. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(fieldexpression.target)  
fieldexpression_target_id, 
 generator_target_brief_f(fieldexpression.target, null) 
fieldexpression_target 
, 
fieldexpression.code 
fieldexpression_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldexpression.fieldexpressionid) id 
, 'fieldexpression' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDEXPRESSION
 join FIELD on FIELD.FIELDID=FIELDEXPRESSION.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldexpression_ru_ru
go
create view v_autofieldexpression_ru_ru as 
select   b2g(fieldexpression. fieldexpressionid) fieldexpressionid,fieldexpression. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(fieldexpression.target)  
fieldexpression_target_id, 
 generator_target_brief_f(fieldexpression.target, 'ru_ru') 
fieldexpression_target 
, 
fieldexpression.code 
fieldexpression_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldexpression.fieldexpressionid) id 
, 'fieldexpression' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDEXPRESSION
 join FIELD on FIELD.FIELDID=FIELDEXPRESSION.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldexpression_en_us
go
create view v_autofieldexpression_en_us as 
select   b2g(fieldexpression. fieldexpressionid) fieldexpressionid,fieldexpression. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(fieldexpression.target)  
fieldexpression_target_id, 
 generator_target_brief_f(fieldexpression.target, 'en_us') 
fieldexpression_target 
, 
fieldexpression.code 
fieldexpression_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldexpression.fieldexpressionid) id 
, 'fieldexpression' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDEXPRESSION
 join FIELD on FIELD.FIELDID=FIELDEXPRESSION.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldvalidator
go
create view v_autofieldvalidator as 
select   b2g(fieldvalidator. fieldvalidatorid) fieldvalidatorid,fieldvalidator. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(fieldvalidator.target)  
fieldvalidator_target_id, 
 generator_target_brief_f(fieldvalidator.target, null) 
fieldvalidator_target 
, 
fieldvalidator.code 
fieldvalidator_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldvalidator.fieldvalidatorid) id 
, 'fieldvalidator' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDVALIDATOR
 join FIELD on FIELD.FIELDID=FIELDVALIDATOR.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldvalidator_ru_ru
go
create view v_autofieldvalidator_ru_ru as 
select   b2g(fieldvalidator. fieldvalidatorid) fieldvalidatorid,fieldvalidator. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(fieldvalidator.target)  
fieldvalidator_target_id, 
 generator_target_brief_f(fieldvalidator.target, 'ru_ru') 
fieldvalidator_target 
, 
fieldvalidator.code 
fieldvalidator_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldvalidator.fieldvalidatorid) id 
, 'fieldvalidator' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDVALIDATOR
 join FIELD on FIELD.FIELDID=FIELDVALIDATOR.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldvalidator_en_us
go
create view v_autofieldvalidator_en_us as 
select   b2g(fieldvalidator. fieldvalidatorid) fieldvalidatorid,fieldvalidator. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 b2g(fieldvalidator.target)  
fieldvalidator_target_id, 
 generator_target_brief_f(fieldvalidator.target, 'en_us') 
fieldvalidator_target 
, 
fieldvalidator.code 
fieldvalidator_code 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldvalidator.fieldvalidatorid) id 
, 'fieldvalidator' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDVALIDATOR
 join FIELD on FIELD.FIELDID=FIELDVALIDATOR.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldmenu
go
create view v_autofieldmenu as 
select   b2g(fieldmenu. fieldmenuid) fieldmenuid,fieldmenu. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 fieldmenu.ismenuitem  
fieldmenu_ismenuitem_val, 
 case fieldmenu.ismenuitem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldmenu_ismenuitem 
, 
 fieldmenu.istoolbarbutton  
fieldmenu_istoolbarbutton_val, 
 case fieldmenu.istoolbarbutton 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldmenu_istoolbarbutton 
, 
fieldmenu.tooltip 
fieldmenu_tooltip 
, 
fieldmenu.hotkey 
fieldmenu_hotkey 
, 
 b2g(fieldmenu.actionid)  
fieldmenu_actionid_id, 
 sharedmethod_brief_f(fieldmenu.actionid, null) 
fieldmenu_actionid 
, 
fieldmenu.name 
fieldmenu_name 
, 
fieldmenu.caption 
fieldmenu_caption 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldmenu.fieldmenuid) id 
, 'fieldmenu' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDMENU
 join FIELD on FIELD.FIELDID=FIELDMENU.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldmenu_ru_ru
go
create view v_autofieldmenu_ru_ru as 
select   b2g(fieldmenu. fieldmenuid) fieldmenuid,fieldmenu. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 fieldmenu.ismenuitem  
fieldmenu_ismenuitem_val, 
 case fieldmenu.ismenuitem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldmenu_ismenuitem 
, 
 fieldmenu.istoolbarbutton  
fieldmenu_istoolbarbutton_val, 
 case fieldmenu.istoolbarbutton 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldmenu_istoolbarbutton 
, 
fieldmenu.tooltip 
fieldmenu_tooltip 
, 
fieldmenu.hotkey 
fieldmenu_hotkey 
, 
 b2g(fieldmenu.actionid)  
fieldmenu_actionid_id, 
 sharedmethod_brief_f(fieldmenu.actionid, 'ru_ru') 
fieldmenu_actionid 
, 
fieldmenu.name 
fieldmenu_name 
, 
fieldmenu.caption 
fieldmenu_caption 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldmenu.fieldmenuid) id 
, 'fieldmenu' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDMENU
 join FIELD on FIELD.FIELDID=FIELDMENU.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldmenu_en_us
go
create view v_autofieldmenu_en_us as 
select   b2g(fieldmenu. fieldmenuid) fieldmenuid,fieldmenu. changestamp changestamp, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 fieldmenu.ismenuitem  
fieldmenu_ismenuitem_val, 
 case fieldmenu.ismenuitem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldmenu_ismenuitem 
, 
 fieldmenu.istoolbarbutton  
fieldmenu_istoolbarbutton_val, 
 case fieldmenu.istoolbarbutton 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldmenu_istoolbarbutton 
, 
fieldmenu.tooltip 
fieldmenu_tooltip 
, 
fieldmenu.hotkey 
fieldmenu_hotkey 
, 
 b2g(fieldmenu.actionid)  
fieldmenu_actionid_id, 
 sharedmethod_brief_f(fieldmenu.actionid, 'en_us') 
fieldmenu_actionid 
, 
fieldmenu.name 
fieldmenu_name 
, 
fieldmenu.caption 
fieldmenu_caption 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldmenu.fieldmenuid) id 
, 'fieldmenu' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDMENU
 join FIELD on FIELD.FIELDID=FIELDMENU.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldparammap
go
create view v_autofieldparammap as 
select   b2g(fieldparammap. fieldparammapid) fieldparammapid,fieldparammap. changestamp changestamp, b2g(fieldmenuid) fieldmenuid, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 fieldparammap.noedit  
fieldparammap_noedit_val, 
 case fieldparammap.noedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldparammap_noedit 
, 
fieldparammap.paramname 
fieldparammap_paramname 
, 
fieldparammap.fieldname 
fieldparammap_fieldname 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldparammap.fieldparammapid) id 
, 'fieldparammap' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDPARAMMAP
 join FIELDMENU on FIELDMENU.FIELDMENUID=FIELDPARAMMAP.ParentStructRowID 
 join FIELD on FIELD.FIELDID=FIELDMENU.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldparammap_ru_ru
go
create view v_autofieldparammap_ru_ru as 
select   b2g(fieldparammap. fieldparammapid) fieldparammapid,fieldparammap. changestamp changestamp, b2g(fieldmenuid) fieldmenuid, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 fieldparammap.noedit  
fieldparammap_noedit_val, 
 case fieldparammap.noedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldparammap_noedit 
, 
fieldparammap.paramname 
fieldparammap_paramname 
, 
fieldparammap.fieldname 
fieldparammap_fieldname 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldparammap.fieldparammapid) id 
, 'fieldparammap' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDPARAMMAP
 join FIELDMENU on FIELDMENU.FIELDMENUID=FIELDPARAMMAP.ParentStructRowID 
 join FIELD on FIELD.FIELDID=FIELDMENU.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofieldparammap_en_us
go
create view v_autofieldparammap_en_us as 
select   b2g(fieldparammap. fieldparammapid) fieldparammapid,fieldparammap. changestamp changestamp, b2g(fieldmenuid) fieldmenuid, b2g(fieldid) fieldid, b2g(partid) partid, b2g(objecttypeid) objecttypeid
, 
 fieldparammap.noedit  
fieldparammap_noedit_val, 
 case fieldparammap.noedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fieldparammap_noedit 
, 
fieldparammap.paramname 
fieldparammap_paramname 
, 
fieldparammap.fieldname 
fieldparammap_fieldname 
, b2g(objecttype.instanceid) instanceid 
, objecttype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fieldparammap.fieldparammapid) id 
, 'fieldparammap' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FIELDPARAMMAP
 join FIELDMENU on FIELDMENU.FIELDMENUID=FIELDPARAMMAP.ParentStructRowID 
 join FIELD on FIELD.FIELDID=FIELDMENU.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtzapp
go
create view v_automtzapp as 
select   b2g(mtzapp. mtzappid) mtzappid,mtzapp. changestamp changestamp
, 
mtzapp.name 
mtzapp_name 
, 
mtzapp.thecomment 
mtzapp_thecomment 
, 
mtzapp.dbname 
mtzapp_dbname 
, b2g(mtzapp.instanceid) instanceid 
, mtzapp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtzapp.mtzappid) id 
, 'mtzapp' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZAPP
 join INSTANCE on MTZAPP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtzapp_ru_ru
go
create view v_automtzapp_ru_ru as 
select   b2g(mtzapp. mtzappid) mtzappid,mtzapp. changestamp changestamp
, 
mtzapp.name 
mtzapp_name 
, 
mtzapp.thecomment 
mtzapp_thecomment 
, 
mtzapp.dbname 
mtzapp_dbname 
, b2g(mtzapp.instanceid) instanceid 
, mtzapp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtzapp.mtzappid) id 
, 'mtzapp' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZAPP
 join INSTANCE on MTZAPP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtzapp_en_us
go
create view v_automtzapp_en_us as 
select   b2g(mtzapp. mtzappid) mtzappid,mtzapp. changestamp changestamp
, 
mtzapp.name 
mtzapp_name 
, 
mtzapp.thecomment 
mtzapp_thecomment 
, 
mtzapp.dbname 
mtzapp_dbname 
, b2g(mtzapp.instanceid) instanceid 
, mtzapp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtzapp.mtzappid) id 
, 'mtzapp' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZAPP
 join INSTANCE on MTZAPP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoparentpackage
go
create view v_autoparentpackage as 
select   b2g(parentpackage. parentpackageid) parentpackageid,parentpackage. changestamp changestamp, b2g(mtzappid) mtzappid
, 
 b2g(parentpackage.package)  
parentpackage_package_id, 
 mtzapp_brief_f(parentpackage.package, null) 
parentpackage_package 
, b2g(mtzapp.instanceid) instanceid 
, mtzapp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(parentpackage.parentpackageid) id 
, 'parentpackage' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ParentPackage
 join MTZAPP on MTZAPP.MTZAPPID=ParentPackage.ParentStructRowID 
 join INSTANCE on MTZAPP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoparentpackage_ru_ru
go
create view v_autoparentpackage_ru_ru as 
select   b2g(parentpackage. parentpackageid) parentpackageid,parentpackage. changestamp changestamp, b2g(mtzappid) mtzappid
, 
 b2g(parentpackage.package)  
parentpackage_package_id, 
 mtzapp_brief_f(parentpackage.package, 'ru_ru') 
parentpackage_package 
, b2g(mtzapp.instanceid) instanceid 
, mtzapp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(parentpackage.parentpackageid) id 
, 'parentpackage' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ParentPackage
 join MTZAPP on MTZAPP.MTZAPPID=ParentPackage.ParentStructRowID 
 join INSTANCE on MTZAPP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoparentpackage_en_us
go
create view v_autoparentpackage_en_us as 
select   b2g(parentpackage. parentpackageid) parentpackageid,parentpackage. changestamp changestamp, b2g(mtzappid) mtzappid
, 
 b2g(parentpackage.package)  
parentpackage_package_id, 
 mtzapp_brief_f(parentpackage.package, 'en_us') 
parentpackage_package 
, b2g(mtzapp.instanceid) instanceid 
, mtzapp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(parentpackage.parentpackageid) id 
, 'parentpackage' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ParentPackage
 join MTZAPP on MTZAPP.MTZAPPID=ParentPackage.ParentStructRowID 
 join INSTANCE on MTZAPP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojournalcolumn
go
create view v_autojournalcolumn as 
select   b2g(journalcolumn. journalcolumnid) journalcolumnid,journalcolumn. changestamp changestamp
, 
journalcolumn.name 
journalcolumn_name 
, 
 journalcolumn.colsort  
journalcolumn_colsort_val, 
 case journalcolumn.colsort 
when 0 then 'as string'
when 1 then 'as numeric'
when 2 then 'as date'
 else '' 
 end  
journalcolumn_colsort 
, 
journalcolumn.sequence 
journalcolumn_sequence 
, 
 journalcolumn.columnalignment  
journalcolumn_columnalignment_val, 
 case journalcolumn.columnalignment 
when 6 then 'right top'
when 7 then 'right center'
when 8 then 'right bottom'
when 3 then 'center top'
when 0 then 'left top'
when 4 then 'center center'
when 1 then 'left center'
when 5 then 'center bottom'
when 2 then 'left bottom'
 else '' 
 end  
journalcolumn_columnalignment 
, 
 journalcolumn.groupaggregation  
journalcolumn_groupaggregation_val, 
 case journalcolumn.groupaggregation 
when 3 then 'sum'
when 1 then 'avg'
when 6 then 'custom'
when 0 then 'none'
when 2 then 'count'
when 5 then 'max'
when 4 then 'min'
 else '' 
 end  
journalcolumn_groupaggregation 
, b2g(journalcolumn.instanceid) instanceid 
, journalcolumn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(journalcolumn.journalcolumnid) id 
, 'journalcolumn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from JournalColumn
 join INSTANCE on JournalColumn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojournalcolumn_ru_ru
go
create view v_autojournalcolumn_ru_ru as 
select   b2g(journalcolumn. journalcolumnid) journalcolumnid,journalcolumn. changestamp changestamp
, 
journalcolumn.name 
journalcolumn_name 
, 
 journalcolumn.colsort  
journalcolumn_colsort_val, 
 case journalcolumn.colsort 
when 0 then 'as string'
when 1 then 'as numeric'
when 2 then 'as date'
 else '' 
 end  
journalcolumn_colsort 
, 
journalcolumn.sequence 
journalcolumn_sequence 
, 
 journalcolumn.columnalignment  
journalcolumn_columnalignment_val, 
 case journalcolumn.columnalignment 
when 6 then 'right top'
when 7 then 'right center'
when 8 then 'right bottom'
when 3 then 'center top'
when 0 then 'left top'
when 4 then 'center center'
when 1 then 'left center'
when 5 then 'center bottom'
when 2 then 'left bottom'
 else '' 
 end  
journalcolumn_columnalignment 
, 
 journalcolumn.groupaggregation  
journalcolumn_groupaggregation_val, 
 case journalcolumn.groupaggregation 
when 3 then 'sum'
when 1 then 'avg'
when 6 then 'custom'
when 0 then 'none'
when 2 then 'count'
when 5 then 'max'
when 4 then 'min'
 else '' 
 end  
journalcolumn_groupaggregation 
, b2g(journalcolumn.instanceid) instanceid 
, journalcolumn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(journalcolumn.journalcolumnid) id 
, 'journalcolumn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from JournalColumn
 join INSTANCE on JournalColumn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojournalcolumn_en_us
go
create view v_autojournalcolumn_en_us as 
select   b2g(journalcolumn. journalcolumnid) journalcolumnid,journalcolumn. changestamp changestamp
, 
journalcolumn.name 
journalcolumn_name 
, 
 journalcolumn.colsort  
journalcolumn_colsort_val, 
 case journalcolumn.colsort 
when 0 then 'as string'
when 1 then 'as numeric'
when 2 then 'as date'
 else '' 
 end  
journalcolumn_colsort 
, 
journalcolumn.sequence 
journalcolumn_sequence 
, 
 journalcolumn.columnalignment  
journalcolumn_columnalignment_val, 
 case journalcolumn.columnalignment 
when 6 then 'right top'
when 7 then 'right center'
when 8 then 'right bottom'
when 3 then 'center top'
when 0 then 'left top'
when 4 then 'center center'
when 1 then 'left center'
when 5 then 'center bottom'
when 2 then 'left bottom'
 else '' 
 end  
journalcolumn_columnalignment 
, 
 journalcolumn.groupaggregation  
journalcolumn_groupaggregation_val, 
 case journalcolumn.groupaggregation 
when 3 then 'sum'
when 1 then 'avg'
when 6 then 'custom'
when 0 then 'none'
when 2 then 'count'
when 5 then 'max'
when 4 then 'min'
 else '' 
 end  
journalcolumn_groupaggregation 
, b2g(journalcolumn.instanceid) instanceid 
, journalcolumn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(journalcolumn.journalcolumnid) id 
, 'journalcolumn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from JournalColumn
 join INSTANCE on JournalColumn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojcolumnsource
go
create view v_autojcolumnsource as 
select   b2g(jcolumnsource. jcolumnsourceid) jcolumnsourceid,jcolumnsource. changestamp changestamp, b2g(journalcolumnid) journalcolumnid
, 
jcolumnsource.viewfield 
jcolumnsource_viewfield 
, 
 b2g(jcolumnsource.srcpartview)  
jcolumnsource_srcpartview_id, 
 journalsrc_brief_f(jcolumnsource.srcpartview, null) 
jcolumnsource_srcpartview 
, b2g(journalcolumn.instanceid) instanceid 
, journalcolumn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(jcolumnsource.jcolumnsourceid) id 
, 'jcolumnsource' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from JColumnSource
 join JournalColumn on JournalColumn.JournalColumnID=JColumnSource.ParentStructRowID 
 join INSTANCE on JournalColumn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojcolumnsource_ru_ru
go
create view v_autojcolumnsource_ru_ru as 
select   b2g(jcolumnsource. jcolumnsourceid) jcolumnsourceid,jcolumnsource. changestamp changestamp, b2g(journalcolumnid) journalcolumnid
, 
jcolumnsource.viewfield 
jcolumnsource_viewfield 
, 
 b2g(jcolumnsource.srcpartview)  
jcolumnsource_srcpartview_id, 
 journalsrc_brief_f(jcolumnsource.srcpartview, 'ru_ru') 
jcolumnsource_srcpartview 
, b2g(journalcolumn.instanceid) instanceid 
, journalcolumn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(jcolumnsource.jcolumnsourceid) id 
, 'jcolumnsource' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from JColumnSource
 join JournalColumn on JournalColumn.JournalColumnID=JColumnSource.ParentStructRowID 
 join INSTANCE on JournalColumn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojcolumnsource_en_us
go
create view v_autojcolumnsource_en_us as 
select   b2g(jcolumnsource. jcolumnsourceid) jcolumnsourceid,jcolumnsource. changestamp changestamp, b2g(journalcolumnid) journalcolumnid
, 
jcolumnsource.viewfield 
jcolumnsource_viewfield 
, 
 b2g(jcolumnsource.srcpartview)  
jcolumnsource_srcpartview_id, 
 journalsrc_brief_f(jcolumnsource.srcpartview, 'en_us') 
jcolumnsource_srcpartview 
, b2g(journalcolumn.instanceid) instanceid 
, journalcolumn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(jcolumnsource.jcolumnsourceid) id 
, 'jcolumnsource' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from JColumnSource
 join JournalColumn on JournalColumn.JournalColumnID=JColumnSource.ParentStructRowID 
 join INSTANCE on JournalColumn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojournalsrc
go
create view v_autojournalsrc as 
select   b2g(journalsrc. journalsrcid) journalsrcid,journalsrc. changestamp changestamp
, 
 journalsrc.onrun  
journalsrc_onrun_val, 
 case journalsrc.onrun 
when 2 then 'открыть документ'
when 0 then 'ничего не делать'
when 1 then 'открыть строку'
 else '' 
 end  
journalsrc_onrun 
, 
journalsrc.partview 
journalsrc_partview 
, 
journalsrc.viewalias 
journalsrc_viewalias 
, 
journalsrc.openmode 
journalsrc_openmode 
, b2g(journalsrc.instanceid) instanceid 
, journalsrc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(journalsrc.journalsrcid) id 
, 'journalsrc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from JournalSrc
 join INSTANCE on JournalSrc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojournalsrc_ru_ru
go
create view v_autojournalsrc_ru_ru as 
select   b2g(journalsrc. journalsrcid) journalsrcid,journalsrc. changestamp changestamp
, 
 journalsrc.onrun  
journalsrc_onrun_val, 
 case journalsrc.onrun 
when 2 then 'открыть документ'
when 0 then 'ничего не делать'
when 1 then 'открыть строку'
 else '' 
 end  
journalsrc_onrun 
, 
journalsrc.partview 
journalsrc_partview 
, 
journalsrc.viewalias 
journalsrc_viewalias 
, 
journalsrc.openmode 
journalsrc_openmode 
, b2g(journalsrc.instanceid) instanceid 
, journalsrc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(journalsrc.journalsrcid) id 
, 'journalsrc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from JournalSrc
 join INSTANCE on JournalSrc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojournalsrc_en_us
go
create view v_autojournalsrc_en_us as 
select   b2g(journalsrc. journalsrcid) journalsrcid,journalsrc. changestamp changestamp
, 
 journalsrc.onrun  
journalsrc_onrun_val, 
 case journalsrc.onrun 
when 2 then 'открыть документ'
when 0 then 'ничего не делать'
when 1 then 'открыть строку'
 else '' 
 end  
journalsrc_onrun 
, 
journalsrc.partview 
journalsrc_partview 
, 
journalsrc.viewalias 
journalsrc_viewalias 
, 
journalsrc.openmode 
journalsrc_openmode 
, b2g(journalsrc.instanceid) instanceid 
, journalsrc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(journalsrc.journalsrcid) id 
, 'journalsrc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from JournalSrc
 join INSTANCE on JournalSrc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojournal
go
create view v_autojournal as 
select   b2g(journal. journalid) journalid,journal. changestamp changestamp
, 
 journal.usefavorites  
journal_usefavorites_val, 
 case journal.usefavorites 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
journal_usefavorites 
, 
journal.thecomment 
journal_thecomment 
, 
journal.jrnliconcls 
journal_jrnliconcls 
, 
journal.name 
journal_name 
, 
journal.the_alias 
journal_the_alias 
, b2g(journal.instanceid) instanceid 
, journal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(journal.journalid) id 
, 'journal' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Journal
 join INSTANCE on Journal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojournal_ru_ru
go
create view v_autojournal_ru_ru as 
select   b2g(journal. journalid) journalid,journal. changestamp changestamp
, 
 journal.usefavorites  
journal_usefavorites_val, 
 case journal.usefavorites 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
journal_usefavorites 
, 
journal.thecomment 
journal_thecomment 
, 
journal.jrnliconcls 
journal_jrnliconcls 
, 
journal.name 
journal_name 
, 
journal.the_alias 
journal_the_alias 
, b2g(journal.instanceid) instanceid 
, journal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(journal.journalid) id 
, 'journal' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Journal
 join INSTANCE on Journal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autojournal_en_us
go
create view v_autojournal_en_us as 
select   b2g(journal. journalid) journalid,journal. changestamp changestamp
, 
 journal.usefavorites  
journal_usefavorites_val, 
 case journal.usefavorites 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
journal_usefavorites 
, 
journal.thecomment 
journal_thecomment 
, 
journal.jrnliconcls 
journal_jrnliconcls 
, 
journal.name 
journal_name 
, 
journal.the_alias 
journal_the_alias 
, b2g(journal.instanceid) instanceid 
, journal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(journal.journalid) id 
, 'journal' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Journal
 join INSTANCE on Journal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_sn
go
create view v_autoiu_urok_sn as 
select   b2g(iu_urok_sn. iu_urok_snid) iu_urok_snid,iu_urok_sn. changestamp changestamp
, 
iu_urok_sn.statusdate 
iu_urok_sn_statusdate 
, 
 b2g(iu_urok_sn.urokstatus)  
iu_urok_sn_urokstatus_id, 
 iud_sn_def_brief_f(iu_urok_sn.urokstatus, null) 
iu_urok_sn_urokstatus 
, b2g(iu_urok_sn.instanceid) instanceid 
, iu_urok_sn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_sn.iu_urok_snid) id 
, 'iu_urok_sn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_sn
 join INSTANCE on iu_urok_sn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_sn_ru_ru
go
create view v_autoiu_urok_sn_ru_ru as 
select   b2g(iu_urok_sn. iu_urok_snid) iu_urok_snid,iu_urok_sn. changestamp changestamp
, 
iu_urok_sn.statusdate 
iu_urok_sn_statusdate 
, 
 b2g(iu_urok_sn.urokstatus)  
iu_urok_sn_urokstatus_id, 
 iud_sn_def_brief_f(iu_urok_sn.urokstatus, 'ru_ru') 
iu_urok_sn_urokstatus 
, b2g(iu_urok_sn.instanceid) instanceid 
, iu_urok_sn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_sn.iu_urok_snid) id 
, 'iu_urok_sn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_sn
 join INSTANCE on iu_urok_sn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_sn_en_us
go
create view v_autoiu_urok_sn_en_us as 
select   b2g(iu_urok_sn. iu_urok_snid) iu_urok_snid,iu_urok_sn. changestamp changestamp
, 
iu_urok_sn.statusdate 
iu_urok_sn_statusdate 
, 
 b2g(iu_urok_sn.urokstatus)  
iu_urok_sn_urokstatus_id, 
 iud_sn_def_brief_f(iu_urok_sn.urokstatus, 'en_us') 
iu_urok_sn_urokstatus 
, b2g(iu_urok_sn.instanceid) instanceid 
, iu_urok_sn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_sn.iu_urok_snid) id 
, 'iu_urok_sn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_sn
 join INSTANCE on iu_urok_sn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_sn_1
go
create view v_autoiu_urok_sn_1 as 
select   b2g(iu_urok_sn. iu_urok_snid) iu_urok_snid,iu_urok_sn. changestamp changestamp
, 
 b2g(iu_urok_sn.urokstatus)  
iu_urok_sn_1_urokstatus_id, 
 iud_sn_def_brief_f(iu_urok_sn.urokstatus, null) 
iu_urok_sn_1_urokstatus 
, 
iu_urok_sn.statusdate 
iu_urok_sn_1_statusdate 
, b2g(iu_urok_sn.instanceid) instanceid 
, iu_urok_sn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_sn.iu_urok_snid) id 
, 'iu_urok_sn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_sn
 join INSTANCE on iu_urok_sn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_sn_1_ru_ru
go
create view v_autoiu_urok_sn_1_ru_ru as 
select   b2g(iu_urok_sn. iu_urok_snid) iu_urok_snid,iu_urok_sn. changestamp changestamp
, 
 b2g(iu_urok_sn.urokstatus)  
iu_urok_sn_1_urokstatus_id, 
 iud_sn_def_brief_f(iu_urok_sn.urokstatus, 'ru_ru') 
iu_urok_sn_1_urokstatus 
, 
iu_urok_sn.statusdate 
iu_urok_sn_1_statusdate 
, b2g(iu_urok_sn.instanceid) instanceid 
, iu_urok_sn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_sn.iu_urok_snid) id 
, 'iu_urok_sn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_sn
 join INSTANCE on iu_urok_sn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_sn_1_en_us
go
create view v_autoiu_urok_sn_1_en_us as 
select   b2g(iu_urok_sn. iu_urok_snid) iu_urok_snid,iu_urok_sn. changestamp changestamp
, 
 b2g(iu_urok_sn.urokstatus)  
iu_urok_sn_1_urokstatus_id, 
 iud_sn_def_brief_f(iu_urok_sn.urokstatus, 'en_us') 
iu_urok_sn_1_urokstatus 
, 
iu_urok_sn.statusdate 
iu_urok_sn_1_statusdate 
, b2g(iu_urok_sn.instanceid) instanceid 
, iu_urok_sn.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_sn.iu_urok_snid) id 
, 'iu_urok_sn' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_sn
 join INSTANCE on iu_urok_sn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_msg
go
create view v_autoiu_urok_msg as 
select   b2g(iu_urok_msg. iu_urok_msgid) iu_urok_msgid,iu_urok_msg. changestamp changestamp
, 
iu_urok_msg.thedate 
iu_urok_msg_thedate 
, 
iu_urok_msg.info 
iu_urok_msg_info 
, b2g(iu_urok_msg.instanceid) instanceid 
, iu_urok_msg.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_msg.iu_urok_msgid) id 
, 'iu_urok_msg' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_msg
 join INSTANCE on iu_urok_msg.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_msg_ru_ru
go
create view v_autoiu_urok_msg_ru_ru as 
select   b2g(iu_urok_msg. iu_urok_msgid) iu_urok_msgid,iu_urok_msg. changestamp changestamp
, 
iu_urok_msg.thedate 
iu_urok_msg_thedate 
, 
iu_urok_msg.info 
iu_urok_msg_info 
, b2g(iu_urok_msg.instanceid) instanceid 
, iu_urok_msg.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_msg.iu_urok_msgid) id 
, 'iu_urok_msg' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_msg
 join INSTANCE on iu_urok_msg.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_msg_en_us
go
create view v_autoiu_urok_msg_en_us as 
select   b2g(iu_urok_msg. iu_urok_msgid) iu_urok_msgid,iu_urok_msg. changestamp changestamp
, 
iu_urok_msg.thedate 
iu_urok_msg_thedate 
, 
iu_urok_msg.info 
iu_urok_msg_info 
, b2g(iu_urok_msg.instanceid) instanceid 
, iu_urok_msg.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_msg.iu_urok_msgid) id 
, 'iu_urok_msg' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_msg
 join INSTANCE on iu_urok_msg.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_graph_1
go
create view v_autoiu_urok_graph_1 as 
select   b2g(iu_urok_graph. iu_urok_graphid) iu_urok_graphid,iu_urok_graph. changestamp changestamp
, 
iu_urok_graph.planstartdate 
iu_urok_graph_1_planstartdate 
, 
iu_urok_graph.planduration 
iu_urok_graph_1_planduration 
, 
 b2g(iu_urok_graph.thestatus)  
iu_urok_graph_1_thestatus_id, 
 iu_status_brief_f(iu_urok_graph.thestatus, null) 
iu_urok_graph_1_thestatus 
, 
iu_urok_graph.stageenddate 
iu_urok_graph_1_stageenddate 
, 
iu_urok_graph.stagestartdate 
iu_urok_graph_1_stagestartdate 
, 
iu_urok_graph.passnumber 
iu_urok_graph_1_passnumber 
, 
iu_urok_graph.stagepercent 
iu_urok_graph_1_stagepercent 
, b2g(iu_urok_graph.instanceid) instanceid 
, iu_urok_graph.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_graph.iu_urok_graphid) id 
, 'iu_urok_graph' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_graph
 join INSTANCE on iu_urok_graph.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_graph_1_ru_ru
go
create view v_autoiu_urok_graph_1_ru_ru as 
select   b2g(iu_urok_graph. iu_urok_graphid) iu_urok_graphid,iu_urok_graph. changestamp changestamp
, 
iu_urok_graph.planstartdate 
iu_urok_graph_1_planstartdate 
, 
iu_urok_graph.planduration 
iu_urok_graph_1_planduration 
, 
 b2g(iu_urok_graph.thestatus)  
iu_urok_graph_1_thestatus_id, 
 iu_status_brief_f(iu_urok_graph.thestatus, 'ru_ru') 
iu_urok_graph_1_thestatus 
, 
iu_urok_graph.stageenddate 
iu_urok_graph_1_stageenddate 
, 
iu_urok_graph.stagestartdate 
iu_urok_graph_1_stagestartdate 
, 
iu_urok_graph.passnumber 
iu_urok_graph_1_passnumber 
, 
iu_urok_graph.stagepercent 
iu_urok_graph_1_stagepercent 
, b2g(iu_urok_graph.instanceid) instanceid 
, iu_urok_graph.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_graph.iu_urok_graphid) id 
, 'iu_urok_graph' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_graph
 join INSTANCE on iu_urok_graph.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_graph_1_en_us
go
create view v_autoiu_urok_graph_1_en_us as 
select   b2g(iu_urok_graph. iu_urok_graphid) iu_urok_graphid,iu_urok_graph. changestamp changestamp
, 
iu_urok_graph.planstartdate 
iu_urok_graph_1_planstartdate 
, 
iu_urok_graph.planduration 
iu_urok_graph_1_planduration 
, 
 b2g(iu_urok_graph.thestatus)  
iu_urok_graph_1_thestatus_id, 
 iu_status_brief_f(iu_urok_graph.thestatus, 'en_us') 
iu_urok_graph_1_thestatus 
, 
iu_urok_graph.stageenddate 
iu_urok_graph_1_stageenddate 
, 
iu_urok_graph.stagestartdate 
iu_urok_graph_1_stagestartdate 
, 
iu_urok_graph.passnumber 
iu_urok_graph_1_passnumber 
, 
iu_urok_graph.stagepercent 
iu_urok_graph_1_stagepercent 
, b2g(iu_urok_graph.instanceid) instanceid 
, iu_urok_graph.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_graph.iu_urok_graphid) id 
, 'iu_urok_graph' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_graph
 join INSTANCE on iu_urok_graph.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_graph
go
create view v_autoiu_urok_graph as 
select   b2g(iu_urok_graph. iu_urok_graphid) iu_urok_graphid,iu_urok_graph. changestamp changestamp
, 
iu_urok_graph.stagestartdate 
iu_urok_graph_stagestartdate 
, 
iu_urok_graph.planstartdate 
iu_urok_graph_planstartdate 
, 
 b2g(iu_urok_graph.thestatus)  
iu_urok_graph_thestatus_id, 
 iu_status_brief_f(iu_urok_graph.thestatus, null) 
iu_urok_graph_thestatus 
, 
iu_urok_graph.passnumber 
iu_urok_graph_passnumber 
, 
iu_urok_graph.planduration 
iu_urok_graph_planduration 
, 
iu_urok_graph.stageenddate 
iu_urok_graph_stageenddate 
, 
iu_urok_graph.stagepercent 
iu_urok_graph_stagepercent 
, b2g(iu_urok_graph.instanceid) instanceid 
, iu_urok_graph.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_graph.iu_urok_graphid) id 
, 'iu_urok_graph' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_graph
 join INSTANCE on iu_urok_graph.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_graph_ru_ru
go
create view v_autoiu_urok_graph_ru_ru as 
select   b2g(iu_urok_graph. iu_urok_graphid) iu_urok_graphid,iu_urok_graph. changestamp changestamp
, 
iu_urok_graph.stagestartdate 
iu_urok_graph_stagestartdate 
, 
iu_urok_graph.planstartdate 
iu_urok_graph_planstartdate 
, 
 b2g(iu_urok_graph.thestatus)  
iu_urok_graph_thestatus_id, 
 iu_status_brief_f(iu_urok_graph.thestatus, 'ru_ru') 
iu_urok_graph_thestatus 
, 
iu_urok_graph.passnumber 
iu_urok_graph_passnumber 
, 
iu_urok_graph.planduration 
iu_urok_graph_planduration 
, 
iu_urok_graph.stageenddate 
iu_urok_graph_stageenddate 
, 
iu_urok_graph.stagepercent 
iu_urok_graph_stagepercent 
, b2g(iu_urok_graph.instanceid) instanceid 
, iu_urok_graph.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_graph.iu_urok_graphid) id 
, 'iu_urok_graph' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_graph
 join INSTANCE on iu_urok_graph.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_graph_en_us
go
create view v_autoiu_urok_graph_en_us as 
select   b2g(iu_urok_graph. iu_urok_graphid) iu_urok_graphid,iu_urok_graph. changestamp changestamp
, 
iu_urok_graph.stagestartdate 
iu_urok_graph_stagestartdate 
, 
iu_urok_graph.planstartdate 
iu_urok_graph_planstartdate 
, 
 b2g(iu_urok_graph.thestatus)  
iu_urok_graph_thestatus_id, 
 iu_status_brief_f(iu_urok_graph.thestatus, 'en_us') 
iu_urok_graph_thestatus 
, 
iu_urok_graph.passnumber 
iu_urok_graph_passnumber 
, 
iu_urok_graph.planduration 
iu_urok_graph_planduration 
, 
iu_urok_graph.stageenddate 
iu_urok_graph_stageenddate 
, 
iu_urok_graph.stagepercent 
iu_urok_graph_stagepercent 
, b2g(iu_urok_graph.instanceid) instanceid 
, iu_urok_graph.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_graph.iu_urok_graphid) id 
, 'iu_urok_graph' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_graph
 join INSTANCE on iu_urok_graph.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_prc
go
create view v_autoiu_urok_prc as 
select   b2g(iu_urok_prc. iu_urok_prcid) iu_urok_prcid,iu_urok_prc. changestamp changestamp
, 
 b2g(iu_urok_prc.laststate)  
iu_urok_prc_laststate_id, 
 iud_sn_def_brief_f(iu_urok_prc.laststate, null) 
iu_urok_prc_laststate 
, 
 iu_urok_prc.manualcontrol  
iu_urok_prc_manualcontrol_val, 
 case iu_urok_prc.manualcontrol 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_prc_manualcontrol 
, 
 b2g(iu_urok_prc.topstage)  
iu_urok_prc_topstage_id, 
 iud_stagedef_brief_f(iu_urok_prc.topstage, null) 
iu_urok_prc_topstage 
, 
 b2g(iu_urok_prc.theprocess)  
iu_urok_prc_theprocess_id, 
 iu_urok_def_brief_f(iu_urok_prc.theprocess, null) 
iu_urok_prc_theprocess 
, 
iu_urok_prc.taskdelayed 
iu_urok_prc_taskdelayed 
, 
 b2g(iu_urok_prc.iu_urok_stage)  
iu_urok_prc_iu_urok_stage_id, 
 iu_status_brief_f(iu_urok_prc.iu_urok_stage, null) 
iu_urok_prc_iu_urok_stage 
, 
iu_urok_prc.lastmessage 
iu_urok_prc_lastmessage 
, 
 iu_urok_prc.isdone  
iu_urok_prc_isdone_val, 
 case iu_urok_prc.isdone 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_prc_isdone 
, b2g(iu_urok_prc.instanceid) instanceid 
, iu_urok_prc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_prc.iu_urok_prcid) id 
, 'iu_urok_prc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_prc
 join INSTANCE on iu_urok_prc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_prc_ru_ru
go
create view v_autoiu_urok_prc_ru_ru as 
select   b2g(iu_urok_prc. iu_urok_prcid) iu_urok_prcid,iu_urok_prc. changestamp changestamp
, 
 b2g(iu_urok_prc.laststate)  
iu_urok_prc_laststate_id, 
 iud_sn_def_brief_f(iu_urok_prc.laststate, 'ru_ru') 
iu_urok_prc_laststate 
, 
 iu_urok_prc.manualcontrol  
iu_urok_prc_manualcontrol_val, 
 case iu_urok_prc.manualcontrol 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_prc_manualcontrol 
, 
 b2g(iu_urok_prc.topstage)  
iu_urok_prc_topstage_id, 
 iud_stagedef_brief_f(iu_urok_prc.topstage, 'ru_ru') 
iu_urok_prc_topstage 
, 
 b2g(iu_urok_prc.theprocess)  
iu_urok_prc_theprocess_id, 
 iu_urok_def_brief_f(iu_urok_prc.theprocess, 'ru_ru') 
iu_urok_prc_theprocess 
, 
iu_urok_prc.taskdelayed 
iu_urok_prc_taskdelayed 
, 
 b2g(iu_urok_prc.iu_urok_stage)  
iu_urok_prc_iu_urok_stage_id, 
 iu_status_brief_f(iu_urok_prc.iu_urok_stage, 'ru_ru') 
iu_urok_prc_iu_urok_stage 
, 
iu_urok_prc.lastmessage 
iu_urok_prc_lastmessage 
, 
 iu_urok_prc.isdone  
iu_urok_prc_isdone_val, 
 case iu_urok_prc.isdone 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_prc_isdone 
, b2g(iu_urok_prc.instanceid) instanceid 
, iu_urok_prc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_prc.iu_urok_prcid) id 
, 'iu_urok_prc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_prc
 join INSTANCE on iu_urok_prc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_prc_en_us
go
create view v_autoiu_urok_prc_en_us as 
select   b2g(iu_urok_prc. iu_urok_prcid) iu_urok_prcid,iu_urok_prc. changestamp changestamp
, 
 b2g(iu_urok_prc.laststate)  
iu_urok_prc_laststate_id, 
 iud_sn_def_brief_f(iu_urok_prc.laststate, 'en_us') 
iu_urok_prc_laststate 
, 
 iu_urok_prc.manualcontrol  
iu_urok_prc_manualcontrol_val, 
 case iu_urok_prc.manualcontrol 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_prc_manualcontrol 
, 
 b2g(iu_urok_prc.topstage)  
iu_urok_prc_topstage_id, 
 iud_stagedef_brief_f(iu_urok_prc.topstage, 'en_us') 
iu_urok_prc_topstage 
, 
 b2g(iu_urok_prc.theprocess)  
iu_urok_prc_theprocess_id, 
 iu_urok_def_brief_f(iu_urok_prc.theprocess, 'en_us') 
iu_urok_prc_theprocess 
, 
iu_urok_prc.taskdelayed 
iu_urok_prc_taskdelayed 
, 
 b2g(iu_urok_prc.iu_urok_stage)  
iu_urok_prc_iu_urok_stage_id, 
 iu_status_brief_f(iu_urok_prc.iu_urok_stage, 'en_us') 
iu_urok_prc_iu_urok_stage 
, 
iu_urok_prc.lastmessage 
iu_urok_prc_lastmessage 
, 
 iu_urok_prc.isdone  
iu_urok_prc_isdone_val, 
 case iu_urok_prc.isdone 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_prc_isdone 
, b2g(iu_urok_prc.instanceid) instanceid 
, iu_urok_prc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_prc.iu_urok_prcid) id 
, 'iu_urok_prc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_prc
 join INSTANCE on iu_urok_prc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_us_def
go
create view v_autoiu_us_def as 
select   b2g(iu_urok_prc. iu_urok_prcid) iu_urok_prcid,iu_urok_prc. changestamp changestamp
, 
 b2g(iu_urok_prc.theprocess)  
iu_us_def_theprocess_id, 
 iu_urok_def_brief_f(iu_urok_prc.theprocess, null) 
iu_us_def_theprocess 
, 
 iu_urok_prc.isdone  
iu_us_def_isdone_val, 
 case iu_urok_prc.isdone 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_us_def_isdone 
, 
 b2g(iu_urok_prc.iu_urok_stage)  
iu_us_def_iu_urok_stage_id, 
 iu_status_brief_f(iu_urok_prc.iu_urok_stage, null) 
iu_us_def_iu_urok_stage 
, 
 b2g(iu_urok_prc.topstage)  
iu_us_def_topstage_id, 
 iud_stagedef_brief_f(iu_urok_prc.topstage, null) 
iu_us_def_topstage 
, b2g(iu_urok_prc.instanceid) instanceid 
, iu_urok_prc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_prc.iu_urok_prcid) id 
, 'iu_urok_prc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_prc
 join INSTANCE on iu_urok_prc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_us_def_ru_ru
go
create view v_autoiu_us_def_ru_ru as 
select   b2g(iu_urok_prc. iu_urok_prcid) iu_urok_prcid,iu_urok_prc. changestamp changestamp
, 
 b2g(iu_urok_prc.theprocess)  
iu_us_def_theprocess_id, 
 iu_urok_def_brief_f(iu_urok_prc.theprocess, 'ru_ru') 
iu_us_def_theprocess 
, 
 iu_urok_prc.isdone  
iu_us_def_isdone_val, 
 case iu_urok_prc.isdone 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_us_def_isdone 
, 
 b2g(iu_urok_prc.iu_urok_stage)  
iu_us_def_iu_urok_stage_id, 
 iu_status_brief_f(iu_urok_prc.iu_urok_stage, 'ru_ru') 
iu_us_def_iu_urok_stage 
, 
 b2g(iu_urok_prc.topstage)  
iu_us_def_topstage_id, 
 iud_stagedef_brief_f(iu_urok_prc.topstage, 'ru_ru') 
iu_us_def_topstage 
, b2g(iu_urok_prc.instanceid) instanceid 
, iu_urok_prc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_prc.iu_urok_prcid) id 
, 'iu_urok_prc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_prc
 join INSTANCE on iu_urok_prc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_us_def_en_us
go
create view v_autoiu_us_def_en_us as 
select   b2g(iu_urok_prc. iu_urok_prcid) iu_urok_prcid,iu_urok_prc. changestamp changestamp
, 
 b2g(iu_urok_prc.theprocess)  
iu_us_def_theprocess_id, 
 iu_urok_def_brief_f(iu_urok_prc.theprocess, 'en_us') 
iu_us_def_theprocess 
, 
 iu_urok_prc.isdone  
iu_us_def_isdone_val, 
 case iu_urok_prc.isdone 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_us_def_isdone 
, 
 b2g(iu_urok_prc.iu_urok_stage)  
iu_us_def_iu_urok_stage_id, 
 iu_status_brief_f(iu_urok_prc.iu_urok_stage, 'en_us') 
iu_us_def_iu_urok_stage 
, 
 b2g(iu_urok_prc.topstage)  
iu_us_def_topstage_id, 
 iud_stagedef_brief_f(iu_urok_prc.topstage, 'en_us') 
iu_us_def_topstage 
, b2g(iu_urok_prc.instanceid) instanceid 
, iu_urok_prc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_prc.iu_urok_prcid) id 
, 'iu_urok_prc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_prc
 join INSTANCE on iu_urok_prc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofolder
go
create view v_autofolder as 
select   b2g(folder. folderid) folderid,folder. changestamp changestamp
, 
folder.name 
folder_name 
, 
 folder.foldertype  
folder_foldertype_val, 
 case folder.foldertype 
when 3 then 'удаленные'
when 1 then 'входящие'
when 9 then 'отложенные'
when 4 then 'журнал'
when 2 then 'исходящие'
when 7 then 'черновики'
when 6 then 'отправленные'
when 8 then 'в работе'
when 5 then 'календарь'
when 10 then 'завершенные'
when 0 then 'cls__'
 else '' 
 end  
folder_foldertype 
, b2g(folder.instanceid) instanceid 
, folder.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(folder.folderid) id 
, 'folder' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Folder
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofolder_ru_ru
go
create view v_autofolder_ru_ru as 
select   b2g(folder. folderid) folderid,folder. changestamp changestamp
, 
folder.name 
folder_name 
, 
 folder.foldertype  
folder_foldertype_val, 
 case folder.foldertype 
when 3 then 'удаленные'
when 1 then 'входящие'
when 9 then 'отложенные'
when 4 then 'журнал'
when 2 then 'исходящие'
when 7 then 'черновики'
when 6 then 'отправленные'
when 8 then 'в работе'
when 5 then 'календарь'
when 10 then 'завершенные'
when 0 then 'cls__'
 else '' 
 end  
folder_foldertype 
, b2g(folder.instanceid) instanceid 
, folder.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(folder.folderid) id 
, 'folder' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Folder
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofolder_en_us
go
create view v_autofolder_en_us as 
select   b2g(folder. folderid) folderid,folder. changestamp changestamp
, 
folder.name 
folder_name 
, 
 folder.foldertype  
folder_foldertype_val, 
 case folder.foldertype 
when 3 then 'удаленные'
when 1 then 'входящие'
when 9 then 'отложенные'
when 4 then 'журнал'
when 2 then 'исходящие'
when 7 then 'черновики'
when 6 then 'отправленные'
when 8 then 'в работе'
when 5 then 'календарь'
when 10 then 'завершенные'
when 0 then 'cls__'
 else '' 
 end  
folder_foldertype 
, b2g(folder.instanceid) instanceid 
, folder.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(folder.folderid) id 
, 'folder' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Folder
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoshortcut
go
create view v_autoshortcut as 
select   b2g(shortcut. shortcutid) shortcutid,shortcut. changestamp changestamp, b2g(folderid) folderid
, 
 b2g(shortcut.docitem)  
shortcut_docitem_id, 
 instance_brief_f(shortcut.docitem , null) 
shortcut_docitem 
, 
shortcut.startmode 
shortcut_startmode 
, b2g(folder.instanceid) instanceid 
, folder.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(shortcut.shortcutid) id 
, 'shortcut' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Shortcut
 join Folder on Folder.FolderID=Shortcut.ParentStructRowID 
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoshortcut_ru_ru
go
create view v_autoshortcut_ru_ru as 
select   b2g(shortcut. shortcutid) shortcutid,shortcut. changestamp changestamp, b2g(folderid) folderid
, 
 b2g(shortcut.docitem)  
shortcut_docitem_id, 
 instance_brief_f(shortcut.docitem, 'ru_ru') 
shortcut_docitem 
, 
shortcut.startmode 
shortcut_startmode 
, b2g(folder.instanceid) instanceid 
, folder.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(shortcut.shortcutid) id 
, 'shortcut' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Shortcut
 join Folder on Folder.FolderID=Shortcut.ParentStructRowID 
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoshortcut_en_us
go
create view v_autoshortcut_en_us as 
select   b2g(shortcut. shortcutid) shortcutid,shortcut. changestamp changestamp, b2g(folderid) folderid
, 
 b2g(shortcut.docitem)  
shortcut_docitem_id, 
 instance_brief_f(shortcut.docitem, 'en_us') 
shortcut_docitem 
, 
shortcut.startmode 
shortcut_startmode 
, b2g(folder.instanceid) instanceid 
, folder.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(shortcut.shortcutid) id 
, 'shortcut' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Shortcut
 join Folder on Folder.FolderID=Shortcut.ParentStructRowID 
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoinfostoredef
go
create view v_autoinfostoredef as 
select   b2g(infostoredef. infostoredefid) infostoredefid,infostoredef. changestamp changestamp
, 
 infostoredef.infostoretype  
infostoredef_infostoretype_val, 
 case infostoredef.infostoretype 
when 2 then 'групповой'
when 0 then ' общий'
when 1 then 'персональный'
 else '' 
 end  
infostoredef_infostoretype 
, 
infostoredef.name 
infostoredef_name 
, 
 b2g(infostoredef.theuser)  
infostoredef_theuser_id, 
 users_brief_f(infostoredef.theuser, null) 
infostoredef_theuser 
, 
 b2g(infostoredef.thegroup)  
infostoredef_thegroup_id, 
 groups_brief_f(infostoredef.thegroup, null) 
infostoredef_thegroup 
, b2g(infostoredef.instanceid) instanceid 
, infostoredef.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(infostoredef.infostoredefid) id 
, 'infostoredef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from InfoStoreDef
 join INSTANCE on InfoStoreDef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoinfostoredef_ru_ru
go
create view v_autoinfostoredef_ru_ru as 
select   b2g(infostoredef. infostoredefid) infostoredefid,infostoredef. changestamp changestamp
, 
 infostoredef.infostoretype  
infostoredef_infostoretype_val, 
 case infostoredef.infostoretype 
when 2 then 'групповой'
when 0 then ' общий'
when 1 then 'персональный'
 else '' 
 end  
infostoredef_infostoretype 
, 
infostoredef.name 
infostoredef_name 
, 
 b2g(infostoredef.theuser)  
infostoredef_theuser_id, 
 users_brief_f(infostoredef.theuser, 'ru_ru') 
infostoredef_theuser 
, 
 b2g(infostoredef.thegroup)  
infostoredef_thegroup_id, 
 groups_brief_f(infostoredef.thegroup, 'ru_ru') 
infostoredef_thegroup 
, b2g(infostoredef.instanceid) instanceid 
, infostoredef.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(infostoredef.infostoredefid) id 
, 'infostoredef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from InfoStoreDef
 join INSTANCE on InfoStoreDef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoinfostoredef_en_us
go
create view v_autoinfostoredef_en_us as 
select   b2g(infostoredef. infostoredefid) infostoredefid,infostoredef. changestamp changestamp
, 
 infostoredef.infostoretype  
infostoredef_infostoretype_val, 
 case infostoredef.infostoretype 
when 2 then 'групповой'
when 0 then ' общий'
when 1 then 'персональный'
 else '' 
 end  
infostoredef_infostoretype 
, 
infostoredef.name 
infostoredef_name 
, 
 b2g(infostoredef.theuser)  
infostoredef_theuser_id, 
 users_brief_f(infostoredef.theuser, 'en_us') 
infostoredef_theuser 
, 
 b2g(infostoredef.thegroup)  
infostoredef_thegroup_id, 
 groups_brief_f(infostoredef.thegroup, 'en_us') 
infostoredef_thegroup 
, b2g(infostoredef.instanceid) instanceid 
, infostoredef.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(infostoredef.infostoredefid) id 
, 'infostoredef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from InfoStoreDef
 join INSTANCE on InfoStoreDef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_rt_def
go
create view v_autoiud_rt_def as 
select   b2g(iud_rt_def. iud_rt_defid) iud_rt_defid,iud_rt_def. changestamp changestamp
, 
iud_rt_def.name 
iud_rt_def_name 
, b2g(iud_rt_def.instanceid) instanceid 
, iud_rt_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_rt_def.iud_rt_defid) id 
, 'iud_rt_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_rt_def
 join INSTANCE on iud_rt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_rt_def_ru_ru
go
create view v_autoiud_rt_def_ru_ru as 
select   b2g(iud_rt_def. iud_rt_defid) iud_rt_defid,iud_rt_def. changestamp changestamp
, 
iud_rt_def.name 
iud_rt_def_name 
, b2g(iud_rt_def.instanceid) instanceid 
, iud_rt_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_rt_def.iud_rt_defid) id 
, 'iud_rt_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_rt_def
 join INSTANCE on iud_rt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_rt_def_en_us
go
create view v_autoiud_rt_def_en_us as 
select   b2g(iud_rt_def. iud_rt_defid) iud_rt_defid,iud_rt_def. changestamp changestamp
, 
iud_rt_def.name 
iud_rt_def_name 
, b2g(iud_rt_def.instanceid) instanceid 
, iud_rt_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_rt_def.iud_rt_defid) id 
, 'iud_rt_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_rt_def
 join INSTANCE on iud_rt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rt_def
go
create view v_autoiu_rt_def as 
select   b2g(iud_rt_def. iud_rt_defid) iud_rt_defid,iud_rt_def. changestamp changestamp
, 
iud_rt_def.name 
iu_rt_def_name 
, b2g(iud_rt_def.instanceid) instanceid 
, iud_rt_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_rt_def.iud_rt_defid) id 
, 'iud_rt_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_rt_def
 join INSTANCE on iud_rt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rt_def_ru_ru
go
create view v_autoiu_rt_def_ru_ru as 
select   b2g(iud_rt_def. iud_rt_defid) iud_rt_defid,iud_rt_def. changestamp changestamp
, 
iud_rt_def.name 
iu_rt_def_name 
, b2g(iud_rt_def.instanceid) instanceid 
, iud_rt_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_rt_def.iud_rt_defid) id 
, 'iud_rt_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_rt_def
 join INSTANCE on iud_rt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rt_def_en_us
go
create view v_autoiu_rt_def_en_us as 
select   b2g(iud_rt_def. iud_rt_defid) iud_rt_defid,iud_rt_def. changestamp changestamp
, 
iud_rt_def.name 
iu_rt_def_name 
, b2g(iud_rt_def.instanceid) instanceid 
, iud_rt_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_rt_def.iud_rt_defid) id 
, 'iud_rt_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_rt_def
 join INSTANCE on iud_rt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autothe_session
go
create view v_autothe_session as 
select   b2g(the_session. the_sessionid) the_sessionid,the_session. changestamp changestamp
, 
 the_session.closed  
the_session_closed_val, 
 case the_session.closed 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
the_session_closed 
, 
the_session.startat 
the_session_startat 
, 
the_session.closedat 
the_session_closedat 
, 
the_session.lang 
the_session_lang 
, 
 b2g(the_session.userrole)  
the_session_userrole_id, 
 groups_brief_f(the_session.userrole, null) 
the_session_userrole 
, 
the_session.lastaccess 
the_session_lastaccess 
, 
the_session.login 
the_session_login 
, 
 b2g(the_session.usersid)  
the_session_usersid_id, 
 users_brief_f(the_session.usersid, null) 
the_session_usersid 
, 
 b2g(the_session.applicationid)  
the_session_applicationid_id, 
 workplace_brief_f(the_session.applicationid, null) 
the_session_applicationid 
, b2g(the_session.instanceid) instanceid 
, the_session.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(the_session.the_sessionid) id 
, 'the_session' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from the_Session
 join INSTANCE on the_Session.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autothe_session_ru_ru
go
create view v_autothe_session_ru_ru as 
select   b2g(the_session. the_sessionid) the_sessionid,the_session. changestamp changestamp
, 
 the_session.closed  
the_session_closed_val, 
 case the_session.closed 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
the_session_closed 
, 
the_session.startat 
the_session_startat 
, 
the_session.closedat 
the_session_closedat 
, 
the_session.lang 
the_session_lang 
, 
 b2g(the_session.userrole)  
the_session_userrole_id, 
 groups_brief_f(the_session.userrole, 'ru_ru') 
the_session_userrole 
, 
the_session.lastaccess 
the_session_lastaccess 
, 
the_session.login 
the_session_login 
, 
 b2g(the_session.usersid)  
the_session_usersid_id, 
 users_brief_f(the_session.usersid, 'ru_ru') 
the_session_usersid 
, 
 b2g(the_session.applicationid)  
the_session_applicationid_id, 
 workplace_brief_f(the_session.applicationid, 'ru_ru') 
the_session_applicationid 
, b2g(the_session.instanceid) instanceid 
, the_session.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(the_session.the_sessionid) id 
, 'the_session' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from the_Session
 join INSTANCE on the_Session.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autothe_session_en_us
go
create view v_autothe_session_en_us as 
select   b2g(the_session. the_sessionid) the_sessionid,the_session. changestamp changestamp
, 
 the_session.closed  
the_session_closed_val, 
 case the_session.closed 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
the_session_closed 
, 
the_session.startat 
the_session_startat 
, 
the_session.closedat 
the_session_closedat 
, 
the_session.lang 
the_session_lang 
, 
 b2g(the_session.userrole)  
the_session_userrole_id, 
 groups_brief_f(the_session.userrole, 'en_us') 
the_session_userrole 
, 
the_session.lastaccess 
the_session_lastaccess 
, 
the_session.login 
the_session_login 
, 
 b2g(the_session.usersid)  
the_session_usersid_id, 
 users_brief_f(the_session.usersid, 'en_us') 
the_session_usersid 
, 
 b2g(the_session.applicationid)  
the_session_applicationid_id, 
 workplace_brief_f(the_session.applicationid, 'en_us') 
the_session_applicationid 
, b2g(the_session.instanceid) instanceid 
, the_session.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(the_session.the_sessionid) id 
, 'the_session' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from the_Session
 join INSTANCE on the_Session.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autosysrefcache
go
create view v_autosysrefcache as 
select   b2g(sysrefcache. sysrefcacheid) sysrefcacheid,sysrefcache. changestamp changestamp
, 
sysrefcache.modulename 
sysrefcache_modulename 
, 
 sysrefcache.cachetype  
sysrefcache_cachetype_val, 
 case sysrefcache.cachetype 
when 2 then 'все'
when 0 then 'только свои'
when 1 then 'подчиненные'
 else '' 
 end  
sysrefcache_cachetype 
, 
sysrefcache.objectownerid 
sysrefcache_objectownerid 
, 
 b2g(sysrefcache.sessionid)  
sysrefcache_sessionid_id, 
 the_session_brief_f(sysrefcache.sessionid, null) 
sysrefcache_sessionid 
, b2g(sysrefcache.instanceid) instanceid 
, sysrefcache.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(sysrefcache.sysrefcacheid) id 
, 'sysrefcache' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SysRefCache
 join INSTANCE on SysRefCache.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autosysrefcache_ru_ru
go
create view v_autosysrefcache_ru_ru as 
select   b2g(sysrefcache. sysrefcacheid) sysrefcacheid,sysrefcache. changestamp changestamp
, 
sysrefcache.modulename 
sysrefcache_modulename 
, 
 sysrefcache.cachetype  
sysrefcache_cachetype_val, 
 case sysrefcache.cachetype 
when 2 then 'все'
when 0 then 'только свои'
when 1 then 'подчиненные'
 else '' 
 end  
sysrefcache_cachetype 
, 
sysrefcache.objectownerid 
sysrefcache_objectownerid 
, 
 b2g(sysrefcache.sessionid)  
sysrefcache_sessionid_id, 
 the_session_brief_f(sysrefcache.sessionid, 'ru_ru') 
sysrefcache_sessionid 
, b2g(sysrefcache.instanceid) instanceid 
, sysrefcache.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(sysrefcache.sysrefcacheid) id 
, 'sysrefcache' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SysRefCache
 join INSTANCE on SysRefCache.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autosysrefcache_en_us
go
create view v_autosysrefcache_en_us as 
select   b2g(sysrefcache. sysrefcacheid) sysrefcacheid,sysrefcache. changestamp changestamp
, 
sysrefcache.modulename 
sysrefcache_modulename 
, 
 sysrefcache.cachetype  
sysrefcache_cachetype_val, 
 case sysrefcache.cachetype 
when 2 then 'все'
when 0 then 'только свои'
when 1 then 'подчиненные'
 else '' 
 end  
sysrefcache_cachetype 
, 
sysrefcache.objectownerid 
sysrefcache_objectownerid 
, 
 b2g(sysrefcache.sessionid)  
sysrefcache_sessionid_id, 
 the_session_brief_f(sysrefcache.sessionid, 'en_us') 
sysrefcache_sessionid 
, b2g(sysrefcache.instanceid) instanceid 
, sysrefcache.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(sysrefcache.sysrefcacheid) id 
, 'sysrefcache' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SysRefCache
 join INSTANCE on SysRefCache.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autosyslog
go
create view v_autosyslog as 
select   b2g(syslog. syslogid) syslogid,syslog. changestamp changestamp
, 
 b2g(syslog.thesession)  
syslog_thesession_id, 
 the_session_brief_f(syslog.thesession, null) 
syslog_thesession 
, 
syslog.loginstanceid 
syslog_loginstanceid 
, 
syslog.the_resource 
syslog_the_resource 
, 
syslog.verb 
syslog_verb 
, 
syslog.logstructid 
syslog_logstructid 
, b2g(syslog.instanceid) instanceid 
, syslog.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(syslog.syslogid) id 
, 'syslog' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SysLog
 join INSTANCE on SysLog.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autosyslog_ru_ru
go
create view v_autosyslog_ru_ru as 
select   b2g(syslog. syslogid) syslogid,syslog. changestamp changestamp
, 
 b2g(syslog.thesession)  
syslog_thesession_id, 
 the_session_brief_f(syslog.thesession, 'ru_ru') 
syslog_thesession 
, 
syslog.loginstanceid 
syslog_loginstanceid 
, 
syslog.the_resource 
syslog_the_resource 
, 
syslog.verb 
syslog_verb 
, 
syslog.logstructid 
syslog_logstructid 
, b2g(syslog.instanceid) instanceid 
, syslog.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(syslog.syslogid) id 
, 'syslog' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SysLog
 join INSTANCE on SysLog.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autosyslog_en_us
go
create view v_autosyslog_en_us as 
select   b2g(syslog. syslogid) syslogid,syslog. changestamp changestamp
, 
 b2g(syslog.thesession)  
syslog_thesession_id, 
 the_session_brief_f(syslog.thesession, 'en_us') 
syslog_thesession 
, 
syslog.loginstanceid 
syslog_loginstanceid 
, 
syslog.the_resource 
syslog_the_resource 
, 
syslog.verb 
syslog_verb 
, 
syslog.logstructid 
syslog_logstructid 
, b2g(syslog.instanceid) instanceid 
, syslog.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(syslog.syslogid) id 
, 'syslog' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from SysLog
 join INSTANCE on SysLog.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjournal
go
create view v_autoarmjournal as 
select   b2g(armjournal. armjournalid) armjournalid,armjournal. changestamp changestamp
, 
 b2g(armjournal.thejournal)  
armjournal_thejournal_id, 
 instance_brief_f(armjournal.thejournal , null) 
armjournal_thejournal 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjournal.armjournalid) id 
, 'armjournal' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJournal
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjournal_ru_ru
go
create view v_autoarmjournal_ru_ru as 
select   b2g(armjournal. armjournalid) armjournalid,armjournal. changestamp changestamp
, 
 b2g(armjournal.thejournal)  
armjournal_thejournal_id, 
 instance_brief_f(armjournal.thejournal, 'ru_ru') 
armjournal_thejournal 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjournal.armjournalid) id 
, 'armjournal' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJournal
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjournal_en_us
go
create view v_autoarmjournal_en_us as 
select   b2g(armjournal. armjournalid) armjournalid,armjournal. changestamp changestamp
, 
 b2g(armjournal.thejournal)  
armjournal_thejournal_id, 
 instance_brief_f(armjournal.thejournal, 'en_us') 
armjournal_thejournal 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjournal.armjournalid) id 
, 'armjournal' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJournal
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjrnlrep
go
create view v_autoarmjrnlrep as 
select   b2g(armjrnlrep. armjrnlrepid) armjrnlrepid,armjrnlrep. changestamp changestamp, b2g(armjournalid) armjournalid
, 
 b2g(armjrnlrep.thereport)  
armjrnlrep_thereport_id, 
 instance_brief_f(armjrnlrep.thereport , null) 
armjrnlrep_thereport 
, 
armjrnlrep.repname 
armjrnlrep_repname 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjrnlrep.armjrnlrepid) id 
, 'armjrnlrep' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJRNLREP
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLREP.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjrnlrep_ru_ru
go
create view v_autoarmjrnlrep_ru_ru as 
select   b2g(armjrnlrep. armjrnlrepid) armjrnlrepid,armjrnlrep. changestamp changestamp, b2g(armjournalid) armjournalid
, 
 b2g(armjrnlrep.thereport)  
armjrnlrep_thereport_id, 
 instance_brief_f(armjrnlrep.thereport, 'ru_ru') 
armjrnlrep_thereport 
, 
armjrnlrep.repname 
armjrnlrep_repname 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjrnlrep.armjrnlrepid) id 
, 'armjrnlrep' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJRNLREP
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLREP.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjrnlrep_en_us
go
create view v_autoarmjrnlrep_en_us as 
select   b2g(armjrnlrep. armjrnlrepid) armjrnlrepid,armjrnlrep. changestamp changestamp, b2g(armjournalid) armjournalid
, 
 b2g(armjrnlrep.thereport)  
armjrnlrep_thereport_id, 
 instance_brief_f(armjrnlrep.thereport, 'en_us') 
armjrnlrep_thereport 
, 
armjrnlrep.repname 
armjrnlrep_repname 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjrnlrep.armjrnlrepid) id 
, 'armjrnlrep' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJRNLREP
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLREP.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjrnlrun
go
create view v_autoarmjrnlrun as 
select   b2g(armjrnlrun. armjrnlrunid) armjrnlrunid,armjrnlrun. changestamp changestamp, b2g(armjournalid) armjournalid
, 
armjrnlrun.name 
armjrnlrun_name 
, 
 b2g(armjrnlrun.theextention)  
armjrnlrun_theextention_id, 
 instance_brief_f(armjrnlrun.theextention , null) 
armjrnlrun_theextention 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjrnlrun.armjrnlrunid) id 
, 'armjrnlrun' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJRNLRUN
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLRUN.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjrnlrun_ru_ru
go
create view v_autoarmjrnlrun_ru_ru as 
select   b2g(armjrnlrun. armjrnlrunid) armjrnlrunid,armjrnlrun. changestamp changestamp, b2g(armjournalid) armjournalid
, 
armjrnlrun.name 
armjrnlrun_name 
, 
 b2g(armjrnlrun.theextention)  
armjrnlrun_theextention_id, 
 instance_brief_f(armjrnlrun.theextention, 'ru_ru') 
armjrnlrun_theextention 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjrnlrun.armjrnlrunid) id 
, 'armjrnlrun' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJRNLRUN
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLRUN.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjrnlrun_en_us
go
create view v_autoarmjrnlrun_en_us as 
select   b2g(armjrnlrun. armjrnlrunid) armjrnlrunid,armjrnlrun. changestamp changestamp, b2g(armjournalid) armjournalid
, 
armjrnlrun.name 
armjrnlrun_name 
, 
 b2g(armjrnlrun.theextention)  
armjrnlrun_theextention_id, 
 instance_brief_f(armjrnlrun.theextention, 'en_us') 
armjrnlrun_theextention 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjrnlrun.armjrnlrunid) id 
, 'armjrnlrun' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJRNLRUN
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLRUN.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjrnladd
go
create view v_autoarmjrnladd as 
select   b2g(armjrnladd. armjrnladdid) armjrnladdid,armjrnladd. changestamp changestamp, b2g(armjournalid) armjournalid
, 
armjrnladd.name 
armjrnladd_name 
, 
 b2g(armjrnladd.theextention)  
armjrnladd_theextention_id, 
 instance_brief_f(armjrnladd.theextention , null) 
armjrnladd_theextention 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjrnladd.armjrnladdid) id 
, 'armjrnladd' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJRNLADD
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLADD.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjrnladd_ru_ru
go
create view v_autoarmjrnladd_ru_ru as 
select   b2g(armjrnladd. armjrnladdid) armjrnladdid,armjrnladd. changestamp changestamp, b2g(armjournalid) armjournalid
, 
armjrnladd.name 
armjrnladd_name 
, 
 b2g(armjrnladd.theextention)  
armjrnladd_theextention_id, 
 instance_brief_f(armjrnladd.theextention, 'ru_ru') 
armjrnladd_theextention 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjrnladd.armjrnladdid) id 
, 'armjrnladd' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJRNLADD
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLADD.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmjrnladd_en_us
go
create view v_autoarmjrnladd_en_us as 
select   b2g(armjrnladd. armjrnladdid) armjrnladdid,armjrnladd. changestamp changestamp, b2g(armjournalid) armjournalid
, 
armjrnladd.name 
armjrnladd_name 
, 
 b2g(armjrnladd.theextention)  
armjrnladd_theextention_id, 
 instance_brief_f(armjrnladd.theextention, 'en_us') 
armjrnladd_theextention 
, b2g(armjournal.instanceid) instanceid 
, armjournal.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armjrnladd.armjrnladdid) id 
, 'armjrnladd' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMJRNLADD
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLADD.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoentrypoints
go
create view v_autoentrypoints as 
select   b2g(entrypoints. entrypointsid) entrypointsid,entrypoints. changestamp changestamp
, 
entrypoints.journalfixedquery 
entrypoints_journalfixedquery 
, 
 entrypoints.allowdel  
entrypoints_allowdel_val, 
 case entrypoints.allowdel 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowdel 
, 
entrypoints.iconfile 
entrypoints_iconfile 
, 
entrypoints.caption 
entrypoints_caption 
, 
 b2g(entrypoints.method)  
entrypoints_method_id, 
 sharedmethod_brief_f(entrypoints.method, null) 
entrypoints_method 
, 
 entrypoints.allowadd  
entrypoints_allowadd_val, 
 case entrypoints.allowadd 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowadd 
, 
 b2g(entrypoints.document)  
entrypoints_document_id, 
 instance_brief_f(entrypoints.document , null) 
entrypoints_document 
, 
 entrypoints.allowedit  
entrypoints_allowedit_val, 
 case entrypoints.allowedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowedit 
, 
 entrypoints.allowfilter  
entrypoints_allowfilter_val, 
 case entrypoints.allowfilter 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowfilter 
, 
 entrypoints.allowprint  
entrypoints_allowprint_val, 
 case entrypoints.allowprint 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowprint 
, 
 b2g(entrypoints.journal)  
entrypoints_journal_id, 
 instance_brief_f(entrypoints.journal , null) 
entrypoints_journal 
, 
 entrypoints.actiontype  
entrypoints_actiontype_val, 
 case entrypoints.actiontype 
when 4 then 'запустить арм'
when 2 then 'выполнить метод'
when 5 then 'открыть отчет'
when 0 then 'ничего не делать'
when 1 then 'открыть документ'
when 3 then 'открыть журнал'
 else '' 
 end  
entrypoints_actiontype 
, 
entrypoints.thecomment 
entrypoints_thecomment 
, 
 b2g(entrypoints.theextention)  
entrypoints_theextention_id, 
 instance_brief_f(entrypoints.theextention , null) 
entrypoints_theextention 
, 
entrypoints.name 
entrypoints_name 
, 
 entrypoints.astoolbaritem  
entrypoints_astoolbaritem_val, 
 case entrypoints.astoolbaritem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_astoolbaritem 
, 
entrypoints.sequence 
entrypoints_sequence 
, 
 b2g(entrypoints.arm)  
entrypoints_arm_id, 
 instance_brief_f(entrypoints.arm , null) 
entrypoints_arm 
, 
 b2g(entrypoints.report)  
entrypoints_report_id, 
 instance_brief_f(entrypoints.report , null) 
entrypoints_report 
, 
 b2g(entrypoints.objecttype)  
entrypoints_objecttype_id, 
 objecttype_brief_f(entrypoints.objecttype, null) 
entrypoints_objecttype 
, 
 b2g(entrypoints.thefilter)  
entrypoints_thefilter_id, 
 instance_brief_f(entrypoints.thefilter , null) 
entrypoints_thefilter 
, b2g(entrypoints.instanceid) instanceid 
, entrypoints.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(entrypoints.entrypointsid) id 
, 'entrypoints' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from EntryPoints
 join INSTANCE on EntryPoints.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoentrypoints_ru_ru
go
create view v_autoentrypoints_ru_ru as 
select   b2g(entrypoints. entrypointsid) entrypointsid,entrypoints. changestamp changestamp
, 
entrypoints.journalfixedquery 
entrypoints_journalfixedquery 
, 
 entrypoints.allowdel  
entrypoints_allowdel_val, 
 case entrypoints.allowdel 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowdel 
, 
entrypoints.iconfile 
entrypoints_iconfile 
, 
entrypoints.caption 
entrypoints_caption 
, 
 b2g(entrypoints.method)  
entrypoints_method_id, 
 sharedmethod_brief_f(entrypoints.method, 'ru_ru') 
entrypoints_method 
, 
 entrypoints.allowadd  
entrypoints_allowadd_val, 
 case entrypoints.allowadd 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowadd 
, 
 b2g(entrypoints.document)  
entrypoints_document_id, 
 instance_brief_f(entrypoints.document, 'ru_ru') 
entrypoints_document 
, 
 entrypoints.allowedit  
entrypoints_allowedit_val, 
 case entrypoints.allowedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowedit 
, 
 entrypoints.allowfilter  
entrypoints_allowfilter_val, 
 case entrypoints.allowfilter 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowfilter 
, 
 entrypoints.allowprint  
entrypoints_allowprint_val, 
 case entrypoints.allowprint 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowprint 
, 
 b2g(entrypoints.journal)  
entrypoints_journal_id, 
 instance_brief_f(entrypoints.journal, 'ru_ru') 
entrypoints_journal 
, 
 entrypoints.actiontype  
entrypoints_actiontype_val, 
 case entrypoints.actiontype 
when 4 then 'запустить арм'
when 2 then 'выполнить метод'
when 5 then 'открыть отчет'
when 0 then 'ничего не делать'
when 1 then 'открыть документ'
when 3 then 'открыть журнал'
 else '' 
 end  
entrypoints_actiontype 
, 
entrypoints.thecomment 
entrypoints_thecomment 
, 
 b2g(entrypoints.theextention)  
entrypoints_theextention_id, 
 instance_brief_f(entrypoints.theextention, 'ru_ru') 
entrypoints_theextention 
, 
entrypoints.name 
entrypoints_name 
, 
 entrypoints.astoolbaritem  
entrypoints_astoolbaritem_val, 
 case entrypoints.astoolbaritem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_astoolbaritem 
, 
entrypoints.sequence 
entrypoints_sequence 
, 
 b2g(entrypoints.arm)  
entrypoints_arm_id, 
 instance_brief_f(entrypoints.arm, 'ru_ru') 
entrypoints_arm 
, 
 b2g(entrypoints.report)  
entrypoints_report_id, 
 instance_brief_f(entrypoints.report, 'ru_ru') 
entrypoints_report 
, 
 b2g(entrypoints.objecttype)  
entrypoints_objecttype_id, 
 objecttype_brief_f(entrypoints.objecttype, 'ru_ru') 
entrypoints_objecttype 
, 
 b2g(entrypoints.thefilter)  
entrypoints_thefilter_id, 
 instance_brief_f(entrypoints.thefilter, 'ru_ru') 
entrypoints_thefilter 
, b2g(entrypoints.instanceid) instanceid 
, entrypoints.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(entrypoints.entrypointsid) id 
, 'entrypoints' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from EntryPoints
 join INSTANCE on EntryPoints.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoentrypoints_en_us
go
create view v_autoentrypoints_en_us as 
select   b2g(entrypoints. entrypointsid) entrypointsid,entrypoints. changestamp changestamp
, 
entrypoints.journalfixedquery 
entrypoints_journalfixedquery 
, 
 entrypoints.allowdel  
entrypoints_allowdel_val, 
 case entrypoints.allowdel 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowdel 
, 
entrypoints.iconfile 
entrypoints_iconfile 
, 
entrypoints.caption 
entrypoints_caption 
, 
 b2g(entrypoints.method)  
entrypoints_method_id, 
 sharedmethod_brief_f(entrypoints.method, 'en_us') 
entrypoints_method 
, 
 entrypoints.allowadd  
entrypoints_allowadd_val, 
 case entrypoints.allowadd 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowadd 
, 
 b2g(entrypoints.document)  
entrypoints_document_id, 
 instance_brief_f(entrypoints.document, 'en_us') 
entrypoints_document 
, 
 entrypoints.allowedit  
entrypoints_allowedit_val, 
 case entrypoints.allowedit 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowedit 
, 
 entrypoints.allowfilter  
entrypoints_allowfilter_val, 
 case entrypoints.allowfilter 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowfilter 
, 
 entrypoints.allowprint  
entrypoints_allowprint_val, 
 case entrypoints.allowprint 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_allowprint 
, 
 b2g(entrypoints.journal)  
entrypoints_journal_id, 
 instance_brief_f(entrypoints.journal, 'en_us') 
entrypoints_journal 
, 
 entrypoints.actiontype  
entrypoints_actiontype_val, 
 case entrypoints.actiontype 
when 4 then 'запустить арм'
when 2 then 'выполнить метод'
when 5 then 'открыть отчет'
when 0 then 'ничего не делать'
when 1 then 'открыть документ'
when 3 then 'открыть журнал'
 else '' 
 end  
entrypoints_actiontype 
, 
entrypoints.thecomment 
entrypoints_thecomment 
, 
 b2g(entrypoints.theextention)  
entrypoints_theextention_id, 
 instance_brief_f(entrypoints.theextention, 'en_us') 
entrypoints_theextention 
, 
entrypoints.name 
entrypoints_name 
, 
 entrypoints.astoolbaritem  
entrypoints_astoolbaritem_val, 
 case entrypoints.astoolbaritem 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
entrypoints_astoolbaritem 
, 
entrypoints.sequence 
entrypoints_sequence 
, 
 b2g(entrypoints.arm)  
entrypoints_arm_id, 
 instance_brief_f(entrypoints.arm, 'en_us') 
entrypoints_arm 
, 
 b2g(entrypoints.report)  
entrypoints_report_id, 
 instance_brief_f(entrypoints.report, 'en_us') 
entrypoints_report 
, 
 b2g(entrypoints.objecttype)  
entrypoints_objecttype_id, 
 objecttype_brief_f(entrypoints.objecttype, 'en_us') 
entrypoints_objecttype 
, 
 b2g(entrypoints.thefilter)  
entrypoints_thefilter_id, 
 instance_brief_f(entrypoints.thefilter, 'en_us') 
entrypoints_thefilter 
, b2g(entrypoints.instanceid) instanceid 
, entrypoints.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(entrypoints.entrypointsid) id 
, 'entrypoints' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from EntryPoints
 join INSTANCE on EntryPoints.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoepfilterlink
go
create view v_autoepfilterlink as 
select   b2g(epfilterlink. epfilterlinkid) epfilterlinkid,epfilterlink. changestamp changestamp, b2g(entrypointsid) entrypointsid
, 
epfilterlink.rowsource 
epfilterlink_rowsource 
, 
epfilterlink.filterfield 
epfilterlink_filterfield 
, 
epfilterlink.theexpression 
epfilterlink_theexpression 
, b2g(entrypoints.instanceid) instanceid 
, entrypoints.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(epfilterlink.epfilterlinkid) id 
, 'epfilterlink' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from EPFilterLink
 join EntryPoints on EntryPoints.EntryPointsID=EPFilterLink.ParentStructRowID 
 join INSTANCE on EntryPoints.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoepfilterlink_ru_ru
go
create view v_autoepfilterlink_ru_ru as 
select   b2g(epfilterlink. epfilterlinkid) epfilterlinkid,epfilterlink. changestamp changestamp, b2g(entrypointsid) entrypointsid
, 
epfilterlink.rowsource 
epfilterlink_rowsource 
, 
epfilterlink.filterfield 
epfilterlink_filterfield 
, 
epfilterlink.theexpression 
epfilterlink_theexpression 
, b2g(entrypoints.instanceid) instanceid 
, entrypoints.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(epfilterlink.epfilterlinkid) id 
, 'epfilterlink' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from EPFilterLink
 join EntryPoints on EntryPoints.EntryPointsID=EPFilterLink.ParentStructRowID 
 join INSTANCE on EntryPoints.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoepfilterlink_en_us
go
create view v_autoepfilterlink_en_us as 
select   b2g(epfilterlink. epfilterlinkid) epfilterlinkid,epfilterlink. changestamp changestamp, b2g(entrypointsid) entrypointsid
, 
epfilterlink.rowsource 
epfilterlink_rowsource 
, 
epfilterlink.filterfield 
epfilterlink_filterfield 
, 
epfilterlink.theexpression 
epfilterlink_theexpression 
, b2g(entrypoints.instanceid) instanceid 
, entrypoints.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(epfilterlink.epfilterlinkid) id 
, 'epfilterlink' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from EPFilterLink
 join EntryPoints on EntryPoints.EntryPointsID=EPFilterLink.ParentStructRowID 
 join INSTANCE on EntryPoints.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoworkplace
go
create view v_autoworkplace as 
select   b2g(workplace. workplaceid) workplaceid,workplace. changestamp changestamp
, 
 workplace.theplatform  
workplace_theplatform_val, 
 case workplace.theplatform 
when 3 then 'other'
when 1 then 'dotnet'
when 2 then 'java'
when 0 then 'vb6'
 else '' 
 end  
workplace_theplatform 
, 
workplace.thecomment 
workplace_thecomment 
, 
workplace.caption 
workplace_caption 
, 
workplace.theversion 
workplace_theversion 
, 
workplace.name 
workplace_name 
, b2g(workplace.instanceid) instanceid 
, workplace.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(workplace.workplaceid) id 
, 'workplace' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from WorkPlace
 join INSTANCE on WorkPlace.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoworkplace_ru_ru
go
create view v_autoworkplace_ru_ru as 
select   b2g(workplace. workplaceid) workplaceid,workplace. changestamp changestamp
, 
 workplace.theplatform  
workplace_theplatform_val, 
 case workplace.theplatform 
when 3 then 'other'
when 1 then 'dotnet'
when 2 then 'java'
when 0 then 'vb6'
 else '' 
 end  
workplace_theplatform 
, 
workplace.thecomment 
workplace_thecomment 
, 
workplace.caption 
workplace_caption 
, 
workplace.theversion 
workplace_theversion 
, 
workplace.name 
workplace_name 
, b2g(workplace.instanceid) instanceid 
, workplace.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(workplace.workplaceid) id 
, 'workplace' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from WorkPlace
 join INSTANCE on WorkPlace.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoworkplace_en_us
go
create view v_autoworkplace_en_us as 
select   b2g(workplace. workplaceid) workplaceid,workplace. changestamp changestamp
, 
 workplace.theplatform  
workplace_theplatform_val, 
 case workplace.theplatform 
when 3 then 'other'
when 1 then 'dotnet'
when 2 then 'java'
when 0 then 'vb6'
 else '' 
 end  
workplace_theplatform 
, 
workplace.thecomment 
workplace_thecomment 
, 
workplace.caption 
workplace_caption 
, 
workplace.theversion 
workplace_theversion 
, 
workplace.name 
workplace_name 
, b2g(workplace.instanceid) instanceid 
, workplace.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(workplace.workplaceid) id 
, 'workplace' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from WorkPlace
 join INSTANCE on WorkPlace.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmtypes
go
create view v_autoarmtypes as 
select   b2g(armtypes. armtypesid) armtypesid,armtypes. changestamp changestamp
, 
 b2g(armtypes.thedocumenttype)  
armtypes_thedocumenttype_id, 
 objecttype_brief_f(armtypes.thedocumenttype, null) 
armtypes_thedocumenttype 
, b2g(armtypes.instanceid) instanceid 
, armtypes.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armtypes.armtypesid) id 
, 'armtypes' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMTypes
 join INSTANCE on ARMTypes.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmtypes_ru_ru
go
create view v_autoarmtypes_ru_ru as 
select   b2g(armtypes. armtypesid) armtypesid,armtypes. changestamp changestamp
, 
 b2g(armtypes.thedocumenttype)  
armtypes_thedocumenttype_id, 
 objecttype_brief_f(armtypes.thedocumenttype, 'ru_ru') 
armtypes_thedocumenttype 
, b2g(armtypes.instanceid) instanceid 
, armtypes.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armtypes.armtypesid) id 
, 'armtypes' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMTypes
 join INSTANCE on ARMTypes.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoarmtypes_en_us
go
create view v_autoarmtypes_en_us as 
select   b2g(armtypes. armtypesid) armtypesid,armtypes. changestamp changestamp
, 
 b2g(armtypes.thedocumenttype)  
armtypes_thedocumenttype_id, 
 objecttype_brief_f(armtypes.thedocumenttype, 'en_us') 
armtypes_thedocumenttype 
, b2g(armtypes.instanceid) instanceid 
, armtypes.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(armtypes.armtypesid) id 
, 'armtypes' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ARMTypes
 join INSTANCE on ARMTypes.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_crole
go
create view v_autoiu_crole as 
select   b2g(iu_crole. iu_croleid) iu_croleid,iu_crole. changestamp changestamp
, 
iu_crole.name 
iu_crole_name 
, 
 iu_crole.allowsetuser  
iu_crole_allowsetuser_val, 
 case iu_crole.allowsetuser 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_crole_allowsetuser 
, b2g(iu_crole.instanceid) instanceid 
, iu_crole.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_crole.iu_croleid) id 
, 'iu_crole' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_crole
 join INSTANCE on iu_crole.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_crole_ru_ru
go
create view v_autoiu_crole_ru_ru as 
select   b2g(iu_crole. iu_croleid) iu_croleid,iu_crole. changestamp changestamp
, 
iu_crole.name 
iu_crole_name 
, 
 iu_crole.allowsetuser  
iu_crole_allowsetuser_val, 
 case iu_crole.allowsetuser 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_crole_allowsetuser 
, b2g(iu_crole.instanceid) instanceid 
, iu_crole.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_crole.iu_croleid) id 
, 'iu_crole' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_crole
 join INSTANCE on iu_crole.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_crole_en_us
go
create view v_autoiu_crole_en_us as 
select   b2g(iu_crole. iu_croleid) iu_croleid,iu_crole. changestamp changestamp
, 
iu_crole.name 
iu_crole_name 
, 
 iu_crole.allowsetuser  
iu_crole_allowsetuser_val, 
 case iu_crole.allowsetuser 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_crole_allowsetuser 
, b2g(iu_crole.instanceid) instanceid 
, iu_crole.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_crole.iu_croleid) id 
, 'iu_crole' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_crole
 join INSTANCE on iu_crole.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_operations
go
create view v_autoroles_operations as 
select   b2g(roles_operations. roles_operationsid) roles_operationsid,roles_operations. changestamp changestamp
, 
roles_operations.info 
roles_operations_info 
, 
 roles_operations.allowaction  
roles_operations_allowaction_val, 
 case roles_operations.allowaction 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_operations_allowaction 
, 
roles_operations.name 
roles_operations_name 
, b2g(roles_operations.instanceid) instanceid 
, roles_operations.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_operations.roles_operationsid) id 
, 'roles_operations' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_OPERATIONS
 join INSTANCE on ROLES_OPERATIONS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_operations_ru_ru
go
create view v_autoroles_operations_ru_ru as 
select   b2g(roles_operations. roles_operationsid) roles_operationsid,roles_operations. changestamp changestamp
, 
roles_operations.info 
roles_operations_info 
, 
 roles_operations.allowaction  
roles_operations_allowaction_val, 
 case roles_operations.allowaction 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_operations_allowaction 
, 
roles_operations.name 
roles_operations_name 
, b2g(roles_operations.instanceid) instanceid 
, roles_operations.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_operations.roles_operationsid) id 
, 'roles_operations' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_OPERATIONS
 join INSTANCE on ROLES_OPERATIONS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_operations_en_us
go
create view v_autoroles_operations_en_us as 
select   b2g(roles_operations. roles_operationsid) roles_operationsid,roles_operations. changestamp changestamp
, 
roles_operations.info 
roles_operations_info 
, 
 roles_operations.allowaction  
roles_operations_allowaction_val, 
 case roles_operations.allowaction 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_operations_allowaction 
, 
roles_operations.name 
roles_operations_name 
, b2g(roles_operations.instanceid) instanceid 
, roles_operations.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_operations.roles_operationsid) id 
, 'roles_operations' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_OPERATIONS
 join INSTANCE on ROLES_OPERATIONS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_wp
go
create view v_autoroles_wp as 
select   b2g(roles_wp. roles_wpid) roles_wpid,roles_wp. changestamp changestamp
, 
 b2g(roles_wp.wp)  
roles_wp_wp_id, 
 workplace_brief_f(roles_wp.wp, null) 
roles_wp_wp 
, b2g(roles_wp.instanceid) instanceid 
, roles_wp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_wp.roles_wpid) id 
, 'roles_wp' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_WP
 join INSTANCE on ROLES_WP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_wp_ru_ru
go
create view v_autoroles_wp_ru_ru as 
select   b2g(roles_wp. roles_wpid) roles_wpid,roles_wp. changestamp changestamp
, 
 b2g(roles_wp.wp)  
roles_wp_wp_id, 
 workplace_brief_f(roles_wp.wp, 'ru_ru') 
roles_wp_wp 
, b2g(roles_wp.instanceid) instanceid 
, roles_wp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_wp.roles_wpid) id 
, 'roles_wp' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_WP
 join INSTANCE on ROLES_WP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_wp_en_us
go
create view v_autoroles_wp_en_us as 
select   b2g(roles_wp. roles_wpid) roles_wpid,roles_wp. changestamp changestamp
, 
 b2g(roles_wp.wp)  
roles_wp_wp_id, 
 workplace_brief_f(roles_wp.wp, 'en_us') 
roles_wp_wp 
, b2g(roles_wp.instanceid) instanceid 
, roles_wp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_wp.roles_wpid) id 
, 'roles_wp' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_WP
 join INSTANCE on ROLES_WP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_act
go
create view v_autoroles_act as 
select   b2g(roles_act. roles_actid) roles_actid,roles_act. changestamp changestamp, b2g(roles_wpid) roles_wpid
, 
 roles_act.accesible  
roles_act_accesible_val, 
 case roles_act.accesible 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_act_accesible 
, 
roles_act.menucode 
roles_act_menucode 
, 
roles_act.menuname 
roles_act_menuname 
, b2g(roles_wp.instanceid) instanceid 
, roles_wp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_act.roles_actid) id 
, 'roles_act' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_ACT
 join ROLES_WP on ROLES_WP.ROLES_WPID=ROLES_ACT.ParentStructRowID 
 join INSTANCE on ROLES_WP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_act_ru_ru
go
create view v_autoroles_act_ru_ru as 
select   b2g(roles_act. roles_actid) roles_actid,roles_act. changestamp changestamp, b2g(roles_wpid) roles_wpid
, 
 roles_act.accesible  
roles_act_accesible_val, 
 case roles_act.accesible 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_act_accesible 
, 
roles_act.menucode 
roles_act_menucode 
, 
roles_act.menuname 
roles_act_menuname 
, b2g(roles_wp.instanceid) instanceid 
, roles_wp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_act.roles_actid) id 
, 'roles_act' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_ACT
 join ROLES_WP on ROLES_WP.ROLES_WPID=ROLES_ACT.ParentStructRowID 
 join INSTANCE on ROLES_WP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_act_en_us
go
create view v_autoroles_act_en_us as 
select   b2g(roles_act. roles_actid) roles_actid,roles_act. changestamp changestamp, b2g(roles_wpid) roles_wpid
, 
 roles_act.accesible  
roles_act_accesible_val, 
 case roles_act.accesible 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_act_accesible 
, 
roles_act.menucode 
roles_act_menucode 
, 
roles_act.menuname 
roles_act_menuname 
, b2g(roles_wp.instanceid) instanceid 
, roles_wp.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_act.roles_actid) id 
, 'roles_act' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_ACT
 join ROLES_WP on ROLES_WP.ROLES_WPID=ROLES_ACT.ParentStructRowID 
 join INSTANCE on ROLES_WP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles2_module
go
create view v_autoroles2_module as 
select   b2g(roles2_module. roles2_moduleid) roles2_moduleid,roles2_module. changestamp changestamp
, 
roles2_module.name 
roles2_module_name 
, 
 roles2_module.moduleaccessible  
roles2_module_moduleaccessible_val, 
 case roles2_module.moduleaccessible 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_moduleaccessible 
, 
roles2_module.caption 
roles2_module_caption 
, 
 roles2_module.customizevisibility  
roles2_module_customizevisibility_val, 
 case roles2_module.customizevisibility 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_customizevisibility 
, 
roles2_module.sequence 
roles2_module_sequence 
, 
roles2_module.thecomment 
roles2_module_thecomment 
, 
roles2_module.groupname 
roles2_module_groupname 
, 
 roles2_module.allobjects  
roles2_module_allobjects_val, 
 case roles2_module.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_allobjects 
, 
roles2_module.theicon 
roles2_module_theicon 
, 
 roles2_module.substructobjects  
roles2_module_substructobjects_val, 
 case roles2_module.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_substructobjects 
, 
 roles2_module.colegsobject  
roles2_module_colegsobject_val, 
 case roles2_module.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_colegsobject 
, b2g(roles2_module.instanceid) instanceid 
, roles2_module.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles2_module.roles2_moduleid) id 
, 'roles2_module' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES2_MODULE
 join INSTANCE on ROLES2_MODULE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles2_module_ru_ru
go
create view v_autoroles2_module_ru_ru as 
select   b2g(roles2_module. roles2_moduleid) roles2_moduleid,roles2_module. changestamp changestamp
, 
roles2_module.name 
roles2_module_name 
, 
 roles2_module.moduleaccessible  
roles2_module_moduleaccessible_val, 
 case roles2_module.moduleaccessible 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_moduleaccessible 
, 
roles2_module.caption 
roles2_module_caption 
, 
 roles2_module.customizevisibility  
roles2_module_customizevisibility_val, 
 case roles2_module.customizevisibility 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_customizevisibility 
, 
roles2_module.sequence 
roles2_module_sequence 
, 
roles2_module.thecomment 
roles2_module_thecomment 
, 
roles2_module.groupname 
roles2_module_groupname 
, 
 roles2_module.allobjects  
roles2_module_allobjects_val, 
 case roles2_module.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_allobjects 
, 
roles2_module.theicon 
roles2_module_theicon 
, 
 roles2_module.substructobjects  
roles2_module_substructobjects_val, 
 case roles2_module.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_substructobjects 
, 
 roles2_module.colegsobject  
roles2_module_colegsobject_val, 
 case roles2_module.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_colegsobject 
, b2g(roles2_module.instanceid) instanceid 
, roles2_module.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles2_module.roles2_moduleid) id 
, 'roles2_module' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES2_MODULE
 join INSTANCE on ROLES2_MODULE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles2_module_en_us
go
create view v_autoroles2_module_en_us as 
select   b2g(roles2_module. roles2_moduleid) roles2_moduleid,roles2_module. changestamp changestamp
, 
roles2_module.name 
roles2_module_name 
, 
 roles2_module.moduleaccessible  
roles2_module_moduleaccessible_val, 
 case roles2_module.moduleaccessible 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_moduleaccessible 
, 
roles2_module.caption 
roles2_module_caption 
, 
 roles2_module.customizevisibility  
roles2_module_customizevisibility_val, 
 case roles2_module.customizevisibility 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_customizevisibility 
, 
roles2_module.sequence 
roles2_module_sequence 
, 
roles2_module.thecomment 
roles2_module_thecomment 
, 
roles2_module.groupname 
roles2_module_groupname 
, 
 roles2_module.allobjects  
roles2_module_allobjects_val, 
 case roles2_module.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_allobjects 
, 
roles2_module.theicon 
roles2_module_theicon 
, 
 roles2_module.substructobjects  
roles2_module_substructobjects_val, 
 case roles2_module.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_substructobjects 
, 
 roles2_module.colegsobject  
roles2_module_colegsobject_val, 
 case roles2_module.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_module_colegsobject 
, b2g(roles2_module.instanceid) instanceid 
, roles2_module.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles2_module.roles2_moduleid) id 
, 'roles2_module' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES2_MODULE
 join INSTANCE on ROLES2_MODULE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles2_modreport
go
create view v_autoroles2_modreport as 
select   b2g(roles2_modreport. roles2_modreportid) roles2_modreportid,roles2_modreport. changestamp changestamp, b2g(roles2_moduleid) roles2_moduleid
, 
roles2_modreport.theicon 
roles2_modreport_theicon 
, 
roles2_modreport.name 
roles2_modreport_name 
, 
roles2_modreport.selecttype 
roles2_modreport_selecttype 
, 
 roles2_modreport.isreport  
roles2_modreport_isreport_val, 
 case roles2_modreport.isreport 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_modreport_isreport 
, 
roles2_modreport.sequence 
roles2_modreport_sequence 
, 
 roles2_modreport.allowaction  
roles2_modreport_allowaction_val, 
 case roles2_modreport.allowaction 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_modreport_allowaction 
, 
roles2_modreport.caption 
roles2_modreport_caption 
, b2g(roles2_module.instanceid) instanceid 
, roles2_module.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles2_modreport.roles2_modreportid) id 
, 'roles2_modreport' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES2_MODREPORT
 join ROLES2_MODULE on ROLES2_MODULE.ROLES2_MODULEID=ROLES2_MODREPORT.ParentStructRowID 
 join INSTANCE on ROLES2_MODULE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles2_modreport_ru_ru
go
create view v_autoroles2_modreport_ru_ru as 
select   b2g(roles2_modreport. roles2_modreportid) roles2_modreportid,roles2_modreport. changestamp changestamp, b2g(roles2_moduleid) roles2_moduleid
, 
roles2_modreport.theicon 
roles2_modreport_theicon 
, 
roles2_modreport.name 
roles2_modreport_name 
, 
roles2_modreport.selecttype 
roles2_modreport_selecttype 
, 
 roles2_modreport.isreport  
roles2_modreport_isreport_val, 
 case roles2_modreport.isreport 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_modreport_isreport 
, 
roles2_modreport.sequence 
roles2_modreport_sequence 
, 
 roles2_modreport.allowaction  
roles2_modreport_allowaction_val, 
 case roles2_modreport.allowaction 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_modreport_allowaction 
, 
roles2_modreport.caption 
roles2_modreport_caption 
, b2g(roles2_module.instanceid) instanceid 
, roles2_module.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles2_modreport.roles2_modreportid) id 
, 'roles2_modreport' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES2_MODREPORT
 join ROLES2_MODULE on ROLES2_MODULE.ROLES2_MODULEID=ROLES2_MODREPORT.ParentStructRowID 
 join INSTANCE on ROLES2_MODULE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles2_modreport_en_us
go
create view v_autoroles2_modreport_en_us as 
select   b2g(roles2_modreport. roles2_modreportid) roles2_modreportid,roles2_modreport. changestamp changestamp, b2g(roles2_moduleid) roles2_moduleid
, 
roles2_modreport.theicon 
roles2_modreport_theicon 
, 
roles2_modreport.name 
roles2_modreport_name 
, 
roles2_modreport.selecttype 
roles2_modreport_selecttype 
, 
 roles2_modreport.isreport  
roles2_modreport_isreport_val, 
 case roles2_modreport.isreport 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_modreport_isreport 
, 
roles2_modreport.sequence 
roles2_modreport_sequence 
, 
 roles2_modreport.allowaction  
roles2_modreport_allowaction_val, 
 case roles2_modreport.allowaction 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles2_modreport_allowaction 
, 
roles2_modreport.caption 
roles2_modreport_caption 
, b2g(roles2_module.instanceid) instanceid 
, roles2_module.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles2_modreport.roles2_modreportid) id 
, 'roles2_modreport' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES2_MODREPORT
 join ROLES2_MODULE on ROLES2_MODULE.ROLES2_MODULEID=ROLES2_MODREPORT.ParentStructRowID 
 join INSTANCE on ROLES2_MODULE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_doc
go
create view v_autoroles_doc as 
select   b2g(roles_doc. roles_docid) roles_docid,roles_doc. changestamp changestamp
, 
 b2g(roles_doc.the_document)  
roles_doc_the_document_id, 
 objecttype_brief_f(roles_doc.the_document, null) 
roles_doc_the_document 
, 
 roles_doc.the_denied  
roles_doc_the_denied_val, 
 case roles_doc.the_denied 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_the_denied 
, 
 roles_doc.allowdeletedoc  
roles_doc_allowdeletedoc_val, 
 case roles_doc.allowdeletedoc 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_allowdeletedoc 
, b2g(roles_doc.instanceid) instanceid 
, roles_doc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_doc.roles_docid) id 
, 'roles_doc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_DOC
 join INSTANCE on ROLES_DOC.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_doc_ru_ru
go
create view v_autoroles_doc_ru_ru as 
select   b2g(roles_doc. roles_docid) roles_docid,roles_doc. changestamp changestamp
, 
 b2g(roles_doc.the_document)  
roles_doc_the_document_id, 
 objecttype_brief_f(roles_doc.the_document, 'ru_ru') 
roles_doc_the_document 
, 
 roles_doc.the_denied  
roles_doc_the_denied_val, 
 case roles_doc.the_denied 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_the_denied 
, 
 roles_doc.allowdeletedoc  
roles_doc_allowdeletedoc_val, 
 case roles_doc.allowdeletedoc 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_allowdeletedoc 
, b2g(roles_doc.instanceid) instanceid 
, roles_doc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_doc.roles_docid) id 
, 'roles_doc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_DOC
 join INSTANCE on ROLES_DOC.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_doc_en_us
go
create view v_autoroles_doc_en_us as 
select   b2g(roles_doc. roles_docid) roles_docid,roles_doc. changestamp changestamp
, 
 b2g(roles_doc.the_document)  
roles_doc_the_document_id, 
 objecttype_brief_f(roles_doc.the_document, 'en_us') 
roles_doc_the_document 
, 
 roles_doc.the_denied  
roles_doc_the_denied_val, 
 case roles_doc.the_denied 
when 1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_the_denied 
, 
 roles_doc.allowdeletedoc  
roles_doc_allowdeletedoc_val, 
 case roles_doc.allowdeletedoc 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_allowdeletedoc 
, b2g(roles_doc.instanceid) instanceid 
, roles_doc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_doc.roles_docid) id 
, 'roles_doc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_DOC
 join INSTANCE on ROLES_DOC.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_doc_state
go
create view v_autoroles_doc_state as 
select   b2g(roles_doc_state. roles_doc_stateid) roles_doc_stateid,roles_doc_state. changestamp changestamp, b2g(roles_docid) roles_docid
, 
 b2g(roles_doc_state.the_state)  
roles_doc_state_the_state_id, 
 objstatus_brief_f(roles_doc_state.the_state, null) 
roles_doc_state_the_state 
, 
 roles_doc_state.allowdelete  
roles_doc_state_allowdelete_val, 
 case roles_doc_state.allowdelete 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_state_allowdelete 
, 
 roles_doc_state.statechangedisabled  
roles_doc_state_statechangedisabled_val, 
 case roles_doc_state.statechangedisabled 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_state_statechangedisabled 
, 
 b2g(roles_doc_state.the_mode)  
roles_doc_state_the_mode_id, 
 objectmode_brief_f(roles_doc_state.the_mode, null) 
roles_doc_state_the_mode 
, b2g(roles_doc.instanceid) instanceid 
, roles_doc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_doc_state.roles_doc_stateid) id 
, 'roles_doc_state' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_DOC_STATE
 join ROLES_DOC on ROLES_DOC.ROLES_DOCID=ROLES_DOC_STATE.ParentStructRowID 
 join INSTANCE on ROLES_DOC.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_doc_state_ru_ru
go
create view v_autoroles_doc_state_ru_ru as 
select   b2g(roles_doc_state. roles_doc_stateid) roles_doc_stateid,roles_doc_state. changestamp changestamp, b2g(roles_docid) roles_docid
, 
 b2g(roles_doc_state.the_state)  
roles_doc_state_the_state_id, 
 objstatus_brief_f(roles_doc_state.the_state, 'ru_ru') 
roles_doc_state_the_state 
, 
 roles_doc_state.allowdelete  
roles_doc_state_allowdelete_val, 
 case roles_doc_state.allowdelete 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_state_allowdelete 
, 
 roles_doc_state.statechangedisabled  
roles_doc_state_statechangedisabled_val, 
 case roles_doc_state.statechangedisabled 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_state_statechangedisabled 
, 
 b2g(roles_doc_state.the_mode)  
roles_doc_state_the_mode_id, 
 objectmode_brief_f(roles_doc_state.the_mode, 'ru_ru') 
roles_doc_state_the_mode 
, b2g(roles_doc.instanceid) instanceid 
, roles_doc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_doc_state.roles_doc_stateid) id 
, 'roles_doc_state' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_DOC_STATE
 join ROLES_DOC on ROLES_DOC.ROLES_DOCID=ROLES_DOC_STATE.ParentStructRowID 
 join INSTANCE on ROLES_DOC.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_doc_state_en_us
go
create view v_autoroles_doc_state_en_us as 
select   b2g(roles_doc_state. roles_doc_stateid) roles_doc_stateid,roles_doc_state. changestamp changestamp, b2g(roles_docid) roles_docid
, 
 b2g(roles_doc_state.the_state)  
roles_doc_state_the_state_id, 
 objstatus_brief_f(roles_doc_state.the_state, 'en_us') 
roles_doc_state_the_state 
, 
 roles_doc_state.allowdelete  
roles_doc_state_allowdelete_val, 
 case roles_doc_state.allowdelete 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_state_allowdelete 
, 
 roles_doc_state.statechangedisabled  
roles_doc_state_statechangedisabled_val, 
 case roles_doc_state.statechangedisabled 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_doc_state_statechangedisabled 
, 
 b2g(roles_doc_state.the_mode)  
roles_doc_state_the_mode_id, 
 objectmode_brief_f(roles_doc_state.the_mode, 'en_us') 
roles_doc_state_the_mode 
, b2g(roles_doc.instanceid) instanceid 
, roles_doc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_doc_state.roles_doc_stateid) id 
, 'roles_doc_state' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_DOC_STATE
 join ROLES_DOC on ROLES_DOC.ROLES_DOCID=ROLES_DOC_STATE.ParentStructRowID 
 join INSTANCE on ROLES_DOC.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_reports
go
create view v_autoroles_reports as 
select   b2g(roles_reports. roles_reportsid) roles_reportsid,roles_reports. changestamp changestamp
, 
 b2g(roles_reports.the_report)  
roles_reports_the_report_id, 
 instance_brief_f(roles_reports.the_report , null) 
roles_reports_the_report 
, b2g(roles_reports.instanceid) instanceid 
, roles_reports.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_reports.roles_reportsid) id 
, 'roles_reports' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_REPORTS
 join INSTANCE on ROLES_REPORTS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_reports_ru_ru
go
create view v_autoroles_reports_ru_ru as 
select   b2g(roles_reports. roles_reportsid) roles_reportsid,roles_reports. changestamp changestamp
, 
 b2g(roles_reports.the_report)  
roles_reports_the_report_id, 
 instance_brief_f(roles_reports.the_report, 'ru_ru') 
roles_reports_the_report 
, b2g(roles_reports.instanceid) instanceid 
, roles_reports.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_reports.roles_reportsid) id 
, 'roles_reports' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_REPORTS
 join INSTANCE on ROLES_REPORTS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_reports_en_us
go
create view v_autoroles_reports_en_us as 
select   b2g(roles_reports. roles_reportsid) roles_reportsid,roles_reports. changestamp changestamp
, 
 b2g(roles_reports.the_report)  
roles_reports_the_report_id, 
 instance_brief_f(roles_reports.the_report, 'en_us') 
roles_reports_the_report 
, b2g(roles_reports.instanceid) instanceid 
, roles_reports.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_reports.roles_reportsid) id 
, 'roles_reports' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_REPORTS
 join INSTANCE on ROLES_REPORTS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_user
go
create view v_autoroles_user as 
select   b2g(roles_user. roles_userid) roles_userid,roles_user. changestamp changestamp
, 
 b2g(roles_user.theuser)  
roles_user_theuser_id, 
 users_brief_f(roles_user.theuser, null) 
roles_user_theuser 
, b2g(roles_user.instanceid) instanceid 
, roles_user.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_user.roles_userid) id 
, 'roles_user' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_USER
 join INSTANCE on ROLES_USER.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_user_ru_ru
go
create view v_autoroles_user_ru_ru as 
select   b2g(roles_user. roles_userid) roles_userid,roles_user. changestamp changestamp
, 
 b2g(roles_user.theuser)  
roles_user_theuser_id, 
 users_brief_f(roles_user.theuser, 'ru_ru') 
roles_user_theuser 
, b2g(roles_user.instanceid) instanceid 
, roles_user.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_user.roles_userid) id 
, 'roles_user' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_USER
 join INSTANCE on ROLES_USER.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_user_en_us
go
create view v_autoroles_user_en_us as 
select   b2g(roles_user. roles_userid) roles_userid,roles_user. changestamp changestamp
, 
 b2g(roles_user.theuser)  
roles_user_theuser_id, 
 users_brief_f(roles_user.theuser, 'en_us') 
roles_user_theuser 
, b2g(roles_user.instanceid) instanceid 
, roles_user.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_user.roles_userid) id 
, 'roles_user' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_USER
 join INSTANCE on ROLES_USER.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_map
go
create view v_autoroles_map as 
select   b2g(roles_map. roles_mapid) roles_mapid,roles_map. changestamp changestamp
, 
 b2g(roles_map.thegroup)  
roles_map_thegroup_id, 
 groups_brief_f(roles_map.thegroup, null) 
roles_map_thegroup 
, b2g(roles_map.instanceid) instanceid 
, roles_map.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_map.roles_mapid) id 
, 'roles_map' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_MAP
 join INSTANCE on ROLES_MAP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_map_ru_ru
go
create view v_autoroles_map_ru_ru as 
select   b2g(roles_map. roles_mapid) roles_mapid,roles_map. changestamp changestamp
, 
 b2g(roles_map.thegroup)  
roles_map_thegroup_id, 
 groups_brief_f(roles_map.thegroup, 'ru_ru') 
roles_map_thegroup 
, b2g(roles_map.instanceid) instanceid 
, roles_map.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_map.roles_mapid) id 
, 'roles_map' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_MAP
 join INSTANCE on ROLES_MAP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_map_en_us
go
create view v_autoroles_map_en_us as 
select   b2g(roles_map. roles_mapid) roles_mapid,roles_map. changestamp changestamp
, 
 b2g(roles_map.thegroup)  
roles_map_thegroup_id, 
 groups_brief_f(roles_map.thegroup, 'en_us') 
roles_map_thegroup 
, b2g(roles_map.instanceid) instanceid 
, roles_map.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_map.roles_mapid) id 
, 'roles_map' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_MAP
 join INSTANCE on ROLES_MAP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_def
go
create view v_autoroles_def as 
select   b2g(roles_def. roles_defid) roles_defid,roles_def. changestamp changestamp
, 
 roles_def.substructobjects  
roles_def_substructobjects_val, 
 case roles_def.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_def_substructobjects 
, 
 roles_def.allobjects  
roles_def_allobjects_val, 
 case roles_def.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_def_allobjects 
, 
roles_def.name 
roles_def_name 
, 
 roles_def.colegsobject  
roles_def_colegsobject_val, 
 case roles_def.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_def_colegsobject 
, b2g(roles_def.instanceid) instanceid 
, roles_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_def.roles_defid) id 
, 'roles_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_DEF
 join INSTANCE on ROLES_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_def_ru_ru
go
create view v_autoroles_def_ru_ru as 
select   b2g(roles_def. roles_defid) roles_defid,roles_def. changestamp changestamp
, 
 roles_def.substructobjects  
roles_def_substructobjects_val, 
 case roles_def.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_def_substructobjects 
, 
 roles_def.allobjects  
roles_def_allobjects_val, 
 case roles_def.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_def_allobjects 
, 
roles_def.name 
roles_def_name 
, 
 roles_def.colegsobject  
roles_def_colegsobject_val, 
 case roles_def.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_def_colegsobject 
, b2g(roles_def.instanceid) instanceid 
, roles_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_def.roles_defid) id 
, 'roles_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_DEF
 join INSTANCE on ROLES_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoroles_def_en_us
go
create view v_autoroles_def_en_us as 
select   b2g(roles_def. roles_defid) roles_defid,roles_def. changestamp changestamp
, 
 roles_def.substructobjects  
roles_def_substructobjects_val, 
 case roles_def.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_def_substructobjects 
, 
 roles_def.allobjects  
roles_def_allobjects_val, 
 case roles_def.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_def_allobjects 
, 
roles_def.name 
roles_def_name 
, 
 roles_def.colegsobject  
roles_def_colegsobject_val, 
 case roles_def.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
roles_def_colegsobject 
, b2g(roles_def.instanceid) instanceid 
, roles_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(roles_def.roles_defid) id 
, 'roles_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from ROLES_DEF
 join INSTANCE on ROLES_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_docs
go
create view v_autoiu_urok_docs as 
select   b2g(iu_urok_docs. iu_urok_docsid) iu_urok_docsid,iu_urok_docs. changestamp changestamp
, 
iu_urok_docs.origname 
iu_urok_docs_origname 
, 
 iu_urok_docs.activeversion  
iu_urok_docs_activeversion_val, 
 case iu_urok_docs.activeversion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_docs_activeversion 
, 
iu_urok_docs.fileref 
iu_urok_docs_fileref 
, 
 b2g(iu_urok_docs.addby)  
iu_urok_docs_addby_id, 
 iu_u_def_brief_f(iu_urok_docs.addby, null) 
iu_urok_docs_addby 
, 
iu_urok_docs.filetext 
iu_urok_docs_filetext 
, 
iu_urok_docs.version 
iu_urok_docs_version 
, 
iu_urok_docs.info 
iu_urok_docs_info 
, 
iu_urok_docs.adddate 
iu_urok_docs_adddate 
, 
iu_urok_docs.fileurl 
iu_urok_docs_fileurl 
, 
 b2g(iu_urok_docs.filereftype)  
iu_urok_docs_filereftype_id, 
 iud_rt_def_brief_f(iu_urok_docs.filereftype, null) 
iu_urok_docs_filereftype 
, 
 b2g(iu_urok_docs.doctype)  
iu_urok_docs_doctype_id, 
 iud_doctype_brief_f(iu_urok_docs.doctype, null) 
iu_urok_docs_doctype 
, b2g(iu_urok_docs.instanceid) instanceid 
, iu_urok_docs.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_docs.iu_urok_docsid) id 
, 'iu_urok_docs' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_docs
 join INSTANCE on iu_urok_docs.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_docs_ru_ru
go
create view v_autoiu_urok_docs_ru_ru as 
select   b2g(iu_urok_docs. iu_urok_docsid) iu_urok_docsid,iu_urok_docs. changestamp changestamp
, 
iu_urok_docs.origname 
iu_urok_docs_origname 
, 
 iu_urok_docs.activeversion  
iu_urok_docs_activeversion_val, 
 case iu_urok_docs.activeversion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_docs_activeversion 
, 
iu_urok_docs.fileref 
iu_urok_docs_fileref 
, 
 b2g(iu_urok_docs.addby)  
iu_urok_docs_addby_id, 
 iu_u_def_brief_f(iu_urok_docs.addby, 'ru_ru') 
iu_urok_docs_addby 
, 
iu_urok_docs.filetext 
iu_urok_docs_filetext 
, 
iu_urok_docs.version 
iu_urok_docs_version 
, 
iu_urok_docs.info 
iu_urok_docs_info 
, 
iu_urok_docs.adddate 
iu_urok_docs_adddate 
, 
iu_urok_docs.fileurl 
iu_urok_docs_fileurl 
, 
 b2g(iu_urok_docs.filereftype)  
iu_urok_docs_filereftype_id, 
 iud_rt_def_brief_f(iu_urok_docs.filereftype, 'ru_ru') 
iu_urok_docs_filereftype 
, 
 b2g(iu_urok_docs.doctype)  
iu_urok_docs_doctype_id, 
 iud_doctype_brief_f(iu_urok_docs.doctype, 'ru_ru') 
iu_urok_docs_doctype 
, b2g(iu_urok_docs.instanceid) instanceid 
, iu_urok_docs.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_docs.iu_urok_docsid) id 
, 'iu_urok_docs' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_docs
 join INSTANCE on iu_urok_docs.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_docs_en_us
go
create view v_autoiu_urok_docs_en_us as 
select   b2g(iu_urok_docs. iu_urok_docsid) iu_urok_docsid,iu_urok_docs. changestamp changestamp
, 
iu_urok_docs.origname 
iu_urok_docs_origname 
, 
 iu_urok_docs.activeversion  
iu_urok_docs_activeversion_val, 
 case iu_urok_docs.activeversion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_docs_activeversion 
, 
iu_urok_docs.fileref 
iu_urok_docs_fileref 
, 
 b2g(iu_urok_docs.addby)  
iu_urok_docs_addby_id, 
 iu_u_def_brief_f(iu_urok_docs.addby, 'en_us') 
iu_urok_docs_addby 
, 
iu_urok_docs.filetext 
iu_urok_docs_filetext 
, 
iu_urok_docs.version 
iu_urok_docs_version 
, 
iu_urok_docs.info 
iu_urok_docs_info 
, 
iu_urok_docs.adddate 
iu_urok_docs_adddate 
, 
iu_urok_docs.fileurl 
iu_urok_docs_fileurl 
, 
 b2g(iu_urok_docs.filereftype)  
iu_urok_docs_filereftype_id, 
 iud_rt_def_brief_f(iu_urok_docs.filereftype, 'en_us') 
iu_urok_docs_filereftype 
, 
 b2g(iu_urok_docs.doctype)  
iu_urok_docs_doctype_id, 
 iud_doctype_brief_f(iu_urok_docs.doctype, 'en_us') 
iu_urok_docs_doctype 
, b2g(iu_urok_docs.instanceid) instanceid 
, iu_urok_docs.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_docs.iu_urok_docsid) id 
, 'iu_urok_docs' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_docs
 join INSTANCE on iu_urok_docs.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_creators
go
create view v_autoiu_urok_creators as 
select   b2g(iu_urok_creators. iu_urok_creatorsid) iu_urok_creatorsid,iu_urok_creators. changestamp changestamp
, 
 b2g(iu_urok_creators.doer)  
iu_urok_creators_doer_id, 
 iu_u_def_brief_f(iu_urok_creators.doer, null) 
iu_urok_creators_doer 
, 
 iu_urok_creators.doers  
iu_urok_creators_doers_id, 
 iu_crole_mref_f(iu_urok_creators.doers, null) 
iu_urok_creators_doers 
, 
iu_urok_creators.selectday 
iu_urok_creators_selectday 
, 
 b2g(iu_urok_creators.selectby)  
iu_urok_creators_selectby_id, 
 iu_u_def_brief_f(iu_urok_creators.selectby, null) 
iu_urok_creators_selectby 
, 
 b2g(iu_urok_creators.processrole)  
iu_urok_creators_processrole_id, 
 iu_crole_brief_f(iu_urok_creators.processrole, null) 
iu_urok_creators_processrole 
, b2g(iu_urok_creators.instanceid) instanceid 
, iu_urok_creators.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_creators.iu_urok_creatorsid) id 
, 'iu_urok_creators' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_creators
 join INSTANCE on iu_urok_creators.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_creators_ru_ru
go
create view v_autoiu_urok_creators_ru_ru as 
select   b2g(iu_urok_creators. iu_urok_creatorsid) iu_urok_creatorsid,iu_urok_creators. changestamp changestamp
, 
 b2g(iu_urok_creators.doer)  
iu_urok_creators_doer_id, 
 iu_u_def_brief_f(iu_urok_creators.doer, 'ru_ru') 
iu_urok_creators_doer 
, 
 iu_urok_creators.doers  
iu_urok_creators_doers_id, 
 iu_crole_mref_f(iu_urok_creators.doers, 'ru_ru') 
iu_urok_creators_doers 
, 
iu_urok_creators.selectday 
iu_urok_creators_selectday 
, 
 b2g(iu_urok_creators.selectby)  
iu_urok_creators_selectby_id, 
 iu_u_def_brief_f(iu_urok_creators.selectby, 'ru_ru') 
iu_urok_creators_selectby 
, 
 b2g(iu_urok_creators.processrole)  
iu_urok_creators_processrole_id, 
 iu_crole_brief_f(iu_urok_creators.processrole, 'ru_ru') 
iu_urok_creators_processrole 
, b2g(iu_urok_creators.instanceid) instanceid 
, iu_urok_creators.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_creators.iu_urok_creatorsid) id 
, 'iu_urok_creators' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_creators
 join INSTANCE on iu_urok_creators.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_creators_en_us
go
create view v_autoiu_urok_creators_en_us as 
select   b2g(iu_urok_creators. iu_urok_creatorsid) iu_urok_creatorsid,iu_urok_creators. changestamp changestamp
, 
 b2g(iu_urok_creators.doer)  
iu_urok_creators_doer_id, 
 iu_u_def_brief_f(iu_urok_creators.doer, 'en_us') 
iu_urok_creators_doer 
, 
 iu_urok_creators.doers  
iu_urok_creators_doers_id, 
 iu_crole_mref_f(iu_urok_creators.doers, 'en_us') 
iu_urok_creators_doers 
, 
iu_urok_creators.selectday 
iu_urok_creators_selectday 
, 
 b2g(iu_urok_creators.selectby)  
iu_urok_creators_selectby_id, 
 iu_u_def_brief_f(iu_urok_creators.selectby, 'en_us') 
iu_urok_creators_selectby 
, 
 b2g(iu_urok_creators.processrole)  
iu_urok_creators_processrole_id, 
 iu_crole_brief_f(iu_urok_creators.processrole, 'en_us') 
iu_urok_creators_processrole 
, b2g(iu_urok_creators.instanceid) instanceid 
, iu_urok_creators.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_creators.iu_urok_creatorsid) id 
, 'iu_urok_creators' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_creators
 join INSTANCE on iu_urok_creators.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_def
go
create view v_autoiu_urok_def as 
select   b2g(iu_urok_def. iu_urok_defid) iu_urok_defid,iu_urok_def. changestamp changestamp
, 
iu_urok_def.thefilmurl 
iu_urok_def_thefilmurl 
, 
iu_urok_def.mainref 
iu_urok_def_mainref 
, 
iu_urok_def.ucode 
iu_urok_def_ucode 
, 
 b2g(iu_urok_def.theteacher)  
iu_urok_def_theteacher_id, 
 iu_tmdef_brief_f(iu_urok_def.theteacher, null) 
iu_urok_def_theteacher 
, 
 b2g(iu_urok_def.processtype)  
iu_urok_def_processtype_id, 
 iud_process_def_brief_f(iu_urok_def.processtype, null) 
iu_urok_def_processtype 
, 
iu_urok_def.plannum 
iu_urok_def_plannum 
, 
 b2g(iu_urok_def.pubstate)  
iu_urok_def_pubstate_id, 
 iud_spub_brief_f(iu_urok_def.pubstate, null) 
iu_urok_def_pubstate 
, 
 b2g(iu_urok_def.ckksn)  
iu_urok_def_ckksn_id, 
 iud_sn_def_brief_f(iu_urok_def.ckksn, null) 
iu_urok_def_ckksn 
, 
iu_urok_def.datecreated 
iu_urok_def_datecreated 
, 
iu_urok_def.rtheme 
iu_urok_def_rtheme 
, 
iu_urok_def.schooldate 
iu_urok_def_schooldate 
, 
 b2g(iu_urok_def.thefilm)  
iu_urok_def_thefilm_id, 
 iu_urok_def_brief_f(iu_urok_def.thefilm, null) 
iu_urok_def_thefilm 
, 
iu_urok_def.info 
iu_urok_def_info 
, 
iu_urok_def.notes 
iu_urok_def_notes 
, 
 b2g(iu_urok_def.methodist)  
iu_urok_def_methodist_id, 
 iu_tmdef_brief_f(iu_urok_def.methodist, null) 
iu_urok_def_methodist 
, 
 b2g(iu_urok_def.methodist2)  
iu_urok_def_methodist2_id, 
 iu_tmdef_brief_f(iu_urok_def.methodist2, null) 
iu_urok_def_methodist2 
, 
 iu_urok_def.thequarter  
iu_urok_def_thequarter_val, 
 case iu_urok_def.thequarter 
when 1 then 'i'
when 4 then 'iv'
when 0 then '?'
when 2 then 'ii'
when 3 then 'iii'
 else '' 
 end  
iu_urok_def_thequarter 
, 
 b2g(iu_urok_def.subject)  
iu_urok_def_subject_id, 
 iud_predmet_brief_f(iu_urok_def.subject, null) 
iu_urok_def_subject 
, 
iu_urok_def.actiondate 
iu_urok_def_actiondate 
, 
 b2g(iu_urok_def.coursetype)  
iu_urok_def_coursetype_id, 
 iud_ctype_brief_f(iu_urok_def.coursetype, null) 
iu_urok_def_coursetype 
, 
 b2g(iu_urok_def.maketown)  
iu_urok_def_maketown_id, 
 iud_town_brief_f(iu_urok_def.maketown, null) 
iu_urok_def_maketown 
, 
iu_urok_def.classtheme 
iu_urok_def_classtheme 
, 
iu_urok_def.testpageref 
iu_urok_def_testpageref 
, 
 b2g(iu_urok_def.curator)  
iu_urok_def_curator_id, 
 iu_u_def_brief_f(iu_urok_def.curator, null) 
iu_urok_def_curator 
, 
iu_urok_def.actiondate2 
iu_urok_def_actiondate2 
, 
 b2g(iu_urok_def.theclassnum)  
iu_urok_def_theclassnum_id, 
 iu_clsinfo_brief_f(iu_urok_def.theclassnum, null) 
iu_urok_def_theclassnum 
, b2g(iu_urok_def.instanceid) instanceid 
, iu_urok_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_def.iu_urok_defid) id 
, 'iu_urok_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_def
 join INSTANCE on iu_urok_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_def_ru_ru
go
create view v_autoiu_urok_def_ru_ru as 
select   b2g(iu_urok_def. iu_urok_defid) iu_urok_defid,iu_urok_def. changestamp changestamp
, 
iu_urok_def.thefilmurl 
iu_urok_def_thefilmurl 
, 
iu_urok_def.mainref 
iu_urok_def_mainref 
, 
iu_urok_def.ucode 
iu_urok_def_ucode 
, 
 b2g(iu_urok_def.theteacher)  
iu_urok_def_theteacher_id, 
 iu_tmdef_brief_f(iu_urok_def.theteacher, 'ru_ru') 
iu_urok_def_theteacher 
, 
 b2g(iu_urok_def.processtype)  
iu_urok_def_processtype_id, 
 iud_process_def_brief_f(iu_urok_def.processtype, 'ru_ru') 
iu_urok_def_processtype 
, 
iu_urok_def.plannum 
iu_urok_def_plannum 
, 
 b2g(iu_urok_def.pubstate)  
iu_urok_def_pubstate_id, 
 iud_spub_brief_f(iu_urok_def.pubstate, 'ru_ru') 
iu_urok_def_pubstate 
, 
 b2g(iu_urok_def.ckksn)  
iu_urok_def_ckksn_id, 
 iud_sn_def_brief_f(iu_urok_def.ckksn, 'ru_ru') 
iu_urok_def_ckksn 
, 
iu_urok_def.datecreated 
iu_urok_def_datecreated 
, 
iu_urok_def.rtheme 
iu_urok_def_rtheme 
, 
iu_urok_def.schooldate 
iu_urok_def_schooldate 
, 
 b2g(iu_urok_def.thefilm)  
iu_urok_def_thefilm_id, 
 iu_urok_def_brief_f(iu_urok_def.thefilm, 'ru_ru') 
iu_urok_def_thefilm 
, 
iu_urok_def.info 
iu_urok_def_info 
, 
iu_urok_def.notes 
iu_urok_def_notes 
, 
 b2g(iu_urok_def.methodist)  
iu_urok_def_methodist_id, 
 iu_tmdef_brief_f(iu_urok_def.methodist, 'ru_ru') 
iu_urok_def_methodist 
, 
 b2g(iu_urok_def.methodist2)  
iu_urok_def_methodist2_id, 
 iu_tmdef_brief_f(iu_urok_def.methodist2, 'ru_ru') 
iu_urok_def_methodist2 
, 
 iu_urok_def.thequarter  
iu_urok_def_thequarter_val, 
 case iu_urok_def.thequarter 
when 1 then 'i'
when 4 then 'iv'
when 0 then '?'
when 2 then 'ii'
when 3 then 'iii'
 else '' 
 end  
iu_urok_def_thequarter 
, 
 b2g(iu_urok_def.subject)  
iu_urok_def_subject_id, 
 iud_predmet_brief_f(iu_urok_def.subject, 'ru_ru') 
iu_urok_def_subject 
, 
iu_urok_def.actiondate 
iu_urok_def_actiondate 
, 
 b2g(iu_urok_def.coursetype)  
iu_urok_def_coursetype_id, 
 iud_ctype_brief_f(iu_urok_def.coursetype, 'ru_ru') 
iu_urok_def_coursetype 
, 
 b2g(iu_urok_def.maketown)  
iu_urok_def_maketown_id, 
 iud_town_brief_f(iu_urok_def.maketown, 'ru_ru') 
iu_urok_def_maketown 
, 
iu_urok_def.classtheme 
iu_urok_def_classtheme 
, 
iu_urok_def.testpageref 
iu_urok_def_testpageref 
, 
 b2g(iu_urok_def.curator)  
iu_urok_def_curator_id, 
 iu_u_def_brief_f(iu_urok_def.curator, 'ru_ru') 
iu_urok_def_curator 
, 
iu_urok_def.actiondate2 
iu_urok_def_actiondate2 
, 
 b2g(iu_urok_def.theclassnum)  
iu_urok_def_theclassnum_id, 
 iu_clsinfo_brief_f(iu_urok_def.theclassnum, 'ru_ru') 
iu_urok_def_theclassnum 
, b2g(iu_urok_def.instanceid) instanceid 
, iu_urok_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_def.iu_urok_defid) id 
, 'iu_urok_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_def
 join INSTANCE on iu_urok_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_def_en_us
go
create view v_autoiu_urok_def_en_us as 
select   b2g(iu_urok_def. iu_urok_defid) iu_urok_defid,iu_urok_def. changestamp changestamp
, 
iu_urok_def.thefilmurl 
iu_urok_def_thefilmurl 
, 
iu_urok_def.mainref 
iu_urok_def_mainref 
, 
iu_urok_def.ucode 
iu_urok_def_ucode 
, 
 b2g(iu_urok_def.theteacher)  
iu_urok_def_theteacher_id, 
 iu_tmdef_brief_f(iu_urok_def.theteacher, 'en_us') 
iu_urok_def_theteacher 
, 
 b2g(iu_urok_def.processtype)  
iu_urok_def_processtype_id, 
 iud_process_def_brief_f(iu_urok_def.processtype, 'en_us') 
iu_urok_def_processtype 
, 
iu_urok_def.plannum 
iu_urok_def_plannum 
, 
 b2g(iu_urok_def.pubstate)  
iu_urok_def_pubstate_id, 
 iud_spub_brief_f(iu_urok_def.pubstate, 'en_us') 
iu_urok_def_pubstate 
, 
 b2g(iu_urok_def.ckksn)  
iu_urok_def_ckksn_id, 
 iud_sn_def_brief_f(iu_urok_def.ckksn, 'en_us') 
iu_urok_def_ckksn 
, 
iu_urok_def.datecreated 
iu_urok_def_datecreated 
, 
iu_urok_def.rtheme 
iu_urok_def_rtheme 
, 
iu_urok_def.schooldate 
iu_urok_def_schooldate 
, 
 b2g(iu_urok_def.thefilm)  
iu_urok_def_thefilm_id, 
 iu_urok_def_brief_f(iu_urok_def.thefilm, 'en_us') 
iu_urok_def_thefilm 
, 
iu_urok_def.info 
iu_urok_def_info 
, 
iu_urok_def.notes 
iu_urok_def_notes 
, 
 b2g(iu_urok_def.methodist)  
iu_urok_def_methodist_id, 
 iu_tmdef_brief_f(iu_urok_def.methodist, 'en_us') 
iu_urok_def_methodist 
, 
 b2g(iu_urok_def.methodist2)  
iu_urok_def_methodist2_id, 
 iu_tmdef_brief_f(iu_urok_def.methodist2, 'en_us') 
iu_urok_def_methodist2 
, 
 iu_urok_def.thequarter  
iu_urok_def_thequarter_val, 
 case iu_urok_def.thequarter 
when 1 then 'i'
when 4 then 'iv'
when 0 then '?'
when 2 then 'ii'
when 3 then 'iii'
 else '' 
 end  
iu_urok_def_thequarter 
, 
 b2g(iu_urok_def.subject)  
iu_urok_def_subject_id, 
 iud_predmet_brief_f(iu_urok_def.subject, 'en_us') 
iu_urok_def_subject 
, 
iu_urok_def.actiondate 
iu_urok_def_actiondate 
, 
 b2g(iu_urok_def.coursetype)  
iu_urok_def_coursetype_id, 
 iud_ctype_brief_f(iu_urok_def.coursetype, 'en_us') 
iu_urok_def_coursetype 
, 
 b2g(iu_urok_def.maketown)  
iu_urok_def_maketown_id, 
 iud_town_brief_f(iu_urok_def.maketown, 'en_us') 
iu_urok_def_maketown 
, 
iu_urok_def.classtheme 
iu_urok_def_classtheme 
, 
iu_urok_def.testpageref 
iu_urok_def_testpageref 
, 
 b2g(iu_urok_def.curator)  
iu_urok_def_curator_id, 
 iu_u_def_brief_f(iu_urok_def.curator, 'en_us') 
iu_urok_def_curator 
, 
iu_urok_def.actiondate2 
iu_urok_def_actiondate2 
, 
 b2g(iu_urok_def.theclassnum)  
iu_urok_def_theclassnum_id, 
 iu_clsinfo_brief_f(iu_urok_def.theclassnum, 'en_us') 
iu_urok_def_theclassnum 
, b2g(iu_urok_def.instanceid) instanceid 
, iu_urok_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_def.iu_urok_defid) id 
, 'iu_urok_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_def
 join INSTANCE on iu_urok_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_video
go
create view v_autoiu_urok_video as 
select   b2g(iu_urok_video. iu_urok_videoid) iu_urok_videoid,iu_urok_video. changestamp changestamp
, 
 b2g(iu_urok_video.addby)  
iu_urok_video_addby_id, 
 iu_u_def_brief_f(iu_urok_video.addby, null) 
iu_urok_video_addby 
, 
iu_urok_video.fileurl 
iu_urok_video_fileurl 
, 
iu_urok_video.adddate 
iu_urok_video_adddate 
, 
iu_urok_video.info 
iu_urok_video_info 
, 
 b2g(iu_urok_video.doctype)  
iu_urok_video_doctype_id, 
 iud_videotype_brief_f(iu_urok_video.doctype, null) 
iu_urok_video_doctype 
, 
 iu_urok_video.activeversion  
iu_urok_video_activeversion_val, 
 case iu_urok_video.activeversion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_video_activeversion 
, 
 iu_urok_video.nocomments  
iu_urok_video_nocomments_val, 
 case iu_urok_video.nocomments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_video_nocomments 
, 
iu_urok_video.fileref 
iu_urok_video_fileref 
, 
iu_urok_video.version 
iu_urok_video_version 
, 
iu_urok_video.origname 
iu_urok_video_origname 
, b2g(iu_urok_video.instanceid) instanceid 
, iu_urok_video.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_video.iu_urok_videoid) id 
, 'iu_urok_video' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_video
 join INSTANCE on iu_urok_video.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_video_ru_ru
go
create view v_autoiu_urok_video_ru_ru as 
select   b2g(iu_urok_video. iu_urok_videoid) iu_urok_videoid,iu_urok_video. changestamp changestamp
, 
 b2g(iu_urok_video.addby)  
iu_urok_video_addby_id, 
 iu_u_def_brief_f(iu_urok_video.addby, 'ru_ru') 
iu_urok_video_addby 
, 
iu_urok_video.fileurl 
iu_urok_video_fileurl 
, 
iu_urok_video.adddate 
iu_urok_video_adddate 
, 
iu_urok_video.info 
iu_urok_video_info 
, 
 b2g(iu_urok_video.doctype)  
iu_urok_video_doctype_id, 
 iud_videotype_brief_f(iu_urok_video.doctype, 'ru_ru') 
iu_urok_video_doctype 
, 
 iu_urok_video.activeversion  
iu_urok_video_activeversion_val, 
 case iu_urok_video.activeversion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_video_activeversion 
, 
 iu_urok_video.nocomments  
iu_urok_video_nocomments_val, 
 case iu_urok_video.nocomments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_video_nocomments 
, 
iu_urok_video.fileref 
iu_urok_video_fileref 
, 
iu_urok_video.version 
iu_urok_video_version 
, 
iu_urok_video.origname 
iu_urok_video_origname 
, b2g(iu_urok_video.instanceid) instanceid 
, iu_urok_video.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_video.iu_urok_videoid) id 
, 'iu_urok_video' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_video
 join INSTANCE on iu_urok_video.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_urok_video_en_us
go
create view v_autoiu_urok_video_en_us as 
select   b2g(iu_urok_video. iu_urok_videoid) iu_urok_videoid,iu_urok_video. changestamp changestamp
, 
 b2g(iu_urok_video.addby)  
iu_urok_video_addby_id, 
 iu_u_def_brief_f(iu_urok_video.addby, 'en_us') 
iu_urok_video_addby 
, 
iu_urok_video.fileurl 
iu_urok_video_fileurl 
, 
iu_urok_video.adddate 
iu_urok_video_adddate 
, 
iu_urok_video.info 
iu_urok_video_info 
, 
 b2g(iu_urok_video.doctype)  
iu_urok_video_doctype_id, 
 iud_videotype_brief_f(iu_urok_video.doctype, 'en_us') 
iu_urok_video_doctype 
, 
 iu_urok_video.activeversion  
iu_urok_video_activeversion_val, 
 case iu_urok_video.activeversion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_video_activeversion 
, 
 iu_urok_video.nocomments  
iu_urok_video_nocomments_val, 
 case iu_urok_video.nocomments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_urok_video_nocomments 
, 
iu_urok_video.fileref 
iu_urok_video_fileref 
, 
iu_urok_video.version 
iu_urok_video_version 
, 
iu_urok_video.origname 
iu_urok_video_origname 
, b2g(iu_urok_video.instanceid) instanceid 
, iu_urok_video.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_urok_video.iu_urok_videoid) id 
, 'iu_urok_video' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_urok_video
 join INSTANCE on iu_urok_video.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_mt_def
go
create view v_autoiud_mt_def as 
select   b2g(iud_mt_def. iud_mt_defid) iud_mt_defid,iud_mt_def. changestamp changestamp
, 
iud_mt_def.name 
iud_mt_def_name 
, 
iud_mt_def.mticon 
iud_mt_def_mticon 
, b2g(iud_mt_def.instanceid) instanceid 
, iud_mt_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_mt_def.iud_mt_defid) id 
, 'iud_mt_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_mt_def
 join INSTANCE on iud_mt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_mt_def_ru_ru
go
create view v_autoiud_mt_def_ru_ru as 
select   b2g(iud_mt_def. iud_mt_defid) iud_mt_defid,iud_mt_def. changestamp changestamp
, 
iud_mt_def.name 
iud_mt_def_name 
, 
iud_mt_def.mticon 
iud_mt_def_mticon 
, b2g(iud_mt_def.instanceid) instanceid 
, iud_mt_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_mt_def.iud_mt_defid) id 
, 'iud_mt_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_mt_def
 join INSTANCE on iud_mt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_mt_def_en_us
go
create view v_autoiud_mt_def_en_us as 
select   b2g(iud_mt_def. iud_mt_defid) iud_mt_defid,iud_mt_def. changestamp changestamp
, 
iud_mt_def.name 
iud_mt_def_name 
, 
iud_mt_def.mticon 
iud_mt_def_mticon 
, b2g(iud_mt_def.instanceid) instanceid 
, iud_mt_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_mt_def.iud_mt_defid) id 
, 'iud_mt_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_mt_def
 join INSTANCE on iud_mt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_sn_def
go
create view v_autoiud_sn_def as 
select   b2g(iud_sn_def. iud_sn_defid) iud_sn_defid,iud_sn_def. changestamp changestamp
, 
 iud_sn_def.isfinal  
iud_sn_def_isfinal_val, 
 case iud_sn_def.isfinal 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iud_sn_def_isfinal 
, 
iud_sn_def.sequence 
iud_sn_def_sequence 
, 
iud_sn_def.name 
iud_sn_def_name 
, b2g(iud_sn_def.instanceid) instanceid 
, iud_sn_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_sn_def.iud_sn_defid) id 
, 'iud_sn_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_sn_def
 join INSTANCE on iud_sn_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_sn_def_ru_ru
go
create view v_autoiud_sn_def_ru_ru as 
select   b2g(iud_sn_def. iud_sn_defid) iud_sn_defid,iud_sn_def. changestamp changestamp
, 
 iud_sn_def.isfinal  
iud_sn_def_isfinal_val, 
 case iud_sn_def.isfinal 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iud_sn_def_isfinal 
, 
iud_sn_def.sequence 
iud_sn_def_sequence 
, 
iud_sn_def.name 
iud_sn_def_name 
, b2g(iud_sn_def.instanceid) instanceid 
, iud_sn_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_sn_def.iud_sn_defid) id 
, 'iud_sn_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_sn_def
 join INSTANCE on iud_sn_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_sn_def_en_us
go
create view v_autoiud_sn_def_en_us as 
select   b2g(iud_sn_def. iud_sn_defid) iud_sn_defid,iud_sn_def. changestamp changestamp
, 
 iud_sn_def.isfinal  
iud_sn_def_isfinal_val, 
 case iud_sn_def.isfinal 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iud_sn_def_isfinal 
, 
iud_sn_def.sequence 
iud_sn_def_sequence 
, 
iud_sn_def.name 
iud_sn_def_name 
, b2g(iud_sn_def.instanceid) instanceid 
, iud_sn_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_sn_def.iud_sn_defid) id 
, 'iud_sn_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_sn_def
 join INSTANCE on iud_sn_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_filestoretype
go
create view v_autoiud_filestoretype as 
select   b2g(iud_filestoretype. iud_filestoretypeid) iud_filestoretypeid,iud_filestoretype. changestamp changestamp
, 
iud_filestoretype.name 
iud_filestoretype_name 
, b2g(iud_filestoretype.instanceid) instanceid 
, iud_filestoretype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_filestoretype.iud_filestoretypeid) id 
, 'iud_filestoretype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_filestoretype
 join INSTANCE on iud_filestoretype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_filestoretype_ru_ru
go
create view v_autoiud_filestoretype_ru_ru as 
select   b2g(iud_filestoretype. iud_filestoretypeid) iud_filestoretypeid,iud_filestoretype. changestamp changestamp
, 
iud_filestoretype.name 
iud_filestoretype_name 
, b2g(iud_filestoretype.instanceid) instanceid 
, iud_filestoretype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_filestoretype.iud_filestoretypeid) id 
, 'iud_filestoretype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_filestoretype
 join INSTANCE on iud_filestoretype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_filestoretype_en_us
go
create view v_autoiud_filestoretype_en_us as 
select   b2g(iud_filestoretype. iud_filestoretypeid) iud_filestoretypeid,iud_filestoretype. changestamp changestamp
, 
iud_filestoretype.name 
iud_filestoretype_name 
, b2g(iud_filestoretype.instanceid) instanceid 
, iud_filestoretype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_filestoretype.iud_filestoretypeid) id 
, 'iud_filestoretype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_filestoretype
 join INSTANCE on iud_filestoretype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_predmet
go
create view v_autoiud_predmet as 
select   b2g(iud_predmet. iud_predmetid) iud_predmetid,iud_predmet. changestamp changestamp
, 
iud_predmet.name 
iud_predmet_name 
, 
iud_predmet.predmeticon 
iud_predmet_predmeticon 
, 
iud_predmet.prefix 
iud_predmet_prefix 
, b2g(iud_predmet.instanceid) instanceid 
, iud_predmet.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_predmet.iud_predmetid) id 
, 'iud_predmet' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_predmet
 join INSTANCE on iud_predmet.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_predmet_ru_ru
go
create view v_autoiud_predmet_ru_ru as 
select   b2g(iud_predmet. iud_predmetid) iud_predmetid,iud_predmet. changestamp changestamp
, 
iud_predmet.name 
iud_predmet_name 
, 
iud_predmet.predmeticon 
iud_predmet_predmeticon 
, 
iud_predmet.prefix 
iud_predmet_prefix 
, b2g(iud_predmet.instanceid) instanceid 
, iud_predmet.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_predmet.iud_predmetid) id 
, 'iud_predmet' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_predmet
 join INSTANCE on iud_predmet.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_predmet_en_us
go
create view v_autoiud_predmet_en_us as 
select   b2g(iud_predmet. iud_predmetid) iud_predmetid,iud_predmet. changestamp changestamp
, 
iud_predmet.name 
iud_predmet_name 
, 
iud_predmet.predmeticon 
iud_predmet_predmeticon 
, 
iud_predmet.prefix 
iud_predmet_prefix 
, b2g(iud_predmet.instanceid) instanceid 
, iud_predmet.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_predmet.iud_predmetid) id 
, 'iud_predmet' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_predmet
 join INSTANCE on iud_predmet.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_doctype
go
create view v_autoiud_doctype as 
select   b2g(iud_doctype. iud_doctypeid) iud_doctypeid,iud_doctype. changestamp changestamp
, 
iud_doctype.name 
iud_doctype_name 
, 
 b2g(iud_doctype.filetype)  
iud_doctype_filetype_id, 
 iud_filetype_brief_f(iud_doctype.filetype, null) 
iud_doctype_filetype 
, 
 b2g(iud_doctype.versionpolicy)  
iud_doctype_versionpolicy_id, 
 iud_filestoretype_brief_f(iud_doctype.versionpolicy, null) 
iud_doctype_versionpolicy 
, 
iud_doctype.sequence 
iud_doctype_sequence 
, b2g(iud_doctype.instanceid) instanceid 
, iud_doctype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_doctype.iud_doctypeid) id 
, 'iud_doctype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_doctype
 join INSTANCE on iud_doctype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_doctype_ru_ru
go
create view v_autoiud_doctype_ru_ru as 
select   b2g(iud_doctype. iud_doctypeid) iud_doctypeid,iud_doctype. changestamp changestamp
, 
iud_doctype.name 
iud_doctype_name 
, 
 b2g(iud_doctype.filetype)  
iud_doctype_filetype_id, 
 iud_filetype_brief_f(iud_doctype.filetype, 'ru_ru') 
iud_doctype_filetype 
, 
 b2g(iud_doctype.versionpolicy)  
iud_doctype_versionpolicy_id, 
 iud_filestoretype_brief_f(iud_doctype.versionpolicy, 'ru_ru') 
iud_doctype_versionpolicy 
, 
iud_doctype.sequence 
iud_doctype_sequence 
, b2g(iud_doctype.instanceid) instanceid 
, iud_doctype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_doctype.iud_doctypeid) id 
, 'iud_doctype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_doctype
 join INSTANCE on iud_doctype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_doctype_en_us
go
create view v_autoiud_doctype_en_us as 
select   b2g(iud_doctype. iud_doctypeid) iud_doctypeid,iud_doctype. changestamp changestamp
, 
iud_doctype.name 
iud_doctype_name 
, 
 b2g(iud_doctype.filetype)  
iud_doctype_filetype_id, 
 iud_filetype_brief_f(iud_doctype.filetype, 'en_us') 
iud_doctype_filetype 
, 
 b2g(iud_doctype.versionpolicy)  
iud_doctype_versionpolicy_id, 
 iud_filestoretype_brief_f(iud_doctype.versionpolicy, 'en_us') 
iud_doctype_versionpolicy 
, 
iud_doctype.sequence 
iud_doctype_sequence 
, b2g(iud_doctype.instanceid) instanceid 
, iud_doctype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_doctype.iud_doctypeid) id 
, 'iud_doctype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_doctype
 join INSTANCE on iud_doctype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autousers
go
create view v_autousers as 
select   b2g(users. usersid) usersid,users. changestamp changestamp
, 
users.domainame 
users_domainame 
, 
users.email 
users_email 
, 
users.family 
users_family 
, 
users.name 
users_name 
, 
users.localphone 
users_localphone 
, 
users.surname 
users_surname 
, 
users.login 
users_login 
, 
users.phone 
users_phone 
, b2g(users.instanceid) instanceid 
, users.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(users.usersid) id 
, 'users' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Users
 join INSTANCE on Users.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autousers_ru_ru
go
create view v_autousers_ru_ru as 
select   b2g(users. usersid) usersid,users. changestamp changestamp
, 
users.domainame 
users_domainame 
, 
users.email 
users_email 
, 
users.family 
users_family 
, 
users.name 
users_name 
, 
users.localphone 
users_localphone 
, 
users.surname 
users_surname 
, 
users.login 
users_login 
, 
users.phone 
users_phone 
, b2g(users.instanceid) instanceid 
, users.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(users.usersid) id 
, 'users' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Users
 join INSTANCE on Users.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autousers_en_us
go
create view v_autousers_en_us as 
select   b2g(users. usersid) usersid,users. changestamp changestamp
, 
users.domainame 
users_domainame 
, 
users.email 
users_email 
, 
users.family 
users_family 
, 
users.name 
users_name 
, 
users.localphone 
users_localphone 
, 
users.surname 
users_surname 
, 
users.login 
users_login 
, 
users.phone 
users_phone 
, b2g(users.instanceid) instanceid 
, users.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(users.usersid) id 
, 'users' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Users
 join INSTANCE on Users.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogroups
go
create view v_autogroups as 
select   b2g(groups. groupsid) groupsid,groups. changestamp changestamp
, 
groups.adgroup 
groups_adgroup 
, 
groups.name 
groups_name 
, b2g(groups.instanceid) instanceid 
, groups.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(groups.groupsid) id 
, 'groups' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Groups
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogroups_ru_ru
go
create view v_autogroups_ru_ru as 
select   b2g(groups. groupsid) groupsid,groups. changestamp changestamp
, 
groups.adgroup 
groups_adgroup 
, 
groups.name 
groups_name 
, b2g(groups.instanceid) instanceid 
, groups.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(groups.groupsid) id 
, 'groups' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Groups
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogroups_en_us
go
create view v_autogroups_en_us as 
select   b2g(groups. groupsid) groupsid,groups. changestamp changestamp
, 
groups.adgroup 
groups_adgroup 
, 
groups.name 
groups_name 
, b2g(groups.instanceid) instanceid 
, groups.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(groups.groupsid) id 
, 'groups' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Groups
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogroupuser
go
create view v_autogroupuser as 
select   b2g(groupuser. groupuserid) groupuserid,groupuser. changestamp changestamp, b2g(groupsid) groupsid
, 
 b2g(groupuser.theuser)  
groupuser_theuser_id, 
 users_brief_f(groupuser.theuser, null) 
groupuser_theuser 
, b2g(groups.instanceid) instanceid 
, groups.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(groupuser.groupuserid) id 
, 'groupuser' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GroupUser
 join Groups on Groups.GroupsID=GroupUser.ParentStructRowID 
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogroupuser_ru_ru
go
create view v_autogroupuser_ru_ru as 
select   b2g(groupuser. groupuserid) groupuserid,groupuser. changestamp changestamp, b2g(groupsid) groupsid
, 
 b2g(groupuser.theuser)  
groupuser_theuser_id, 
 users_brief_f(groupuser.theuser, 'ru_ru') 
groupuser_theuser 
, b2g(groups.instanceid) instanceid 
, groups.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(groupuser.groupuserid) id 
, 'groupuser' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GroupUser
 join Groups on Groups.GroupsID=GroupUser.ParentStructRowID 
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autogroupuser_en_us
go
create view v_autogroupuser_en_us as 
select   b2g(groupuser. groupuserid) groupuserid,groupuser. changestamp changestamp, b2g(groupsid) groupsid
, 
 b2g(groupuser.theuser)  
groupuser_theuser_id, 
 users_brief_f(groupuser.theuser, 'en_us') 
groupuser_theuser 
, b2g(groups.instanceid) instanceid 
, groups.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(groupuser.groupuserid) id 
, 'groupuser' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from GroupUser
 join Groups on Groups.GroupsID=GroupUser.ParentStructRowID 
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_clsinfo
go
create view v_autoiu_clsinfo as 
select   b2g(iu_clsinfo. iu_clsinfoid) iu_clsinfoid,iu_clsinfo. changestamp changestamp
, 
iu_clsinfo.name 
iu_clsinfo_name 
, 
iu_clsinfo.sequence 
iu_clsinfo_sequence 
, b2g(iu_clsinfo.instanceid) instanceid 
, iu_clsinfo.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_clsinfo.iu_clsinfoid) id 
, 'iu_clsinfo' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_clsinfo
 join INSTANCE on iu_clsinfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_clsinfo_ru_ru
go
create view v_autoiu_clsinfo_ru_ru as 
select   b2g(iu_clsinfo. iu_clsinfoid) iu_clsinfoid,iu_clsinfo. changestamp changestamp
, 
iu_clsinfo.name 
iu_clsinfo_name 
, 
iu_clsinfo.sequence 
iu_clsinfo_sequence 
, b2g(iu_clsinfo.instanceid) instanceid 
, iu_clsinfo.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_clsinfo.iu_clsinfoid) id 
, 'iu_clsinfo' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_clsinfo
 join INSTANCE on iu_clsinfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_clsinfo_en_us
go
create view v_autoiu_clsinfo_en_us as 
select   b2g(iu_clsinfo. iu_clsinfoid) iu_clsinfoid,iu_clsinfo. changestamp changestamp
, 
iu_clsinfo.name 
iu_clsinfo_name 
, 
iu_clsinfo.sequence 
iu_clsinfo_sequence 
, b2g(iu_clsinfo.instanceid) instanceid 
, iu_clsinfo.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_clsinfo.iu_clsinfoid) id 
, 'iu_clsinfo' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_clsinfo
 join INSTANCE on iu_clsinfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonum_zones
go
create view v_autonum_zones as 
select   b2g(num_zones. num_zonesid) num_zonesid,num_zones. changestamp changestamp
, 
num_zones.zonemask 
num_zones_zonemask 
, b2g(num_zones.instanceid) instanceid 
, num_zones.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(num_zones.num_zonesid) id 
, 'num_zones' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Num_zones
 join INSTANCE on Num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonum_zones_ru_ru
go
create view v_autonum_zones_ru_ru as 
select   b2g(num_zones. num_zonesid) num_zonesid,num_zones. changestamp changestamp
, 
num_zones.zonemask 
num_zones_zonemask 
, b2g(num_zones.instanceid) instanceid 
, num_zones.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(num_zones.num_zonesid) id 
, 'num_zones' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Num_zones
 join INSTANCE on Num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonum_zones_en_us
go
create view v_autonum_zones_en_us as 
select   b2g(num_zones. num_zonesid) num_zonesid,num_zones. changestamp changestamp
, 
num_zones.zonemask 
num_zones_zonemask 
, b2g(num_zones.instanceid) instanceid 
, num_zones.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(num_zones.num_zonesid) id 
, 'num_zones' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Num_zones
 join INSTANCE on Num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonum_values
go
create view v_autonum_values as 
select   b2g(num_values. num_valuesid) num_valuesid,num_values. changestamp changestamp, b2g(num_zonesid) num_zonesid
, 
num_values.ownerrowid 
num_values_ownerrowid 
, 
num_values.the_value 
num_values_the_value 
, 
num_values.ownerpartname 
num_values_ownerpartname 
, b2g(num_zones.instanceid) instanceid 
, num_zones.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(num_values.num_valuesid) id 
, 'num_values' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Num_Values
 join Num_zones on Num_zones.Num_zonesID=Num_Values.ParentStructRowID 
 join INSTANCE on Num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonum_values_ru_ru
go
create view v_autonum_values_ru_ru as 
select   b2g(num_values. num_valuesid) num_valuesid,num_values. changestamp changestamp, b2g(num_zonesid) num_zonesid
, 
num_values.ownerrowid 
num_values_ownerrowid 
, 
num_values.the_value 
num_values_the_value 
, 
num_values.ownerpartname 
num_values_ownerpartname 
, b2g(num_zones.instanceid) instanceid 
, num_zones.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(num_values.num_valuesid) id 
, 'num_values' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Num_Values
 join Num_zones on Num_zones.Num_zonesID=Num_Values.ParentStructRowID 
 join INSTANCE on Num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonum_values_en_us
go
create view v_autonum_values_en_us as 
select   b2g(num_values. num_valuesid) num_valuesid,num_values. changestamp changestamp, b2g(num_zonesid) num_zonesid
, 
num_values.ownerrowid 
num_values_ownerrowid 
, 
num_values.the_value 
num_values_the_value 
, 
num_values.ownerpartname 
num_values_ownerpartname 
, b2g(num_zones.instanceid) instanceid 
, num_zones.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(num_values.num_valuesid) id 
, 'num_values' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Num_Values
 join Num_zones on Num_zones.Num_zonesID=Num_Values.ParentStructRowID 
 join INSTANCE on Num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonum_head
go
create view v_autonum_head as 
select   b2g(num_head. num_headid) num_headid,num_head. changestamp changestamp
, 
num_head.name 
num_head_name 
, 
 num_head.shema  
num_head_shema_val, 
 case num_head.shema 
when 2 then 'по кварталу'
when 3 then 'по месяцу'
when 0 then 'единая зона'
when 4 then 'по дню'
when 1 then 'по году'
when 10 then 'произвольные зоны'
 else '' 
 end  
num_head_shema 
, b2g(num_head.instanceid) instanceid 
, num_head.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(num_head.num_headid) id 
, 'num_head' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Num_head
 join INSTANCE on Num_head.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonum_head_ru_ru
go
create view v_autonum_head_ru_ru as 
select   b2g(num_head. num_headid) num_headid,num_head. changestamp changestamp
, 
num_head.name 
num_head_name 
, 
 num_head.shema  
num_head_shema_val, 
 case num_head.shema 
when 2 then 'по кварталу'
when 3 then 'по месяцу'
when 0 then 'единая зона'
when 4 then 'по дню'
when 1 then 'по году'
when 10 then 'произвольные зоны'
 else '' 
 end  
num_head_shema 
, b2g(num_head.instanceid) instanceid 
, num_head.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(num_head.num_headid) id 
, 'num_head' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Num_head
 join INSTANCE on Num_head.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autonum_head_en_us
go
create view v_autonum_head_en_us as 
select   b2g(num_head. num_headid) num_headid,num_head. changestamp changestamp
, 
num_head.name 
num_head_name 
, 
 num_head.shema  
num_head_shema_val, 
 case num_head.shema 
when 2 then 'по кварталу'
when 3 then 'по месяцу'
when 0 then 'единая зона'
when 4 then 'по дню'
when 1 then 'по году'
when 10 then 'произвольные зоны'
 else '' 
 end  
num_head_shema 
, b2g(num_head.instanceid) instanceid 
, num_head.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(num_head.num_headid) id 
, 'num_head' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Num_head
 join INSTANCE on Num_head.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_filetype
go
create view v_autoiud_filetype as 
select   b2g(iud_filetype. iud_filetypeid) iud_filetypeid,iud_filetype. changestamp changestamp
, 
iud_filetype.name 
iud_filetype_name 
, 
 iud_filetype.allowtiming  
iud_filetype_allowtiming_val, 
 case iud_filetype.allowtiming 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iud_filetype_allowtiming 
, b2g(iud_filetype.instanceid) instanceid 
, iud_filetype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_filetype.iud_filetypeid) id 
, 'iud_filetype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_filetype
 join INSTANCE on iud_filetype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_filetype_ru_ru
go
create view v_autoiud_filetype_ru_ru as 
select   b2g(iud_filetype. iud_filetypeid) iud_filetypeid,iud_filetype. changestamp changestamp
, 
iud_filetype.name 
iud_filetype_name 
, 
 iud_filetype.allowtiming  
iud_filetype_allowtiming_val, 
 case iud_filetype.allowtiming 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iud_filetype_allowtiming 
, b2g(iud_filetype.instanceid) instanceid 
, iud_filetype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_filetype.iud_filetypeid) id 
, 'iud_filetype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_filetype
 join INSTANCE on iud_filetype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_filetype_en_us
go
create view v_autoiud_filetype_en_us as 
select   b2g(iud_filetype. iud_filetypeid) iud_filetypeid,iud_filetype. changestamp changestamp
, 
iud_filetype.name 
iud_filetype_name 
, 
 iud_filetype.allowtiming  
iud_filetype_allowtiming_val, 
 case iud_filetype.allowtiming 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iud_filetype_allowtiming 
, b2g(iud_filetype.instanceid) instanceid 
, iud_filetype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_filetype.iud_filetypeid) id 
, 'iud_filetype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_filetype
 join INSTANCE on iud_filetype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtzext_def
go
create view v_automtzext_def as 
select   b2g(mtzext_def. mtzext_defid) mtzext_defid,mtzext_def. changestamp changestamp
, 
mtzext_def.thedescription 
mtzext_def_thedescription 
, 
 mtzext_def.exttype  
mtzext_def_exttype_val, 
 case mtzext_def.exttype 
when 6 then 'verifyrowext'
when 7 then 'codegenerator'
when 5 then 'defaultext'
when 0 then 'statusext'
when 4 then 'jrnlrunext'
when 2 then 'customext'
when 8 then 'armgenerator'
when 1 then 'onformext'
when 3 then 'jrnladdext'
 else '' 
 end  
mtzext_def_exttype 
, 
mtzext_def.name 
mtzext_def_name 
, b2g(mtzext_def.instanceid) instanceid 
, mtzext_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtzext_def.mtzext_defid) id 
, 'mtzext_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZExt_def
 join INSTANCE on MTZExt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtzext_def_ru_ru
go
create view v_automtzext_def_ru_ru as 
select   b2g(mtzext_def. mtzext_defid) mtzext_defid,mtzext_def. changestamp changestamp
, 
mtzext_def.thedescription 
mtzext_def_thedescription 
, 
 mtzext_def.exttype  
mtzext_def_exttype_val, 
 case mtzext_def.exttype 
when 6 then 'verifyrowext'
when 7 then 'codegenerator'
when 5 then 'defaultext'
when 0 then 'statusext'
when 4 then 'jrnlrunext'
when 2 then 'customext'
when 8 then 'armgenerator'
when 1 then 'onformext'
when 3 then 'jrnladdext'
 else '' 
 end  
mtzext_def_exttype 
, 
mtzext_def.name 
mtzext_def_name 
, b2g(mtzext_def.instanceid) instanceid 
, mtzext_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtzext_def.mtzext_defid) id 
, 'mtzext_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZExt_def
 join INSTANCE on MTZExt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtzext_def_en_us
go
create view v_automtzext_def_en_us as 
select   b2g(mtzext_def. mtzext_defid) mtzext_defid,mtzext_def. changestamp changestamp
, 
mtzext_def.thedescription 
mtzext_def_thedescription 
, 
 mtzext_def.exttype  
mtzext_def_exttype_val, 
 case mtzext_def.exttype 
when 6 then 'verifyrowext'
when 7 then 'codegenerator'
when 5 then 'defaultext'
when 0 then 'statusext'
when 4 then 'jrnlrunext'
when 2 then 'customext'
when 8 then 'armgenerator'
when 1 then 'onformext'
when 3 then 'jrnladdext'
 else '' 
 end  
mtzext_def_exttype 
, 
mtzext_def.name 
mtzext_def_name 
, b2g(mtzext_def.instanceid) instanceid 
, mtzext_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtzext_def.mtzext_defid) id 
, 'mtzext_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZExt_def
 join INSTANCE on MTZExt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtzextrel
go
create view v_automtzextrel as 
select   b2g(mtzextrel. mtzextrelid) mtzextrelid,mtzextrel. changestamp changestamp
, 
mtzextrel.theclassname 
mtzextrel_theclassname 
, 
 mtzextrel.theplatform  
mtzextrel_theplatform_val, 
 case mtzextrel.theplatform 
when 3 then 'other'
when 1 then 'dotnet'
when 2 then 'java'
when 0 then 'vb6'
 else '' 
 end  
mtzextrel_theplatform 
, 
mtzextrel.thelibraryname 
mtzextrel_thelibraryname 
, b2g(mtzextrel.instanceid) instanceid 
, mtzextrel.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtzextrel.mtzextrelid) id 
, 'mtzextrel' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZExtRel
 join INSTANCE on MTZExtRel.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtzextrel_ru_ru
go
create view v_automtzextrel_ru_ru as 
select   b2g(mtzextrel. mtzextrelid) mtzextrelid,mtzextrel. changestamp changestamp
, 
mtzextrel.theclassname 
mtzextrel_theclassname 
, 
 mtzextrel.theplatform  
mtzextrel_theplatform_val, 
 case mtzextrel.theplatform 
when 3 then 'other'
when 1 then 'dotnet'
when 2 then 'java'
when 0 then 'vb6'
 else '' 
 end  
mtzextrel_theplatform 
, 
mtzextrel.thelibraryname 
mtzextrel_thelibraryname 
, b2g(mtzextrel.instanceid) instanceid 
, mtzextrel.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtzextrel.mtzextrelid) id 
, 'mtzextrel' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZExtRel
 join INSTANCE on MTZExtRel.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtzextrel_en_us
go
create view v_automtzextrel_en_us as 
select   b2g(mtzextrel. mtzextrelid) mtzextrelid,mtzextrel. changestamp changestamp
, 
mtzextrel.theclassname 
mtzextrel_theclassname 
, 
 mtzextrel.theplatform  
mtzextrel_theplatform_val, 
 case mtzextrel.theplatform 
when 3 then 'other'
when 1 then 'dotnet'
when 2 then 'java'
when 0 then 'vb6'
 else '' 
 end  
mtzextrel_theplatform 
, 
mtzextrel.thelibraryname 
mtzextrel_thelibraryname 
, b2g(mtzextrel.instanceid) instanceid 
, mtzextrel.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtzextrel.mtzextrelid) id 
, 'mtzextrel' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZExtRel
 join INSTANCE on MTZExtRel.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_videotype
go
create view v_autoiud_videotype as 
select   b2g(iud_videotype. iud_videotypeid) iud_videotypeid,iud_videotype. changestamp changestamp
, 
 iud_videotype.nocomments  
iud_videotype_nocomments_val, 
 case iud_videotype.nocomments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iud_videotype_nocomments 
, 
iud_videotype.name 
iud_videotype_name 
, 
 b2g(iud_videotype.versionpolicy)  
iud_videotype_versionpolicy_id, 
 iud_filestoretype_brief_f(iud_videotype.versionpolicy, null) 
iud_videotype_versionpolicy 
, 
iud_videotype.sequence 
iud_videotype_sequence 
, 
 b2g(iud_videotype.filetype)  
iud_videotype_filetype_id, 
 iud_filetype_brief_f(iud_videotype.filetype, null) 
iud_videotype_filetype 
, b2g(iud_videotype.instanceid) instanceid 
, iud_videotype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_videotype.iud_videotypeid) id 
, 'iud_videotype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_videotype
 join INSTANCE on iud_videotype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_videotype_ru_ru
go
create view v_autoiud_videotype_ru_ru as 
select   b2g(iud_videotype. iud_videotypeid) iud_videotypeid,iud_videotype. changestamp changestamp
, 
 iud_videotype.nocomments  
iud_videotype_nocomments_val, 
 case iud_videotype.nocomments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iud_videotype_nocomments 
, 
iud_videotype.name 
iud_videotype_name 
, 
 b2g(iud_videotype.versionpolicy)  
iud_videotype_versionpolicy_id, 
 iud_filestoretype_brief_f(iud_videotype.versionpolicy, 'ru_ru') 
iud_videotype_versionpolicy 
, 
iud_videotype.sequence 
iud_videotype_sequence 
, 
 b2g(iud_videotype.filetype)  
iud_videotype_filetype_id, 
 iud_filetype_brief_f(iud_videotype.filetype, 'ru_ru') 
iud_videotype_filetype 
, b2g(iud_videotype.instanceid) instanceid 
, iud_videotype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_videotype.iud_videotypeid) id 
, 'iud_videotype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_videotype
 join INSTANCE on iud_videotype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_videotype_en_us
go
create view v_autoiud_videotype_en_us as 
select   b2g(iud_videotype. iud_videotypeid) iud_videotypeid,iud_videotype. changestamp changestamp
, 
 iud_videotype.nocomments  
iud_videotype_nocomments_val, 
 case iud_videotype.nocomments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iud_videotype_nocomments 
, 
iud_videotype.name 
iud_videotype_name 
, 
 b2g(iud_videotype.versionpolicy)  
iud_videotype_versionpolicy_id, 
 iud_filestoretype_brief_f(iud_videotype.versionpolicy, 'en_us') 
iud_videotype_versionpolicy 
, 
iud_videotype.sequence 
iud_videotype_sequence 
, 
 b2g(iud_videotype.filetype)  
iud_videotype_filetype_id, 
 iud_filetype_brief_f(iud_videotype.filetype, 'en_us') 
iud_videotype_filetype 
, b2g(iud_videotype.instanceid) instanceid 
, iud_videotype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_videotype.iud_videotypeid) id 
, 'iud_videotype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_videotype
 join INSTANCE on iud_videotype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_cm_def
go
create view v_autoiu_cm_def as 
select   b2g(iu_cm_def. iu_cm_defid) iu_cm_defid,iu_cm_def. changestamp changestamp
, 
 b2g(iu_cm_def.thedoc)  
iu_cm_def_thedoc_id, 
 iu_urok_docs_brief_f(iu_cm_def.thedoc, null) 
iu_cm_def_thedoc 
, 
 b2g(iu_cm_def.theauthor)  
iu_cm_def_theauthor_id, 
 iu_u_def_brief_f(iu_cm_def.theauthor, null) 
iu_cm_def_theauthor 
, 
iu_cm_def.thedate 
iu_cm_def_thedate 
, 
 b2g(iu_cm_def.theprocess)  
iu_cm_def_theprocess_id, 
 iu_urok_def_brief_f(iu_cm_def.theprocess, null) 
iu_cm_def_theprocess 
, 
 b2g(iu_cm_def.thevideo)  
iu_cm_def_thevideo_id, 
 iu_urok_video_brief_f(iu_cm_def.thevideo, null) 
iu_cm_def_thevideo 
, 
 iu_cm_def.isdiscussion  
iu_cm_def_isdiscussion_val, 
 case iu_cm_def.isdiscussion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_cm_def_isdiscussion 
, 
iu_cm_def.thetheme 
iu_cm_def_thetheme 
, b2g(iu_cm_def.instanceid) instanceid 
, iu_cm_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_cm_def.iu_cm_defid) id 
, 'iu_cm_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_cm_def
 join INSTANCE on iu_cm_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_cm_def_ru_ru
go
create view v_autoiu_cm_def_ru_ru as 
select   b2g(iu_cm_def. iu_cm_defid) iu_cm_defid,iu_cm_def. changestamp changestamp
, 
 b2g(iu_cm_def.thedoc)  
iu_cm_def_thedoc_id, 
 iu_urok_docs_brief_f(iu_cm_def.thedoc, 'ru_ru') 
iu_cm_def_thedoc 
, 
 b2g(iu_cm_def.theauthor)  
iu_cm_def_theauthor_id, 
 iu_u_def_brief_f(iu_cm_def.theauthor, 'ru_ru') 
iu_cm_def_theauthor 
, 
iu_cm_def.thedate 
iu_cm_def_thedate 
, 
 b2g(iu_cm_def.theprocess)  
iu_cm_def_theprocess_id, 
 iu_urok_def_brief_f(iu_cm_def.theprocess, 'ru_ru') 
iu_cm_def_theprocess 
, 
 b2g(iu_cm_def.thevideo)  
iu_cm_def_thevideo_id, 
 iu_urok_video_brief_f(iu_cm_def.thevideo, 'ru_ru') 
iu_cm_def_thevideo 
, 
 iu_cm_def.isdiscussion  
iu_cm_def_isdiscussion_val, 
 case iu_cm_def.isdiscussion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_cm_def_isdiscussion 
, 
iu_cm_def.thetheme 
iu_cm_def_thetheme 
, b2g(iu_cm_def.instanceid) instanceid 
, iu_cm_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_cm_def.iu_cm_defid) id 
, 'iu_cm_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_cm_def
 join INSTANCE on iu_cm_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_cm_def_en_us
go
create view v_autoiu_cm_def_en_us as 
select   b2g(iu_cm_def. iu_cm_defid) iu_cm_defid,iu_cm_def. changestamp changestamp
, 
 b2g(iu_cm_def.thedoc)  
iu_cm_def_thedoc_id, 
 iu_urok_docs_brief_f(iu_cm_def.thedoc, 'en_us') 
iu_cm_def_thedoc 
, 
 b2g(iu_cm_def.theauthor)  
iu_cm_def_theauthor_id, 
 iu_u_def_brief_f(iu_cm_def.theauthor, 'en_us') 
iu_cm_def_theauthor 
, 
iu_cm_def.thedate 
iu_cm_def_thedate 
, 
 b2g(iu_cm_def.theprocess)  
iu_cm_def_theprocess_id, 
 iu_urok_def_brief_f(iu_cm_def.theprocess, 'en_us') 
iu_cm_def_theprocess 
, 
 b2g(iu_cm_def.thevideo)  
iu_cm_def_thevideo_id, 
 iu_urok_video_brief_f(iu_cm_def.thevideo, 'en_us') 
iu_cm_def_thevideo 
, 
 iu_cm_def.isdiscussion  
iu_cm_def_isdiscussion_val, 
 case iu_cm_def.isdiscussion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_cm_def_isdiscussion 
, 
iu_cm_def.thetheme 
iu_cm_def_thetheme 
, b2g(iu_cm_def.instanceid) instanceid 
, iu_cm_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_cm_def.iu_cm_defid) id 
, 'iu_cm_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_cm_def
 join INSTANCE on iu_cm_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_cm_time
go
create view v_autoiu_cm_time as 
select   b2g(iu_cm_time. iu_cm_timeid) iu_cm_timeid,iu_cm_time. changestamp changestamp
, 
iu_cm_time.theref 
iu_cm_time_theref 
, 
iu_cm_time.thefile 
iu_cm_time_thefile 
, 
iu_cm_time.thedate 
iu_cm_time_thedate 
, 
iu_cm_time.info 
iu_cm_time_info 
, 
iu_cm_time.endtime 
iu_cm_time_endtime 
, 
 iu_cm_time.ischecked  
iu_cm_time_ischecked_val, 
 case iu_cm_time.ischecked 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_cm_time_ischecked 
, 
 iu_cm_time.curatoronly  
iu_cm_time_curatoronly_val, 
 case iu_cm_time.curatoronly 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_cm_time_curatoronly 
, 
 b2g(iu_cm_time.theauthor)  
iu_cm_time_theauthor_id, 
 iu_u_def_brief_f(iu_cm_time.theauthor, null) 
iu_cm_time_theauthor 
, 
iu_cm_time.starttime 
iu_cm_time_starttime 
, 
 b2g(iu_cm_time.messagetype)  
iu_cm_time_messagetype_id, 
 iud_mt_def_brief_f(iu_cm_time.messagetype, null) 
iu_cm_time_messagetype 
, b2g(iu_cm_time.instanceid) instanceid 
, iu_cm_time.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_cm_time.iu_cm_timeid) id 
, 'iu_cm_time' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_cm_time
 join INSTANCE on iu_cm_time.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_cm_time_ru_ru
go
create view v_autoiu_cm_time_ru_ru as 
select   b2g(iu_cm_time. iu_cm_timeid) iu_cm_timeid,iu_cm_time. changestamp changestamp
, 
iu_cm_time.theref 
iu_cm_time_theref 
, 
iu_cm_time.thefile 
iu_cm_time_thefile 
, 
iu_cm_time.thedate 
iu_cm_time_thedate 
, 
iu_cm_time.info 
iu_cm_time_info 
, 
iu_cm_time.endtime 
iu_cm_time_endtime 
, 
 iu_cm_time.ischecked  
iu_cm_time_ischecked_val, 
 case iu_cm_time.ischecked 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_cm_time_ischecked 
, 
 iu_cm_time.curatoronly  
iu_cm_time_curatoronly_val, 
 case iu_cm_time.curatoronly 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_cm_time_curatoronly 
, 
 b2g(iu_cm_time.theauthor)  
iu_cm_time_theauthor_id, 
 iu_u_def_brief_f(iu_cm_time.theauthor, 'ru_ru') 
iu_cm_time_theauthor 
, 
iu_cm_time.starttime 
iu_cm_time_starttime 
, 
 b2g(iu_cm_time.messagetype)  
iu_cm_time_messagetype_id, 
 iud_mt_def_brief_f(iu_cm_time.messagetype, 'ru_ru') 
iu_cm_time_messagetype 
, b2g(iu_cm_time.instanceid) instanceid 
, iu_cm_time.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_cm_time.iu_cm_timeid) id 
, 'iu_cm_time' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_cm_time
 join INSTANCE on iu_cm_time.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_cm_time_en_us
go
create view v_autoiu_cm_time_en_us as 
select   b2g(iu_cm_time. iu_cm_timeid) iu_cm_timeid,iu_cm_time. changestamp changestamp
, 
iu_cm_time.theref 
iu_cm_time_theref 
, 
iu_cm_time.thefile 
iu_cm_time_thefile 
, 
iu_cm_time.thedate 
iu_cm_time_thedate 
, 
iu_cm_time.info 
iu_cm_time_info 
, 
iu_cm_time.endtime 
iu_cm_time_endtime 
, 
 iu_cm_time.ischecked  
iu_cm_time_ischecked_val, 
 case iu_cm_time.ischecked 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_cm_time_ischecked 
, 
 iu_cm_time.curatoronly  
iu_cm_time_curatoronly_val, 
 case iu_cm_time.curatoronly 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_cm_time_curatoronly 
, 
 b2g(iu_cm_time.theauthor)  
iu_cm_time_theauthor_id, 
 iu_u_def_brief_f(iu_cm_time.theauthor, 'en_us') 
iu_cm_time_theauthor 
, 
iu_cm_time.starttime 
iu_cm_time_starttime 
, 
 b2g(iu_cm_time.messagetype)  
iu_cm_time_messagetype_id, 
 iud_mt_def_brief_f(iu_cm_time.messagetype, 'en_us') 
iu_cm_time_messagetype 
, b2g(iu_cm_time.instanceid) instanceid 
, iu_cm_time.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_cm_time.iu_cm_timeid) id 
, 'iu_cm_time' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_cm_time
 join INSTANCE on iu_cm_time.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_cm_msg
go
create view v_autoiu_cm_msg as 
select   b2g(iu_cm_msg. iu_cm_msgid) iu_cm_msgid,iu_cm_msg. changestamp changestamp
, 
 b2g(iu_cm_msg.theauthor)  
iu_cm_msg_theauthor_id, 
 iu_u_def_brief_f(iu_cm_msg.theauthor, null) 
iu_cm_msg_theauthor 
, 
iu_cm_msg.info 
iu_cm_msg_info 
, 
iu_cm_msg.thefile 
iu_cm_msg_thefile 
, 
 b2g(iu_cm_msg.messagetype)  
iu_cm_msg_messagetype_id, 
 iud_mt_def_brief_f(iu_cm_msg.messagetype, null) 
iu_cm_msg_messagetype 
, 
iu_cm_msg.theref 
iu_cm_msg_theref 
, 
iu_cm_msg.thedate 
iu_cm_msg_thedate 
, b2g(iu_cm_msg.instanceid) instanceid 
, iu_cm_msg.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_cm_msg.iu_cm_msgid) id 
, 'iu_cm_msg' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_cm_msg
 join INSTANCE on iu_cm_msg.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_cm_msg_ru_ru
go
create view v_autoiu_cm_msg_ru_ru as 
select   b2g(iu_cm_msg. iu_cm_msgid) iu_cm_msgid,iu_cm_msg. changestamp changestamp
, 
 b2g(iu_cm_msg.theauthor)  
iu_cm_msg_theauthor_id, 
 iu_u_def_brief_f(iu_cm_msg.theauthor, 'ru_ru') 
iu_cm_msg_theauthor 
, 
iu_cm_msg.info 
iu_cm_msg_info 
, 
iu_cm_msg.thefile 
iu_cm_msg_thefile 
, 
 b2g(iu_cm_msg.messagetype)  
iu_cm_msg_messagetype_id, 
 iud_mt_def_brief_f(iu_cm_msg.messagetype, 'ru_ru') 
iu_cm_msg_messagetype 
, 
iu_cm_msg.theref 
iu_cm_msg_theref 
, 
iu_cm_msg.thedate 
iu_cm_msg_thedate 
, b2g(iu_cm_msg.instanceid) instanceid 
, iu_cm_msg.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_cm_msg.iu_cm_msgid) id 
, 'iu_cm_msg' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_cm_msg
 join INSTANCE on iu_cm_msg.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_cm_msg_en_us
go
create view v_autoiu_cm_msg_en_us as 
select   b2g(iu_cm_msg. iu_cm_msgid) iu_cm_msgid,iu_cm_msg. changestamp changestamp
, 
 b2g(iu_cm_msg.theauthor)  
iu_cm_msg_theauthor_id, 
 iu_u_def_brief_f(iu_cm_msg.theauthor, 'en_us') 
iu_cm_msg_theauthor 
, 
iu_cm_msg.info 
iu_cm_msg_info 
, 
iu_cm_msg.thefile 
iu_cm_msg_thefile 
, 
 b2g(iu_cm_msg.messagetype)  
iu_cm_msg_messagetype_id, 
 iud_mt_def_brief_f(iu_cm_msg.messagetype, 'en_us') 
iu_cm_msg_messagetype 
, 
iu_cm_msg.theref 
iu_cm_msg_theref 
, 
iu_cm_msg.thedate 
iu_cm_msg_thedate 
, b2g(iu_cm_msg.instanceid) instanceid 
, iu_cm_msg.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_cm_msg.iu_cm_msgid) id 
, 'iu_cm_msg' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_cm_msg
 join INSTANCE on iu_cm_msg.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_plevent
go
create view v_autoiu_plevent as 
select   b2g(iu_plevent. iu_pleventid) iu_pleventid,iu_plevent. changestamp changestamp
, 
 b2g(iu_plevent.thediscussion)  
iu_plevent_thediscussion_id, 
 iu_cm_def_brief_f(iu_plevent.thediscussion, null) 
iu_plevent_thediscussion 
, 
 b2g(iu_plevent.doer)  
iu_plevent_doer_id, 
 iu_u_def_brief_f(iu_plevent.doer, null) 
iu_plevent_doer 
, 
iu_plevent.info 
iu_plevent_info 
, 
iu_plevent.createdate 
iu_plevent_createdate 
, 
iu_plevent.eventtype 
iu_plevent_eventtype 
, 
 b2g(iu_plevent.theprocess)  
iu_plevent_theprocess_id, 
 iu_urok_def_brief_f(iu_plevent.theprocess, null) 
iu_plevent_theprocess 
, 
 b2g(iu_plevent.statetask)  
iu_plevent_statetask_id, 
 iu_task_brief_f(iu_plevent.statetask, null) 
iu_plevent_statetask 
, 
 b2g(iu_plevent.thedoc)  
iu_plevent_thedoc_id, 
 iu_urok_docs_brief_f(iu_plevent.thedoc, null) 
iu_plevent_thedoc 
, 
 b2g(iu_plevent.processstatus)  
iu_plevent_processstatus_id, 
 iu_status_brief_f(iu_plevent.processstatus, null) 
iu_plevent_processstatus 
, 
 b2g(iu_plevent.thevideo)  
iu_plevent_thevideo_id, 
 iu_urok_video_brief_f(iu_plevent.thevideo, null) 
iu_plevent_thevideo 
, b2g(iu_plevent.instanceid) instanceid 
, iu_plevent.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_plevent.iu_pleventid) id 
, 'iu_plevent' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_plevent
 join INSTANCE on iu_plevent.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_plevent_ru_ru
go
create view v_autoiu_plevent_ru_ru as 
select   b2g(iu_plevent. iu_pleventid) iu_pleventid,iu_plevent. changestamp changestamp
, 
 b2g(iu_plevent.thediscussion)  
iu_plevent_thediscussion_id, 
 iu_cm_def_brief_f(iu_plevent.thediscussion, 'ru_ru') 
iu_plevent_thediscussion 
, 
 b2g(iu_plevent.doer)  
iu_plevent_doer_id, 
 iu_u_def_brief_f(iu_plevent.doer, 'ru_ru') 
iu_plevent_doer 
, 
iu_plevent.info 
iu_plevent_info 
, 
iu_plevent.createdate 
iu_plevent_createdate 
, 
iu_plevent.eventtype 
iu_plevent_eventtype 
, 
 b2g(iu_plevent.theprocess)  
iu_plevent_theprocess_id, 
 iu_urok_def_brief_f(iu_plevent.theprocess, 'ru_ru') 
iu_plevent_theprocess 
, 
 b2g(iu_plevent.statetask)  
iu_plevent_statetask_id, 
 iu_task_brief_f(iu_plevent.statetask, 'ru_ru') 
iu_plevent_statetask 
, 
 b2g(iu_plevent.thedoc)  
iu_plevent_thedoc_id, 
 iu_urok_docs_brief_f(iu_plevent.thedoc, 'ru_ru') 
iu_plevent_thedoc 
, 
 b2g(iu_plevent.processstatus)  
iu_plevent_processstatus_id, 
 iu_status_brief_f(iu_plevent.processstatus, 'ru_ru') 
iu_plevent_processstatus 
, 
 b2g(iu_plevent.thevideo)  
iu_plevent_thevideo_id, 
 iu_urok_video_brief_f(iu_plevent.thevideo, 'ru_ru') 
iu_plevent_thevideo 
, b2g(iu_plevent.instanceid) instanceid 
, iu_plevent.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_plevent.iu_pleventid) id 
, 'iu_plevent' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_plevent
 join INSTANCE on iu_plevent.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_plevent_en_us
go
create view v_autoiu_plevent_en_us as 
select   b2g(iu_plevent. iu_pleventid) iu_pleventid,iu_plevent. changestamp changestamp
, 
 b2g(iu_plevent.thediscussion)  
iu_plevent_thediscussion_id, 
 iu_cm_def_brief_f(iu_plevent.thediscussion, 'en_us') 
iu_plevent_thediscussion 
, 
 b2g(iu_plevent.doer)  
iu_plevent_doer_id, 
 iu_u_def_brief_f(iu_plevent.doer, 'en_us') 
iu_plevent_doer 
, 
iu_plevent.info 
iu_plevent_info 
, 
iu_plevent.createdate 
iu_plevent_createdate 
, 
iu_plevent.eventtype 
iu_plevent_eventtype 
, 
 b2g(iu_plevent.theprocess)  
iu_plevent_theprocess_id, 
 iu_urok_def_brief_f(iu_plevent.theprocess, 'en_us') 
iu_plevent_theprocess 
, 
 b2g(iu_plevent.statetask)  
iu_plevent_statetask_id, 
 iu_task_brief_f(iu_plevent.statetask, 'en_us') 
iu_plevent_statetask 
, 
 b2g(iu_plevent.thedoc)  
iu_plevent_thedoc_id, 
 iu_urok_docs_brief_f(iu_plevent.thedoc, 'en_us') 
iu_plevent_thedoc 
, 
 b2g(iu_plevent.processstatus)  
iu_plevent_processstatus_id, 
 iu_status_brief_f(iu_plevent.processstatus, 'en_us') 
iu_plevent_processstatus 
, 
 b2g(iu_plevent.thevideo)  
iu_plevent_thevideo_id, 
 iu_urok_video_brief_f(iu_plevent.thevideo, 'en_us') 
iu_plevent_thevideo 
, b2g(iu_plevent.instanceid) instanceid 
, iu_plevent.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_plevent.iu_pleventid) id 
, 'iu_plevent' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_plevent
 join INSTANCE on iu_plevent.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rcfg_mod
go
create view v_autoiu_rcfg_mod as 
select   b2g(iu_rcfg_mod. iu_rcfg_modid) iu_rcfg_modid,iu_rcfg_mod. changestamp changestamp
, 
 iu_rcfg_mod.tmobjects  
iu_rcfg_mod_tmobjects_val, 
 case iu_rcfg_mod.tmobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_tmobjects 
, 
iu_rcfg_mod.name 
iu_rcfg_mod_name 
, 
iu_rcfg_mod.mydocmode 
iu_rcfg_mod_mydocmode 
, 
iu_rcfg_mod.sequence 
iu_rcfg_mod_sequence 
, 
 iu_rcfg_mod.substructobjects  
iu_rcfg_mod_substructobjects_val, 
 case iu_rcfg_mod.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_substructobjects 
, 
iu_rcfg_mod.controldocmode 
iu_rcfg_mod_controldocmode 
, 
iu_rcfg_mod.groupname 
iu_rcfg_mod_groupname 
, 
iu_rcfg_mod.caption 
iu_rcfg_mod_caption 
, 
 iu_rcfg_mod.allobjects  
iu_rcfg_mod_allobjects_val, 
 case iu_rcfg_mod.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_allobjects 
, 
 iu_rcfg_mod.visiblecontrol  
iu_rcfg_mod_visiblecontrol_val, 
 case iu_rcfg_mod.visiblecontrol 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_visiblecontrol 
, 
 iu_rcfg_mod.colegsobject  
iu_rcfg_mod_colegsobject_val, 
 case iu_rcfg_mod.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_colegsobject 
, 
 iu_rcfg_mod.moduleaccessible  
iu_rcfg_mod_moduleaccessible_val, 
 case iu_rcfg_mod.moduleaccessible 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_moduleaccessible 
, 
iu_rcfg_mod.otherdocmode 
iu_rcfg_mod_otherdocmode 
, 
iu_rcfg_mod.theicon 
iu_rcfg_mod_theicon 
, b2g(iu_rcfg_mod.instanceid) instanceid 
, iu_rcfg_mod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_rcfg_mod.iu_rcfg_modid) id 
, 'iu_rcfg_mod' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_rcfg_mod
 join INSTANCE on iu_rcfg_mod.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rcfg_mod_ru_ru
go
create view v_autoiu_rcfg_mod_ru_ru as 
select   b2g(iu_rcfg_mod. iu_rcfg_modid) iu_rcfg_modid,iu_rcfg_mod. changestamp changestamp
, 
 iu_rcfg_mod.tmobjects  
iu_rcfg_mod_tmobjects_val, 
 case iu_rcfg_mod.tmobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_tmobjects 
, 
iu_rcfg_mod.name 
iu_rcfg_mod_name 
, 
iu_rcfg_mod.mydocmode 
iu_rcfg_mod_mydocmode 
, 
iu_rcfg_mod.sequence 
iu_rcfg_mod_sequence 
, 
 iu_rcfg_mod.substructobjects  
iu_rcfg_mod_substructobjects_val, 
 case iu_rcfg_mod.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_substructobjects 
, 
iu_rcfg_mod.controldocmode 
iu_rcfg_mod_controldocmode 
, 
iu_rcfg_mod.groupname 
iu_rcfg_mod_groupname 
, 
iu_rcfg_mod.caption 
iu_rcfg_mod_caption 
, 
 iu_rcfg_mod.allobjects  
iu_rcfg_mod_allobjects_val, 
 case iu_rcfg_mod.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_allobjects 
, 
 iu_rcfg_mod.visiblecontrol  
iu_rcfg_mod_visiblecontrol_val, 
 case iu_rcfg_mod.visiblecontrol 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_visiblecontrol 
, 
 iu_rcfg_mod.colegsobject  
iu_rcfg_mod_colegsobject_val, 
 case iu_rcfg_mod.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_colegsobject 
, 
 iu_rcfg_mod.moduleaccessible  
iu_rcfg_mod_moduleaccessible_val, 
 case iu_rcfg_mod.moduleaccessible 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_moduleaccessible 
, 
iu_rcfg_mod.otherdocmode 
iu_rcfg_mod_otherdocmode 
, 
iu_rcfg_mod.theicon 
iu_rcfg_mod_theicon 
, b2g(iu_rcfg_mod.instanceid) instanceid 
, iu_rcfg_mod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_rcfg_mod.iu_rcfg_modid) id 
, 'iu_rcfg_mod' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_rcfg_mod
 join INSTANCE on iu_rcfg_mod.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rcfg_mod_en_us
go
create view v_autoiu_rcfg_mod_en_us as 
select   b2g(iu_rcfg_mod. iu_rcfg_modid) iu_rcfg_modid,iu_rcfg_mod. changestamp changestamp
, 
 iu_rcfg_mod.tmobjects  
iu_rcfg_mod_tmobjects_val, 
 case iu_rcfg_mod.tmobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_tmobjects 
, 
iu_rcfg_mod.name 
iu_rcfg_mod_name 
, 
iu_rcfg_mod.mydocmode 
iu_rcfg_mod_mydocmode 
, 
iu_rcfg_mod.sequence 
iu_rcfg_mod_sequence 
, 
 iu_rcfg_mod.substructobjects  
iu_rcfg_mod_substructobjects_val, 
 case iu_rcfg_mod.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_substructobjects 
, 
iu_rcfg_mod.controldocmode 
iu_rcfg_mod_controldocmode 
, 
iu_rcfg_mod.groupname 
iu_rcfg_mod_groupname 
, 
iu_rcfg_mod.caption 
iu_rcfg_mod_caption 
, 
 iu_rcfg_mod.allobjects  
iu_rcfg_mod_allobjects_val, 
 case iu_rcfg_mod.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_allobjects 
, 
 iu_rcfg_mod.visiblecontrol  
iu_rcfg_mod_visiblecontrol_val, 
 case iu_rcfg_mod.visiblecontrol 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_visiblecontrol 
, 
 iu_rcfg_mod.colegsobject  
iu_rcfg_mod_colegsobject_val, 
 case iu_rcfg_mod.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_colegsobject 
, 
 iu_rcfg_mod.moduleaccessible  
iu_rcfg_mod_moduleaccessible_val, 
 case iu_rcfg_mod.moduleaccessible 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_mod_moduleaccessible 
, 
iu_rcfg_mod.otherdocmode 
iu_rcfg_mod_otherdocmode 
, 
iu_rcfg_mod.theicon 
iu_rcfg_mod_theicon 
, b2g(iu_rcfg_mod.instanceid) instanceid 
, iu_rcfg_mod.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_rcfg_mod.iu_rcfg_modid) id 
, 'iu_rcfg_mod' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_rcfg_mod
 join INSTANCE on iu_rcfg_mod.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rcfg_docmode
go
create view v_autoiu_rcfg_docmode as 
select   b2g(iu_rcfg_docmode. iu_rcfg_docmodeid) iu_rcfg_docmodeid,iu_rcfg_docmode. changestamp changestamp
, 
 iu_rcfg_docmode.allowdelete  
iu_rcfg_docmode_allowdelete_val, 
 case iu_rcfg_docmode.allowdelete 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_docmode_allowdelete 
, 
iu_rcfg_docmode.addmode 
iu_rcfg_docmode_addmode 
, 
 iu_rcfg_docmode.allowdelegate  
iu_rcfg_docmode_allowdelegate_val, 
 case iu_rcfg_docmode.allowdelegate 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_docmode_allowdelegate 
, 
iu_rcfg_docmode.editmode 
iu_rcfg_docmode_editmode 
, 
 b2g(iu_rcfg_docmode.the_document)  
iu_rcfg_docmode_the_document_id, 
 objecttype_brief_f(iu_rcfg_docmode.the_document, null) 
iu_rcfg_docmode_the_document 
, 
 iu_rcfg_docmode.allowadd  
iu_rcfg_docmode_allowadd_val, 
 case iu_rcfg_docmode.allowadd 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_docmode_allowadd 
, b2g(iu_rcfg_docmode.instanceid) instanceid 
, iu_rcfg_docmode.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_rcfg_docmode.iu_rcfg_docmodeid) id 
, 'iu_rcfg_docmode' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_rcfg_docmode
 join INSTANCE on iu_rcfg_docmode.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rcfg_docmode_ru_ru
go
create view v_autoiu_rcfg_docmode_ru_ru as 
select   b2g(iu_rcfg_docmode. iu_rcfg_docmodeid) iu_rcfg_docmodeid,iu_rcfg_docmode. changestamp changestamp
, 
 iu_rcfg_docmode.allowdelete  
iu_rcfg_docmode_allowdelete_val, 
 case iu_rcfg_docmode.allowdelete 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_docmode_allowdelete 
, 
iu_rcfg_docmode.addmode 
iu_rcfg_docmode_addmode 
, 
 iu_rcfg_docmode.allowdelegate  
iu_rcfg_docmode_allowdelegate_val, 
 case iu_rcfg_docmode.allowdelegate 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_docmode_allowdelegate 
, 
iu_rcfg_docmode.editmode 
iu_rcfg_docmode_editmode 
, 
 b2g(iu_rcfg_docmode.the_document)  
iu_rcfg_docmode_the_document_id, 
 objecttype_brief_f(iu_rcfg_docmode.the_document, 'ru_ru') 
iu_rcfg_docmode_the_document 
, 
 iu_rcfg_docmode.allowadd  
iu_rcfg_docmode_allowadd_val, 
 case iu_rcfg_docmode.allowadd 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_docmode_allowadd 
, b2g(iu_rcfg_docmode.instanceid) instanceid 
, iu_rcfg_docmode.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_rcfg_docmode.iu_rcfg_docmodeid) id 
, 'iu_rcfg_docmode' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_rcfg_docmode
 join INSTANCE on iu_rcfg_docmode.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rcfg_docmode_en_us
go
create view v_autoiu_rcfg_docmode_en_us as 
select   b2g(iu_rcfg_docmode. iu_rcfg_docmodeid) iu_rcfg_docmodeid,iu_rcfg_docmode. changestamp changestamp
, 
 iu_rcfg_docmode.allowdelete  
iu_rcfg_docmode_allowdelete_val, 
 case iu_rcfg_docmode.allowdelete 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_docmode_allowdelete 
, 
iu_rcfg_docmode.addmode 
iu_rcfg_docmode_addmode 
, 
 iu_rcfg_docmode.allowdelegate  
iu_rcfg_docmode_allowdelegate_val, 
 case iu_rcfg_docmode.allowdelegate 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_docmode_allowdelegate 
, 
iu_rcfg_docmode.editmode 
iu_rcfg_docmode_editmode 
, 
 b2g(iu_rcfg_docmode.the_document)  
iu_rcfg_docmode_the_document_id, 
 objecttype_brief_f(iu_rcfg_docmode.the_document, 'en_us') 
iu_rcfg_docmode_the_document 
, 
 iu_rcfg_docmode.allowadd  
iu_rcfg_docmode_allowadd_val, 
 case iu_rcfg_docmode.allowadd 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_rcfg_docmode_allowadd 
, b2g(iu_rcfg_docmode.instanceid) instanceid 
, iu_rcfg_docmode.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_rcfg_docmode.iu_rcfg_docmodeid) id 
, 'iu_rcfg_docmode' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_rcfg_docmode
 join INSTANCE on iu_rcfg_docmode.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rcfg_def
go
create view v_autoiu_rcfg_def as 
select   b2g(iu_rcfg_def. iu_rcfg_defid) iu_rcfg_defid,iu_rcfg_def. changestamp changestamp
, 
 b2g(iu_rcfg_def.therole)  
iu_rcfg_def_therole_id, 
 iu_crole_brief_f(iu_rcfg_def.therole, null) 
iu_rcfg_def_therole 
, b2g(iu_rcfg_def.instanceid) instanceid 
, iu_rcfg_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_rcfg_def.iu_rcfg_defid) id 
, 'iu_rcfg_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_rcfg_def
 join INSTANCE on iu_rcfg_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rcfg_def_ru_ru
go
create view v_autoiu_rcfg_def_ru_ru as 
select   b2g(iu_rcfg_def. iu_rcfg_defid) iu_rcfg_defid,iu_rcfg_def. changestamp changestamp
, 
 b2g(iu_rcfg_def.therole)  
iu_rcfg_def_therole_id, 
 iu_crole_brief_f(iu_rcfg_def.therole, 'ru_ru') 
iu_rcfg_def_therole 
, b2g(iu_rcfg_def.instanceid) instanceid 
, iu_rcfg_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_rcfg_def.iu_rcfg_defid) id 
, 'iu_rcfg_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_rcfg_def
 join INSTANCE on iu_rcfg_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_rcfg_def_en_us
go
create view v_autoiu_rcfg_def_en_us as 
select   b2g(iu_rcfg_def. iu_rcfg_defid) iu_rcfg_defid,iu_rcfg_def. changestamp changestamp
, 
 b2g(iu_rcfg_def.therole)  
iu_rcfg_def_therole_id, 
 iu_crole_brief_f(iu_rcfg_def.therole, 'en_us') 
iu_rcfg_def_therole 
, b2g(iu_rcfg_def.instanceid) instanceid 
, iu_rcfg_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_rcfg_def.iu_rcfg_defid) id 
, 'iu_rcfg_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_rcfg_def
 join INSTANCE on iu_rcfg_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_town
go
create view v_autoiud_town as 
select   b2g(iud_town. iud_townid) iud_townid,iud_town. changestamp changestamp
, 
iud_town.name 
iud_town_name 
, b2g(iud_town.instanceid) instanceid 
, iud_town.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_town.iud_townid) id 
, 'iud_town' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_town
 join INSTANCE on iud_town.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_town_ru_ru
go
create view v_autoiud_town_ru_ru as 
select   b2g(iud_town. iud_townid) iud_townid,iud_town. changestamp changestamp
, 
iud_town.name 
iud_town_name 
, b2g(iud_town.instanceid) instanceid 
, iud_town.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_town.iud_townid) id 
, 'iud_town' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_town
 join INSTANCE on iud_town.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_town_en_us
go
create view v_autoiud_town_en_us as 
select   b2g(iud_town. iud_townid) iud_townid,iud_town. changestamp changestamp
, 
iud_town.name 
iud_town_name 
, b2g(iud_town.instanceid) instanceid 
, iud_town.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_town.iud_townid) id 
, 'iud_town' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_town
 join INSTANCE on iud_town.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_regtree
go
create view v_autoiu_regtree as 
select   b2g(iu_regtree. iu_regtreeid) iu_regtreeid,iu_regtree. changestamp changestamp
, 
iu_regtree.name 
iu_regtree_name 
, b2g(iu_regtree.instanceid) instanceid 
, iu_regtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_regtree.iu_regtreeid) id 
, 'iu_regtree' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_regtree
 join INSTANCE on iu_regtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_regtree_ru_ru
go
create view v_autoiu_regtree_ru_ru as 
select   b2g(iu_regtree. iu_regtreeid) iu_regtreeid,iu_regtree. changestamp changestamp
, 
iu_regtree.name 
iu_regtree_name 
, b2g(iu_regtree.instanceid) instanceid 
, iu_regtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_regtree.iu_regtreeid) id 
, 'iu_regtree' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_regtree
 join INSTANCE on iu_regtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_regtree_en_us
go
create view v_autoiu_regtree_en_us as 
select   b2g(iu_regtree. iu_regtreeid) iu_regtreeid,iu_regtree. changestamp changestamp
, 
iu_regtree.name 
iu_regtree_name 
, b2g(iu_regtree.instanceid) instanceid 
, iu_regtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_regtree.iu_regtreeid) id 
, 'iu_regtree' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_regtree
 join INSTANCE on iu_regtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_regdocs
go
create view v_autoiu_regdocs as 
select   b2g(iu_regdocs. iu_regdocsid) iu_regdocsid,iu_regdocs. changestamp changestamp, b2g(iu_regtreeid) iu_regtreeid
, 
iu_regdocs.thecomment 
iu_regdocs_thecomment 
, 
iu_regdocs.origname 
iu_regdocs_origname 
, 
iu_regdocs.thedoc 
iu_regdocs_thedoc 
, 
iu_regdocs.docname 
iu_regdocs_docname 
, b2g(iu_regtree.instanceid) instanceid 
, iu_regtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_regdocs.iu_regdocsid) id 
, 'iu_regdocs' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_regdocs
 join iu_regtree on iu_regtree.iu_regtreeID=iu_regdocs.ParentStructRowID 
 join INSTANCE on iu_regtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_regdocs_ru_ru
go
create view v_autoiu_regdocs_ru_ru as 
select   b2g(iu_regdocs. iu_regdocsid) iu_regdocsid,iu_regdocs. changestamp changestamp, b2g(iu_regtreeid) iu_regtreeid
, 
iu_regdocs.thecomment 
iu_regdocs_thecomment 
, 
iu_regdocs.origname 
iu_regdocs_origname 
, 
iu_regdocs.thedoc 
iu_regdocs_thedoc 
, 
iu_regdocs.docname 
iu_regdocs_docname 
, b2g(iu_regtree.instanceid) instanceid 
, iu_regtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_regdocs.iu_regdocsid) id 
, 'iu_regdocs' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_regdocs
 join iu_regtree on iu_regtree.iu_regtreeID=iu_regdocs.ParentStructRowID 
 join INSTANCE on iu_regtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_regdocs_en_us
go
create view v_autoiu_regdocs_en_us as 
select   b2g(iu_regdocs. iu_regdocsid) iu_regdocsid,iu_regdocs. changestamp changestamp, b2g(iu_regtreeid) iu_regtreeid
, 
iu_regdocs.thecomment 
iu_regdocs_thecomment 
, 
iu_regdocs.origname 
iu_regdocs_origname 
, 
iu_regdocs.thedoc 
iu_regdocs_thedoc 
, 
iu_regdocs.docname 
iu_regdocs_docname 
, b2g(iu_regtree.instanceid) instanceid 
, iu_regtree.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_regdocs.iu_regdocsid) id 
, 'iu_regdocs' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_regdocs
 join iu_regtree on iu_regtree.iu_regtreeID=iu_regdocs.ParentStructRowID 
 join INSTANCE on iu_regtree.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_status
go
create view v_autoiu_status as 
select   b2g(iu_status. iu_statusid) iu_statusid,iu_status. changestamp changestamp
, 
 b2g(iu_status.thestage)  
iu_status_thestage_id, 
 iud_stagedef_brief_f(iu_status.thestage, null) 
iu_status_thestage 
, 
iu_status.sequence 
iu_status_sequence 
, 
 iu_status.isfinishstate  
iu_status_isfinishstate_val, 
 case iu_status.isfinishstate 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_status_isfinishstate 
, 
iu_status.name 
iu_status_name 
, 
 iu_status.isstartupstate  
iu_status_isstartupstate_val, 
 case iu_status.isstartupstate 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_status_isstartupstate 
, 
 b2g(iu_status.theprocess)  
iu_status_theprocess_id, 
 iud_process_def_brief_f(iu_status.theprocess, null) 
iu_status_theprocess 
, b2g(iu_status.instanceid) instanceid 
, iu_status.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_status.iu_statusid) id 
, 'iu_status' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_status
 join INSTANCE on iu_status.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_status_ru_ru
go
create view v_autoiu_status_ru_ru as 
select   b2g(iu_status. iu_statusid) iu_statusid,iu_status. changestamp changestamp
, 
 b2g(iu_status.thestage)  
iu_status_thestage_id, 
 iud_stagedef_brief_f(iu_status.thestage, 'ru_ru') 
iu_status_thestage 
, 
iu_status.sequence 
iu_status_sequence 
, 
 iu_status.isfinishstate  
iu_status_isfinishstate_val, 
 case iu_status.isfinishstate 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_status_isfinishstate 
, 
iu_status.name 
iu_status_name 
, 
 iu_status.isstartupstate  
iu_status_isstartupstate_val, 
 case iu_status.isstartupstate 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_status_isstartupstate 
, 
 b2g(iu_status.theprocess)  
iu_status_theprocess_id, 
 iud_process_def_brief_f(iu_status.theprocess, 'ru_ru') 
iu_status_theprocess 
, b2g(iu_status.instanceid) instanceid 
, iu_status.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_status.iu_statusid) id 
, 'iu_status' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_status
 join INSTANCE on iu_status.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_status_en_us
go
create view v_autoiu_status_en_us as 
select   b2g(iu_status. iu_statusid) iu_statusid,iu_status. changestamp changestamp
, 
 b2g(iu_status.thestage)  
iu_status_thestage_id, 
 iud_stagedef_brief_f(iu_status.thestage, 'en_us') 
iu_status_thestage 
, 
iu_status.sequence 
iu_status_sequence 
, 
 iu_status.isfinishstate  
iu_status_isfinishstate_val, 
 case iu_status.isfinishstate 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_status_isfinishstate 
, 
iu_status.name 
iu_status_name 
, 
 iu_status.isstartupstate  
iu_status_isstartupstate_val, 
 case iu_status.isstartupstate 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_status_isstartupstate 
, 
 b2g(iu_status.theprocess)  
iu_status_theprocess_id, 
 iud_process_def_brief_f(iu_status.theprocess, 'en_us') 
iu_status_theprocess 
, b2g(iu_status.instanceid) instanceid 
, iu_status.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_status.iu_statusid) id 
, 'iu_status' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_status
 join INSTANCE on iu_status.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_status_doer
go
create view v_autoiu_status_doer as 
select   b2g(iu_status_doer. iu_status_doerid) iu_status_doerid,iu_status_doer. changestamp changestamp
, 
 iu_status_doer.doerallowed  
iu_status_doer_doerallowed_val, 
 case iu_status_doer.doerallowed 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_status_doer_doerallowed 
, 
 b2g(iu_status_doer.doertype)  
iu_status_doer_doertype_id, 
 iu_crole_brief_f(iu_status_doer.doertype, null) 
iu_status_doer_doertype 
, b2g(iu_status_doer.instanceid) instanceid 
, iu_status_doer.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_status_doer.iu_status_doerid) id 
, 'iu_status_doer' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_status_doer
 join INSTANCE on iu_status_doer.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_status_doer_ru_ru
go
create view v_autoiu_status_doer_ru_ru as 
select   b2g(iu_status_doer. iu_status_doerid) iu_status_doerid,iu_status_doer. changestamp changestamp
, 
 iu_status_doer.doerallowed  
iu_status_doer_doerallowed_val, 
 case iu_status_doer.doerallowed 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_status_doer_doerallowed 
, 
 b2g(iu_status_doer.doertype)  
iu_status_doer_doertype_id, 
 iu_crole_brief_f(iu_status_doer.doertype, 'ru_ru') 
iu_status_doer_doertype 
, b2g(iu_status_doer.instanceid) instanceid 
, iu_status_doer.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_status_doer.iu_status_doerid) id 
, 'iu_status_doer' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_status_doer
 join INSTANCE on iu_status_doer.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_status_doer_en_us
go
create view v_autoiu_status_doer_en_us as 
select   b2g(iu_status_doer. iu_status_doerid) iu_status_doerid,iu_status_doer. changestamp changestamp
, 
 iu_status_doer.doerallowed  
iu_status_doer_doerallowed_val, 
 case iu_status_doer.doerallowed 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_status_doer_doerallowed 
, 
 b2g(iu_status_doer.doertype)  
iu_status_doer_doertype_id, 
 iu_crole_brief_f(iu_status_doer.doertype, 'en_us') 
iu_status_doer_doertype 
, b2g(iu_status_doer.instanceid) instanceid 
, iu_status_doer.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_status_doer.iu_status_doerid) id 
, 'iu_status_doer' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_status_doer
 join INSTANCE on iu_status_doer.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_statustask
go
create view v_autoiu_statustask as 
select   b2g(iu_statustask. iu_statustaskid) iu_statustaskid,iu_statustask. changestamp changestamp
, 
iu_statustask.name 
iu_statustask_name 
, 
iu_statustask.tasksequence 
iu_statustask_tasksequence 
, 
 b2g(iu_statustask.statusonclose)  
iu_statustask_statusonclose_id, 
 iud_sn_def_brief_f(iu_statustask.statusonclose, null) 
iu_statustask_statusonclose 
, 
iu_statustask.info 
iu_statustask_info 
, 
 b2g(iu_statustask.contoller)  
iu_statustask_contoller_id, 
 iu_crole_brief_f(iu_statustask.contoller, null) 
iu_statustask_contoller 
, 
 iu_statustask.finishallowed  
iu_statustask_finishallowed_val, 
 case iu_statustask.finishallowed 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_statustask_finishallowed 
, 
 iu_statustask.possiblestatuses  
iu_statustask_possiblestatuses_id, 
 iud_sn_def_mref_f(iu_statustask.possiblestatuses, null) 
iu_statustask_possiblestatuses 
, 
iu_statustask.duration_plan 
iu_statustask_duration_plan 
, 
 iu_statustask.afterall  
iu_statustask_afterall_val, 
 case iu_statustask.afterall 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_statustask_afterall 
, 
 b2g(iu_statustask.doertype)  
iu_statustask_doertype_id, 
 iu_crole_brief_f(iu_statustask.doertype, null) 
iu_statustask_doertype 
, b2g(iu_statustask.instanceid) instanceid 
, iu_statustask.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_statustask.iu_statustaskid) id 
, 'iu_statustask' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_statustask
 join INSTANCE on iu_statustask.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_statustask_ru_ru
go
create view v_autoiu_statustask_ru_ru as 
select   b2g(iu_statustask. iu_statustaskid) iu_statustaskid,iu_statustask. changestamp changestamp
, 
iu_statustask.name 
iu_statustask_name 
, 
iu_statustask.tasksequence 
iu_statustask_tasksequence 
, 
 b2g(iu_statustask.statusonclose)  
iu_statustask_statusonclose_id, 
 iud_sn_def_brief_f(iu_statustask.statusonclose, 'ru_ru') 
iu_statustask_statusonclose 
, 
iu_statustask.info 
iu_statustask_info 
, 
 b2g(iu_statustask.contoller)  
iu_statustask_contoller_id, 
 iu_crole_brief_f(iu_statustask.contoller, 'ru_ru') 
iu_statustask_contoller 
, 
 iu_statustask.finishallowed  
iu_statustask_finishallowed_val, 
 case iu_statustask.finishallowed 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_statustask_finishallowed 
, 
 iu_statustask.possiblestatuses  
iu_statustask_possiblestatuses_id, 
 iud_sn_def_mref_f(iu_statustask.possiblestatuses, 'ru_ru') 
iu_statustask_possiblestatuses 
, 
iu_statustask.duration_plan 
iu_statustask_duration_plan 
, 
 iu_statustask.afterall  
iu_statustask_afterall_val, 
 case iu_statustask.afterall 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_statustask_afterall 
, 
 b2g(iu_statustask.doertype)  
iu_statustask_doertype_id, 
 iu_crole_brief_f(iu_statustask.doertype, 'ru_ru') 
iu_statustask_doertype 
, b2g(iu_statustask.instanceid) instanceid 
, iu_statustask.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_statustask.iu_statustaskid) id 
, 'iu_statustask' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_statustask
 join INSTANCE on iu_statustask.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_statustask_en_us
go
create view v_autoiu_statustask_en_us as 
select   b2g(iu_statustask. iu_statustaskid) iu_statustaskid,iu_statustask. changestamp changestamp
, 
iu_statustask.name 
iu_statustask_name 
, 
iu_statustask.tasksequence 
iu_statustask_tasksequence 
, 
 b2g(iu_statustask.statusonclose)  
iu_statustask_statusonclose_id, 
 iud_sn_def_brief_f(iu_statustask.statusonclose, 'en_us') 
iu_statustask_statusonclose 
, 
iu_statustask.info 
iu_statustask_info 
, 
 b2g(iu_statustask.contoller)  
iu_statustask_contoller_id, 
 iu_crole_brief_f(iu_statustask.contoller, 'en_us') 
iu_statustask_contoller 
, 
 iu_statustask.finishallowed  
iu_statustask_finishallowed_val, 
 case iu_statustask.finishallowed 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_statustask_finishallowed 
, 
 iu_statustask.possiblestatuses  
iu_statustask_possiblestatuses_id, 
 iud_sn_def_mref_f(iu_statustask.possiblestatuses, 'en_us') 
iu_statustask_possiblestatuses 
, 
iu_statustask.duration_plan 
iu_statustask_duration_plan 
, 
 iu_statustask.afterall  
iu_statustask_afterall_val, 
 case iu_statustask.afterall 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_statustask_afterall 
, 
 b2g(iu_statustask.doertype)  
iu_statustask_doertype_id, 
 iu_crole_brief_f(iu_statustask.doertype, 'en_us') 
iu_statustask_doertype 
, b2g(iu_statustask.instanceid) instanceid 
, iu_statustask.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_statustask.iu_statustaskid) id 
, 'iu_statustask' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_statustask
 join INSTANCE on iu_statustask.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_state_tasklink
go
create view v_autoiu_state_tasklink as 
select   b2g(iu_state_tasklink. iu_state_tasklinkid) iu_state_tasklinkid,iu_state_tasklink. changestamp changestamp, b2g(iu_statustaskid) iu_statustaskid
, 
 iu_state_tasklink.allversions  
iu_state_tasklink_allversions_val, 
 case iu_state_tasklink.allversions 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_state_tasklink_allversions 
, 
 b2g(iu_state_tasklink.doctype)  
iu_state_tasklink_doctype_id, 
 iud_doctype_brief_f(iu_state_tasklink.doctype, null) 
iu_state_tasklink_doctype 
, b2g(iu_statustask.instanceid) instanceid 
, iu_statustask.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_state_tasklink.iu_state_tasklinkid) id 
, 'iu_state_tasklink' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_state_tasklink
 join iu_statustask on iu_statustask.iu_statustaskID=iu_state_tasklink.ParentStructRowID 
 join INSTANCE on iu_statustask.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_state_tasklink_ru_ru
go
create view v_autoiu_state_tasklink_ru_ru as 
select   b2g(iu_state_tasklink. iu_state_tasklinkid) iu_state_tasklinkid,iu_state_tasklink. changestamp changestamp, b2g(iu_statustaskid) iu_statustaskid
, 
 iu_state_tasklink.allversions  
iu_state_tasklink_allversions_val, 
 case iu_state_tasklink.allversions 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_state_tasklink_allversions 
, 
 b2g(iu_state_tasklink.doctype)  
iu_state_tasklink_doctype_id, 
 iud_doctype_brief_f(iu_state_tasklink.doctype, 'ru_ru') 
iu_state_tasklink_doctype 
, b2g(iu_statustask.instanceid) instanceid 
, iu_statustask.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_state_tasklink.iu_state_tasklinkid) id 
, 'iu_state_tasklink' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_state_tasklink
 join iu_statustask on iu_statustask.iu_statustaskID=iu_state_tasklink.ParentStructRowID 
 join INSTANCE on iu_statustask.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_state_tasklink_en_us
go
create view v_autoiu_state_tasklink_en_us as 
select   b2g(iu_state_tasklink. iu_state_tasklinkid) iu_state_tasklinkid,iu_state_tasklink. changestamp changestamp, b2g(iu_statustaskid) iu_statustaskid
, 
 iu_state_tasklink.allversions  
iu_state_tasklink_allversions_val, 
 case iu_state_tasklink.allversions 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_state_tasklink_allversions 
, 
 b2g(iu_state_tasklink.doctype)  
iu_state_tasklink_doctype_id, 
 iud_doctype_brief_f(iu_state_tasklink.doctype, 'en_us') 
iu_state_tasklink_doctype 
, b2g(iu_statustask.instanceid) instanceid 
, iu_statustask.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_state_tasklink.iu_state_tasklinkid) id 
, 'iu_state_tasklink' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_state_tasklink
 join iu_statustask on iu_statustask.iu_statustaskID=iu_state_tasklink.ParentStructRowID 
 join INSTANCE on iu_statustask.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_stausdoc
go
create view v_autoiu_stausdoc as 
select   b2g(iu_stausdoc. iu_stausdocid) iu_stausdocid,iu_stausdoc. changestamp changestamp
, 
 iu_stausdoc.allowdoc  
iu_stausdoc_allowdoc_val, 
 case iu_stausdoc.allowdoc 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_stausdoc_allowdoc 
, 
iu_stausdoc.info 
iu_stausdoc_info 
, 
 b2g(iu_stausdoc.doctype)  
iu_stausdoc_doctype_id, 
 iud_doctype_brief_f(iu_stausdoc.doctype, null) 
iu_stausdoc_doctype 
, 
iu_stausdoc.name 
iu_stausdoc_name 
, b2g(iu_stausdoc.instanceid) instanceid 
, iu_stausdoc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_stausdoc.iu_stausdocid) id 
, 'iu_stausdoc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_stausdoc
 join INSTANCE on iu_stausdoc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_stausdoc_ru_ru
go
create view v_autoiu_stausdoc_ru_ru as 
select   b2g(iu_stausdoc. iu_stausdocid) iu_stausdocid,iu_stausdoc. changestamp changestamp
, 
 iu_stausdoc.allowdoc  
iu_stausdoc_allowdoc_val, 
 case iu_stausdoc.allowdoc 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_stausdoc_allowdoc 
, 
iu_stausdoc.info 
iu_stausdoc_info 
, 
 b2g(iu_stausdoc.doctype)  
iu_stausdoc_doctype_id, 
 iud_doctype_brief_f(iu_stausdoc.doctype, 'ru_ru') 
iu_stausdoc_doctype 
, 
iu_stausdoc.name 
iu_stausdoc_name 
, b2g(iu_stausdoc.instanceid) instanceid 
, iu_stausdoc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_stausdoc.iu_stausdocid) id 
, 'iu_stausdoc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_stausdoc
 join INSTANCE on iu_stausdoc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_stausdoc_en_us
go
create view v_autoiu_stausdoc_en_us as 
select   b2g(iu_stausdoc. iu_stausdocid) iu_stausdocid,iu_stausdoc. changestamp changestamp
, 
 iu_stausdoc.allowdoc  
iu_stausdoc_allowdoc_val, 
 case iu_stausdoc.allowdoc 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_stausdoc_allowdoc 
, 
iu_stausdoc.info 
iu_stausdoc_info 
, 
 b2g(iu_stausdoc.doctype)  
iu_stausdoc_doctype_id, 
 iud_doctype_brief_f(iu_stausdoc.doctype, 'en_us') 
iu_stausdoc_doctype 
, 
iu_stausdoc.name 
iu_stausdoc_name 
, b2g(iu_stausdoc.instanceid) instanceid 
, iu_stausdoc.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_stausdoc.iu_stausdocid) id 
, 'iu_stausdoc' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_stausdoc
 join INSTANCE on iu_stausdoc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_statusnext
go
create view v_autoiu_statusnext as 
select   b2g(iu_statusnext. iu_statusnextid) iu_statusnextid,iu_statusnext. changestamp changestamp
, 
 b2g(iu_statusnext.nextstatus)  
iu_statusnext_nextstatus_id, 
 iu_status_brief_f(iu_statusnext.nextstatus, null) 
iu_statusnext_nextstatus 
, 
 b2g(iu_statusnext.statusafter)  
iu_statusnext_statusafter_id, 
 iud_sn_def_brief_f(iu_statusnext.statusafter, null) 
iu_statusnext_statusafter 
, b2g(iu_statusnext.instanceid) instanceid 
, iu_statusnext.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_statusnext.iu_statusnextid) id 
, 'iu_statusnext' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_statusnext
 join INSTANCE on iu_statusnext.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_statusnext_ru_ru
go
create view v_autoiu_statusnext_ru_ru as 
select   b2g(iu_statusnext. iu_statusnextid) iu_statusnextid,iu_statusnext. changestamp changestamp
, 
 b2g(iu_statusnext.nextstatus)  
iu_statusnext_nextstatus_id, 
 iu_status_brief_f(iu_statusnext.nextstatus, 'ru_ru') 
iu_statusnext_nextstatus 
, 
 b2g(iu_statusnext.statusafter)  
iu_statusnext_statusafter_id, 
 iud_sn_def_brief_f(iu_statusnext.statusafter, 'ru_ru') 
iu_statusnext_statusafter 
, b2g(iu_statusnext.instanceid) instanceid 
, iu_statusnext.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_statusnext.iu_statusnextid) id 
, 'iu_statusnext' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_statusnext
 join INSTANCE on iu_statusnext.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_statusnext_en_us
go
create view v_autoiu_statusnext_en_us as 
select   b2g(iu_statusnext. iu_statusnextid) iu_statusnextid,iu_statusnext. changestamp changestamp
, 
 b2g(iu_statusnext.nextstatus)  
iu_statusnext_nextstatus_id, 
 iu_status_brief_f(iu_statusnext.nextstatus, 'en_us') 
iu_statusnext_nextstatus 
, 
 b2g(iu_statusnext.statusafter)  
iu_statusnext_statusafter_id, 
 iud_sn_def_brief_f(iu_statusnext.statusafter, 'en_us') 
iu_statusnext_statusafter 
, b2g(iu_statusnext.instanceid) instanceid 
, iu_statusnext.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_statusnext.iu_statusnextid) id 
, 'iu_statusnext' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_statusnext
 join INSTANCE on iu_statusnext.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_statuschanger
go
create view v_autoiu_statuschanger as 
select   b2g(iu_statuschanger. iu_statuschangerid) iu_statuschangerid,iu_statuschanger. changestamp changestamp, b2g(iu_statusnextid) iu_statusnextid
, 
 iu_statuschanger.checkdocuments  
iu_statuschanger_checkdocuments_val, 
 case iu_statuschanger.checkdocuments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_statuschanger_checkdocuments 
, 
 b2g(iu_statuschanger.whocan)  
iu_statuschanger_whocan_id, 
 iu_crole_brief_f(iu_statuschanger.whocan, null) 
iu_statuschanger_whocan 
, b2g(iu_statusnext.instanceid) instanceid 
, iu_statusnext.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_statuschanger.iu_statuschangerid) id 
, 'iu_statuschanger' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_statuschanger
 join iu_statusnext on iu_statusnext.iu_statusnextID=iu_statuschanger.ParentStructRowID 
 join INSTANCE on iu_statusnext.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_statuschanger_ru_ru
go
create view v_autoiu_statuschanger_ru_ru as 
select   b2g(iu_statuschanger. iu_statuschangerid) iu_statuschangerid,iu_statuschanger. changestamp changestamp, b2g(iu_statusnextid) iu_statusnextid
, 
 iu_statuschanger.checkdocuments  
iu_statuschanger_checkdocuments_val, 
 case iu_statuschanger.checkdocuments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_statuschanger_checkdocuments 
, 
 b2g(iu_statuschanger.whocan)  
iu_statuschanger_whocan_id, 
 iu_crole_brief_f(iu_statuschanger.whocan, 'ru_ru') 
iu_statuschanger_whocan 
, b2g(iu_statusnext.instanceid) instanceid 
, iu_statusnext.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_statuschanger.iu_statuschangerid) id 
, 'iu_statuschanger' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_statuschanger
 join iu_statusnext on iu_statusnext.iu_statusnextID=iu_statuschanger.ParentStructRowID 
 join INSTANCE on iu_statusnext.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_statuschanger_en_us
go
create view v_autoiu_statuschanger_en_us as 
select   b2g(iu_statuschanger. iu_statuschangerid) iu_statuschangerid,iu_statuschanger. changestamp changestamp, b2g(iu_statusnextid) iu_statusnextid
, 
 iu_statuschanger.checkdocuments  
iu_statuschanger_checkdocuments_val, 
 case iu_statuschanger.checkdocuments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_statuschanger_checkdocuments 
, 
 b2g(iu_statuschanger.whocan)  
iu_statuschanger_whocan_id, 
 iu_crole_brief_f(iu_statuschanger.whocan, 'en_us') 
iu_statuschanger_whocan 
, b2g(iu_statusnext.instanceid) instanceid 
, iu_statusnext.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_statuschanger.iu_statuschangerid) id 
, 'iu_statuschanger' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_statuschanger
 join iu_statusnext on iu_statusnext.iu_statusnextID=iu_statuschanger.ParentStructRowID 
 join INSTANCE on iu_statusnext.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtz2job_def
go
create view v_automtz2job_def as 
select   b2g(mtz2job_def. mtz2job_defid) mtz2job_defid,mtz2job_def. changestamp changestamp
, 
mtz2job_def.processdate 
mtz2job_def_processdate 
, 
mtz2job_def.eventype 
mtz2job_def_eventype 
, 
mtz2job_def.thrustate 
mtz2job_def_thrustate 
, 
 b2g(mtz2job_def.thruobject)  
mtz2job_def_thruobject_id, 
 instance_brief_f(mtz2job_def.thruobject , null) 
mtz2job_def_thruobject 
, 
mtz2job_def.nextstate 
mtz2job_def_nextstate 
, 
 mtz2job_def.processed  
mtz2job_def_processed_val, 
 case mtz2job_def.processed 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
mtz2job_def_processed 
, 
mtz2job_def.eventdate 
mtz2job_def_eventdate 
, b2g(mtz2job_def.instanceid) instanceid 
, mtz2job_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtz2job_def.mtz2job_defid) id 
, 'mtz2job_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZ2JOB_DEF
 join INSTANCE on MTZ2JOB_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtz2job_def_ru_ru
go
create view v_automtz2job_def_ru_ru as 
select   b2g(mtz2job_def. mtz2job_defid) mtz2job_defid,mtz2job_def. changestamp changestamp
, 
mtz2job_def.processdate 
mtz2job_def_processdate 
, 
mtz2job_def.eventype 
mtz2job_def_eventype 
, 
mtz2job_def.thrustate 
mtz2job_def_thrustate 
, 
 b2g(mtz2job_def.thruobject)  
mtz2job_def_thruobject_id, 
 instance_brief_f(mtz2job_def.thruobject, 'ru_ru') 
mtz2job_def_thruobject 
, 
mtz2job_def.nextstate 
mtz2job_def_nextstate 
, 
 mtz2job_def.processed  
mtz2job_def_processed_val, 
 case mtz2job_def.processed 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
mtz2job_def_processed 
, 
mtz2job_def.eventdate 
mtz2job_def_eventdate 
, b2g(mtz2job_def.instanceid) instanceid 
, mtz2job_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtz2job_def.mtz2job_defid) id 
, 'mtz2job_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZ2JOB_DEF
 join INSTANCE on MTZ2JOB_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_automtz2job_def_en_us
go
create view v_automtz2job_def_en_us as 
select   b2g(mtz2job_def. mtz2job_defid) mtz2job_defid,mtz2job_def. changestamp changestamp
, 
mtz2job_def.processdate 
mtz2job_def_processdate 
, 
mtz2job_def.eventype 
mtz2job_def_eventype 
, 
mtz2job_def.thrustate 
mtz2job_def_thrustate 
, 
 b2g(mtz2job_def.thruobject)  
mtz2job_def_thruobject_id, 
 instance_brief_f(mtz2job_def.thruobject, 'en_us') 
mtz2job_def_thruobject 
, 
mtz2job_def.nextstate 
mtz2job_def_nextstate 
, 
 mtz2job_def.processed  
mtz2job_def_processed_val, 
 case mtz2job_def.processed 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
mtz2job_def_processed 
, 
mtz2job_def.eventdate 
mtz2job_def_eventdate 
, b2g(mtz2job_def.instanceid) instanceid 
, mtz2job_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(mtz2job_def.mtz2job_defid) id 
, 'mtz2job_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from MTZ2JOB_DEF
 join INSTANCE on MTZ2JOB_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_ctype
go
create view v_autoiud_ctype as 
select   b2g(iud_ctype. iud_ctypeid) iud_ctypeid,iud_ctype. changestamp changestamp
, 
iud_ctype.name 
iud_ctype_name 
, b2g(iud_ctype.instanceid) instanceid 
, iud_ctype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_ctype.iud_ctypeid) id 
, 'iud_ctype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_ctype
 join INSTANCE on iud_ctype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_ctype_ru_ru
go
create view v_autoiud_ctype_ru_ru as 
select   b2g(iud_ctype. iud_ctypeid) iud_ctypeid,iud_ctype. changestamp changestamp
, 
iud_ctype.name 
iud_ctype_name 
, b2g(iud_ctype.instanceid) instanceid 
, iud_ctype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_ctype.iud_ctypeid) id 
, 'iud_ctype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_ctype
 join INSTANCE on iud_ctype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_ctype_en_us
go
create view v_autoiud_ctype_en_us as 
select   b2g(iud_ctype. iud_ctypeid) iud_ctypeid,iud_ctype. changestamp changestamp
, 
iud_ctype.name 
iud_ctype_name 
, b2g(iud_ctype.instanceid) instanceid 
, iud_ctype.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_ctype.iud_ctypeid) id 
, 'iud_ctype' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_ctype
 join INSTANCE on iud_ctype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_spub
go
create view v_autoiud_spub as 
select   b2g(iud_spub. iud_spubid) iud_spubid,iud_spub. changestamp changestamp
, 
iud_spub.name 
iud_spub_name 
, b2g(iud_spub.instanceid) instanceid 
, iud_spub.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_spub.iud_spubid) id 
, 'iud_spub' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_spub
 join INSTANCE on iud_spub.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_spub_ru_ru
go
create view v_autoiud_spub_ru_ru as 
select   b2g(iud_spub. iud_spubid) iud_spubid,iud_spub. changestamp changestamp
, 
iud_spub.name 
iud_spub_name 
, b2g(iud_spub.instanceid) instanceid 
, iud_spub.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_spub.iud_spubid) id 
, 'iud_spub' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_spub
 join INSTANCE on iud_spub.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiud_spub_en_us
go
create view v_autoiud_spub_en_us as 
select   b2g(iud_spub. iud_spubid) iud_spubid,iud_spub. changestamp changestamp
, 
iud_spub.name 
iud_spub_name 
, b2g(iud_spub.instanceid) instanceid 
, iud_spub.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iud_spub.iud_spubid) id 
, 'iud_spub' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iud_spub
 join INSTANCE on iud_spub.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofilterfieldgroup
go
create view v_autofilterfieldgroup as 
select   b2g(filterfieldgroup. filterfieldgroupid) filterfieldgroupid,filterfieldgroup. changestamp changestamp
, 
filterfieldgroup.name 
filterfieldgroup_name 
, 
filterfieldgroup.caption 
filterfieldgroup_caption 
, 
 filterfieldgroup.allowignore  
filterfieldgroup_allowignore_val, 
 case filterfieldgroup.allowignore 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
filterfieldgroup_allowignore 
, 
filterfieldgroup.sequence 
filterfieldgroup_sequence 
, b2g(filterfieldgroup.instanceid) instanceid 
, filterfieldgroup.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(filterfieldgroup.filterfieldgroupid) id 
, 'filterfieldgroup' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FilterFieldGroup
 join INSTANCE on FilterFieldGroup.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofilterfieldgroup_ru_ru
go
create view v_autofilterfieldgroup_ru_ru as 
select   b2g(filterfieldgroup. filterfieldgroupid) filterfieldgroupid,filterfieldgroup. changestamp changestamp
, 
filterfieldgroup.name 
filterfieldgroup_name 
, 
filterfieldgroup.caption 
filterfieldgroup_caption 
, 
 filterfieldgroup.allowignore  
filterfieldgroup_allowignore_val, 
 case filterfieldgroup.allowignore 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
filterfieldgroup_allowignore 
, 
filterfieldgroup.sequence 
filterfieldgroup_sequence 
, b2g(filterfieldgroup.instanceid) instanceid 
, filterfieldgroup.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(filterfieldgroup.filterfieldgroupid) id 
, 'filterfieldgroup' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FilterFieldGroup
 join INSTANCE on FilterFieldGroup.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofilterfieldgroup_en_us
go
create view v_autofilterfieldgroup_en_us as 
select   b2g(filterfieldgroup. filterfieldgroupid) filterfieldgroupid,filterfieldgroup. changestamp changestamp
, 
filterfieldgroup.name 
filterfieldgroup_name 
, 
filterfieldgroup.caption 
filterfieldgroup_caption 
, 
 filterfieldgroup.allowignore  
filterfieldgroup_allowignore_val, 
 case filterfieldgroup.allowignore 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
filterfieldgroup_allowignore 
, 
filterfieldgroup.sequence 
filterfieldgroup_sequence 
, b2g(filterfieldgroup.instanceid) instanceid 
, filterfieldgroup.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(filterfieldgroup.filterfieldgroupid) id 
, 'filterfieldgroup' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FilterFieldGroup
 join INSTANCE on FilterFieldGroup.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofileterfield
go
create view v_autofileterfield as 
select   b2g(fileterfield. fileterfieldid) fileterfieldid,fileterfield. changestamp changestamp, b2g(filterfieldgroupid) filterfieldgroupid
, 
fileterfield.sequence 
fileterfield_sequence 
, 
fileterfield.name 
fileterfield_name 
, 
 fileterfield.reftype  
fileterfield_reftype_val, 
 case fileterfield.reftype 
when 3 then 'на источник данных'
when 0 then 'скалярное поле ( не ссылка)'
when 2 then 'на строку раздела'
when 1 then 'на объект '
 else '' 
 end  
fileterfield_reftype 
, 
 b2g(fileterfield.reftotype)  
fileterfield_reftotype_id, 
 objecttype_brief_f(fileterfield.reftotype, null) 
fileterfield_reftotype 
, 
fileterfield.caption 
fileterfield_caption 
, 
fileterfield.fieldsize 
fileterfield_fieldsize 
, 
 fileterfield.valuearray  
fileterfield_valuearray_val, 
 case fileterfield.valuearray 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fileterfield_valuearray 
, 
 b2g(fileterfield.reftopart)  
fileterfield_reftopart_id, 
 part_brief_f(fileterfield.reftopart, null) 
fileterfield_reftopart 
, 
 b2g(fileterfield.fieldtype)  
fileterfield_fieldtype_id, 
 fieldtype_brief_f(fileterfield.fieldtype, null) 
fileterfield_fieldtype 
, b2g(filterfieldgroup.instanceid) instanceid 
, filterfieldgroup.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fileterfield.fileterfieldid) id 
, 'fileterfield' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FileterField
 join FilterFieldGroup on FilterFieldGroup.FilterFieldGroupID=FileterField.ParentStructRowID 
 join INSTANCE on FilterFieldGroup.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofileterfield_ru_ru
go
create view v_autofileterfield_ru_ru as 
select   b2g(fileterfield. fileterfieldid) fileterfieldid,fileterfield. changestamp changestamp, b2g(filterfieldgroupid) filterfieldgroupid
, 
fileterfield.sequence 
fileterfield_sequence 
, 
fileterfield.name 
fileterfield_name 
, 
 fileterfield.reftype  
fileterfield_reftype_val, 
 case fileterfield.reftype 
when 3 then 'на источник данных'
when 0 then 'скалярное поле ( не ссылка)'
when 2 then 'на строку раздела'
when 1 then 'на объект '
 else '' 
 end  
fileterfield_reftype 
, 
 b2g(fileterfield.reftotype)  
fileterfield_reftotype_id, 
 objecttype_brief_f(fileterfield.reftotype, 'ru_ru') 
fileterfield_reftotype 
, 
fileterfield.caption 
fileterfield_caption 
, 
fileterfield.fieldsize 
fileterfield_fieldsize 
, 
 fileterfield.valuearray  
fileterfield_valuearray_val, 
 case fileterfield.valuearray 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fileterfield_valuearray 
, 
 b2g(fileterfield.reftopart)  
fileterfield_reftopart_id, 
 part_brief_f(fileterfield.reftopart, 'ru_ru') 
fileterfield_reftopart 
, 
 b2g(fileterfield.fieldtype)  
fileterfield_fieldtype_id, 
 fieldtype_brief_f(fileterfield.fieldtype, 'ru_ru') 
fileterfield_fieldtype 
, b2g(filterfieldgroup.instanceid) instanceid 
, filterfieldgroup.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fileterfield.fileterfieldid) id 
, 'fileterfield' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FileterField
 join FilterFieldGroup on FilterFieldGroup.FilterFieldGroupID=FileterField.ParentStructRowID 
 join INSTANCE on FilterFieldGroup.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofileterfield_en_us
go
create view v_autofileterfield_en_us as 
select   b2g(fileterfield. fileterfieldid) fileterfieldid,fileterfield. changestamp changestamp, b2g(filterfieldgroupid) filterfieldgroupid
, 
fileterfield.sequence 
fileterfield_sequence 
, 
fileterfield.name 
fileterfield_name 
, 
 fileterfield.reftype  
fileterfield_reftype_val, 
 case fileterfield.reftype 
when 3 then 'на источник данных'
when 0 then 'скалярное поле ( не ссылка)'
when 2 then 'на строку раздела'
when 1 then 'на объект '
 else '' 
 end  
fileterfield_reftype 
, 
 b2g(fileterfield.reftotype)  
fileterfield_reftotype_id, 
 objecttype_brief_f(fileterfield.reftotype, 'en_us') 
fileterfield_reftotype 
, 
fileterfield.caption 
fileterfield_caption 
, 
fileterfield.fieldsize 
fileterfield_fieldsize 
, 
 fileterfield.valuearray  
fileterfield_valuearray_val, 
 case fileterfield.valuearray 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
fileterfield_valuearray 
, 
 b2g(fileterfield.reftopart)  
fileterfield_reftopart_id, 
 part_brief_f(fileterfield.reftopart, 'en_us') 
fileterfield_reftopart 
, 
 b2g(fileterfield.fieldtype)  
fileterfield_fieldtype_id, 
 fieldtype_brief_f(fileterfield.fieldtype, 'en_us') 
fileterfield_fieldtype 
, b2g(filterfieldgroup.instanceid) instanceid 
, filterfieldgroup.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(fileterfield.fileterfieldid) id 
, 'fileterfield' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from FileterField
 join FilterFieldGroup on FilterFieldGroup.FilterFieldGroupID=FileterField.ParentStructRowID 
 join INSTANCE on FilterFieldGroup.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofilters
go
create view v_autofilters as 
select   b2g(filters. filtersid) filtersid,filters. changestamp changestamp
, 
filters.thecomment 
filters_thecomment 
, 
filters.name 
filters_name 
, 
filters.thecaption 
filters_thecaption 
, b2g(filters.instanceid) instanceid 
, filters.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(filters.filtersid) id 
, 'filters' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Filters
 join INSTANCE on Filters.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofilters_ru_ru
go
create view v_autofilters_ru_ru as 
select   b2g(filters. filtersid) filtersid,filters. changestamp changestamp
, 
filters.thecomment 
filters_thecomment 
, 
filters.name 
filters_name 
, 
filters.thecaption 
filters_thecaption 
, b2g(filters.instanceid) instanceid 
, filters.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(filters.filtersid) id 
, 'filters' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Filters
 join INSTANCE on Filters.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autofilters_en_us
go
create view v_autofilters_en_us as 
select   b2g(filters. filtersid) filtersid,filters. changestamp changestamp
, 
filters.thecomment 
filters_thecomment 
, 
filters.name 
filters_name 
, 
filters.thecaption 
filters_thecaption 
, b2g(filters.instanceid) instanceid 
, filters.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(filters.filtersid) id 
, 'filters' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Filters
 join INSTANCE on Filters.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_int_modules
go
create view v_autoiu_int_modules as 
select   b2g(iu_int_modules. iu_int_modulesid) iu_int_modulesid,iu_int_modules. changestamp changestamp
, 
 iu_int_modules.substructobjects  
iu_int_modules_substructobjects_val, 
 case iu_int_modules.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_substructobjects 
, 
iu_int_modules.caption 
iu_int_modules_caption 
, 
iu_int_modules.name 
iu_int_modules_name 
, 
iu_int_modules.groupname 
iu_int_modules_groupname 
, 
iu_int_modules.sequence 
iu_int_modules_sequence 
, 
 iu_int_modules.colegsobject  
iu_int_modules_colegsobject_val, 
 case iu_int_modules.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_colegsobject 
, 
 iu_int_modules.allobjects  
iu_int_modules_allobjects_val, 
 case iu_int_modules.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_allobjects 
, 
 iu_int_modules.visiblecontrol  
iu_int_modules_visiblecontrol_val, 
 case iu_int_modules.visiblecontrol 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_visiblecontrol 
, 
iu_int_modules.controldocmode 
iu_int_modules_controldocmode 
, 
iu_int_modules.otherdocmode 
iu_int_modules_otherdocmode 
, 
iu_int_modules.mydocmode 
iu_int_modules_mydocmode 
, 
iu_int_modules.theicon 
iu_int_modules_theicon 
, b2g(iu_int_modules.instanceid) instanceid 
, iu_int_modules.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_int_modules.iu_int_modulesid) id 
, 'iu_int_modules' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_int_modules
 join INSTANCE on iu_int_modules.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_int_modules_ru_ru
go
create view v_autoiu_int_modules_ru_ru as 
select   b2g(iu_int_modules. iu_int_modulesid) iu_int_modulesid,iu_int_modules. changestamp changestamp
, 
 iu_int_modules.substructobjects  
iu_int_modules_substructobjects_val, 
 case iu_int_modules.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_substructobjects 
, 
iu_int_modules.caption 
iu_int_modules_caption 
, 
iu_int_modules.name 
iu_int_modules_name 
, 
iu_int_modules.groupname 
iu_int_modules_groupname 
, 
iu_int_modules.sequence 
iu_int_modules_sequence 
, 
 iu_int_modules.colegsobject  
iu_int_modules_colegsobject_val, 
 case iu_int_modules.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_colegsobject 
, 
 iu_int_modules.allobjects  
iu_int_modules_allobjects_val, 
 case iu_int_modules.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_allobjects 
, 
 iu_int_modules.visiblecontrol  
iu_int_modules_visiblecontrol_val, 
 case iu_int_modules.visiblecontrol 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_visiblecontrol 
, 
iu_int_modules.controldocmode 
iu_int_modules_controldocmode 
, 
iu_int_modules.otherdocmode 
iu_int_modules_otherdocmode 
, 
iu_int_modules.mydocmode 
iu_int_modules_mydocmode 
, 
iu_int_modules.theicon 
iu_int_modules_theicon 
, b2g(iu_int_modules.instanceid) instanceid 
, iu_int_modules.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_int_modules.iu_int_modulesid) id 
, 'iu_int_modules' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_int_modules
 join INSTANCE on iu_int_modules.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_int_modules_en_us
go
create view v_autoiu_int_modules_en_us as 
select   b2g(iu_int_modules. iu_int_modulesid) iu_int_modulesid,iu_int_modules. changestamp changestamp
, 
 iu_int_modules.substructobjects  
iu_int_modules_substructobjects_val, 
 case iu_int_modules.substructobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_substructobjects 
, 
iu_int_modules.caption 
iu_int_modules_caption 
, 
iu_int_modules.name 
iu_int_modules_name 
, 
iu_int_modules.groupname 
iu_int_modules_groupname 
, 
iu_int_modules.sequence 
iu_int_modules_sequence 
, 
 iu_int_modules.colegsobject  
iu_int_modules_colegsobject_val, 
 case iu_int_modules.colegsobject 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_colegsobject 
, 
 iu_int_modules.allobjects  
iu_int_modules_allobjects_val, 
 case iu_int_modules.allobjects 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_allobjects 
, 
 iu_int_modules.visiblecontrol  
iu_int_modules_visiblecontrol_val, 
 case iu_int_modules.visiblecontrol 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_int_modules_visiblecontrol 
, 
iu_int_modules.controldocmode 
iu_int_modules_controldocmode 
, 
iu_int_modules.otherdocmode 
iu_int_modules_otherdocmode 
, 
iu_int_modules.mydocmode 
iu_int_modules_mydocmode 
, 
iu_int_modules.theicon 
iu_int_modules_theicon 
, b2g(iu_int_modules.instanceid) instanceid 
, iu_int_modules.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_int_modules.iu_int_modulesid) id 
, 'iu_int_modules' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_int_modules
 join INSTANCE on iu_int_modules.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_task
go
create view v_autoiu_task as 
select   b2g(iu_task. iu_taskid) iu_taskid,iu_task. changestamp changestamp
, 
 b2g(iu_task.theprocess)  
iu_task_theprocess_id, 
 iu_urok_def_brief_f(iu_task.theprocess, null) 
iu_task_theprocess 
, 
 b2g(iu_task.processstatus)  
iu_task_processstatus_id, 
 iu_status_brief_f(iu_task.processstatus, null) 
iu_task_processstatus 
, 
 b2g(iu_task.contoller)  
iu_task_contoller_id, 
 iu_u_def_brief_f(iu_task.contoller, null) 
iu_task_contoller 
, 
iu_task.doer_comment 
iu_task_doer_comment 
, 
 b2g(iu_task.doer)  
iu_task_doer_id, 
 iu_u_def_brief_f(iu_task.doer, null) 
iu_task_doer 
, 
iu_task.info 
iu_task_info 
, 
 b2g(iu_task.delegatefrom)  
iu_task_delegatefrom_id, 
 iu_task_brief_f(iu_task.delegatefrom, null) 
iu_task_delegatefrom 
, 
 iu_task.taskcancelled  
iu_task_taskcancelled_val, 
 case iu_task.taskcancelled 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_taskcancelled 
, 
iu_task.senttodoer 
iu_task_senttodoer 
, 
 iu_task.manualtask  
iu_task_manualtask_val, 
 case iu_task.manualtask 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_manualtask 
, 
 b2g(iu_task.doer_states)  
iu_task_doer_states_id, 
 iud_sn_def_brief_f(iu_task.doer_states, null) 
iu_task_doer_states 
, 
iu_task.finishdate 
iu_task_finishdate 
, 
iu_task.createdate 
iu_task_createdate 
, 
 b2g(iu_task.statetask)  
iu_task_statetask_id, 
 iu_statustask_brief_f(iu_task.statetask, null) 
iu_task_statetask 
, 
 iu_task.isdelegated  
iu_task_isdelegated_val, 
 case iu_task.isdelegated 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_isdelegated 
, 
iu_task.subj 
iu_task_subj 
, 
 iu_task.taskfinished  
iu_task_taskfinished_val, 
 case iu_task.taskfinished 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_taskfinished 
, 
iu_task.planenddate 
iu_task_planenddate 
, 
 iu_task.ischecked  
iu_task_ischecked_val, 
 case iu_task.ischecked 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_ischecked 
, 
iu_task.controller_comment 
iu_task_controller_comment 
, b2g(iu_task.instanceid) instanceid 
, iu_task.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_task.iu_taskid) id 
, 'iu_task' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_task
 join INSTANCE on iu_task.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_task_ru_ru
go
create view v_autoiu_task_ru_ru as 
select   b2g(iu_task. iu_taskid) iu_taskid,iu_task. changestamp changestamp
, 
 b2g(iu_task.theprocess)  
iu_task_theprocess_id, 
 iu_urok_def_brief_f(iu_task.theprocess, 'ru_ru') 
iu_task_theprocess 
, 
 b2g(iu_task.processstatus)  
iu_task_processstatus_id, 
 iu_status_brief_f(iu_task.processstatus, 'ru_ru') 
iu_task_processstatus 
, 
 b2g(iu_task.contoller)  
iu_task_contoller_id, 
 iu_u_def_brief_f(iu_task.contoller, 'ru_ru') 
iu_task_contoller 
, 
iu_task.doer_comment 
iu_task_doer_comment 
, 
 b2g(iu_task.doer)  
iu_task_doer_id, 
 iu_u_def_brief_f(iu_task.doer, 'ru_ru') 
iu_task_doer 
, 
iu_task.info 
iu_task_info 
, 
 b2g(iu_task.delegatefrom)  
iu_task_delegatefrom_id, 
 iu_task_brief_f(iu_task.delegatefrom, 'ru_ru') 
iu_task_delegatefrom 
, 
 iu_task.taskcancelled  
iu_task_taskcancelled_val, 
 case iu_task.taskcancelled 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_taskcancelled 
, 
iu_task.senttodoer 
iu_task_senttodoer 
, 
 iu_task.manualtask  
iu_task_manualtask_val, 
 case iu_task.manualtask 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_manualtask 
, 
 b2g(iu_task.doer_states)  
iu_task_doer_states_id, 
 iud_sn_def_brief_f(iu_task.doer_states, 'ru_ru') 
iu_task_doer_states 
, 
iu_task.finishdate 
iu_task_finishdate 
, 
iu_task.createdate 
iu_task_createdate 
, 
 b2g(iu_task.statetask)  
iu_task_statetask_id, 
 iu_statustask_brief_f(iu_task.statetask, 'ru_ru') 
iu_task_statetask 
, 
 iu_task.isdelegated  
iu_task_isdelegated_val, 
 case iu_task.isdelegated 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_isdelegated 
, 
iu_task.subj 
iu_task_subj 
, 
 iu_task.taskfinished  
iu_task_taskfinished_val, 
 case iu_task.taskfinished 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_taskfinished 
, 
iu_task.planenddate 
iu_task_planenddate 
, 
 iu_task.ischecked  
iu_task_ischecked_val, 
 case iu_task.ischecked 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_ischecked 
, 
iu_task.controller_comment 
iu_task_controller_comment 
, b2g(iu_task.instanceid) instanceid 
, iu_task.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_task.iu_taskid) id 
, 'iu_task' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_task
 join INSTANCE on iu_task.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_task_en_us
go
create view v_autoiu_task_en_us as 
select   b2g(iu_task. iu_taskid) iu_taskid,iu_task. changestamp changestamp
, 
 b2g(iu_task.theprocess)  
iu_task_theprocess_id, 
 iu_urok_def_brief_f(iu_task.theprocess, 'en_us') 
iu_task_theprocess 
, 
 b2g(iu_task.processstatus)  
iu_task_processstatus_id, 
 iu_status_brief_f(iu_task.processstatus, 'en_us') 
iu_task_processstatus 
, 
 b2g(iu_task.contoller)  
iu_task_contoller_id, 
 iu_u_def_brief_f(iu_task.contoller, 'en_us') 
iu_task_contoller 
, 
iu_task.doer_comment 
iu_task_doer_comment 
, 
 b2g(iu_task.doer)  
iu_task_doer_id, 
 iu_u_def_brief_f(iu_task.doer, 'en_us') 
iu_task_doer 
, 
iu_task.info 
iu_task_info 
, 
 b2g(iu_task.delegatefrom)  
iu_task_delegatefrom_id, 
 iu_task_brief_f(iu_task.delegatefrom, 'en_us') 
iu_task_delegatefrom 
, 
 iu_task.taskcancelled  
iu_task_taskcancelled_val, 
 case iu_task.taskcancelled 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_taskcancelled 
, 
iu_task.senttodoer 
iu_task_senttodoer 
, 
 iu_task.manualtask  
iu_task_manualtask_val, 
 case iu_task.manualtask 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_manualtask 
, 
 b2g(iu_task.doer_states)  
iu_task_doer_states_id, 
 iud_sn_def_brief_f(iu_task.doer_states, 'en_us') 
iu_task_doer_states 
, 
iu_task.finishdate 
iu_task_finishdate 
, 
iu_task.createdate 
iu_task_createdate 
, 
 b2g(iu_task.statetask)  
iu_task_statetask_id, 
 iu_statustask_brief_f(iu_task.statetask, 'en_us') 
iu_task_statetask 
, 
 iu_task.isdelegated  
iu_task_isdelegated_val, 
 case iu_task.isdelegated 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_isdelegated 
, 
iu_task.subj 
iu_task_subj 
, 
 iu_task.taskfinished  
iu_task_taskfinished_val, 
 case iu_task.taskfinished 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_taskfinished 
, 
iu_task.planenddate 
iu_task_planenddate 
, 
 iu_task.ischecked  
iu_task_ischecked_val, 
 case iu_task.ischecked 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_task_ischecked 
, 
iu_task.controller_comment 
iu_task_controller_comment 
, b2g(iu_task.instanceid) instanceid 
, iu_task.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_task.iu_taskid) id 
, 'iu_task' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_task
 join INSTANCE on iu_task.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_taskattach
go
create view v_autoiu_taskattach as 
select   b2g(iu_taskattach. iu_taskattachid) iu_taskattachid,iu_taskattach. changestamp changestamp
, 
 b2g(iu_taskattach.filereftype)  
iu_taskattach_filereftype_id, 
 iud_rt_def_brief_f(iu_taskattach.filereftype, null) 
iu_taskattach_filereftype 
, 
iu_taskattach.filetext 
iu_taskattach_filetext 
, 
iu_taskattach.theref 
iu_taskattach_theref 
, 
iu_taskattach.info 
iu_taskattach_info 
, 
 b2g(iu_taskattach.dtype)  
iu_taskattach_dtype_id, 
 iud_doctype_brief_f(iu_taskattach.dtype, null) 
iu_taskattach_dtype 
, 
iu_taskattach.fileurl 
iu_taskattach_fileurl 
, 
iu_taskattach.origname 
iu_taskattach_origname 
, b2g(iu_taskattach.instanceid) instanceid 
, iu_taskattach.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_taskattach.iu_taskattachid) id 
, 'iu_taskattach' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_taskattach
 join INSTANCE on iu_taskattach.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_taskattach_ru_ru
go
create view v_autoiu_taskattach_ru_ru as 
select   b2g(iu_taskattach. iu_taskattachid) iu_taskattachid,iu_taskattach. changestamp changestamp
, 
 b2g(iu_taskattach.filereftype)  
iu_taskattach_filereftype_id, 
 iud_rt_def_brief_f(iu_taskattach.filereftype, 'ru_ru') 
iu_taskattach_filereftype 
, 
iu_taskattach.filetext 
iu_taskattach_filetext 
, 
iu_taskattach.theref 
iu_taskattach_theref 
, 
iu_taskattach.info 
iu_taskattach_info 
, 
 b2g(iu_taskattach.dtype)  
iu_taskattach_dtype_id, 
 iud_doctype_brief_f(iu_taskattach.dtype, 'ru_ru') 
iu_taskattach_dtype 
, 
iu_taskattach.fileurl 
iu_taskattach_fileurl 
, 
iu_taskattach.origname 
iu_taskattach_origname 
, b2g(iu_taskattach.instanceid) instanceid 
, iu_taskattach.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_taskattach.iu_taskattachid) id 
, 'iu_taskattach' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_taskattach
 join INSTANCE on iu_taskattach.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_taskattach_en_us
go
create view v_autoiu_taskattach_en_us as 
select   b2g(iu_taskattach. iu_taskattachid) iu_taskattachid,iu_taskattach. changestamp changestamp
, 
 b2g(iu_taskattach.filereftype)  
iu_taskattach_filereftype_id, 
 iud_rt_def_brief_f(iu_taskattach.filereftype, 'en_us') 
iu_taskattach_filereftype 
, 
iu_taskattach.filetext 
iu_taskattach_filetext 
, 
iu_taskattach.theref 
iu_taskattach_theref 
, 
iu_taskattach.info 
iu_taskattach_info 
, 
 b2g(iu_taskattach.dtype)  
iu_taskattach_dtype_id, 
 iud_doctype_brief_f(iu_taskattach.dtype, 'en_us') 
iu_taskattach_dtype 
, 
iu_taskattach.fileurl 
iu_taskattach_fileurl 
, 
iu_taskattach.origname 
iu_taskattach_origname 
, b2g(iu_taskattach.instanceid) instanceid 
, iu_taskattach.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_taskattach.iu_taskattachid) id 
, 'iu_taskattach' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_taskattach
 join INSTANCE on iu_taskattach.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_taskvideo
go
create view v_autoiu_taskvideo as 
select   b2g(iu_taskvideo. iu_taskvideoid) iu_taskvideoid,iu_taskvideo. changestamp changestamp
, 
 b2g(iu_taskvideo.doctype)  
iu_taskvideo_doctype_id, 
 iud_videotype_brief_f(iu_taskvideo.doctype, null) 
iu_taskvideo_doctype 
, 
 iu_taskvideo.nocomments  
iu_taskvideo_nocomments_val, 
 case iu_taskvideo.nocomments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_taskvideo_nocomments 
, 
iu_taskvideo.origname 
iu_taskvideo_origname 
, 
iu_taskvideo.adddate 
iu_taskvideo_adddate 
, 
iu_taskvideo.fileref 
iu_taskvideo_fileref 
, 
 iu_taskvideo.activeversion  
iu_taskvideo_activeversion_val, 
 case iu_taskvideo.activeversion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_taskvideo_activeversion 
, 
iu_taskvideo.info 
iu_taskvideo_info 
, 
iu_taskvideo.fileurl 
iu_taskvideo_fileurl 
, 
 b2g(iu_taskvideo.addby)  
iu_taskvideo_addby_id, 
 iu_u_def_brief_f(iu_taskvideo.addby, null) 
iu_taskvideo_addby 
, 
iu_taskvideo.version 
iu_taskvideo_version 
, b2g(iu_taskvideo.instanceid) instanceid 
, iu_taskvideo.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_taskvideo.iu_taskvideoid) id 
, 'iu_taskvideo' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_taskvideo
 join INSTANCE on iu_taskvideo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_taskvideo_ru_ru
go
create view v_autoiu_taskvideo_ru_ru as 
select   b2g(iu_taskvideo. iu_taskvideoid) iu_taskvideoid,iu_taskvideo. changestamp changestamp
, 
 b2g(iu_taskvideo.doctype)  
iu_taskvideo_doctype_id, 
 iud_videotype_brief_f(iu_taskvideo.doctype, 'ru_ru') 
iu_taskvideo_doctype 
, 
 iu_taskvideo.nocomments  
iu_taskvideo_nocomments_val, 
 case iu_taskvideo.nocomments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_taskvideo_nocomments 
, 
iu_taskvideo.origname 
iu_taskvideo_origname 
, 
iu_taskvideo.adddate 
iu_taskvideo_adddate 
, 
iu_taskvideo.fileref 
iu_taskvideo_fileref 
, 
 iu_taskvideo.activeversion  
iu_taskvideo_activeversion_val, 
 case iu_taskvideo.activeversion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_taskvideo_activeversion 
, 
iu_taskvideo.info 
iu_taskvideo_info 
, 
iu_taskvideo.fileurl 
iu_taskvideo_fileurl 
, 
 b2g(iu_taskvideo.addby)  
iu_taskvideo_addby_id, 
 iu_u_def_brief_f(iu_taskvideo.addby, 'ru_ru') 
iu_taskvideo_addby 
, 
iu_taskvideo.version 
iu_taskvideo_version 
, b2g(iu_taskvideo.instanceid) instanceid 
, iu_taskvideo.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_taskvideo.iu_taskvideoid) id 
, 'iu_taskvideo' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_taskvideo
 join INSTANCE on iu_taskvideo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_taskvideo_en_us
go
create view v_autoiu_taskvideo_en_us as 
select   b2g(iu_taskvideo. iu_taskvideoid) iu_taskvideoid,iu_taskvideo. changestamp changestamp
, 
 b2g(iu_taskvideo.doctype)  
iu_taskvideo_doctype_id, 
 iud_videotype_brief_f(iu_taskvideo.doctype, 'en_us') 
iu_taskvideo_doctype 
, 
 iu_taskvideo.nocomments  
iu_taskvideo_nocomments_val, 
 case iu_taskvideo.nocomments 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_taskvideo_nocomments 
, 
iu_taskvideo.origname 
iu_taskvideo_origname 
, 
iu_taskvideo.adddate 
iu_taskvideo_adddate 
, 
iu_taskvideo.fileref 
iu_taskvideo_fileref 
, 
 iu_taskvideo.activeversion  
iu_taskvideo_activeversion_val, 
 case iu_taskvideo.activeversion 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_taskvideo_activeversion 
, 
iu_taskvideo.info 
iu_taskvideo_info 
, 
iu_taskvideo.fileurl 
iu_taskvideo_fileurl 
, 
 b2g(iu_taskvideo.addby)  
iu_taskvideo_addby_id, 
 iu_u_def_brief_f(iu_taskvideo.addby, 'en_us') 
iu_taskvideo_addby 
, 
iu_taskvideo.version 
iu_taskvideo_version 
, b2g(iu_taskvideo.instanceid) instanceid 
, iu_taskvideo.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_taskvideo.iu_taskvideoid) id 
, 'iu_taskvideo' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_taskvideo
 join INSTANCE on iu_taskvideo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_taskrefs
go
create view v_autoiu_taskrefs as 
select   b2g(iu_taskrefs. iu_taskrefsid) iu_taskrefsid,iu_taskrefs. changestamp changestamp
, 
iu_taskrefs.adddate 
iu_taskrefs_adddate 
, 
iu_taskrefs.theref 
iu_taskrefs_theref 
, 
iu_taskrefs.filetext 
iu_taskrefs_filetext 
, 
iu_taskrefs.dtypename 
iu_taskrefs_dtypename 
, 
iu_taskrefs.fileurl 
iu_taskrefs_fileurl 
, 
iu_taskrefs.origname 
iu_taskrefs_origname 
, 
 b2g(iu_taskrefs.filereftype)  
iu_taskrefs_filereftype_id, 
 iud_rt_def_brief_f(iu_taskrefs.filereftype, null) 
iu_taskrefs_filereftype 
, 
iu_taskrefs.version 
iu_taskrefs_version 
, 
 b2g(iu_taskrefs.addby)  
iu_taskrefs_addby_id, 
 iu_u_def_brief_f(iu_taskrefs.addby, null) 
iu_taskrefs_addby 
, 
iu_taskrefs.info 
iu_taskrefs_info 
, b2g(iu_taskrefs.instanceid) instanceid 
, iu_taskrefs.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_taskrefs.iu_taskrefsid) id 
, 'iu_taskrefs' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_taskrefs
 join INSTANCE on iu_taskrefs.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_taskrefs_ru_ru
go
create view v_autoiu_taskrefs_ru_ru as 
select   b2g(iu_taskrefs. iu_taskrefsid) iu_taskrefsid,iu_taskrefs. changestamp changestamp
, 
iu_taskrefs.adddate 
iu_taskrefs_adddate 
, 
iu_taskrefs.theref 
iu_taskrefs_theref 
, 
iu_taskrefs.filetext 
iu_taskrefs_filetext 
, 
iu_taskrefs.dtypename 
iu_taskrefs_dtypename 
, 
iu_taskrefs.fileurl 
iu_taskrefs_fileurl 
, 
iu_taskrefs.origname 
iu_taskrefs_origname 
, 
 b2g(iu_taskrefs.filereftype)  
iu_taskrefs_filereftype_id, 
 iud_rt_def_brief_f(iu_taskrefs.filereftype, 'ru_ru') 
iu_taskrefs_filereftype 
, 
iu_taskrefs.version 
iu_taskrefs_version 
, 
 b2g(iu_taskrefs.addby)  
iu_taskrefs_addby_id, 
 iu_u_def_brief_f(iu_taskrefs.addby, 'ru_ru') 
iu_taskrefs_addby 
, 
iu_taskrefs.info 
iu_taskrefs_info 
, b2g(iu_taskrefs.instanceid) instanceid 
, iu_taskrefs.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_taskrefs.iu_taskrefsid) id 
, 'iu_taskrefs' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_taskrefs
 join INSTANCE on iu_taskrefs.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_taskrefs_en_us
go
create view v_autoiu_taskrefs_en_us as 
select   b2g(iu_taskrefs. iu_taskrefsid) iu_taskrefsid,iu_taskrefs. changestamp changestamp
, 
iu_taskrefs.adddate 
iu_taskrefs_adddate 
, 
iu_taskrefs.theref 
iu_taskrefs_theref 
, 
iu_taskrefs.filetext 
iu_taskrefs_filetext 
, 
iu_taskrefs.dtypename 
iu_taskrefs_dtypename 
, 
iu_taskrefs.fileurl 
iu_taskrefs_fileurl 
, 
iu_taskrefs.origname 
iu_taskrefs_origname 
, 
 b2g(iu_taskrefs.filereftype)  
iu_taskrefs_filereftype_id, 
 iud_rt_def_brief_f(iu_taskrefs.filereftype, 'en_us') 
iu_taskrefs_filereftype 
, 
iu_taskrefs.version 
iu_taskrefs_version 
, 
 b2g(iu_taskrefs.addby)  
iu_taskrefs_addby_id, 
 iu_u_def_brief_f(iu_taskrefs.addby, 'en_us') 
iu_taskrefs_addby 
, 
iu_taskrefs.info 
iu_taskrefs_info 
, b2g(iu_taskrefs.instanceid) instanceid 
, iu_taskrefs.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_taskrefs.iu_taskrefsid) id 
, 'iu_taskrefs' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_taskrefs
 join INSTANCE on iu_taskrefs.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_l_def
go
create view v_autoiu_l_def as 
select   b2g(iu_l_def. iu_l_defid) iu_l_defid,iu_l_def. changestamp changestamp
, 
iu_l_def.readdate 
iu_l_def_readdate 
, 
iu_l_def.info 
iu_l_def_info 
, 
iu_l_def.createdate 
iu_l_def_createdate 
, 
 b2g(iu_l_def.sender)  
iu_l_def_sender_id, 
 iu_u_def_brief_f(iu_l_def.sender, null) 
iu_l_def_sender 
, 
 b2g(iu_l_def.doer)  
iu_l_def_doer_id, 
 iu_u_def_brief_f(iu_l_def.doer, null) 
iu_l_def_doer 
, b2g(iu_l_def.instanceid) instanceid 
, iu_l_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_l_def.iu_l_defid) id 
, 'iu_l_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_l_def
 join INSTANCE on iu_l_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_l_def_ru_ru
go
create view v_autoiu_l_def_ru_ru as 
select   b2g(iu_l_def. iu_l_defid) iu_l_defid,iu_l_def. changestamp changestamp
, 
iu_l_def.readdate 
iu_l_def_readdate 
, 
iu_l_def.info 
iu_l_def_info 
, 
iu_l_def.createdate 
iu_l_def_createdate 
, 
 b2g(iu_l_def.sender)  
iu_l_def_sender_id, 
 iu_u_def_brief_f(iu_l_def.sender, 'ru_ru') 
iu_l_def_sender 
, 
 b2g(iu_l_def.doer)  
iu_l_def_doer_id, 
 iu_u_def_brief_f(iu_l_def.doer, 'ru_ru') 
iu_l_def_doer 
, b2g(iu_l_def.instanceid) instanceid 
, iu_l_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_l_def.iu_l_defid) id 
, 'iu_l_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_l_def
 join INSTANCE on iu_l_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_l_def_en_us
go
create view v_autoiu_l_def_en_us as 
select   b2g(iu_l_def. iu_l_defid) iu_l_defid,iu_l_def. changestamp changestamp
, 
iu_l_def.readdate 
iu_l_def_readdate 
, 
iu_l_def.info 
iu_l_def_info 
, 
iu_l_def.createdate 
iu_l_def_createdate 
, 
 b2g(iu_l_def.sender)  
iu_l_def_sender_id, 
 iu_u_def_brief_f(iu_l_def.sender, 'en_us') 
iu_l_def_sender 
, 
 b2g(iu_l_def.doer)  
iu_l_def_doer_id, 
 iu_u_def_brief_f(iu_l_def.doer, 'en_us') 
iu_l_def_doer 
, b2g(iu_l_def.instanceid) instanceid 
, iu_l_def.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_l_def.iu_l_defid) id 
, 'iu_l_def' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_l_def
 join INSTANCE on iu_l_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_records
go
create view v_autoiu_tm_records as 
select   b2g(iu_tm_records. iu_tm_recordsid) iu_tm_recordsid,iu_tm_records. changestamp changestamp
, 
iu_tm_records.bankinfo 
iu_tm_records_bankinfo 
, 
iu_tm_records.scansnils 
iu_tm_records_scansnils 
, 
iu_tm_records.thecomment 
iu_tm_records_thecomment 
, 
iu_tm_records.passport 
iu_tm_records_passport 
, 
iu_tm_records.inn 
iu_tm_records_inn 
, 
iu_tm_records.scaninn 
iu_tm_records_scaninn 
, 
iu_tm_records.snils 
iu_tm_records_snils 
, 
iu_tm_records.tmfile 
iu_tm_records_tmfile 
, 
iu_tm_records.scanpassport 
iu_tm_records_scanpassport 
, 
iu_tm_records.info 
iu_tm_records_info 
, b2g(iu_tm_records.instanceid) instanceid 
, iu_tm_records.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_records.iu_tm_recordsid) id 
, 'iu_tm_records' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_records
 join INSTANCE on iu_tm_records.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_records_ru_ru
go
create view v_autoiu_tm_records_ru_ru as 
select   b2g(iu_tm_records. iu_tm_recordsid) iu_tm_recordsid,iu_tm_records. changestamp changestamp
, 
iu_tm_records.bankinfo 
iu_tm_records_bankinfo 
, 
iu_tm_records.scansnils 
iu_tm_records_scansnils 
, 
iu_tm_records.thecomment 
iu_tm_records_thecomment 
, 
iu_tm_records.passport 
iu_tm_records_passport 
, 
iu_tm_records.inn 
iu_tm_records_inn 
, 
iu_tm_records.scaninn 
iu_tm_records_scaninn 
, 
iu_tm_records.snils 
iu_tm_records_snils 
, 
iu_tm_records.tmfile 
iu_tm_records_tmfile 
, 
iu_tm_records.scanpassport 
iu_tm_records_scanpassport 
, 
iu_tm_records.info 
iu_tm_records_info 
, b2g(iu_tm_records.instanceid) instanceid 
, iu_tm_records.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_records.iu_tm_recordsid) id 
, 'iu_tm_records' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_records
 join INSTANCE on iu_tm_records.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_records_en_us
go
create view v_autoiu_tm_records_en_us as 
select   b2g(iu_tm_records. iu_tm_recordsid) iu_tm_recordsid,iu_tm_records. changestamp changestamp
, 
iu_tm_records.bankinfo 
iu_tm_records_bankinfo 
, 
iu_tm_records.scansnils 
iu_tm_records_scansnils 
, 
iu_tm_records.thecomment 
iu_tm_records_thecomment 
, 
iu_tm_records.passport 
iu_tm_records_passport 
, 
iu_tm_records.inn 
iu_tm_records_inn 
, 
iu_tm_records.scaninn 
iu_tm_records_scaninn 
, 
iu_tm_records.snils 
iu_tm_records_snils 
, 
iu_tm_records.tmfile 
iu_tm_records_tmfile 
, 
iu_tm_records.scanpassport 
iu_tm_records_scanpassport 
, 
iu_tm_records.info 
iu_tm_records_info 
, b2g(iu_tm_records.instanceid) instanceid 
, iu_tm_records.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_records.iu_tm_recordsid) id 
, 'iu_tm_records' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_records
 join INSTANCE on iu_tm_records.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tmdef
go
create view v_autoiu_tmdef as 
select   b2g(iu_tmdef. iu_tmdefid) iu_tmdefid,iu_tmdef. changestamp changestamp
, 
iu_tmdef.email 
iu_tmdef_email 
, 
iu_tmdef.surname 
iu_tmdef_surname 
, 
iu_tmdef.lastname 
iu_tmdef_lastname 
, 
iu_tmdef.name 
iu_tmdef_name 
, 
iu_tmdef.thephone 
iu_tmdef_thephone 
, 
 iu_tmdef.ismethodist  
iu_tmdef_ismethodist_val, 
 case iu_tmdef.ismethodist 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_tmdef_ismethodist 
, 
 b2g(iu_tmdef.thetown)  
iu_tmdef_thetown_id, 
 iud_town_brief_f(iu_tmdef.thetown, null) 
iu_tmdef_thetown 
, 
iu_tmdef.classes 
iu_tmdef_classes 
, 
iu_tmdef.workat 
iu_tmdef_workat 
, 
 iu_tmdef.subjects  
iu_tmdef_subjects_id, 
 iud_predmet_mref_f(iu_tmdef.subjects, null) 
iu_tmdef_subjects 
, 
 iu_tmdef.sendtomail  
iu_tmdef_sendtomail_val, 
 case iu_tmdef.sendtomail 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_tmdef_sendtomail 
, 
iu_tmdef.regal 
iu_tmdef_regal 
, b2g(iu_tmdef.instanceid) instanceid 
, iu_tmdef.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tmdef.iu_tmdefid) id 
, 'iu_tmdef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tmdef
 join INSTANCE on iu_tmdef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tmdef_ru_ru
go
create view v_autoiu_tmdef_ru_ru as 
select   b2g(iu_tmdef. iu_tmdefid) iu_tmdefid,iu_tmdef. changestamp changestamp
, 
iu_tmdef.email 
iu_tmdef_email 
, 
iu_tmdef.surname 
iu_tmdef_surname 
, 
iu_tmdef.lastname 
iu_tmdef_lastname 
, 
iu_tmdef.name 
iu_tmdef_name 
, 
iu_tmdef.thephone 
iu_tmdef_thephone 
, 
 iu_tmdef.ismethodist  
iu_tmdef_ismethodist_val, 
 case iu_tmdef.ismethodist 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_tmdef_ismethodist 
, 
 b2g(iu_tmdef.thetown)  
iu_tmdef_thetown_id, 
 iud_town_brief_f(iu_tmdef.thetown, 'ru_ru') 
iu_tmdef_thetown 
, 
iu_tmdef.classes 
iu_tmdef_classes 
, 
iu_tmdef.workat 
iu_tmdef_workat 
, 
 iu_tmdef.subjects  
iu_tmdef_subjects_id, 
 iud_predmet_mref_f(iu_tmdef.subjects, 'ru_ru') 
iu_tmdef_subjects 
, 
 iu_tmdef.sendtomail  
iu_tmdef_sendtomail_val, 
 case iu_tmdef.sendtomail 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_tmdef_sendtomail 
, 
iu_tmdef.regal 
iu_tmdef_regal 
, b2g(iu_tmdef.instanceid) instanceid 
, iu_tmdef.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tmdef.iu_tmdefid) id 
, 'iu_tmdef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tmdef
 join INSTANCE on iu_tmdef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tmdef_en_us
go
create view v_autoiu_tmdef_en_us as 
select   b2g(iu_tmdef. iu_tmdefid) iu_tmdefid,iu_tmdef. changestamp changestamp
, 
iu_tmdef.email 
iu_tmdef_email 
, 
iu_tmdef.surname 
iu_tmdef_surname 
, 
iu_tmdef.lastname 
iu_tmdef_lastname 
, 
iu_tmdef.name 
iu_tmdef_name 
, 
iu_tmdef.thephone 
iu_tmdef_thephone 
, 
 iu_tmdef.ismethodist  
iu_tmdef_ismethodist_val, 
 case iu_tmdef.ismethodist 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_tmdef_ismethodist 
, 
 b2g(iu_tmdef.thetown)  
iu_tmdef_thetown_id, 
 iud_town_brief_f(iu_tmdef.thetown, 'en_us') 
iu_tmdef_thetown 
, 
iu_tmdef.classes 
iu_tmdef_classes 
, 
iu_tmdef.workat 
iu_tmdef_workat 
, 
 iu_tmdef.subjects  
iu_tmdef_subjects_id, 
 iud_predmet_mref_f(iu_tmdef.subjects, 'en_us') 
iu_tmdef_subjects 
, 
 iu_tmdef.sendtomail  
iu_tmdef_sendtomail_val, 
 case iu_tmdef.sendtomail 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_tmdef_sendtomail 
, 
iu_tmdef.regal 
iu_tmdef_regal 
, b2g(iu_tmdef.instanceid) instanceid 
, iu_tmdef.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tmdef.iu_tmdefid) id 
, 'iu_tmdef' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tmdef
 join INSTANCE on iu_tmdef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tmcadr
go
create view v_autoiu_tmcadr as 
select   b2g(iu_tmcadr. iu_tmcadrid) iu_tmcadrid,iu_tmcadr. changestamp changestamp
, 
iu_tmcadr.info 
iu_tmcadr_info 
, 
 iu_tmcadr.mastercadr  
iu_tmcadr_mastercadr_val, 
 case iu_tmcadr.mastercadr 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_tmcadr_mastercadr 
, 
iu_tmcadr.photo 
iu_tmcadr_photo 
, b2g(iu_tmcadr.instanceid) instanceid 
, iu_tmcadr.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tmcadr.iu_tmcadrid) id 
, 'iu_tmcadr' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tmcadr
 join INSTANCE on iu_tmcadr.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tmcadr_ru_ru
go
create view v_autoiu_tmcadr_ru_ru as 
select   b2g(iu_tmcadr. iu_tmcadrid) iu_tmcadrid,iu_tmcadr. changestamp changestamp
, 
iu_tmcadr.info 
iu_tmcadr_info 
, 
 iu_tmcadr.mastercadr  
iu_tmcadr_mastercadr_val, 
 case iu_tmcadr.mastercadr 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_tmcadr_mastercadr 
, 
iu_tmcadr.photo 
iu_tmcadr_photo 
, b2g(iu_tmcadr.instanceid) instanceid 
, iu_tmcadr.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tmcadr.iu_tmcadrid) id 
, 'iu_tmcadr' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tmcadr
 join INSTANCE on iu_tmcadr.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tmcadr_en_us
go
create view v_autoiu_tmcadr_en_us as 
select   b2g(iu_tmcadr. iu_tmcadrid) iu_tmcadrid,iu_tmcadr. changestamp changestamp
, 
iu_tmcadr.info 
iu_tmcadr_info 
, 
 iu_tmcadr.mastercadr  
iu_tmcadr_mastercadr_val, 
 case iu_tmcadr.mastercadr 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_tmcadr_mastercadr 
, 
iu_tmcadr.photo 
iu_tmcadr_photo 
, b2g(iu_tmcadr.instanceid) instanceid 
, iu_tmcadr.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tmcadr.iu_tmcadrid) id 
, 'iu_tmcadr' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tmcadr
 join INSTANCE on iu_tmcadr.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_act
go
create view v_autoiu_tm_act as 
select   b2g(iu_tm_act. iu_tm_actid) iu_tm_actid,iu_tm_act. changestamp changestamp
, 
iu_tm_act.paymentdate 
iu_tm_act_paymentdate 
, 
iu_tm_act.aktfile 
iu_tm_act_aktfile 
, 
iu_tm_act.aktnum 
iu_tm_act_aktnum 
, 
iu_tm_act.quantity 
iu_tm_act_quantity 
, 
iu_tm_act.payment 
iu_tm_act_payment 
, 
iu_tm_act.thecomment 
iu_tm_act_thecomment 
, b2g(iu_tm_act.instanceid) instanceid 
, iu_tm_act.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_act.iu_tm_actid) id 
, 'iu_tm_act' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_act
 join INSTANCE on iu_tm_act.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_act_ru_ru
go
create view v_autoiu_tm_act_ru_ru as 
select   b2g(iu_tm_act. iu_tm_actid) iu_tm_actid,iu_tm_act. changestamp changestamp
, 
iu_tm_act.paymentdate 
iu_tm_act_paymentdate 
, 
iu_tm_act.aktfile 
iu_tm_act_aktfile 
, 
iu_tm_act.aktnum 
iu_tm_act_aktnum 
, 
iu_tm_act.quantity 
iu_tm_act_quantity 
, 
iu_tm_act.payment 
iu_tm_act_payment 
, 
iu_tm_act.thecomment 
iu_tm_act_thecomment 
, b2g(iu_tm_act.instanceid) instanceid 
, iu_tm_act.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_act.iu_tm_actid) id 
, 'iu_tm_act' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_act
 join INSTANCE on iu_tm_act.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_act_en_us
go
create view v_autoiu_tm_act_en_us as 
select   b2g(iu_tm_act. iu_tm_actid) iu_tm_actid,iu_tm_act. changestamp changestamp
, 
iu_tm_act.paymentdate 
iu_tm_act_paymentdate 
, 
iu_tm_act.aktfile 
iu_tm_act_aktfile 
, 
iu_tm_act.aktnum 
iu_tm_act_aktnum 
, 
iu_tm_act.quantity 
iu_tm_act_quantity 
, 
iu_tm_act.payment 
iu_tm_act_payment 
, 
iu_tm_act.thecomment 
iu_tm_act_thecomment 
, b2g(iu_tm_act.instanceid) instanceid 
, iu_tm_act.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_act.iu_tm_actid) id 
, 'iu_tm_act' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_act
 join INSTANCE on iu_tm_act.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_actfile
go
create view v_autoiu_tm_actfile as 
select   b2g(iu_tm_actfile. iu_tm_actfileid) iu_tm_actfileid,iu_tm_actfile. changestamp changestamp, b2g(iu_tm_actid) iu_tm_actid
, 
iu_tm_actfile.info 
iu_tm_actfile_info 
, 
 b2g(iu_tm_actfile.dtype)  
iu_tm_actfile_dtype_id, 
 iud_adt_doc_brief_f(iu_tm_actfile.dtype, null) 
iu_tm_actfile_dtype 
, 
iu_tm_actfile.theref 
iu_tm_actfile_theref 
, b2g(iu_tm_act.instanceid) instanceid 
, iu_tm_act.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_actfile.iu_tm_actfileid) id 
, 'iu_tm_actfile' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_actfile
 join iu_tm_act on iu_tm_act.iu_tm_actID=iu_tm_actfile.ParentStructRowID 
 join INSTANCE on iu_tm_act.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_actfile_ru_ru
go
create view v_autoiu_tm_actfile_ru_ru as 
select   b2g(iu_tm_actfile. iu_tm_actfileid) iu_tm_actfileid,iu_tm_actfile. changestamp changestamp, b2g(iu_tm_actid) iu_tm_actid
, 
iu_tm_actfile.info 
iu_tm_actfile_info 
, 
 b2g(iu_tm_actfile.dtype)  
iu_tm_actfile_dtype_id, 
 iud_adt_doc_brief_f(iu_tm_actfile.dtype, 'ru_ru') 
iu_tm_actfile_dtype 
, 
iu_tm_actfile.theref 
iu_tm_actfile_theref 
, b2g(iu_tm_act.instanceid) instanceid 
, iu_tm_act.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_actfile.iu_tm_actfileid) id 
, 'iu_tm_actfile' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_actfile
 join iu_tm_act on iu_tm_act.iu_tm_actID=iu_tm_actfile.ParentStructRowID 
 join INSTANCE on iu_tm_act.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_actfile_en_us
go
create view v_autoiu_tm_actfile_en_us as 
select   b2g(iu_tm_actfile. iu_tm_actfileid) iu_tm_actfileid,iu_tm_actfile. changestamp changestamp, b2g(iu_tm_actid) iu_tm_actid
, 
iu_tm_actfile.info 
iu_tm_actfile_info 
, 
 b2g(iu_tm_actfile.dtype)  
iu_tm_actfile_dtype_id, 
 iud_adt_doc_brief_f(iu_tm_actfile.dtype, 'en_us') 
iu_tm_actfile_dtype 
, 
iu_tm_actfile.theref 
iu_tm_actfile_theref 
, b2g(iu_tm_act.instanceid) instanceid 
, iu_tm_act.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_actfile.iu_tm_actfileid) id 
, 'iu_tm_actfile' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_actfile
 join iu_tm_act on iu_tm_act.iu_tm_actID=iu_tm_actfile.ParentStructRowID 
 join INSTANCE on iu_tm_act.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_dog
go
create view v_autoiu_tm_dog as 
select   b2g(iu_tm_dog. iu_tm_dogid) iu_tm_dogid,iu_tm_dog. changestamp changestamp
, 
iu_tm_dog.info 
iu_tm_dog_info 
, 
iu_tm_dog.thenumber 
iu_tm_dog_thenumber 
, 
iu_tm_dog.thedate 
iu_tm_dog_thedate 
, 
iu_tm_dog.dogfile 
iu_tm_dog_dogfile 
, b2g(iu_tm_dog.instanceid) instanceid 
, iu_tm_dog.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_dog.iu_tm_dogid) id 
, 'iu_tm_dog' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_dog
 join INSTANCE on iu_tm_dog.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_dog_ru_ru
go
create view v_autoiu_tm_dog_ru_ru as 
select   b2g(iu_tm_dog. iu_tm_dogid) iu_tm_dogid,iu_tm_dog. changestamp changestamp
, 
iu_tm_dog.info 
iu_tm_dog_info 
, 
iu_tm_dog.thenumber 
iu_tm_dog_thenumber 
, 
iu_tm_dog.thedate 
iu_tm_dog_thedate 
, 
iu_tm_dog.dogfile 
iu_tm_dog_dogfile 
, b2g(iu_tm_dog.instanceid) instanceid 
, iu_tm_dog.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_dog.iu_tm_dogid) id 
, 'iu_tm_dog' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_dog
 join INSTANCE on iu_tm_dog.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_tm_dog_en_us
go
create view v_autoiu_tm_dog_en_us as 
select   b2g(iu_tm_dog. iu_tm_dogid) iu_tm_dogid,iu_tm_dog. changestamp changestamp
, 
iu_tm_dog.info 
iu_tm_dog_info 
, 
iu_tm_dog.thenumber 
iu_tm_dog_thenumber 
, 
iu_tm_dog.thedate 
iu_tm_dog_thedate 
, 
iu_tm_dog.dogfile 
iu_tm_dog_dogfile 
, b2g(iu_tm_dog.instanceid) instanceid 
, iu_tm_dog.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_tm_dog.iu_tm_dogid) id 
, 'iu_tm_dog' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_tm_dog
 join INSTANCE on iu_tm_dog.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autorptstruct
go
create view v_autorptstruct as 
select   b2g(rptstruct. rptstructid) rptstructid,rptstruct. changestamp changestamp
, 
rptstruct.caption 
rptstruct_caption 
, 
rptstruct.name 
rptstruct_name 
, b2g(rptstruct.instanceid) instanceid 
, rptstruct.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(rptstruct.rptstructid) id 
, 'rptstruct' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from RPTStruct
 join INSTANCE on RPTStruct.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autorptstruct_ru_ru
go
create view v_autorptstruct_ru_ru as 
select   b2g(rptstruct. rptstructid) rptstructid,rptstruct. changestamp changestamp
, 
rptstruct.caption 
rptstruct_caption 
, 
rptstruct.name 
rptstruct_name 
, b2g(rptstruct.instanceid) instanceid 
, rptstruct.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(rptstruct.rptstructid) id 
, 'rptstruct' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from RPTStruct
 join INSTANCE on RPTStruct.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autorptstruct_en_us
go
create view v_autorptstruct_en_us as 
select   b2g(rptstruct. rptstructid) rptstructid,rptstruct. changestamp changestamp
, 
rptstruct.caption 
rptstruct_caption 
, 
rptstruct.name 
rptstruct_name 
, b2g(rptstruct.instanceid) instanceid 
, rptstruct.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(rptstruct.rptstructid) id 
, 'rptstruct' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from RPTStruct
 join INSTANCE on RPTStruct.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autorptfields
go
create view v_autorptfields as 
select   b2g(rptfields. rptfieldsid) rptfieldsid,rptfields. changestamp changestamp, b2g(rptstructid) rptstructid
, 
 b2g(rptfields.fieldtype)  
rptfields_fieldtype_id, 
 fieldtype_brief_f(rptfields.fieldtype, null) 
rptfields_fieldtype 
, 
rptfields.fieldsize 
rptfields_fieldsize 
, 
rptfields.name 
rptfields_name 
, 
rptfields.caption 
rptfields_caption 
, b2g(rptstruct.instanceid) instanceid 
, rptstruct.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(rptfields.rptfieldsid) id 
, 'rptfields' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from RPTFields
 join RPTStruct on RPTStruct.RPTStructID=RPTFields.ParentStructRowID 
 join INSTANCE on RPTStruct.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autorptfields_ru_ru
go
create view v_autorptfields_ru_ru as 
select   b2g(rptfields. rptfieldsid) rptfieldsid,rptfields. changestamp changestamp, b2g(rptstructid) rptstructid
, 
 b2g(rptfields.fieldtype)  
rptfields_fieldtype_id, 
 fieldtype_brief_f(rptfields.fieldtype, 'ru_ru') 
rptfields_fieldtype 
, 
rptfields.fieldsize 
rptfields_fieldsize 
, 
rptfields.name 
rptfields_name 
, 
rptfields.caption 
rptfields_caption 
, b2g(rptstruct.instanceid) instanceid 
, rptstruct.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(rptfields.rptfieldsid) id 
, 'rptfields' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from RPTFields
 join RPTStruct on RPTStruct.RPTStructID=RPTFields.ParentStructRowID 
 join INSTANCE on RPTStruct.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autorptfields_en_us
go
create view v_autorptfields_en_us as 
select   b2g(rptfields. rptfieldsid) rptfieldsid,rptfields. changestamp changestamp, b2g(rptstructid) rptstructid
, 
 b2g(rptfields.fieldtype)  
rptfields_fieldtype_id, 
 fieldtype_brief_f(rptfields.fieldtype, 'en_us') 
rptfields_fieldtype 
, 
rptfields.fieldsize 
rptfields_fieldsize 
, 
rptfields.name 
rptfields_name 
, 
rptfields.caption 
rptfields_caption 
, b2g(rptstruct.instanceid) instanceid 
, rptstruct.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(rptfields.rptfieldsid) id 
, 'rptfields' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from RPTFields
 join RPTStruct on RPTStruct.RPTStructID=RPTFields.ParentStructRowID 
 join INSTANCE on RPTStruct.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autorptformula
go
create view v_autorptformula as 
select   b2g(rptformula. rptformulaid) rptformulaid,rptformula. changestamp changestamp
, 
 b2g(rptformula.platform)  
rptformula_platform_id, 
 generator_target_brief_f(rptformula.platform, null) 
rptformula_platform 
, 
rptformula.code 
rptformula_code 
, 
rptformula.name 
rptformula_name 
, b2g(rptformula.instanceid) instanceid 
, rptformula.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(rptformula.rptformulaid) id 
, 'rptformula' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from RPTFormula
 join INSTANCE on RPTFormula.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autorptformula_ru_ru
go
create view v_autorptformula_ru_ru as 
select   b2g(rptformula. rptformulaid) rptformulaid,rptformula. changestamp changestamp
, 
 b2g(rptformula.platform)  
rptformula_platform_id, 
 generator_target_brief_f(rptformula.platform, 'ru_ru') 
rptformula_platform 
, 
rptformula.code 
rptformula_code 
, 
rptformula.name 
rptformula_name 
, b2g(rptformula.instanceid) instanceid 
, rptformula.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(rptformula.rptformulaid) id 
, 'rptformula' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from RPTFormula
 join INSTANCE on RPTFormula.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autorptformula_en_us
go
create view v_autorptformula_en_us as 
select   b2g(rptformula. rptformulaid) rptformulaid,rptformula. changestamp changestamp
, 
 b2g(rptformula.platform)  
rptformula_platform_id, 
 generator_target_brief_f(rptformula.platform, 'en_us') 
rptformula_platform 
, 
rptformula.code 
rptformula_code 
, 
rptformula.name 
rptformula_name 
, b2g(rptformula.instanceid) instanceid 
, rptformula.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(rptformula.rptformulaid) id 
, 'rptformula' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from RPTFormula
 join INSTANCE on RPTFormula.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoreports
go
create view v_autoreports as 
select   b2g(reports. reportsid) reportsid,reports. changestamp changestamp
, 
 reports.reporttype  
reports_reporttype_val, 
 case reports.reporttype 
when 4 then 'экспорт по excel шаблону'
when 0 then 'таблица'
when 3 then 'экспорт по word шаблону'
when 1 then 'двумерная матрица'
when 2 then 'только расчет'
 else '' 
 end  
reports_reporttype 
, 
reports.reportview 
reports_reportview 
, 
reports.caption 
reports_caption 
, 
reports.name 
reports_name 
, 
 b2g(reports.thereportext)  
reports_thereportext_id, 
 instance_brief_f(reports.thereportext , null) 
reports_thereportext 
, 
reports.reportfile 
reports_reportfile 
, 
 b2g(reports.preparemethod)  
reports_preparemethod_id, 
 sharedmethod_brief_f(reports.preparemethod, null) 
reports_preparemethod 
, 
reports.thecomment 
reports_thecomment 
, b2g(reports.instanceid) instanceid 
, reports.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(reports.reportsid) id 
, 'reports' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Reports
 join INSTANCE on Reports.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoreports_ru_ru
go
create view v_autoreports_ru_ru as 
select   b2g(reports. reportsid) reportsid,reports. changestamp changestamp
, 
 reports.reporttype  
reports_reporttype_val, 
 case reports.reporttype 
when 4 then 'экспорт по excel шаблону'
when 0 then 'таблица'
when 3 then 'экспорт по word шаблону'
when 1 then 'двумерная матрица'
when 2 then 'только расчет'
 else '' 
 end  
reports_reporttype 
, 
reports.reportview 
reports_reportview 
, 
reports.caption 
reports_caption 
, 
reports.name 
reports_name 
, 
 b2g(reports.thereportext)  
reports_thereportext_id, 
 instance_brief_f(reports.thereportext, 'ru_ru') 
reports_thereportext 
, 
reports.reportfile 
reports_reportfile 
, 
 b2g(reports.preparemethod)  
reports_preparemethod_id, 
 sharedmethod_brief_f(reports.preparemethod, 'ru_ru') 
reports_preparemethod 
, 
reports.thecomment 
reports_thecomment 
, b2g(reports.instanceid) instanceid 
, reports.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(reports.reportsid) id 
, 'reports' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Reports
 join INSTANCE on Reports.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoreports_en_us
go
create view v_autoreports_en_us as 
select   b2g(reports. reportsid) reportsid,reports. changestamp changestamp
, 
 reports.reporttype  
reports_reporttype_val, 
 case reports.reporttype 
when 4 then 'экспорт по excel шаблону'
when 0 then 'таблица'
when 3 then 'экспорт по word шаблону'
when 1 then 'двумерная матрица'
when 2 then 'только расчет'
 else '' 
 end  
reports_reporttype 
, 
reports.reportview 
reports_reportview 
, 
reports.caption 
reports_caption 
, 
reports.name 
reports_name 
, 
 b2g(reports.thereportext)  
reports_thereportext_id, 
 instance_brief_f(reports.thereportext, 'en_us') 
reports_thereportext 
, 
reports.reportfile 
reports_reportfile 
, 
 b2g(reports.preparemethod)  
reports_preparemethod_id, 
 sharedmethod_brief_f(reports.preparemethod, 'en_us') 
reports_preparemethod 
, 
reports.thecomment 
reports_thecomment 
, b2g(reports.instanceid) instanceid 
, reports.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(reports.reportsid) id 
, 'reports' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from Reports
 join INSTANCE on Reports.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_subsribe
go
create view v_autoiu_subsribe as 
select   b2g(iu_subsribe. iu_subsribeid) iu_subsribeid,iu_subsribe. changestamp changestamp
, 
 b2g(iu_subsribe.theprocess)  
iu_subsribe_theprocess_id, 
 iu_urok_def_brief_f(iu_subsribe.theprocess, null) 
iu_subsribe_theprocess 
, 
 b2g(iu_subsribe.thedoc)  
iu_subsribe_thedoc_id, 
 iu_urok_docs_brief_f(iu_subsribe.thedoc, null) 
iu_subsribe_thedoc 
, 
 b2g(iu_subsribe.statetask)  
iu_subsribe_statetask_id, 
 iu_task_brief_f(iu_subsribe.statetask, null) 
iu_subsribe_statetask 
, 
iu_subsribe.scandate 
iu_subsribe_scandate 
, 
 b2g(iu_subsribe.thevideo)  
iu_subsribe_thevideo_id, 
 iu_urok_video_brief_f(iu_subsribe.thevideo, null) 
iu_subsribe_thevideo 
, 
 b2g(iu_subsribe.thediscussion)  
iu_subsribe_thediscussion_id, 
 iu_cm_def_brief_f(iu_subsribe.thediscussion, null) 
iu_subsribe_thediscussion 
, 
 b2g(iu_subsribe.processstatus)  
iu_subsribe_processstatus_id, 
 iu_status_brief_f(iu_subsribe.processstatus, null) 
iu_subsribe_processstatus 
, 
 iu_subsribe.isactive  
iu_subsribe_isactive_val, 
 case iu_subsribe.isactive 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_subsribe_isactive 
, 
iu_subsribe.eventtype 
iu_subsribe_eventtype 
, 
 b2g(iu_subsribe.doer)  
iu_subsribe_doer_id, 
 iu_u_def_brief_f(iu_subsribe.doer, null) 
iu_subsribe_doer 
, 
 b2g(iu_subsribe.subscriber)  
iu_subsribe_subscriber_id, 
 iu_u_def_brief_f(iu_subsribe.subscriber, null) 
iu_subsribe_subscriber 
, b2g(iu_subsribe.instanceid) instanceid 
, iu_subsribe.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_subsribe.iu_subsribeid) id 
, 'iu_subsribe' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_subsribe
 join INSTANCE on iu_subsribe.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_subsribe_ru_ru
go
create view v_autoiu_subsribe_ru_ru as 
select   b2g(iu_subsribe. iu_subsribeid) iu_subsribeid,iu_subsribe. changestamp changestamp
, 
 b2g(iu_subsribe.theprocess)  
iu_subsribe_theprocess_id, 
 iu_urok_def_brief_f(iu_subsribe.theprocess, 'ru_ru') 
iu_subsribe_theprocess 
, 
 b2g(iu_subsribe.thedoc)  
iu_subsribe_thedoc_id, 
 iu_urok_docs_brief_f(iu_subsribe.thedoc, 'ru_ru') 
iu_subsribe_thedoc 
, 
 b2g(iu_subsribe.statetask)  
iu_subsribe_statetask_id, 
 iu_task_brief_f(iu_subsribe.statetask, 'ru_ru') 
iu_subsribe_statetask 
, 
iu_subsribe.scandate 
iu_subsribe_scandate 
, 
 b2g(iu_subsribe.thevideo)  
iu_subsribe_thevideo_id, 
 iu_urok_video_brief_f(iu_subsribe.thevideo, 'ru_ru') 
iu_subsribe_thevideo 
, 
 b2g(iu_subsribe.thediscussion)  
iu_subsribe_thediscussion_id, 
 iu_cm_def_brief_f(iu_subsribe.thediscussion, 'ru_ru') 
iu_subsribe_thediscussion 
, 
 b2g(iu_subsribe.processstatus)  
iu_subsribe_processstatus_id, 
 iu_status_brief_f(iu_subsribe.processstatus, 'ru_ru') 
iu_subsribe_processstatus 
, 
 iu_subsribe.isactive  
iu_subsribe_isactive_val, 
 case iu_subsribe.isactive 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_subsribe_isactive 
, 
iu_subsribe.eventtype 
iu_subsribe_eventtype 
, 
 b2g(iu_subsribe.doer)  
iu_subsribe_doer_id, 
 iu_u_def_brief_f(iu_subsribe.doer, 'ru_ru') 
iu_subsribe_doer 
, 
 b2g(iu_subsribe.subscriber)  
iu_subsribe_subscriber_id, 
 iu_u_def_brief_f(iu_subsribe.subscriber, 'ru_ru') 
iu_subsribe_subscriber 
, b2g(iu_subsribe.instanceid) instanceid 
, iu_subsribe.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_subsribe.iu_subsribeid) id 
, 'iu_subsribe' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_subsribe
 join INSTANCE on iu_subsribe.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO


drop view if exists v_autoiu_subsribe_en_us
go
create view v_autoiu_subsribe_en_us as 
select   b2g(iu_subsribe. iu_subsribeid) iu_subsribeid,iu_subsribe. changestamp changestamp
, 
 b2g(iu_subsribe.theprocess)  
iu_subsribe_theprocess_id, 
 iu_urok_def_brief_f(iu_subsribe.theprocess, 'en_us') 
iu_subsribe_theprocess 
, 
 b2g(iu_subsribe.thedoc)  
iu_subsribe_thedoc_id, 
 iu_urok_docs_brief_f(iu_subsribe.thedoc, 'en_us') 
iu_subsribe_thedoc 
, 
 b2g(iu_subsribe.statetask)  
iu_subsribe_statetask_id, 
 iu_task_brief_f(iu_subsribe.statetask, 'en_us') 
iu_subsribe_statetask 
, 
iu_subsribe.scandate 
iu_subsribe_scandate 
, 
 b2g(iu_subsribe.thevideo)  
iu_subsribe_thevideo_id, 
 iu_urok_video_brief_f(iu_subsribe.thevideo, 'en_us') 
iu_subsribe_thevideo 
, 
 b2g(iu_subsribe.thediscussion)  
iu_subsribe_thediscussion_id, 
 iu_cm_def_brief_f(iu_subsribe.thediscussion, 'en_us') 
iu_subsribe_thediscussion 
, 
 b2g(iu_subsribe.processstatus)  
iu_subsribe_processstatus_id, 
 iu_status_brief_f(iu_subsribe.processstatus, 'en_us') 
iu_subsribe_processstatus 
, 
 iu_subsribe.isactive  
iu_subsribe_isactive_val, 
 case iu_subsribe.isactive 
when -1 then 'да'
when 0 then 'нет'
 else '' 
 end  
iu_subsribe_isactive 
, 
iu_subsribe.eventtype 
iu_subsribe_eventtype 
, 
 b2g(iu_subsribe.doer)  
iu_subsribe_doer_id, 
 iu_u_def_brief_f(iu_subsribe.doer, 'en_us') 
iu_subsribe_doer 
, 
 b2g(iu_subsribe.subscriber)  
iu_subsribe_subscriber_id, 
 iu_u_def_brief_f(iu_subsribe.subscriber, 'en_us') 
iu_subsribe_subscriber 
, b2g(iu_subsribe.instanceid) instanceid 
, iu_subsribe.instanceid instanceid_val 
,  instance.archived   instance_archived 
, b2g(iu_subsribe.iu_subsribeid) id 
, 'iu_subsribe' viewbase 
, xxxmystatusxxx.name statusname 
, b2g(xxxmystatusxxx.objstatusid) intsancestatusid
 from iu_subsribe
 join INSTANCE on iu_subsribe.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid

GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procs" File="">
    <BlockHolder BlockName="--body" BlockCode=" 


drop procedure if exists iud_stage_copy
go

create procedure iud_stage_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_stagedef_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_stage_access_f
go

create function iud_stage_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_stage_export_f
go

create function iud_stage_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_adtype_copy
go

create procedure iud_adtype_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_adt_doc_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_adtype_access_f
go

create function iud_adtype_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_adtype_export_f
go

create function iud_adtype_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_org_copy
go

create procedure iu_org_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_orgtree_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_org_access_f
go

create function iu_org_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_org_export_f
go

create function iu_org_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_u_copy
go

create procedure iu_u_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_u_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_u_access_f
go

create function iu_u_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_u_export_f
go

create function iu_u_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_u_gettotemp
go

create procedure iu_u_gettotemp (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
call iu_u_def_gettotemp(acursession,ainstanceid);
select 'ok' result;
 end 
GO


drop procedure if exists iu_u_commitfromtemp
go

create procedure iu_u_commitfromtemp (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
call iu_u_def_commitfromtemp(acursession,ainstanceid);
select 'ok' result;
 end 
GO


drop procedure if exists iu_u_droptempdata
go

create procedure iu_u_droptempdata (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
call iu_u_def_droptempdata(acursession,ainstanceid);
select 'ok' result;
 end 
GO


drop procedure if exists iud_process_copy
go

create procedure iud_process_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_process_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_process_access_f
go

create function iud_process_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_process_export_f
go

create function iud_process_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtzmetamodel_copy
go

create procedure mtzmetamodel_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call genpackage_copy(acursession,aaction,ainstanceid);
call localizeinfo_copy(acursession,aaction,ainstanceid);
call fieldtype_copy(acursession,aaction,ainstanceid);
call sharedmethod_copy(acursession,aaction,ainstanceid);
call objecttype_copy(acursession,aaction,ainstanceid);
call mtzapp_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtzmetamodel_access_f
go

create function mtzmetamodel_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtzmetamodel_export_f
go

create function mtzmetamodel_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtzjrnl_copy
go

create procedure mtzjrnl_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call journalcolumn_copy(acursession,aaction,ainstanceid);
call journalsrc_copy(acursession,aaction,ainstanceid);
call journal_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtzjrnl_access_f
go

create function mtzjrnl_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtzjrnl_export_f
go

create function mtzjrnl_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_us_copy
go

create procedure iu_us_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_urok_sn_copy(acursession,aaction,ainstanceid);
call iu_urok_msg_copy(acursession,aaction,ainstanceid);
call iu_urok_graph_copy(acursession,aaction,ainstanceid);
call iu_urok_prc_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_us_access_f
go

create function iu_us_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_us_export_f
go

create function iu_us_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists stdinfostore_copy
go

create procedure stdinfostore_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call folder_copy(acursession,aaction,ainstanceid);
call infostoredef_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists stdinfostore_access_f
go

create function stdinfostore_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists stdinfostore_export_f
go

create function stdinfostore_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_rt_copy
go

create procedure iud_rt_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_rt_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_rt_access_f
go

create function iud_rt_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_rt_export_f
go

create function iud_rt_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtzsystem_copy
go

create procedure mtzsystem_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call the_session_copy(acursession,aaction,ainstanceid);
call sysrefcache_copy(acursession,aaction,ainstanceid);
call syslog_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtzsystem_access_f
go

create function mtzsystem_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtzsystem_export_f
go

create function mtzsystem_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtzwp_copy
go

create procedure mtzwp_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call armjournal_copy(acursession,aaction,ainstanceid);
call entrypoints_copy(acursession,aaction,ainstanceid);
call workplace_copy(acursession,aaction,ainstanceid);
call armtypes_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtzwp_access_f
go

create function mtzwp_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtzwp_export_f
go

create function mtzwp_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_d_urole_copy
go

create procedure iu_d_urole_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_crole_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_d_urole_access_f
go

create function iu_d_urole_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_d_urole_export_f
go

create function iu_d_urole_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists roles_copy
go

create procedure roles_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call roles_operations_copy(acursession,aaction,ainstanceid);
call roles_wp_copy(acursession,aaction,ainstanceid);
call roles2_module_copy(acursession,aaction,ainstanceid);
call roles_doc_copy(acursession,aaction,ainstanceid);
call roles_reports_copy(acursession,aaction,ainstanceid);
call roles_user_copy(acursession,aaction,ainstanceid);
call roles_map_copy(acursession,aaction,ainstanceid);
call roles_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists roles_access_f
go

create function roles_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists roles_export_f
go

create function roles_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_urok_copy
go

create procedure iu_urok_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_urok_docs_copy(acursession,aaction,ainstanceid);
call iu_urok_creators_copy(acursession,aaction,ainstanceid);
call iu_urok_def_copy(acursession,aaction,ainstanceid);
call iu_urok_video_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO


drop procedure if exists iu_urok_initownership
go

create procedure iu_urok_initownership  (
 acursession varchar(38),
 ainstanceid varchar(38)
) body: begin  
 declare aec int;
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     leave body;
  end if;
end 
go
GO



drop function if exists iu_urok_access_f
go

create function iu_urok_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_urok_export_f
go

create function iu_urok_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_mt_copy
go

create procedure iud_mt_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_mt_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_mt_access_f
go

create function iud_mt_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_mt_export_f
go

create function iud_mt_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_sn_copy
go

create procedure iud_sn_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_sn_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_sn_access_f
go

create function iud_sn_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_sn_export_f
go

create function iud_sn_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_fst_copy
go

create procedure iud_fst_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_filestoretype_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_fst_access_f
go

create function iud_fst_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_fst_export_f
go

create function iud_fst_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_p_copy
go

create procedure iud_p_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_predmet_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_p_access_f
go

create function iud_p_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_p_export_f
go

create function iud_p_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_d_doctype_copy
go

create procedure iu_d_doctype_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_doctype_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_d_doctype_access_f
go

create function iu_d_doctype_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_d_doctype_export_f
go

create function iu_d_doctype_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtzusers_copy
go

create procedure mtzusers_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call users_copy(acursession,aaction,ainstanceid);
call groups_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtzusers_access_f
go

create function mtzusers_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtzusers_export_f
go

create function mtzusers_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_cls_copy
go

create procedure iu_cls_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_clsinfo_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_cls_access_f
go

create function iu_cls_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_cls_export_f
go

create function iu_cls_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists stdnumerator_copy
go

create procedure stdnumerator_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call num_zones_copy(acursession,aaction,ainstanceid);
call num_head_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists stdnumerator_access_f
go

create function stdnumerator_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists stdnumerator_export_f
go

create function stdnumerator_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_ft_copy
go

create procedure iud_ft_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_filetype_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_ft_access_f
go

create function iud_ft_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_ft_export_f
go

create function iud_ft_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtzext_copy
go

create procedure mtzext_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call mtzext_def_copy(acursession,aaction,ainstanceid);
call mtzextrel_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtzext_access_f
go

create function mtzext_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtzext_export_f
go

create function mtzext_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_vt_copy
go

create procedure iud_vt_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_videotype_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_vt_access_f
go

create function iud_vt_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_vt_export_f
go

create function iud_vt_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_cm_copy
go

create procedure iu_cm_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_cm_def_copy(acursession,aaction,ainstanceid);
call iu_cm_time_copy(acursession,aaction,ainstanceid);
call iu_cm_msg_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_cm_access_f
go

create function iu_cm_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_cm_export_f
go

create function iu_cm_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_plog_copy
go

create procedure iu_plog_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_plevent_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_plog_access_f
go

create function iu_plog_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_plog_export_f
go

create function iu_plog_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_rcfg_copy
go

create procedure iu_rcfg_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_rcfg_mod_copy(acursession,aaction,ainstanceid);
call iu_rcfg_docmode_copy(acursession,aaction,ainstanceid);
call iu_rcfg_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_rcfg_access_f
go

create function iu_rcfg_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_rcfg_export_f
go

create function iu_rcfg_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_t_copy
go

create procedure iud_t_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_town_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_t_access_f
go

create function iud_t_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_t_export_f
go

create function iud_t_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_reg_copy
go

create procedure iu_reg_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_regtree_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_reg_access_f
go

create function iu_reg_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_reg_export_f
go

create function iu_reg_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_s_copy
go

create procedure iu_s_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_status_copy(acursession,aaction,ainstanceid);
call iu_status_doer_copy(acursession,aaction,ainstanceid);
call iu_statustask_copy(acursession,aaction,ainstanceid);
call iu_stausdoc_copy(acursession,aaction,ainstanceid);
call iu_statusnext_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_s_access_f
go

create function iu_s_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_s_export_f
go

create function iu_s_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtz2job_copy
go

create procedure mtz2job_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call mtz2job_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtz2job_access_f
go

create function mtz2job_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtz2job_export_f
go

create function mtz2job_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_c_copy
go

create procedure iud_c_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_ctype_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_c_access_f
go

create function iud_c_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_c_export_f
go

create function iud_c_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iud_sp_copy
go

create procedure iud_sp_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iud_spub_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iud_sp_access_f
go

create function iud_sp_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iud_sp_export_f
go

create function iud_sp_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtzfltr_copy
go

create procedure mtzfltr_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call filterfieldgroup_copy(acursession,aaction,ainstanceid);
call filters_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtzfltr_access_f
go

create function mtzfltr_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtzfltr_export_f
go

create function mtzfltr_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_int_copy
go

create procedure iu_int_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_int_modules_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_int_access_f
go

create function iu_int_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_int_export_f
go

create function iu_int_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_t_copy
go

create procedure iu_t_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_task_copy(acursession,aaction,ainstanceid);
call iu_taskattach_copy(acursession,aaction,ainstanceid);
call iu_taskvideo_copy(acursession,aaction,ainstanceid);
call iu_taskrefs_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO


drop procedure if exists iu_t_initownership
go

create procedure iu_t_initownership  (
 acursession varchar(38),
 ainstanceid varchar(38)
) body: begin  
 declare aec int;
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     leave body;
  end if;
end 
go
GO



drop function if exists iu_t_access_f
go

create function iu_t_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_t_export_f
go

create function iu_t_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_l_copy
go

create procedure iu_l_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_l_def_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO


drop procedure if exists iu_l_initownership
go

create procedure iu_l_initownership  (
 acursession varchar(38),
 ainstanceid varchar(38)
) body: begin  
 declare aec int;
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     leave body;
  end if;
end 
go
GO



drop function if exists iu_l_access_f
go

create function iu_l_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_l_export_f
go

create function iu_l_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_tm_copy
go

create procedure iu_tm_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_tm_records_copy(acursession,aaction,ainstanceid);
call iu_tmdef_copy(acursession,aaction,ainstanceid);
call iu_tmcadr_copy(acursession,aaction,ainstanceid);
call iu_tm_act_copy(acursession,aaction,ainstanceid);
call iu_tm_dog_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists iu_tm_access_f
go

create function iu_tm_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_tm_export_f
go

create function iu_tm_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists mtzrprt_copy
go

create procedure mtzrprt_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call rptstruct_copy(acursession,aaction,ainstanceid);
call rptformula_copy(acursession,aaction,ainstanceid);
call reports_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO



drop function if exists mtzrprt_access_f
go

create function mtzrprt_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists mtzrprt_export_f
go

create function mtzrprt_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_subs_copy
go

create procedure iu_subs_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
call iu_subsribe_copy(acursession,aaction,ainstanceid);
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO


drop procedure if exists iu_subs_initownership
go

create procedure iu_subs_initownership  (
 acursession varchar(38),
 ainstanceid varchar(38)
) body: begin  
 declare aec int;
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     leave body;
  end if;
end 
go
GO



drop function if exists iu_subs_access_f
go

create function iu_subs_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_subs_export_f
go

create function iu_subs_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO


drop procedure if exists iu_subs_gettotemp
go

create procedure iu_subs_gettotemp (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
call iu_subsribe_gettotemp(acursession,ainstanceid);
select 'ok' result;
 end 
GO


drop procedure if exists iu_subs_commitfromtemp
go

create procedure iu_subs_commitfromtemp (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
call iu_subsribe_commitfromtemp(acursession,ainstanceid);
select 'ok' result;
 end 
GO


drop procedure if exists iu_subs_droptempdata
go

create procedure iu_subs_droptempdata (
 acursession varchar(38),
 ainstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
call iu_subsribe_droptempdata(acursession,ainstanceid);
select 'ok' result;
 end 
GO


drop procedure if exists iu_urok_arch_copy
go

create procedure iu_urok_arch_copy (
 acursession varchar(38),
 ainstanceid varchar(38), 
 anewinstanceid varchar(38) 
)  body: begin  
declare aaction varchar(38);
 declare aec int;
 select count(*) into aec from the_session where the_sessionid=g2b(acursession) and closed=0 ;
if aec=0  then
    select 'сессия уже завершена.' result;
    leave body;
 end if;
select uuid() into aaction;
insert into copymapdata(actionid,inpid,outid) values(g2b(aaction),g2b(ainstanceid),g2b(anewinstanceid));
insert into instance(instanceid,name,objtype,status,archived)  select g2b(anewinstanceid),name,objtype,status,archived from instance where instanceid=g2b(ainstanceid); 
delete from copymapdata where actionid=g2b(aaction);
select 'ok' result;
 end 
GO


drop procedure if exists iu_urok_arch_initownership
go

create procedure iu_urok_arch_initownership  (
 acursession varchar(38),
 ainstanceid varchar(38)
) body: begin  
 declare aec int;
 select count(*) into aec  from the_session where the_sessionid=g2b(acursession) and closed=0 ;
 if aec=0 then
     leave body;
  end if;
end 
go
GO



drop function if exists iu_urok_arch_access_f
go

create function iu_urok_arch_access_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt &gt; 0 then
     return 1;
  else
     return 0;
  end if;
 return 1;
end
go


drop function if exists iu_urok_arch_export_f
go

create function iu_urok_arch_export_f  (
 acursession varchar(38)
, ainstanceid varchar(38)
) returns tinyint(1)  
  reads sql data  
begin  
  declare existscnt int;  
  select count(*) into existscnt from the_session 
  where the_sessionid =g2b(acursession)  and closed=0;
  if existscnt = 0 then
     return 0;
  end if;
 -- export no data by default !!! 
 return 0;
end
go
GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--ManualCode" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
/*индексы ()*/
CREATE  INDEX Syslog_times ON SysLog(ChangeStamp) 
$$

create index instance_lockuser on instance(lockuserid)

$$

create index instance_locksession on instance(locksessionid)

$$

 

GO
/*V_ROLEENTRY (V_ROLEENTRY)*/
drop view if exists V_RoleEntryPoints 
$$
create view V_RoleEntryPoints as
select 
Roles_WP.instanceid ROLEID ,
Roles_WP.WP ARMID,
Roles_ACT.Accesible,
Entrypoints.Name,
Entrypoints.Caption
from ROLES_WP 
join ROLES_ACT on ROLES_WP.ROLES_WPID=ROLES_ACT.parentstructrowid
join entrypoints on 
ROLES_ACT.entrypoints=entrypoints.entrypointsid
$$
GO
/*V_SYSLOG (V_SYSLOG)*/
drop view if exists V_SYSLOG
$$

create view V_SYSLOG as
select 
syslog.syslogid,syslog.changestamp,syslog.the_Resource,syslog.LogStructID,syslog.VERB,users.login,users.Family,users.Name,users.Surname,syslog.LogInstanceID 
from  syslog 
join the_session on syslog.thesession=the_session.the_sessionid 
join users on the_session.usersid=users.usersid
GO
/*V_LOG (V_LOG)*/
drop view if exists V_LOG
$$
create view V_LOG as 
select syslog.syslogid
,syslog.changestamp
,the_session.StartAt
,the_session.Closed
,syslog.the_Resource
,syslog.LogStructID
,syslog.LogInstanceID
,syslog.VERB
,users.login
,users.Family
,users.Name
,users.Surname
,instance.name instname
,instance.objtype
,part.caption
,objecttype.the_comment
 from  syslog
join the_session on syslog.thesession=the_session.the_sessionid
join users on the_session.usersid=users.usersid
left join instance on syslog.loginstanceid = instance.instanceid
left join part on syslog.logstructid = part.name
left join objecttype on instance.objtype =objecttype.name

$$
GO
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Maintains" File="">
    <BlockHolder BlockName="--create" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Options" File="">
    <BlockHolder BlockName="--Load" BlockCode=" 

drop procedure if exists init;
go
create procedure init() begin
declare aid binary(16);
declare ainstid binary(16);
declare auid binary(16);
declare asession varchar(38);
declare acid binary(16);
declare asecid binary(16);
declare ahid binary(16);
declare atmpstr varchar(255);
declare aec int;
select count(*) into aec from instance where objtype='mtzsystem';
if aec=0 then
    set ainstid = g2b('c5a874a1-1d01-43f5-aa2b-5431031fd45c');
    insert into instance(instanceid,objtype,name,changestamp) values(ainstid, 'mtzsystem','системная информация',now());
else
    select instanceid into ainstid from instance where objtype='mtzsystem';
end if;
set auid = g2b('e311596f-b616-4a9a-8528-52d7be52574f'); 
set asecid = g2b('c6f9df83-bf05-428d-8028-fe5e2f54190c'); 
set ahid = g2b('f0b10953-162d-430d-863b-3fad95d98ed7'); 
select count(*) into aec from users where usersid=auid;
if aec=0 then
insert into users(usersid,instanceid,login,password) values(auid,null,'init',md5('init'));
end if;
select count(*) into aec from typelist where name='iud_stage';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_stage', 'iud_stage_register', 'iud_stage_delete', 'iud_stage_hcl', 'iud_stage_propagate');
end if;
select count(*) into aec from typelist where name='iud_adtype';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_adtype', 'iud_adtype_register', 'iud_adtype_delete', 'iud_adtype_hcl', 'iud_adtype_propagate');
end if;
select count(*) into aec from typelist where name='iu_org';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_org', 'iu_org_register', 'iu_org_delete', 'iu_org_hcl', 'iu_org_propagate');
end if;
select count(*) into aec from typelist where name='iu_u';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_u', 'iu_u_register', 'iu_u_delete', 'iu_u_hcl', 'iu_u_propagate');
end if;
select count(*) into aec from typelist where name='iud_process';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_process', 'iud_process_register', 'iud_process_delete', 'iud_process_hcl', 'iud_process_propagate');
end if;
select count(*) into aec from typelist where name='mtzmetamodel';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'mtzmetamodel', 'mtzmetamodel_register', 'mtzmetamodel_delete', 'mtzmetamodel_hcl', 'mtzmetamodel_propagate');
end if;
select count(*) into aec from typelist where name='mtzjrnl';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'mtzjrnl', 'mtzjrnl_register', 'mtzjrnl_delete', 'mtzjrnl_hcl', 'mtzjrnl_propagate');
end if;
select count(*) into aec from typelist where name='iu_us';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_us', 'iu_us_register', 'iu_us_delete', 'iu_us_hcl', 'iu_us_propagate');
end if;
select count(*) into aec from typelist where name='stdinfostore';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'stdinfostore', 'stdinfostore_register', 'stdinfostore_delete', 'stdinfostore_hcl', 'stdinfostore_propagate');
end if;
select count(*) into aec from typelist where name='iud_rt';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_rt', 'iud_rt_register', 'iud_rt_delete', 'iud_rt_hcl', 'iud_rt_propagate');
end if;
select count(*) into aec from typelist where name='mtzsystem';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'mtzsystem', 'mtzsystem_register', 'mtzsystem_delete', 'mtzsystem_hcl', 'mtzsystem_propagate');
end if;
select count(*) into aec from typelist where name='mtzwp';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'mtzwp', 'mtzwp_register', 'mtzwp_delete', 'mtzwp_hcl', 'mtzwp_propagate');
end if;
select count(*) into aec from typelist where name='iu_d_urole';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_d_urole', 'iu_d_urole_register', 'iu_d_urole_delete', 'iu_d_urole_hcl', 'iu_d_urole_propagate');
end if;
select count(*) into aec from typelist where name='roles';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'roles', 'roles_register', 'roles_delete', 'roles_hcl', 'roles_propagate');
end if;
select count(*) into aec from typelist where name='iu_urok';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_urok', 'iu_urok_register', 'iu_urok_delete', 'iu_urok_hcl', 'iu_urok_propagate');
end if;
select count(*) into aec from typelist where name='iud_mt';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_mt', 'iud_mt_register', 'iud_mt_delete', 'iud_mt_hcl', 'iud_mt_propagate');
end if;
select count(*) into aec from typelist where name='iud_sn';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_sn', 'iud_sn_register', 'iud_sn_delete', 'iud_sn_hcl', 'iud_sn_propagate');
end if;
select count(*) into aec from typelist where name='iud_fst';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_fst', 'iud_fst_register', 'iud_fst_delete', 'iud_fst_hcl', 'iud_fst_propagate');
end if;
select count(*) into aec from typelist where name='iud_p';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_p', 'iud_p_register', 'iud_p_delete', 'iud_p_hcl', 'iud_p_propagate');
end if;
select count(*) into aec from typelist where name='iu_d_doctype';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_d_doctype', 'iu_d_doctype_register', 'iu_d_doctype_delete', 'iu_d_doctype_hcl', 'iu_d_doctype_propagate');
end if;
select count(*) into aec from typelist where name='mtzusers';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'mtzusers', 'mtzusers_register', 'mtzusers_delete', 'mtzusers_hcl', 'mtzusers_propagate');
end if;
select count(*) into aec from typelist where name='iu_cls';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_cls', 'iu_cls_register', 'iu_cls_delete', 'iu_cls_hcl', 'iu_cls_propagate');
end if;
select count(*) into aec from typelist where name='stdnumerator';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'stdnumerator', 'stdnumerator_register', 'stdnumerator_delete', 'stdnumerator_hcl', 'stdnumerator_propagate');
end if;
select count(*) into aec from typelist where name='iud_ft';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_ft', 'iud_ft_register', 'iud_ft_delete', 'iud_ft_hcl', 'iud_ft_propagate');
end if;
select count(*) into aec from typelist where name='mtzext';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'mtzext', 'mtzext_register', 'mtzext_delete', 'mtzext_hcl', 'mtzext_propagate');
end if;
select count(*) into aec from typelist where name='iud_vt';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_vt', 'iud_vt_register', 'iud_vt_delete', 'iud_vt_hcl', 'iud_vt_propagate');
end if;
select count(*) into aec from typelist where name='iu_cm';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_cm', 'iu_cm_register', 'iu_cm_delete', 'iu_cm_hcl', 'iu_cm_propagate');
end if;
select count(*) into aec from typelist where name='iu_plog';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_plog', 'iu_plog_register', 'iu_plog_delete', 'iu_plog_hcl', 'iu_plog_propagate');
end if;
select count(*) into aec from typelist where name='iu_rcfg';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_rcfg', 'iu_rcfg_register', 'iu_rcfg_delete', 'iu_rcfg_hcl', 'iu_rcfg_propagate');
end if;
select count(*) into aec from typelist where name='iud_t';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_t', 'iud_t_register', 'iud_t_delete', 'iud_t_hcl', 'iud_t_propagate');
end if;
select count(*) into aec from typelist where name='iu_reg';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_reg', 'iu_reg_register', 'iu_reg_delete', 'iu_reg_hcl', 'iu_reg_propagate');
end if;
select count(*) into aec from typelist where name='iu_s';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_s', 'iu_s_register', 'iu_s_delete', 'iu_s_hcl', 'iu_s_propagate');
end if;
select count(*) into aec from typelist where name='mtz2job';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'mtz2job', 'mtz2job_register', 'mtz2job_delete', 'mtz2job_hcl', 'mtz2job_propagate');
end if;
select count(*) into aec from typelist where name='iud_c';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_c', 'iud_c_register', 'iud_c_delete', 'iud_c_hcl', 'iud_c_propagate');
end if;
select count(*) into aec from typelist where name='iud_sp';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iud_sp', 'iud_sp_register', 'iud_sp_delete', 'iud_sp_hcl', 'iud_sp_propagate');
end if;
select count(*) into aec from typelist where name='mtzfltr';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'mtzfltr', 'mtzfltr_register', 'mtzfltr_delete', 'mtzfltr_hcl', 'mtzfltr_propagate');
end if;
select count(*) into aec from typelist where name='iu_int';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_int', 'iu_int_register', 'iu_int_delete', 'iu_int_hcl', 'iu_int_propagate');
end if;
select count(*) into aec from typelist where name='iu_t';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_t', 'iu_t_register', 'iu_t_delete', 'iu_t_hcl', 'iu_t_propagate');
end if;
select count(*) into aec from typelist where name='iu_l';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_l', 'iu_l_register', 'iu_l_delete', 'iu_l_hcl', 'iu_l_propagate');
end if;
select count(*) into aec from typelist where name='iu_tm';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_tm', 'iu_tm_register', 'iu_tm_delete', 'iu_tm_hcl', 'iu_tm_propagate');
end if;
select count(*) into aec from typelist where name='mtzrprt';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'mtzrprt', 'mtzrprt_register', 'mtzrprt_delete', 'mtzrprt_hcl', 'mtzrprt_propagate');
end if;
select count(*) into aec from typelist where name='iu_subs';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_subs', 'iu_subs_register', 'iu_subs_delete', 'iu_subs_hcl', 'iu_subs_propagate');
end if;
select count(*) into aec from typelist where name='iu_urok_arch';
if aec=0 then
insert into typelist(typelistid, name,registerproc,deleteproc, hclproc, propagateproc) values(g2b(uuid()),'iu_urok_arch', 'iu_urok_arch_register', 'iu_urok_arch_delete', 'iu_urok_arch_hcl', 'iu_urok_arch_propagate');
end if;

set aid = g2b('a991a890-511b-44d1-92bb-4f5f7e364e41');
call sysoptions_save ( b2g(aid), 'iud_stagedef', 'iud_stage', 'struct_type');

set aid = g2b('dfaacab0-3651-4fa2-a9cd-83b33abb8610');
call sysoptions_save ( b2g(aid), 'iud_stagedef', 'autoiud_stagedef', 'defview');

set aid = g2b('cc568ff4-010d-4e86-9886-0f0d4b753e87');
call sysoptions_save ( b2g(aid), 'iud_adt_doc', 'iud_adtype', 'struct_type');

set aid = g2b('94573962-c98f-4c35-a616-cea6d739541d');
call sysoptions_save ( b2g(aid), 'iud_adt_doc', 'autoiud_adt_doc', 'defview');

set aid = g2b('4a118ef5-4cd3-4ad3-8e6e-fb8b18fbbe95');
call sysoptions_save ( b2g(aid), 'iu_orgtree', 'iu_org', 'struct_type');

set aid = g2b('f2ae4117-75c6-45ca-aea1-86d48b564c7e');
call sysoptions_save ( b2g(aid), 'iu_orgusr', 'iu_org', 'struct_type');
set aid = g2b('bdc93e2a-a79e-4648-95a5-96233c3e7169');
call sysoptions_save(  b2g(aid), 'iu_orgusr', 'iu_orgtree', 'parent');


set aid = g2b('ae78c00a-1ed8-4c72-9478-8c1ce9b6bc1b');
call sysoptions_save ( b2g(aid), 'iu_orgusr', 'autoiu_orgusr', 'defview');

set aid = g2b('2c6d7b2a-1737-4968-a6c2-e18737ff3a98');
call sysoptions_save ( b2g(aid), 'iu_u_def', 'iu_u', 'struct_type');

set aid = g2b('79a3e556-b7d0-4d74-a62a-02d5adfba6e1');
call sysoptions_save ( b2g(aid), 'iu_u_def', 'autoiu_u_def', 'defview');

set aid = g2b('04df200c-6588-4614-a3ec-9c73b47250da');
call sysoptions_save ( b2g(aid), 'iud_process_def', 'iud_process', 'struct_type');

set aid = g2b('36cfcde2-ae39-4df5-8117-8016cd1318cc');
call sysoptions_save ( b2g(aid), 'iud_process_def', 'autoiud_process_def', 'defview');

set aid = g2b('d3c4dbf9-2651-47aa-a477-f4f8b05b6560');
call sysoptions_save ( b2g(aid), 'genpackage', 'mtzmetamodel', 'struct_type');

set aid = g2b('dbb759df-302c-456d-ae88-a9526b9d73e1');
call sysoptions_save ( b2g(aid), 'generator_target', 'mtzmetamodel', 'struct_type');
set aid = g2b('f4964a51-c40c-4516-86dd-54f78a4df755');
call sysoptions_save(  b2g(aid), 'generator_target', 'genpackage', 'parent');

set aid = g2b('d7020d32-d4d2-4f57-ba8a-995fc38a6b35');
call sysoptions_save ( b2g(aid), 'genreference', 'mtzmetamodel', 'struct_type');
set aid = g2b('1778150e-1a25-46d8-ab39-efe69f2e8bad');
call sysoptions_save(  b2g(aid), 'genreference', 'generator_target', 'parent');

set aid = g2b('418d29a1-8359-44ab-8825-88b3312c2dc1');
call sysoptions_save ( b2g(aid), 'genmanualcode', 'mtzmetamodel', 'struct_type');
set aid = g2b('24c550ae-7754-4d10-829b-e3412984e360');
call sysoptions_save(  b2g(aid), 'genmanualcode', 'generator_target', 'parent');

set aid = g2b('d664232c-d8cd-4f09-8503-fd7721a22b73');
call sysoptions_save ( b2g(aid), 'gencontrols', 'mtzmetamodel', 'struct_type');
set aid = g2b('b0c7dcb2-b3b6-48f0-bd9d-419f88f07aee');
call sysoptions_save(  b2g(aid), 'gencontrols', 'generator_target', 'parent');

set aid = g2b('2ffb70c0-51ab-45af-9d48-2ec6f915f9c5');
call sysoptions_save ( b2g(aid), 'genpackage', 'autogenpackage', 'defview');

set aid = g2b('fe158bf4-8dd8-4e37-a158-f5621f0dec6d');
call sysoptions_save ( b2g(aid), 'generator_target', 'autogenerator_target', 'defview');

set aid = g2b('2d934ec7-1d4f-4986-a0ba-a152858aa6ba');
call sysoptions_save ( b2g(aid), 'genreference', 'autogenreference', 'defview');

set aid = g2b('3c592857-7d45-4735-91fe-655ddfeeb997');
call sysoptions_save ( b2g(aid), 'genmanualcode', 'autogenmanualcode', 'defview');

set aid = g2b('bacab54a-3a93-4a4a-ad3a-3af98af6d97f');
call sysoptions_save ( b2g(aid), 'gencontrols', 'autogencontrols', 'defview');

set aid = g2b('e8658163-a666-48d1-8017-5a1313237f19');
call sysoptions_save ( b2g(aid), 'localizeinfo', 'mtzmetamodel', 'struct_type');

set aid = g2b('7a700972-43c4-476c-944a-3e2874f9446b');
call sysoptions_save ( b2g(aid), 'localizeinfo', 'autolocalizeinfo', 'defview');

set aid = g2b('5868eeff-57a3-492e-81a8-523b77e727c4');
call sysoptions_save ( b2g(aid), 'fieldtype', 'mtzmetamodel', 'struct_type');

set aid = g2b('10d7b6c6-7a6d-4a76-ae1d-d795dc3208bd');
call sysoptions_save ( b2g(aid), 'enumitem', 'mtzmetamodel', 'struct_type');
set aid = g2b('82352a47-a0c8-4f5d-a949-4400b7aaa038');
call sysoptions_save(  b2g(aid), 'enumitem', 'fieldtype', 'parent');

set aid = g2b('1ea55e46-6bec-46db-9d4c-1c0260b73d83');
call sysoptions_save ( b2g(aid), 'fieldtypemap', 'mtzmetamodel', 'struct_type');
set aid = g2b('0e9b9d97-2fb4-4636-afcf-4b07651e7da1');
call sysoptions_save(  b2g(aid), 'fieldtypemap', 'fieldtype', 'parent');

set aid = g2b('af4dd26a-c33e-4d55-8cb0-714de7c47e18');
call sysoptions_save ( b2g(aid), 'fieldtype', 'autofieldtype', 'defview');

set aid = g2b('df0b0774-b9d3-4566-ad11-b7b6f2d76f9f');
call sysoptions_save ( b2g(aid), 'enumitem', 'autoenumitem', 'defview');

set aid = g2b('f88bb018-11dd-4d0f-a43f-25ba6ebee2e7');
call sysoptions_save ( b2g(aid), 'fieldtypemap', 'autofieldtypemap', 'defview');

set aid = g2b('a75e372d-66b3-4da1-a8b3-92530d20562b');
call sysoptions_save ( b2g(aid), 'sharedmethod', 'mtzmetamodel', 'struct_type');

set aid = g2b('f675f30f-f9c0-4d9e-9d13-5f13ffab164e');
call sysoptions_save ( b2g(aid), 'script', 'mtzmetamodel', 'struct_type');
set aid = g2b('d498dbf5-f193-4e5d-9e30-6b6e295f189a');
call sysoptions_save(  b2g(aid), 'script', 'sharedmethod', 'parent');

set aid = g2b('746240a1-5cd4-4534-b006-9b0e3bb9c40d');
call sysoptions_save ( b2g(aid), 'parameters', 'mtzmetamodel', 'struct_type');
set aid = g2b('2e9fc6f6-77c0-46af-8797-88a7c7a603e9');
call sysoptions_save(  b2g(aid), 'parameters', 'script', 'parent');

set aid = g2b('2f380764-550a-42a1-bfa7-015bc591159d');
call sysoptions_save ( b2g(aid), 'sharedmethod', 'autosharedmethod', 'defview');

set aid = g2b('8f07464a-ce97-41d7-921d-b88e88b2b829');
call sysoptions_save ( b2g(aid), 'script', 'autoscript', 'defview');

set aid = g2b('cc3bcb64-0f1f-4a1b-82aa-5a14d0387e33');
call sysoptions_save ( b2g(aid), 'parameters', 'autoparameters', 'defview');

set aid = g2b('cd64af64-d9bb-4d97-b8cd-e5bee3743359');
call sysoptions_save ( b2g(aid), 'objecttype', 'mtzmetamodel', 'struct_type');

set aid = g2b('03c2fa52-bc51-47be-abf9-8faed3563cfd');
call sysoptions_save ( b2g(aid), 'objstatus', 'mtzmetamodel', 'struct_type');
set aid = g2b('ae3e6e5e-ebd2-4756-93b9-e24f047fdff6');
call sysoptions_save(  b2g(aid), 'objstatus', 'objecttype', 'parent');

set aid = g2b('53b44a82-b53e-43ee-8e01-f280ccce02c0');
call sysoptions_save ( b2g(aid), 'nextstate', 'mtzmetamodel', 'struct_type');
set aid = g2b('01a56c6c-187f-4e6d-a487-da5154f688e6');
call sysoptions_save(  b2g(aid), 'nextstate', 'objstatus', 'parent');

set aid = g2b('c4ccf733-d32c-4cb7-ba11-3476c9e7b929');
call sysoptions_save ( b2g(aid), 'objectmode', 'mtzmetamodel', 'struct_type');
set aid = g2b('1fb27905-1ec8-4348-b52d-acc24a500798');
call sysoptions_save(  b2g(aid), 'objectmode', 'objecttype', 'parent');

set aid = g2b('2e7db259-fd03-461e-a2b6-5f5091e3283a');
call sysoptions_save ( b2g(aid), 'structrestriction', 'mtzmetamodel', 'struct_type');
set aid = g2b('461e4b87-335d-40c5-a8fe-d8830f7d25aa');
call sysoptions_save(  b2g(aid), 'structrestriction', 'objectmode', 'parent');

set aid = g2b('04a1c9de-864f-4a8a-9280-4bd663e57880');
call sysoptions_save ( b2g(aid), 'methodrestriction', 'mtzmetamodel', 'struct_type');
set aid = g2b('55b3d860-877c-458d-8ba5-007e1eae4fb9');
call sysoptions_save(  b2g(aid), 'methodrestriction', 'objectmode', 'parent');

set aid = g2b('50ada5bf-45e0-4b40-9d75-9277d4a3cc11');
call sysoptions_save ( b2g(aid), 'fieldrestriction', 'mtzmetamodel', 'struct_type');
set aid = g2b('2fcb8f4d-c8e4-4f4f-8c1d-6788eecfde82');
call sysoptions_save(  b2g(aid), 'fieldrestriction', 'objectmode', 'parent');

set aid = g2b('ba948dda-c286-4ff9-8d48-f6aca46bc49c');
call sysoptions_save ( b2g(aid), 'typemenu', 'mtzmetamodel', 'struct_type');
set aid = g2b('baf39fe4-1aec-4416-b251-ca5ef3298edf');
call sysoptions_save(  b2g(aid), 'typemenu', 'objecttype', 'parent');

set aid = g2b('1518fc27-04c0-4333-b37f-289c3035e4e4');
call sysoptions_save ( b2g(aid), 'instancevalidator', 'mtzmetamodel', 'struct_type');
set aid = g2b('2c4ca55c-8963-4d38-a151-1f7c4c64703d');
call sysoptions_save(  b2g(aid), 'instancevalidator', 'objecttype', 'parent');

set aid = g2b('b736e915-6d1f-4abc-a8ca-c679ab3767d3');
call sysoptions_save ( b2g(aid), 'part', 'mtzmetamodel', 'struct_type');
set aid = g2b('6acb8202-c47e-4707-9736-46744c41e03e');
call sysoptions_save(  b2g(aid), 'part', 'objecttype', 'parent');

set aid = g2b('302869be-7c3e-4443-a402-dc5d5a448c27');
call sysoptions_save ( b2g(aid), 'partmenu', 'mtzmetamodel', 'struct_type');
set aid = g2b('c3e38c4f-e012-46a1-9349-72a7545c7f7e');
call sysoptions_save(  b2g(aid), 'partmenu', 'part', 'parent');

set aid = g2b('08b66fc5-9473-42ec-b60b-bc8eb3900bb4');
call sysoptions_save ( b2g(aid), 'partparammap', 'mtzmetamodel', 'struct_type');
set aid = g2b('4e439314-203e-43a9-a05d-863fe138dd72');
call sysoptions_save(  b2g(aid), 'partparammap', 'partmenu', 'parent');

set aid = g2b('ca953ac8-4eda-423f-adc9-413fa4aa1745');
call sysoptions_save ( b2g(aid), 'partview', 'mtzmetamodel', 'struct_type');
set aid = g2b('3ab6a75e-b4a6-4bf9-9897-36038db8b797');
call sysoptions_save(  b2g(aid), 'partview', 'part', 'parent');

set aid = g2b('29417304-33f1-40b5-bf91-04163e77514a');
call sysoptions_save ( b2g(aid), 'viewcolumn', 'mtzmetamodel', 'struct_type');
set aid = g2b('e279f2be-b08e-48a8-baf1-f75c7159374c');
call sysoptions_save(  b2g(aid), 'viewcolumn', 'partview', 'parent');

set aid = g2b('ec6d2101-e20f-4207-aed4-2e93289dcea4');
call sysoptions_save ( b2g(aid), 'partview_lnk', 'mtzmetamodel', 'struct_type');
set aid = g2b('1d3dc45f-b52e-48f9-93b6-1b791f03484d');
call sysoptions_save(  b2g(aid), 'partview_lnk', 'partview', 'parent');

set aid = g2b('6926714a-ff8f-4a5f-99d2-b09273bae51c');
call sysoptions_save ( b2g(aid), 'validator', 'mtzmetamodel', 'struct_type');
set aid = g2b('cb8e6e40-900c-4e1f-aa23-2a6a1eff2a8c');
call sysoptions_save(  b2g(aid), 'validator', 'part', 'parent');

set aid = g2b('83d78af6-5f05-45ce-9ed7-cb7c5f0c2648');
call sysoptions_save ( b2g(aid), 'uniqueconstraint', 'mtzmetamodel', 'struct_type');
set aid = g2b('b9436564-0522-419a-805d-2e9fa14cfb4d');
call sysoptions_save(  b2g(aid), 'uniqueconstraint', 'part', 'parent');

set aid = g2b('22589c87-3c6b-4887-a5a1-30f843e9fc97');
call sysoptions_save ( b2g(aid), 'constraintfield', 'mtzmetamodel', 'struct_type');
set aid = g2b('fa9d0b45-b9d8-4800-b4de-bac392c3c5d5');
call sysoptions_save(  b2g(aid), 'constraintfield', 'uniqueconstraint', 'parent');

set aid = g2b('35cc3536-3dfc-44fa-ad55-3db758548831');
call sysoptions_save ( b2g(aid), 'extenderinterface', 'mtzmetamodel', 'struct_type');
set aid = g2b('31616a9e-5ef8-41fc-806e-5fb1a23c6ea1');
call sysoptions_save(  b2g(aid), 'extenderinterface', 'part', 'parent');

set aid = g2b('08e19363-91a3-4d75-8f15-d51ec8f3c36f');
call sysoptions_save ( b2g(aid), 'field', 'mtzmetamodel', 'struct_type');
set aid = g2b('f7b5a607-1978-4c5d-af95-a0add0a14dab');
call sysoptions_save(  b2g(aid), 'field', 'part', 'parent');

set aid = g2b('ad129818-8a7c-4ff9-9472-68bc4421d220');
call sysoptions_save ( b2g(aid), 'fldextenders', 'mtzmetamodel', 'struct_type');
set aid = g2b('14f41f9e-fb3b-47ad-9f5d-fddc0136ce44');
call sysoptions_save(  b2g(aid), 'fldextenders', 'field', 'parent');

set aid = g2b('c65c4c88-f11c-42bf-b64d-67d71c83dd14');
call sysoptions_save ( b2g(aid), 'fieldsrcdef', 'mtzmetamodel', 'struct_type');
set aid = g2b('2d024d6e-888d-44eb-bedf-c6d8e4fb5d73');
call sysoptions_save(  b2g(aid), 'fieldsrcdef', 'field', 'parent');

set aid = g2b('bacc2396-e907-451d-ba9b-cab92059d0c9');
call sysoptions_save ( b2g(aid), 'dinamicfilterscript', 'mtzmetamodel', 'struct_type');
set aid = g2b('f737d43e-5e65-40af-b209-055bd204132b');
call sysoptions_save(  b2g(aid), 'dinamicfilterscript', 'field', 'parent');

set aid = g2b('dc9ab1c3-c0ac-430d-a55e-18667a722f41');
call sysoptions_save ( b2g(aid), 'fieldexpression', 'mtzmetamodel', 'struct_type');
set aid = g2b('4a3739f4-12a2-4b4b-9e5b-d7eca42cc39a');
call sysoptions_save(  b2g(aid), 'fieldexpression', 'field', 'parent');

set aid = g2b('c36cd550-cc57-4d4a-9944-36013bc43b36');
call sysoptions_save ( b2g(aid), 'fieldvalidator', 'mtzmetamodel', 'struct_type');
set aid = g2b('921c9710-c08c-4032-9216-4f21be4370e8');
call sysoptions_save(  b2g(aid), 'fieldvalidator', 'field', 'parent');

set aid = g2b('0dae32bd-7628-4be1-ac61-40ea8d2e7fc2');
call sysoptions_save ( b2g(aid), 'fieldmenu', 'mtzmetamodel', 'struct_type');
set aid = g2b('8417ae87-e1fc-4414-bb71-722869b8a234');
call sysoptions_save(  b2g(aid), 'fieldmenu', 'field', 'parent');

set aid = g2b('9f26272e-2dc4-4890-a8f1-8b23cc7851bf');
call sysoptions_save ( b2g(aid), 'fieldparammap', 'mtzmetamodel', 'struct_type');
set aid = g2b('64721f49-63bb-4ee0-a8f4-62f2351c4b0b');
call sysoptions_save(  b2g(aid), 'fieldparammap', 'fieldmenu', 'parent');

set aid = g2b('f19eff07-0cc1-47b6-abd6-77a6ef9433cd');
call sysoptions_save ( b2g(aid), 'objecttype', 'autoobjecttype', 'defview');

set aid = g2b('0442d439-105b-41d0-bf6a-33d39f42e8b3');
call sysoptions_save ( b2g(aid), 'objstatus', 'autoobjstatus', 'defview');

set aid = g2b('9dd826b7-186c-4c77-a263-b6c6249b22b0');
call sysoptions_save ( b2g(aid), 'nextstate', 'autonextstate', 'defview');

set aid = g2b('df89a981-fb8d-4e72-b678-798774fc0804');
call sysoptions_save ( b2g(aid), 'objectmode', 'autoobjectmode', 'defview');

set aid = g2b('51d27cd0-4606-4bc9-a636-c1c8a5520b31');
call sysoptions_save ( b2g(aid), 'structrestriction', 'autostructrestriction', 'defview');

set aid = g2b('36c2a54e-5dec-4aa1-b476-1182eda3e6ce');
call sysoptions_save ( b2g(aid), 'methodrestriction', 'automethodrestriction', 'defview');

set aid = g2b('14a3e0ff-4f46-4f2d-9e30-188720dc51d7');
call sysoptions_save ( b2g(aid), 'fieldrestriction', 'autofieldrestriction', 'defview');

set aid = g2b('db63d3fc-7df7-4cc9-bfa2-d1c0b7eb8054');
call sysoptions_save ( b2g(aid), 'typemenu', 'autotypemenu', 'defview');

set aid = g2b('057d4d63-d38c-46b9-a58f-7deb6a819a65');
call sysoptions_save ( b2g(aid), 'instancevalidator', 'autoinstancevalidator', 'defview');


set aid = g2b('2750e592-2352-4e82-82cc-35e47868d2dc');
call sysoptions_save ( b2g(aid), 'partmenu', 'autopartmenu', 'defview');

set aid = g2b('a225252d-d339-4d55-9081-720e2a178563');
call sysoptions_save ( b2g(aid), 'partparammap', 'autopartparammap', 'defview');

set aid = g2b('3f6f172b-8d54-47b5-847e-4b230f7e5e36');
call sysoptions_save ( b2g(aid), 'partview', 'autopartview', 'defview');

set aid = g2b('38336b97-f558-4fa7-a727-3792682d489b');
call sysoptions_save ( b2g(aid), 'viewcolumn', 'autoviewcolumn', 'defview');

set aid = g2b('29354c8c-8675-4e82-aef7-2f1102d40ee4');
call sysoptions_save ( b2g(aid), 'partview_lnk', 'autopartview_lnk', 'defview');

set aid = g2b('a336925a-03e6-459f-9240-81c0a144b322');
call sysoptions_save ( b2g(aid), 'validator', 'autovalidator', 'defview');

set aid = g2b('a6eb37f9-ff18-445f-a9e7-24700196df3c');
call sysoptions_save ( b2g(aid), 'uniqueconstraint', 'autouniqueconstraint', 'defview');

set aid = g2b('a25eef75-1e9a-4bcf-8dfe-04e6b11127a4');
call sysoptions_save ( b2g(aid), 'constraintfield', 'autoconstraintfield', 'defview');

set aid = g2b('67ae54ed-cb13-4f69-b078-4dfb57b0a9a6');
call sysoptions_save ( b2g(aid), 'extenderinterface', 'autoextenderinterface', 'defview');

set aid = g2b('90d378c3-16bd-4dc4-b4c4-85e7b67dbc74');
call sysoptions_save ( b2g(aid), 'field', 'autofield', 'defview');

set aid = g2b('48e57fe5-ce27-4186-928e-b92369c99bd6');
call sysoptions_save ( b2g(aid), 'fldextenders', 'autofldextenders', 'defview');

set aid = g2b('b5809a2b-c78a-4e46-a49b-d29887e2fa37');
call sysoptions_save ( b2g(aid), 'fieldsrcdef', 'autofieldsrcdef', 'defview');

set aid = g2b('3594bcf6-a8d0-4f83-91b5-e73c6a87736d');
call sysoptions_save ( b2g(aid), 'dinamicfilterscript', 'autodinamicfilterscript', 'defview');

set aid = g2b('6fa188ea-50ac-4ab2-8727-d9fff458a5fb');
call sysoptions_save ( b2g(aid), 'fieldexpression', 'autofieldexpression', 'defview');

set aid = g2b('bee28ff1-a9b3-44ca-a4cf-5f2daaac231c');
call sysoptions_save ( b2g(aid), 'fieldvalidator', 'autofieldvalidator', 'defview');

set aid = g2b('6f384634-5d1b-4562-bbe3-cf68bb12ce36');
call sysoptions_save ( b2g(aid), 'fieldmenu', 'autofieldmenu', 'defview');

set aid = g2b('160c81f7-a549-4ed0-87f5-7e0481eb6061');
call sysoptions_save ( b2g(aid), 'fieldparammap', 'autofieldparammap', 'defview');

set aid = g2b('4bc74f0b-b039-4156-91c6-4663a1b43193');
call sysoptions_save ( b2g(aid), 'mtzapp', 'mtzmetamodel', 'struct_type');

set aid = g2b('fa1c743f-62e9-4ba6-8199-b7ce8780b8ff');
call sysoptions_save ( b2g(aid), 'parentpackage', 'mtzmetamodel', 'struct_type');
set aid = g2b('a597db55-2af4-450f-a339-85b74a547a75');
call sysoptions_save(  b2g(aid), 'parentpackage', 'mtzapp', 'parent');

set aid = g2b('ce3f0728-ea65-4d4b-9f5c-1dc44d1f9f98');
call sysoptions_save ( b2g(aid), 'mtzapp', 'automtzapp', 'defview');

set aid = g2b('731be0eb-e376-44af-a109-f4af4b032ddd');
call sysoptions_save ( b2g(aid), 'parentpackage', 'autoparentpackage', 'defview');

set aid = g2b('ba5ec6b3-e320-4b2a-9230-b92cb60eb59e');
call sysoptions_save ( b2g(aid), 'journalcolumn', 'mtzjrnl', 'struct_type');

set aid = g2b('968b0b51-eb16-4904-9d2c-936697991a93');
call sysoptions_save ( b2g(aid), 'jcolumnsource', 'mtzjrnl', 'struct_type');
set aid = g2b('4650eb32-528f-4282-95ea-af6a8ada191a');
call sysoptions_save(  b2g(aid), 'jcolumnsource', 'journalcolumn', 'parent');

set aid = g2b('2602a946-ae36-41ae-b1df-343b92949dee');
call sysoptions_save ( b2g(aid), 'journalcolumn', 'autojournalcolumn', 'defview');

set aid = g2b('780a61d3-51e5-4884-8105-0854025326c4');
call sysoptions_save ( b2g(aid), 'jcolumnsource', 'autojcolumnsource', 'defview');

set aid = g2b('bb6b000b-3f10-4f0f-8e07-39f48e39c2fb');
call sysoptions_save ( b2g(aid), 'journalsrc', 'mtzjrnl', 'struct_type');

set aid = g2b('65a1aa24-f879-48b9-ad63-a2240fd044e6');
call sysoptions_save ( b2g(aid), 'journalsrc', 'autojournalsrc', 'defview');

set aid = g2b('1365419c-fd36-42e7-834d-dcb81b7ac0af');
call sysoptions_save ( b2g(aid), 'journal', 'mtzjrnl', 'struct_type');

set aid = g2b('00c2b6dc-d5ac-4afd-9882-a9709a67b266');
call sysoptions_save ( b2g(aid), 'journal', 'autojournal', 'defview');

set aid = g2b('eb828f80-9a48-4827-9a69-3577f62bf56f');
call sysoptions_save ( b2g(aid), 'iu_urok_sn', 'iu_us', 'struct_type');

set aid = g2b('a96b5284-4cca-44e2-a459-74a2299ce3fa');
call sysoptions_save ( b2g(aid), 'iu_urok_sn', 'autoiu_urok_sn_1', 'defview');

set aid = g2b('6e1df735-4e12-4b14-928a-dd8e77eff739');
call sysoptions_save ( b2g(aid), 'iu_urok_msg', 'iu_us', 'struct_type');


set aid = g2b('38754601-f264-4a42-9ce2-86da20135763');
call sysoptions_save ( b2g(aid), 'iu_urok_graph', 'iu_us', 'struct_type');

set aid = g2b('d7339133-cbdb-4da4-8770-0f5d50141414');
call sysoptions_save ( b2g(aid), 'iu_urok_graph', 'autoiu_urok_graph_1', 'defview');

set aid = g2b('9e96c3b8-2d33-4cab-8d2d-4e888934004f');
call sysoptions_save ( b2g(aid), 'iu_urok_prc', 'iu_us', 'struct_type');

set aid = g2b('15a17090-a171-41d9-897d-2b78ea034d52');
call sysoptions_save ( b2g(aid), 'iu_urok_prc', 'autoiu_us_def', 'defview');

set aid = g2b('26384c1f-91ff-4791-a36a-511bd0277af6');
call sysoptions_save ( b2g(aid), 'folder', 'stdinfostore', 'struct_type');

set aid = g2b('d80f2339-5bff-4747-b14d-f972f7604711');
call sysoptions_save ( b2g(aid), 'shortcut', 'stdinfostore', 'struct_type');
set aid = g2b('916ff81f-392c-4261-8f00-9333b652c9e2');
call sysoptions_save(  b2g(aid), 'shortcut', 'folder', 'parent');


set aid = g2b('f0b04842-f6f9-4349-a30b-aef90fc7be19');
call sysoptions_save ( b2g(aid), 'shortcut', 'autoshortcut', 'defview');

set aid = g2b('a6366b73-1ee1-423e-9062-6de7a296429c');
call sysoptions_save ( b2g(aid), 'infostoredef', 'stdinfostore', 'struct_type');

set aid = g2b('7843c050-cd20-49f4-a1e6-a5af0df40b35');
call sysoptions_save ( b2g(aid), 'infostoredef', 'autoinfostoredef', 'defview');

set aid = g2b('9a9982c6-5b30-4006-9461-d47723a0fa4d');
call sysoptions_save ( b2g(aid), 'iud_rt_def', 'iud_rt', 'struct_type');

set aid = g2b('d6a1033f-1797-45e2-87b1-220338220598');
call sysoptions_save ( b2g(aid), 'iud_rt_def', 'autoiu_rt_def', 'defview');

set aid = g2b('caa0169d-675a-446a-8636-2c6edae9504e');
call sysoptions_save ( b2g(aid), 'the_session', 'mtzsystem', 'struct_type');

set aid = g2b('9cc6f816-e7d5-4b35-a24f-05c4ed13db27');
call sysoptions_save ( b2g(aid), 'the_session', 'autothe_session', 'defview');

set aid = g2b('fd57cea5-3c5e-4b95-b8d5-39c4b10af547');
call sysoptions_save ( b2g(aid), 'sysrefcache', 'mtzsystem', 'struct_type');

set aid = g2b('675b2ea8-e3a4-40fd-9f7e-af7264977876');
call sysoptions_save ( b2g(aid), 'sysrefcache', 'autosysrefcache', 'defview');

set aid = g2b('62ab05eb-b67c-4411-b39a-ffd5a01e110c');
call sysoptions_save ( b2g(aid), 'syslog', 'mtzsystem', 'struct_type');

set aid = g2b('703e92bc-fd6b-49b6-b024-10d1fd01a6f4');
call sysoptions_save ( b2g(aid), 'syslog', 'autosyslog', 'defview');

set aid = g2b('bef6592b-dc8c-42c0-9e9a-965f2783df09');
call sysoptions_save ( b2g(aid), 'armjournal', 'mtzwp', 'struct_type');

set aid = g2b('dc57aa1e-ae84-41b9-b626-69fcb9901ba8');
call sysoptions_save ( b2g(aid), 'armjrnlrep', 'mtzwp', 'struct_type');
set aid = g2b('a90249a7-b45a-44c2-9bbf-e2dd20f2ad8d');
call sysoptions_save(  b2g(aid), 'armjrnlrep', 'armjournal', 'parent');

set aid = g2b('148eb814-fa44-4993-ad80-97e0076976d5');
call sysoptions_save ( b2g(aid), 'armjrnlrun', 'mtzwp', 'struct_type');
set aid = g2b('68f4f225-0afa-4e7b-9415-cbfcb66674fe');
call sysoptions_save(  b2g(aid), 'armjrnlrun', 'armjournal', 'parent');

set aid = g2b('71aa27dd-5eda-4829-8139-1bd7a6ddc7bd');
call sysoptions_save ( b2g(aid), 'armjrnladd', 'mtzwp', 'struct_type');
set aid = g2b('dbb13072-cea5-45c9-90c9-bebf3d887391');
call sysoptions_save(  b2g(aid), 'armjrnladd', 'armjournal', 'parent');

set aid = g2b('a8e6958e-f9d3-46a3-ab6d-92da427afa21');
call sysoptions_save ( b2g(aid), 'armjournal', 'autoarmjournal', 'defview');

set aid = g2b('5929f036-8b17-49dc-aa96-ae3162515cab');
call sysoptions_save ( b2g(aid), 'armjrnlrep', 'autoarmjrnlrep', 'defview');

set aid = g2b('b39ca484-601c-4c47-a478-a9d932faa7a5');
call sysoptions_save ( b2g(aid), 'armjrnlrun', 'autoarmjrnlrun', 'defview');

set aid = g2b('e64d699a-5c29-4b8f-9b37-dd63dac1b75b');
call sysoptions_save ( b2g(aid), 'armjrnladd', 'autoarmjrnladd', 'defview');

set aid = g2b('6cb12664-e870-4f61-803d-5a270746d888');
call sysoptions_save ( b2g(aid), 'entrypoints', 'mtzwp', 'struct_type');

set aid = g2b('59009dda-041a-46e7-9b5d-f50d212275ef');
call sysoptions_save ( b2g(aid), 'epfilterlink', 'mtzwp', 'struct_type');
set aid = g2b('5622498f-7ada-434e-9ab3-5a9682b3c1a2');
call sysoptions_save(  b2g(aid), 'epfilterlink', 'entrypoints', 'parent');


set aid = g2b('a51699d7-f774-4d98-b7f7-24b9c4fd864d');
call sysoptions_save ( b2g(aid), 'epfilterlink', 'autoepfilterlink', 'defview');

set aid = g2b('cd4c6fb9-532d-4abd-8126-0e42b4283217');
call sysoptions_save ( b2g(aid), 'workplace', 'mtzwp', 'struct_type');

set aid = g2b('5b8be37f-172f-4bc7-b342-021b3d617f65');
call sysoptions_save ( b2g(aid), 'workplace', 'autoworkplace', 'defview');

set aid = g2b('fdcc7375-37ed-4c87-95dd-adf5007d784c');
call sysoptions_save ( b2g(aid), 'armtypes', 'mtzwp', 'struct_type');

set aid = g2b('66660e22-3c3d-4acf-aa22-8d0673e766ab');
call sysoptions_save ( b2g(aid), 'armtypes', 'autoarmtypes', 'defview');

set aid = g2b('be056d5b-5391-428e-a9af-7e35af596097');
call sysoptions_save ( b2g(aid), 'iu_crole', 'iu_d_urole', 'struct_type');

set aid = g2b('77055ded-93e1-425f-9025-1cbfdef8cbb6');
call sysoptions_save ( b2g(aid), 'iu_crole', 'autoiu_crole', 'defview');

set aid = g2b('16e4fa00-0daf-4b09-94f5-9df31e57e985');
call sysoptions_save ( b2g(aid), 'roles_operations', 'roles', 'struct_type');

set aid = g2b('3948f3ac-5784-49f1-943c-07409f809653');
call sysoptions_save ( b2g(aid), 'roles_operations', 'autoroles_operations', 'defview');

set aid = g2b('a8bff00e-3998-428d-b257-50a7cb2ab4d0');
call sysoptions_save ( b2g(aid), 'roles_wp', 'roles', 'struct_type');

set aid = g2b('8b466a2d-5f96-4008-bf8f-0d927f423dbe');
call sysoptions_save ( b2g(aid), 'roles_act', 'roles', 'struct_type');
set aid = g2b('4b07483c-e570-4eab-bb75-2684d8678f0c');
call sysoptions_save(  b2g(aid), 'roles_act', 'roles_wp', 'parent');

set aid = g2b('1f874a66-1551-4414-8b83-00098879a4a1');
call sysoptions_save ( b2g(aid), 'roles_wp', 'autoroles_wp', 'defview');

set aid = g2b('82f6f7ef-2778-42be-adb2-7c62c5ff5094');
call sysoptions_save ( b2g(aid), 'roles_act', 'autoroles_act', 'defview');

set aid = g2b('69be00e6-f12f-451e-bb94-fe780e9b35b8');
call sysoptions_save ( b2g(aid), 'roles2_module', 'roles', 'struct_type');

set aid = g2b('487711f6-0ecd-4376-9938-93ddbb87522b');
call sysoptions_save ( b2g(aid), 'roles2_modreport', 'roles', 'struct_type');
set aid = g2b('06a1b8c9-ea66-417e-8a3e-99398b202fd8');
call sysoptions_save(  b2g(aid), 'roles2_modreport', 'roles2_module', 'parent');

set aid = g2b('4bec53c8-65f9-4e0d-b5a9-ef43ba30d37b');
call sysoptions_save ( b2g(aid), 'roles2_module', 'autoroles2_module', 'defview');

set aid = g2b('bc765ca8-93b2-47ee-a32d-b58e4c1fa4a3');
call sysoptions_save ( b2g(aid), 'roles2_modreport', 'autoroles2_modreport', 'defview');

set aid = g2b('a670d7a3-f17d-4db4-985b-813856e17145');
call sysoptions_save ( b2g(aid), 'roles_doc', 'roles', 'struct_type');

set aid = g2b('304a3e57-cb24-433f-96a0-d786f953960b');
call sysoptions_save ( b2g(aid), 'roles_doc_state', 'roles', 'struct_type');
set aid = g2b('bf4d690a-9250-409d-9370-a04487589d9d');
call sysoptions_save(  b2g(aid), 'roles_doc_state', 'roles_doc', 'parent');

set aid = g2b('26874d9e-f2e3-4ece-a1a6-e5ca0e41805d');
call sysoptions_save ( b2g(aid), 'roles_doc', 'autoroles_doc', 'defview');

set aid = g2b('64ce7e4e-fe7f-487a-ac41-88b53a0eecd5');
call sysoptions_save ( b2g(aid), 'roles_doc_state', 'autoroles_doc_state', 'defview');

set aid = g2b('9bd554f9-5b52-4d7f-b07c-d48f765ac7c5');
call sysoptions_save ( b2g(aid), 'roles_reports', 'roles', 'struct_type');

set aid = g2b('69d486d3-b8f8-4aba-892b-8517314cb577');
call sysoptions_save ( b2g(aid), 'roles_reports', 'autoroles_reports', 'defview');

set aid = g2b('3b2bbf0e-8c85-415e-b4d0-37a92e0a563a');
call sysoptions_save ( b2g(aid), 'roles_user', 'roles', 'struct_type');

set aid = g2b('5c787387-46ff-4d43-8b36-ff0a4ea63d27');
call sysoptions_save ( b2g(aid), 'roles_user', 'autoroles_user', 'defview');

set aid = g2b('ca0abcc7-b396-4344-b528-84c29d35fb25');
call sysoptions_save ( b2g(aid), 'roles_map', 'roles', 'struct_type');

set aid = g2b('dfe5da90-2cec-426e-82f3-585306e32d1b');
call sysoptions_save ( b2g(aid), 'roles_map', 'autoroles_map', 'defview');

set aid = g2b('73ae66df-1672-482f-9b7a-c850912f22a5');
call sysoptions_save ( b2g(aid), 'roles_def', 'roles', 'struct_type');

set aid = g2b('c8f024e6-d475-4c7d-b1d0-cd14d31ea002');
call sysoptions_save ( b2g(aid), 'roles_def', 'autoroles_def', 'defview');



set aid = g2b('f7c45b26-221d-4f8d-b88b-a699e7b3cc56');
call sysoptions_save ( b2g(aid), 'iu_urok_docs', 'iu_urok', 'struct_type');

set aid = g2b('3290306f-1404-472f-8270-334ed545a8db');
call sysoptions_save ( b2g(aid), 'iu_urok_docs', 'autoiu_urok_docs', 'defview');

set aid = g2b('e537cff5-8a43-417c-bddb-f40bac1ecc5c');
call sysoptions_save ( b2g(aid), 'iu_urok_creators', 'iu_urok', 'struct_type');

set aid = g2b('3a46a507-fc8e-4f1a-849b-c79c193e68c3');
call sysoptions_save ( b2g(aid), 'iu_urok_creators', 'autoiu_urok_creators', 'defview');

set aid = g2b('ba103309-6e19-4570-9259-737c5fb80731');
call sysoptions_save ( b2g(aid), 'iu_urok_def', 'iu_urok', 'struct_type');

set aid = g2b('dfc94b39-55fe-4d3e-ab05-ff3b241afcf1');
call sysoptions_save ( b2g(aid), 'iu_urok_def', 'autoiu_urok_def', 'defview');

set aid = g2b('f70d9d33-4491-42f0-9b52-a6230d390269');
call sysoptions_save ( b2g(aid), 'iu_urok_video', 'iu_urok', 'struct_type');

set aid = g2b('31b5eb17-861c-4e7e-8924-f6e78ec5a376');
call sysoptions_save ( b2g(aid), 'iu_urok_video', 'autoiu_urok_video', 'defview');

set aid = g2b('2ddd27c8-c091-4251-a831-27637a8b8b6d');
call sysoptions_save ( b2g(aid), 'iud_mt_def', 'iud_mt', 'struct_type');

set aid = g2b('6efc7912-2199-404e-87ce-68f564e11616');
call sysoptions_save ( b2g(aid), 'iud_mt_def', 'autoiud_mt_def', 'defview');

set aid = g2b('877e3954-5322-4dfa-8967-3c7fc8c2dd3d');
call sysoptions_save ( b2g(aid), 'iud_sn_def', 'iud_sn', 'struct_type');

set aid = g2b('75386c46-51ea-49dd-a2a1-d470c75b464e');
call sysoptions_save ( b2g(aid), 'iud_sn_def', 'autoiud_sn_def', 'defview');

set aid = g2b('6e0998f4-fde2-4329-b65a-d923959d6d6a');
call sysoptions_save ( b2g(aid), 'iud_filestoretype', 'iud_fst', 'struct_type');

set aid = g2b('440c79da-adda-424b-9078-a664f13ff23c');
call sysoptions_save ( b2g(aid), 'iud_filestoretype', 'autoiud_filestoretype', 'defview');

set aid = g2b('6beb0aea-5e9d-4654-b4a2-44acf2da259c');
call sysoptions_save ( b2g(aid), 'iud_predmet', 'iud_p', 'struct_type');

set aid = g2b('254b31e3-5626-4c91-93b5-4e66a25d2e34');
call sysoptions_save ( b2g(aid), 'iud_predmet', 'autoiud_predmet', 'defview');

set aid = g2b('9c97287e-f796-40bc-be51-4ff8f728adac');
call sysoptions_save ( b2g(aid), 'iud_doctype', 'iu_d_doctype', 'struct_type');

set aid = g2b('3c990a52-6e99-40c6-8efc-b42af4e5f6ad');
call sysoptions_save ( b2g(aid), 'iud_doctype', 'autoiud_doctype', 'defview');

set aid = g2b('91671309-30c3-451f-af70-0bc6ca2a1060');
call sysoptions_save ( b2g(aid), 'users', 'mtzusers', 'struct_type');

set aid = g2b('9bec7b78-c660-457f-8100-96b2b720ad3e');
call sysoptions_save ( b2g(aid), 'users', 'autousers', 'defview');

set aid = g2b('65e63c0c-ebef-48d3-a77b-c5b7fd80b975');
call sysoptions_save ( b2g(aid), 'groups', 'mtzusers', 'struct_type');

set aid = g2b('b0f69828-4c07-4a95-84f6-794c1518792c');
call sysoptions_save ( b2g(aid), 'groupuser', 'mtzusers', 'struct_type');
set aid = g2b('7b784de2-0959-4659-bc8b-67b5457d33d9');
call sysoptions_save(  b2g(aid), 'groupuser', 'groups', 'parent');

set aid = g2b('a7b5e133-c046-458f-953a-8e5543f175b0');
call sysoptions_save ( b2g(aid), 'groups', 'autogroups', 'defview');

set aid = g2b('835c535f-b34d-4ac4-b2b1-ac8daa79bb8c');
call sysoptions_save ( b2g(aid), 'groupuser', 'autogroupuser', 'defview');

set aid = g2b('a591b935-9114-4aff-bcc0-63d2190105f8');
call sysoptions_save ( b2g(aid), 'iu_clsinfo', 'iu_cls', 'struct_type');

set aid = g2b('3ed438f9-a0e7-4848-bacf-c11b18c877cc');
call sysoptions_save ( b2g(aid), 'iu_clsinfo', 'autoiu_clsinfo', 'defview');

set aid = g2b('7f1f9225-5860-4ab7-9c6d-0ba9e38b2cb5');
call sysoptions_save ( b2g(aid), 'num_zones', 'stdnumerator', 'struct_type');

set aid = g2b('aa2be784-300b-43bc-9d97-fe1e747ff358');
call sysoptions_save ( b2g(aid), 'num_values', 'stdnumerator', 'struct_type');
set aid = g2b('f746a178-49d2-434a-b307-984769971ab1');
call sysoptions_save(  b2g(aid), 'num_values', 'num_zones', 'parent');

set aid = g2b('1c7b720d-9544-4eb3-b515-4dd569995aa8');
call sysoptions_save ( b2g(aid), 'num_zones', 'autonum_zones', 'defview');

set aid = g2b('c0db15e2-cddc-4cbe-8909-b644b18e0316');
call sysoptions_save ( b2g(aid), 'num_values', 'autonum_values', 'defview');

set aid = g2b('769466e5-7950-4586-adda-8dccebdda426');
call sysoptions_save ( b2g(aid), 'num_head', 'stdnumerator', 'struct_type');

set aid = g2b('37936590-6cd0-4ac0-8a79-891ce715e960');
call sysoptions_save ( b2g(aid), 'num_head', 'autonum_head', 'defview');

set aid = g2b('18ec44e3-6657-4c4c-b695-332351904eb3');
call sysoptions_save ( b2g(aid), 'iud_filetype', 'iud_ft', 'struct_type');

set aid = g2b('d98c776e-c4cd-491b-acf6-2e2e6a94a1d9');
call sysoptions_save ( b2g(aid), 'iud_filetype', 'autoiud_filetype', 'defview');

set aid = g2b('2c59f485-6858-4d13-85b8-ea75e2ca4642');
call sysoptions_save ( b2g(aid), 'mtzext_def', 'mtzext', 'struct_type');

set aid = g2b('b118460b-cd7d-4a1e-9391-4d8f92408d06');
call sysoptions_save ( b2g(aid), 'mtzext_def', 'automtzext_def', 'defview');

set aid = g2b('4df8fb92-94ac-4f7e-a9fb-96271cd6fb89');
call sysoptions_save ( b2g(aid), 'mtzextrel', 'mtzext', 'struct_type');

set aid = g2b('e54cbe8f-cfe4-4665-ba58-1eae08067422');
call sysoptions_save ( b2g(aid), 'mtzextrel', 'automtzextrel', 'defview');

set aid = g2b('960c7a1c-900c-4c6d-870b-f4e80892df3b');
call sysoptions_save ( b2g(aid), 'iud_videotype', 'iud_vt', 'struct_type');

set aid = g2b('d7ce9849-d8b4-465f-a657-9b98a3574f3c');
call sysoptions_save ( b2g(aid), 'iud_videotype', 'autoiud_videotype', 'defview');

set aid = g2b('486ea25a-f2da-4f78-a717-122e6379fbd3');
call sysoptions_save ( b2g(aid), 'iu_cm_def', 'iu_cm', 'struct_type');

set aid = g2b('478ff2dd-a9b3-47cb-865e-5e5225bedd15');
call sysoptions_save ( b2g(aid), 'iu_cm_def', 'autoiu_cm_def', 'defview');

set aid = g2b('19453ae2-f338-4ed5-8021-4c787b1275ea');
call sysoptions_save ( b2g(aid), 'iu_cm_time', 'iu_cm', 'struct_type');

set aid = g2b('1125f88e-c647-49c4-b5a7-01f272c4a6b2');
call sysoptions_save ( b2g(aid), 'iu_cm_time', 'autoiu_cm_time', 'defview');

set aid = g2b('5fb4b21a-f1a6-4a1c-80dd-282c99281c03');
call sysoptions_save ( b2g(aid), 'iu_cm_msg', 'iu_cm', 'struct_type');


set aid = g2b('0249ae76-3c39-4bd7-a7c6-df96891d348b');
call sysoptions_save ( b2g(aid), 'iu_plevent', 'iu_plog', 'struct_type');

set aid = g2b('30bb9369-5350-44b3-8b0b-3098a05e752e');
call sysoptions_save ( b2g(aid), 'iu_plevent', 'autoiu_plevent', 'defview');

set aid = g2b('69286d13-08d2-49ab-bee0-5f833ea4c2cf');
call sysoptions_save ( b2g(aid), 'iu_rcfg_mod', 'iu_rcfg', 'struct_type');

set aid = g2b('d4d8d45d-e9d8-4a42-826c-958d9b3bde2c');
call sysoptions_save ( b2g(aid), 'iu_rcfg_mod', 'autoiu_rcfg_mod', 'defview');

set aid = g2b('d1546fa8-6dbd-41c6-b5e2-87e87e0a9064');
call sysoptions_save ( b2g(aid), 'iu_rcfg_docmode', 'iu_rcfg', 'struct_type');

set aid = g2b('b1204369-4a30-4c49-95b7-6415fd854d36');
call sysoptions_save ( b2g(aid), 'iu_rcfg_docmode', 'autoiu_rcfg_docmode', 'defview');

set aid = g2b('2858cccd-8643-4a45-8d29-b30ecc6205e0');
call sysoptions_save ( b2g(aid), 'iu_rcfg_def', 'iu_rcfg', 'struct_type');

set aid = g2b('388f61d3-b1cd-4f99-8464-5686a65d92c0');
call sysoptions_save ( b2g(aid), 'iu_rcfg_def', 'autoiu_rcfg_def', 'defview');

set aid = g2b('11c78ac7-ce4d-4401-a832-1383c2a4c091');
call sysoptions_save ( b2g(aid), 'iud_town', 'iud_t', 'struct_type');

set aid = g2b('af9a390f-f3e7-4fe8-8f28-9ec2abb947b5');
call sysoptions_save ( b2g(aid), 'iud_town', 'autoiud_town', 'defview');

set aid = g2b('8fd7847b-d5e2-400c-a70a-986b43a58a73');
call sysoptions_save ( b2g(aid), 'iu_regtree', 'iu_reg', 'struct_type');

set aid = g2b('aa32f0f6-8928-4b80-8965-236c08e4cde6');
call sysoptions_save ( b2g(aid), 'iu_regdocs', 'iu_reg', 'struct_type');
set aid = g2b('9801617a-3684-491d-977a-ef71c566d202');
call sysoptions_save(  b2g(aid), 'iu_regdocs', 'iu_regtree', 'parent');


set aid = g2b('cbf26a99-7afb-44fd-827f-bb9a2df6fa30');
call sysoptions_save ( b2g(aid), 'iu_regdocs', 'autoiu_regdocs', 'defview');

set aid = g2b('a72d4095-1782-46b3-9a0f-58a30e13e845');
call sysoptions_save ( b2g(aid), 'iu_status', 'iu_s', 'struct_type');

set aid = g2b('5f724255-2ce4-4f6d-8f88-433c4c4f78d3');
call sysoptions_save ( b2g(aid), 'iu_status', 'autoiu_status', 'defview');

set aid = g2b('7452b43e-b024-4451-8e18-28e4b6845d10');
call sysoptions_save ( b2g(aid), 'iu_status_doer', 'iu_s', 'struct_type');

set aid = g2b('4546001b-30da-4712-98c7-d696cbe64f9b');
call sysoptions_save ( b2g(aid), 'iu_status_doer', 'autoiu_status_doer', 'defview');

set aid = g2b('89b07813-3639-4913-a2fb-4c7fd958dff0');
call sysoptions_save ( b2g(aid), 'iu_statustask', 'iu_s', 'struct_type');

set aid = g2b('1aef187c-728b-42bd-92ad-e0bcc4c06cf4');
call sysoptions_save ( b2g(aid), 'iu_state_tasklink', 'iu_s', 'struct_type');
set aid = g2b('500f7ead-751f-4776-8584-f7e1981f68f4');
call sysoptions_save(  b2g(aid), 'iu_state_tasklink', 'iu_statustask', 'parent');

set aid = g2b('295e839e-2668-4596-8481-c82e151855bb');
call sysoptions_save ( b2g(aid), 'iu_statustask', 'autoiu_statustask', 'defview');

set aid = g2b('e841260d-e8d0-4fff-898a-f261e1f097e0');
call sysoptions_save ( b2g(aid), 'iu_state_tasklink', 'autoiu_state_tasklink', 'defview');

set aid = g2b('1637f021-0655-4b43-b5a2-b58fa0d0f033');
call sysoptions_save ( b2g(aid), 'iu_stausdoc', 'iu_s', 'struct_type');

set aid = g2b('61344d89-2b63-497a-b839-321855b1e431');
call sysoptions_save ( b2g(aid), 'iu_stausdoc', 'autoiu_stausdoc', 'defview');

set aid = g2b('9cd52282-bc29-4442-8c18-bea21f705cc1');
call sysoptions_save ( b2g(aid), 'iu_statusnext', 'iu_s', 'struct_type');

set aid = g2b('a48052e7-f24d-46d8-9396-0d325b6e5130');
call sysoptions_save ( b2g(aid), 'iu_statuschanger', 'iu_s', 'struct_type');
set aid = g2b('0cf75eb5-b630-406e-8543-131256595f3c');
call sysoptions_save(  b2g(aid), 'iu_statuschanger', 'iu_statusnext', 'parent');

set aid = g2b('46e55415-03a8-444b-9fd5-38f986494df9');
call sysoptions_save ( b2g(aid), 'iu_statusnext', 'autoiu_statusnext', 'defview');

set aid = g2b('6281dc38-e7d9-49a5-8975-a6fda5de84e5');
call sysoptions_save ( b2g(aid), 'iu_statuschanger', 'autoiu_statuschanger', 'defview');

set aid = g2b('ddf5182a-c8e8-4c6f-afa9-6ca82dbae2dc');
call sysoptions_save ( b2g(aid), 'mtz2job_def', 'mtz2job', 'struct_type');

set aid = g2b('0eba0739-ffca-4806-895e-41e2c30427d8');
call sysoptions_save ( b2g(aid), 'mtz2job_def', 'automtz2job_def', 'defview');

set aid = g2b('29c0467e-8176-48eb-9f3f-d2aabfa78841');
call sysoptions_save ( b2g(aid), 'iud_ctype', 'iud_c', 'struct_type');

set aid = g2b('1d9cf2fa-d0fe-4855-9002-514a435c33b6');
call sysoptions_save ( b2g(aid), 'iud_ctype', 'autoiud_ctype', 'defview');

set aid = g2b('c73556cb-ede5-40a8-a68a-6eb7d2f1100d');
call sysoptions_save ( b2g(aid), 'iud_spub', 'iud_sp', 'struct_type');

set aid = g2b('e77de7d0-0124-49a4-802f-868633f6c53c');
call sysoptions_save ( b2g(aid), 'iud_spub', 'autoiud_spub', 'defview');

set aid = g2b('bd1eee19-c740-4b0c-9158-b66e581822f8');
call sysoptions_save ( b2g(aid), 'filterfieldgroup', 'mtzfltr', 'struct_type');

set aid = g2b('cbe2c2e2-f9c3-4735-b116-cb61d5c886b4');
call sysoptions_save ( b2g(aid), 'fileterfield', 'mtzfltr', 'struct_type');
set aid = g2b('a965155a-d775-4fd6-a175-2565040cef14');
call sysoptions_save(  b2g(aid), 'fileterfield', 'filterfieldgroup', 'parent');

set aid = g2b('4febde8c-09cd-4466-a063-4eeb8b9fab4e');
call sysoptions_save ( b2g(aid), 'filterfieldgroup', 'autofilterfieldgroup', 'defview');

set aid = g2b('a05c334a-3740-460a-922d-25d5d2af7342');
call sysoptions_save ( b2g(aid), 'fileterfield', 'autofileterfield', 'defview');

set aid = g2b('4f9234a0-932e-4055-9a7e-6dfcef73ea5d');
call sysoptions_save ( b2g(aid), 'filters', 'mtzfltr', 'struct_type');

set aid = g2b('ccd06f3c-f830-4512-840b-bd66b697c27f');
call sysoptions_save ( b2g(aid), 'filters', 'autofilters', 'defview');

set aid = g2b('5f5a7d99-a0f6-4eb5-a129-b096fa160c2e');
call sysoptions_save ( b2g(aid), 'iu_int_modules', 'iu_int', 'struct_type');

set aid = g2b('c2054eea-f588-42ba-bac3-2883afa8103e');
call sysoptions_save ( b2g(aid), 'iu_int_modules', 'autoiu_int_modules', 'defview');

set aid = g2b('d1d027c6-c74a-4c98-b5f7-bde6f749de31');
call sysoptions_save ( b2g(aid), 'iu_task', 'iu_t', 'struct_type');

set aid = g2b('aab4f35b-65e8-45d2-8333-d6bbb20e0691');
call sysoptions_save ( b2g(aid), 'iu_task', 'autoiu_task', 'defview');

set aid = g2b('01f86b7c-b933-4df0-bcc9-f3ad2fbb8a26');
call sysoptions_save ( b2g(aid), 'iu_taskattach', 'iu_t', 'struct_type');

set aid = g2b('d9e9aa15-9c66-4ee0-9eec-a333247cbaac');
call sysoptions_save ( b2g(aid), 'iu_taskattach', 'autoiu_taskattach', 'defview');

set aid = g2b('8ce8fce9-9537-4f46-9e57-fa221662ebc4');
call sysoptions_save ( b2g(aid), 'iu_taskvideo', 'iu_t', 'struct_type');

set aid = g2b('89b95ca2-fc38-42ee-9a87-6c03240d9ae3');
call sysoptions_save ( b2g(aid), 'iu_taskvideo', 'autoiu_taskvideo', 'defview');

set aid = g2b('927118e1-fe5c-4155-822a-51b3cf137e27');
call sysoptions_save ( b2g(aid), 'iu_taskrefs', 'iu_t', 'struct_type');

set aid = g2b('3d1e46ca-b1ef-4aaf-8b90-0da176c6acd6');
call sysoptions_save ( b2g(aid), 'iu_taskrefs', 'autoiu_taskrefs', 'defview');

set aid = g2b('7261e5a6-ec44-4c4f-8c09-fe0f4921ba76');
call sysoptions_save ( b2g(aid), 'iu_l_def', 'iu_l', 'struct_type');

set aid = g2b('c2eb48e9-0883-4e55-9264-ba79062c6e0e');
call sysoptions_save ( b2g(aid), 'iu_l_def', 'autoiu_l_def', 'defview');

set aid = g2b('77fcddfd-3675-4345-b3d9-f619dd1e41a0');
call sysoptions_save ( b2g(aid), 'iu_tm_records', 'iu_tm', 'struct_type');

set aid = g2b('428d765c-3312-4713-936a-e20204f063c2');
call sysoptions_save ( b2g(aid), 'iu_tm_records', 'autoiu_tm_records', 'defview');

set aid = g2b('2966a948-0bdd-42ef-9ec5-325cf2d8f4d3');
call sysoptions_save ( b2g(aid), 'iu_tmdef', 'iu_tm', 'struct_type');

set aid = g2b('faa4a3f1-47d1-4928-ac22-bd9763bc1e19');
call sysoptions_save ( b2g(aid), 'iu_tmdef', 'autoiu_tmdef', 'defview');

set aid = g2b('524db249-152c-4f99-a107-87e8cbdb8480');
call sysoptions_save ( b2g(aid), 'iu_tmcadr', 'iu_tm', 'struct_type');

set aid = g2b('3acd86c6-b719-4960-b719-9730cc0a6ea6');
call sysoptions_save ( b2g(aid), 'iu_tmcadr', 'autoiu_tmcadr', 'defview');

set aid = g2b('9fea06bd-b57b-456e-b0ec-faeee28c192b');
call sysoptions_save ( b2g(aid), 'iu_tm_act', 'iu_tm', 'struct_type');

set aid = g2b('bb710abe-2d63-4350-a394-1ab197fdc9e9');
call sysoptions_save ( b2g(aid), 'iu_tm_actfile', 'iu_tm', 'struct_type');
set aid = g2b('48db0a15-d1c1-4184-ac3b-2c7009f70cd8');
call sysoptions_save(  b2g(aid), 'iu_tm_actfile', 'iu_tm_act', 'parent');

set aid = g2b('ac607556-6bcb-4b47-a500-e0fc5d238a4e');
call sysoptions_save ( b2g(aid), 'iu_tm_act', 'autoiu_tm_act', 'defview');

set aid = g2b('663b43e2-f01e-44cf-a017-20f0448da118');
call sysoptions_save ( b2g(aid), 'iu_tm_actfile', 'autoiu_tm_actfile', 'defview');

set aid = g2b('d28e2db6-2010-426c-a0b5-6351673c86a0');
call sysoptions_save ( b2g(aid), 'iu_tm_dog', 'iu_tm', 'struct_type');

set aid = g2b('876e6042-8c28-44f9-be5f-77a8fc2c468a');
call sysoptions_save ( b2g(aid), 'iu_tm_dog', 'autoiu_tm_dog', 'defview');

set aid = g2b('a516a434-6e9f-4147-9e8f-ce9a2a2e781c');
call sysoptions_save ( b2g(aid), 'rptstruct', 'mtzrprt', 'struct_type');

set aid = g2b('39b647cc-b53d-4aff-8b83-5c1167df465e');
call sysoptions_save ( b2g(aid), 'rptfields', 'mtzrprt', 'struct_type');
set aid = g2b('316bbe42-d739-40e5-b895-a6a1a27c9364');
call sysoptions_save(  b2g(aid), 'rptfields', 'rptstruct', 'parent');


set aid = g2b('860eae45-28f3-4a1f-ad90-83a84dc83de4');
call sysoptions_save ( b2g(aid), 'rptfields', 'autorptfields', 'defview');

set aid = g2b('50fbe53c-6dae-4803-9232-b8d45e7f0898');
call sysoptions_save ( b2g(aid), 'rptformula', 'mtzrprt', 'struct_type');

set aid = g2b('3a4495aa-75d4-47ff-8fff-a033f71889e7');
call sysoptions_save ( b2g(aid), 'rptformula', 'autorptformula', 'defview');

set aid = g2b('9cc6f412-ba8a-4d8e-90e1-d154dba88758');
call sysoptions_save ( b2g(aid), 'reports', 'mtzrprt', 'struct_type');

set aid = g2b('a3318920-6b41-4d0a-b7a5-a74966b1c980');
call sysoptions_save ( b2g(aid), 'reports', 'autoreports', 'defview');

set aid = g2b('22c3a94b-c97f-48a4-9464-43116b3ace80');
call sysoptions_save ( b2g(aid), 'iu_subsribe', 'iu_subs', 'struct_type');

set aid = g2b('775a1348-09a9-44eb-ba35-98e6cb8c3ae7');
call sysoptions_save ( b2g(aid), 'iu_subsribe', 'autoiu_subsribe', 'defview');
set aid = g2b('45cc2566-353f-4577-9b3c-51c6238abcee');
call sysoptions_save(b2g(aid),'9181af0d-f0d0-4539-8cdb-67cdb500c41e','getfreenumber', 'methodname');
set aid = g2b('3fe475d7-df6e-496b-9215-3585c854d722');
call sysoptions_save(b2g(aid),'2bb30818-90ed-4627-8abb-85b3fba46750','vbnewpayout', 'methodname');
set aid = g2b('17156fdd-cbf8-4b4d-ba3d-08e29be891df');
call sysoptions_save(b2g(aid),'4fb59d1a-0123-47d3-9f4f-e12085c5d074','vbupdateitemname', 'methodname');
set aid = g2b('aafaa21a-4ea9-4725-89be-339076739d07');
call sysoptions_save(b2g(aid),'477b8d25-4ff7-491a-a0b0-d3437ec16957','makenewfolderec', 'methodname');
set aid = g2b('801d4d44-03c5-4480-8db9-b28961ff4be1');
call sysoptions_save(b2g(aid),'42a1a436-8aa2-4f1f-999b-6680dff514de','vbsavehistory', 'methodname');
set aid = g2b('701dbbfc-af2f-4444-84bf-82ca1f2913e6');
call sysoptions_save(b2g(aid),'6fb1873a-45a9-420f-90ce-cde34b5aee19','autoclosesession', 'methodname');
set aid = g2b('e5d3de42-6930-42dc-b230-21033814314e');
call sysoptions_save(b2g(aid),'61393545-abf7-46f7-82f3-9b7e610dd9c0','vbupdateobjname', 'methodname');
set aid = g2b('8ac1f441-7c5d-40c3-b4d2-455388aed334');
call sysoptions_save(b2g(aid),'897d3b55-6599-42db-aa1c-54bab3d2f597','getnewnumber', 'methodname');
set aid = g2b('280d1163-0bfd-47c8-84fa-72ff6bbecab5');
call sysoptions_save(b2g(aid),'2b0cee5c-7ffa-490d-9f5a-b5e8692551dd','erasenumber', 'methodname');
set aid = g2b('a05ff6f8-ef65-48c0-b8d2-cc6138ecdfb8');
call sysoptions_save(b2g(aid),'73be205e-f7ea-4a5a-a41f-85e25ca6511e','sessioncheckpoint', 'methodname');
set aid = g2b('6a724203-1c79-455a-b22d-a6840add3f0e');
call sysoptions_save(b2g(aid),'a87a3a65-ecd1-414f-8fdf-91e53aced1ba','rowstoinstances', 'methodname');
set aid = g2b('69b6216d-742d-4c59-9b16-ac03cedacee6');
call sysoptions_save(b2g(aid),'a282dd68-9188-4c40-b0f2-be69caee3dea','checkverbright', 'methodname');
set aid = g2b('2424b442-2474-432a-a309-3debde96ae2d');
call sysoptions_save(b2g(aid),'68bd7f75-ad54-4837-a6a7-a8dde3b2992a','mtzlogin', 'methodname');
set aid = g2b('56a9fe0d-cb39-415c-af80-9061fba9a28c');
call sysoptions_save(b2g(aid),'a2eee876-54d8-4aed-b124-775f5da2d911','vbaddobjbyref', 'methodname');
set aid = g2b('592327e5-dcda-4228-9782-62d19c970bd0');
call sysoptions_save(b2g(aid),'73e7cf77-e6ba-42b4-a03b-4f67eedef4f1','adminunlockall', 'methodname');
set aid = g2b('6200e88d-0b6b-48a5-aa51-93d5727a74a9');
call sysoptions_save(b2g(aid),'8d492a94-7078-4b7d-9847-aefc27b4855d','rowtoinstance', 'methodname');
set aid = g2b('604397ac-d59d-4769-a5c4-f18c45f94b2e');
call sysoptions_save(b2g(aid),'7929d795-41c5-4a5c-bff2-a4e677a62143','sessiontouch', 'methodname');
set aid = g2b('45701357-254e-4e47-a1a4-8eb45d7b2f23');
call sysoptions_save(b2g(aid),'6c6e6daa-5cd2-48c3-a2aa-a24539b45a49','getservertime', 'methodname');
set aid = g2b('57952cff-5d28-4dba-a53c-1e978ce53b3e');
call sysoptions_save(b2g(aid),'0c9985af-27ee-4ad5-a564-635e0bffc9d5','testnumber', 'methodname');
set aid = g2b('01ebf232-117c-4d01-99ad-aca8a7eaa1fa');
call sysoptions_save(b2g(aid),'8d3b38b4-c4f9-45ac-8ece-bf3be39d8100','logout', 'methodname');
set aid = g2b('d67d8dc0-f1ea-4f4b-b9b6-94ae0cdb6399');
call sysoptions_save(b2g(aid),'d8914fb4-6b5d-491a-a72f-985617727583','wffuncname', 'methodname');
set aid = g2b('fb895a91-66fd-48d4-b347-897858166885');
call sysoptions_save(b2g(aid),'074e33b9-1ec9-4aa1-8300-e98c73d55fe2','login', 'methodname');
set aid = g2b('28dc0c38-295d-4cb6-b8d5-b7eea999a212');
call sysoptions_save(b2g(aid),'d49a40b9-6174-4946-a81d-b7fe105c3546','adminunlock', 'methodname');
set aid = g2b('41971a50-6f79-4ee4-b6c4-3e7294425323');
call sysoptions_save(b2g(aid),'5b8fb7b9-d8b1-4ca0-90af-55f83d1a6e5d','vbmakereport', 'methodname');
set aid = g2b('affe5375-642c-47fd-bed9-753ffbd48d5e');
call sysoptions_save(b2g(aid),'94e8f6db-106a-44dc-9483-86c801798ff0','vbopenref', 'methodname');
set aid = g2b('e3ac4e8f-dbd5-479b-abf3-698784b431f4');
call sysoptions_save(b2g(aid),'069956dc-3305-45ef-9331-91ce323b5942','wfdefname', 'methodname');
set aid = g2b('c556b299-a5ac-47f3-9ffd-f0a3b0478b13');
call sysoptions_save(b2g(aid),'aa4085e6-745b-4a37-8ec4-65d99a653966','vbremovesymmetricobjref', 'methodname');
set aid = g2b('26b877eb-ae38-4779-bc30-071da3925e58');
call sysoptions_save(b2g(aid),'49a49ae8-db4b-4329-80fb-801a24c9d7af','clearnumerators', 'methodname');
set aid = g2b('fff2a64b-1b23-46db-95d3-6ac7fb48862c');
call sysoptions_save(b2g(aid),'79e6bdeb-91d5-4b2e-81f7-3e091fb65e3a','vbcheckdescrs', 'methodname');
set aid = g2b('978a4036-9c0f-44ce-b27b-93b3ed82499e');
call sysoptions_save(b2g(aid),'0454d6f0-8624-4887-94b0-64fbc74775e6','sessionverify', 'methodname');
set aid = g2b('cfc37886-af9e-46b3-a194-118a4d5a0665');
call sysoptions_save(b2g(aid),'5b376af5-339b-4365-ba80-785e28bcf4da','vbupdatesymmetricobjref', 'methodname');
set aid = g2b('4ef2b28a-eb5c-481f-9f37-46b073fcd40f');
call sysoptions_save(b2g(aid),'31ec6cf7-8dbd-4efe-bf12-4d168f653d34','vbapplysecurity', 'methodname');
set aid = g2b('9e5ff904-a7e1-46cd-83f2-508afde46b99');
call sysoptions_save(b2g(aid),'79ded4fd-045c-45f8-ac79-2e5a3d956d97','vbmigrateright', 'methodname');
call login( asession  , 'init', 'init');
select count(*) into aec from instance where objtype='mtzusers';
if aec=0 then
   set asecid=g2b('e0fb5e85-050e-4322-8505-9e0ca132e901');
   insert into instance(instanceid,objtype,name) values(asecid, 'mtzusers','пользователи и группы');
else
   select instanceid into asecid from instance where objtype='mtzusers';
end if;
delete from users where login = 'supervisor';
set auid=g2b('5433c66a-b75b-4805-8558-be283d762764');
insert into users(usersid,instanceid,password,login,name,changestamp) values(auid, asecid,  
 md5('bami'),  'supervisor', 'администратор',now());
call logout(asession);
delete from users where login = 'init';
end
go
call init();
go
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
</root>